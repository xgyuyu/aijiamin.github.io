/*! For license information please see main.js.LICENSE.txt */
(()=>{
    var __webpack_modules__ = {
      840: (e,t,i)=>{
        var n;
        !function(r, s, a, o) {
          "use strict";
          var l, h = ["", "webkit", "Moz", "MS", "ms", "o"], c = s.createElement("div"), u = Math.round, d = Math.abs, p = Date.now;
          function f(e, t, i) {
            return setTimeout(b(e, i), t)
          }
          function m(e, t, i) {
            return !!Array.isArray(e) && (g(e, i[t], i),
              !0)
          }
          function g(e, t, i) {
            var n;
            if (e)
              if (e.forEach)
                e.forEach(t, i);
              else if (e.length !== o)
                for (n = 0; n < e.length; )
                  t.call(i, e[n], n, e),
                    n++;
              else
                for (n in e)
                  e.hasOwnProperty(n) && t.call(i, e[n], n, e)
          }
          function v(e, t, i) {
            var n = "DEPRECATED METHOD: " + t + "\n" + i + " AT \n";
            return function() {
              var t = new Error("get-stack-trace")
                , i = t && t.stack ? t.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace"
                , s = r.console && (r.console.warn || r.console.log);
              return s && s.call(r.console, n, i),
                e.apply(this, arguments)
            }
          }
          l = "function" != typeof Object.assign ? function(e) {
              if (e === o || null === e)
                throw new TypeError("Cannot convert undefined or null to object");
              for (var t = Object(e), i = 1; i < arguments.length; i++) {
                var n = arguments[i];
                if (n !== o && null !== n)
                  for (var r in n)
                    n.hasOwnProperty(r) && (t[r] = n[r])
              }
              return t
            }
            : Object.assign;
          var y = v((function(e, t, i) {
              for (var n = Object.keys(t), r = 0; r < n.length; )
                (!i || i && e[n[r]] === o) && (e[n[r]] = t[n[r]]),
                  r++;
              return e
            }
          ), "extend", "Use `assign`.")
            , x = v((function(e, t) {
              return y(e, t, !0)
            }
          ), "merge", "Use `assign`.");
          function _(e, t, i) {
            var n, r = t.prototype;
            (n = e.prototype = Object.create(r)).constructor = e,
              n._super = r,
            i && l(n, i)
          }
          function b(e, t) {
            return function() {
              return e.apply(t, arguments)
            }
          }
          function w(e, t) {
            return "function" == typeof e ? e.apply(t && t[0] || o, t) : e
          }
          function A(e, t) {
            return e === o ? t : e
          }
          function S(e, t, i) {
            g(C(t), (function(t) {
                e.addEventListener(t, i, !1)
              }
            ))
          }
          function M(e, t, i) {
            g(C(t), (function(t) {
                e.removeEventListener(t, i, !1)
              }
            ))
          }
          function T(e, t) {
            for (; e; ) {
              if (e == t)
                return !0;
              e = e.parentNode
            }
            return !1
          }
          function E(e, t) {
            return e.indexOf(t) > -1
          }
          function C(e) {
            return e.trim().split(/\s+/g)
          }
          function P(e, t, i) {
            if (e.indexOf && !i)
              return e.indexOf(t);
            for (var n = 0; n < e.length; ) {
              if (i && e[n][i] == t || !i && e[n] === t)
                return n;
              n++
            }
            return -1
          }
          function D(e) {
            return Array.prototype.slice.call(e, 0)
          }
          function I(e, t, i) {
            for (var n = [], r = [], s = 0; s < e.length; ) {
              var a = t ? e[s][t] : e[s];
              P(r, a) < 0 && n.push(e[s]),
                r[s] = a,
                s++
            }
            return i && (n = t ? n.sort((function(e, i) {
                return e[t] > i[t]
              }
            )) : n.sort()),
              n
          }
          function R(e, t) {
            for (var i, n, r = t[0].toUpperCase() + t.slice(1), s = 0; s < h.length; ) {
              if ((n = (i = h[s]) ? i + r : t)in e)
                return n;
              s++
            }
            return o
          }
          var L = 1;
          function k(e) {
            var t = e.ownerDocument || e;
            return t.defaultView || t.parentWindow || r
          }
          var F = "ontouchstart"in r
            , B = R(r, "PointerEvent") !== o
            , O = F && /mobile|tablet|ip(ad|hone|od)|android/i.test(navigator.userAgent)
            , N = "touch"
            , z = "mouse"
            , U = ["x", "y"]
            , G = ["clientX", "clientY"];
          function V(e, t) {
            var i = this;
            this.manager = e,
              this.callback = t,
              this.element = e.element,
              this.target = e.options.inputTarget,
              this.domHandler = function(t) {
                w(e.options.enable, [e]) && i.handler(t)
              }
              ,
              this.init()
          }
          function H(e, t, i) {
            var n = i.pointers.length
              , r = i.changedPointers.length
              , s = 1 & t && n - r == 0
              , a = 12 & t && n - r == 0;
            i.isFirst = !!s,
              i.isFinal = !!a,
            s && (e.session = {}),
              i.eventType = t,
              function(e, t) {
                var i = e.session
                  , n = t.pointers
                  , r = n.length;
                i.firstInput || (i.firstInput = W(t)),
                  r > 1 && !i.firstMultiple ? i.firstMultiple = W(t) : 1 === r && (i.firstMultiple = !1);
                var s = i.firstInput
                  , a = i.firstMultiple
                  , l = a ? a.center : s.center
                  , h = t.center = j(n);
                t.timeStamp = p(),
                  t.deltaTime = t.timeStamp - s.timeStamp,
                  t.angle = Q(l, h),
                  t.distance = q(l, h),
                  function(e, t) {
                    var i = t.center
                      , n = e.offsetDelta || {}
                      , r = e.prevDelta || {}
                      , s = e.prevInput || {};
                    1 !== t.eventType && 4 !== s.eventType || (r = e.prevDelta = {
                      x: s.deltaX || 0,
                      y: s.deltaY || 0
                    },
                      n = e.offsetDelta = {
                        x: i.x,
                        y: i.y
                      }),
                      t.deltaX = r.x + (i.x - n.x),
                      t.deltaY = r.y + (i.y - n.y)
                  }(i, t),
                  t.offsetDirection = Y(t.deltaX, t.deltaY);
                var c, u, f = X(t.deltaTime, t.deltaX, t.deltaY);
                t.overallVelocityX = f.x,
                  t.overallVelocityY = f.y,
                  t.overallVelocity = d(f.x) > d(f.y) ? f.x : f.y,
                  t.scale = a ? (c = a.pointers,
                  q((u = n)[0], u[1], G) / q(c[0], c[1], G)) : 1,
                  t.rotation = a ? function(e, t) {
                    return Q(t[1], t[0], G) + Q(e[1], e[0], G)
                  }(a.pointers, n) : 0,
                  t.maxPointers = i.prevInput ? t.pointers.length > i.prevInput.maxPointers ? t.pointers.length : i.prevInput.maxPointers : t.pointers.length,
                  function(e, t) {
                    var i, n, r, s, a = e.lastInterval || t, l = t.timeStamp - a.timeStamp;
                    if (8 != t.eventType && (l > 25 || a.velocity === o)) {
                      var h = t.deltaX - a.deltaX
                        , c = t.deltaY - a.deltaY
                        , u = X(l, h, c);
                      n = u.x,
                        r = u.y,
                        i = d(u.x) > d(u.y) ? u.x : u.y,
                        s = Y(h, c),
                        e.lastInterval = t
                    } else
                      i = a.velocity,
                        n = a.velocityX,
                        r = a.velocityY,
                        s = a.direction;
                    t.velocity = i,
                      t.velocityX = n,
                      t.velocityY = r,
                      t.direction = s
                  }(i, t);
                var m = e.element;
                T(t.srcEvent.target, m) && (m = t.srcEvent.target),
                  t.target = m
              }(e, i),
              e.emit("hammer.input", i),
              e.recognize(i),
              e.session.prevInput = i
          }
          function W(e) {
            for (var t = [], i = 0; i < e.pointers.length; )
              t[i] = {
                clientX: u(e.pointers[i].clientX),
                clientY: u(e.pointers[i].clientY)
              },
                i++;
            return {
              timeStamp: p(),
              pointers: t,
              center: j(t),
              deltaX: e.deltaX,
              deltaY: e.deltaY
            }
          }
          function j(e) {
            var t = e.length;
            if (1 === t)
              return {
                x: u(e[0].clientX),
                y: u(e[0].clientY)
              };
            for (var i = 0, n = 0, r = 0; r < t; )
              i += e[r].clientX,
                n += e[r].clientY,
                r++;
            return {
              x: u(i / t),
              y: u(n / t)
            }
          }
          function X(e, t, i) {
            return {
              x: t / e || 0,
              y: i / e || 0
            }
          }
          function Y(e, t) {
            return e === t ? 1 : d(e) >= d(t) ? e < 0 ? 2 : 4 : t < 0 ? 8 : 16
          }
          function q(e, t, i) {
            i || (i = U);
            var n = t[i[0]] - e[i[0]]
              , r = t[i[1]] - e[i[1]];
            return Math.sqrt(n * n + r * r)
          }
          function Q(e, t, i) {
            i || (i = U);
            var n = t[i[0]] - e[i[0]]
              , r = t[i[1]] - e[i[1]];
            return 180 * Math.atan2(r, n) / Math.PI
          }
          V.prototype = {
            handler: function() {},
            init: function() {
              this.evEl && S(this.element, this.evEl, this.domHandler),
              this.evTarget && S(this.target, this.evTarget, this.domHandler),
              this.evWin && S(k(this.element), this.evWin, this.domHandler)
            },
            destroy: function() {
              this.evEl && M(this.element, this.evEl, this.domHandler),
              this.evTarget && M(this.target, this.evTarget, this.domHandler),
              this.evWin && M(k(this.element), this.evWin, this.domHandler)
            }
          };
          var K = {
            mousedown: 1,
            mousemove: 2,
            mouseup: 4
          }
            , J = "mousedown"
            , Z = "mousemove mouseup";
          function $() {
            this.evEl = J,
              this.evWin = Z,
              this.pressed = !1,
              V.apply(this, arguments)
          }
          _($, V, {
            handler: function(e) {
              var t = K[e.type];
              1 & t && 0 === e.button && (this.pressed = !0),
              2 & t && 1 !== e.which && (t = 4),
              this.pressed && (4 & t && (this.pressed = !1),
                this.callback(this.manager, t, {
                  pointers: [e],
                  changedPointers: [e],
                  pointerType: z,
                  srcEvent: e
                }))
            }
          });
          var ee = {
            pointerdown: 1,
            pointermove: 2,
            pointerup: 4,
            pointercancel: 8,
            pointerout: 8
          }
            , te = {
            2: N,
            3: "pen",
            4: z,
            5: "kinect"
          }
            , ie = "pointerdown"
            , ne = "pointermove pointerup pointercancel";
          function re() {
            this.evEl = ie,
              this.evWin = ne,
              V.apply(this, arguments),
              this.store = this.manager.session.pointerEvents = []
          }
          r.MSPointerEvent && !r.PointerEvent && (ie = "MSPointerDown",
            ne = "MSPointerMove MSPointerUp MSPointerCancel"),
            _(re, V, {
              handler: function(e) {
                var t = this.store
                  , i = !1
                  , n = e.type.toLowerCase().replace("ms", "")
                  , r = ee[n]
                  , s = te[e.pointerType] || e.pointerType
                  , a = s == N
                  , o = P(t, e.pointerId, "pointerId");
                1 & r && (0 === e.button || a) ? o < 0 && (t.push(e),
                  o = t.length - 1) : 12 & r && (i = !0),
                o < 0 || (t[o] = e,
                  this.callback(this.manager, r, {
                    pointers: t,
                    changedPointers: [e],
                    pointerType: s,
                    srcEvent: e
                  }),
                i && t.splice(o, 1))
              }
            });
          var se = {
            touchstart: 1,
            touchmove: 2,
            touchend: 4,
            touchcancel: 8
          }
            , ae = "touchstart"
            , oe = "touchstart touchmove touchend touchcancel";
          function le() {
            this.evTarget = ae,
              this.evWin = oe,
              this.started = !1,
              V.apply(this, arguments)
          }
          function he(e, t) {
            var i = D(e.touches)
              , n = D(e.changedTouches);
            return 12 & t && (i = I(i.concat(n), "identifier", !0)),
              [i, n]
          }
          _(le, V, {
            handler: function(e) {
              var t = se[e.type];
              if (1 === t && (this.started = !0),
                this.started) {
                var i = he.call(this, e, t);
                12 & t && i[0].length - i[1].length == 0 && (this.started = !1),
                  this.callback(this.manager, t, {
                    pointers: i[0],
                    changedPointers: i[1],
                    pointerType: N,
                    srcEvent: e
                  })
              }
            }
          });
          var ce = {
            touchstart: 1,
            touchmove: 2,
            touchend: 4,
            touchcancel: 8
          }
            , ue = "touchstart touchmove touchend touchcancel";
          function de() {
            this.evTarget = ue,
              this.targetIds = {},
              V.apply(this, arguments)
          }
          function pe(e, t) {
            var i = D(e.touches)
              , n = this.targetIds;
            if (3 & t && 1 === i.length)
              return n[i[0].identifier] = !0,
                [i, i];
            var r, s, a = D(e.changedTouches), o = [], l = this.target;
            if (s = i.filter((function(e) {
                return T(e.target, l)
              }
            )),
            1 === t)
              for (r = 0; r < s.length; )
                n[s[r].identifier] = !0,
                  r++;
            for (r = 0; r < a.length; )
              n[a[r].identifier] && o.push(a[r]),
              12 & t && delete n[a[r].identifier],
                r++;
            return o.length ? [I(s.concat(o), "identifier", !0), o] : void 0
          }
          function fe() {
            V.apply(this, arguments);
            var e = b(this.handler, this);
            this.touch = new de(this.manager,e),
              this.mouse = new $(this.manager,e),
              this.primaryTouch = null,
              this.lastTouches = []
          }
          function me(e, t) {
            1 & e ? (this.primaryTouch = t.changedPointers[0].identifier,
              ge.call(this, t)) : 12 & e && ge.call(this, t)
          }
          function ge(e) {
            var t = e.changedPointers[0];
            if (t.identifier === this.primaryTouch) {
              var i = {
                x: t.clientX,
                y: t.clientY
              };
              this.lastTouches.push(i);
              var n = this.lastTouches;
              setTimeout((function() {
                  var e = n.indexOf(i);
                  e > -1 && n.splice(e, 1)
                }
              ), 2500)
            }
          }
          function ve(e) {
            for (var t = e.srcEvent.clientX, i = e.srcEvent.clientY, n = 0; n < this.lastTouches.length; n++) {
              var r = this.lastTouches[n]
                , s = Math.abs(t - r.x)
                , a = Math.abs(i - r.y);
              if (s <= 25 && a <= 25)
                return !0
            }
            return !1
          }
          _(de, V, {
            handler: function(e) {
              var t = ce[e.type]
                , i = pe.call(this, e, t);
              i && this.callback(this.manager, t, {
                pointers: i[0],
                changedPointers: i[1],
                pointerType: N,
                srcEvent: e
              })
            }
          }),
            _(fe, V, {
              handler: function(e, t, i) {
                var n = i.pointerType == N
                  , r = i.pointerType == z;
                if (!(r && i.sourceCapabilities && i.sourceCapabilities.firesTouchEvents)) {
                  if (n)
                    me.call(this, t, i);
                  else if (r && ve.call(this, i))
                    return;
                  this.callback(e, t, i)
                }
              },
              destroy: function() {
                this.touch.destroy(),
                  this.mouse.destroy()
              }
            });
          var ye = R(c.style, "touchAction")
            , xe = ye !== o
            , _e = "compute"
            , be = "auto"
            , we = "manipulation"
            , Ae = "none"
            , Se = "pan-x"
            , Me = "pan-y"
            , Te = function() {
            if (!xe)
              return !1;
            var e = {}
              , t = r.CSS && r.CSS.supports;
            return ["auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none"].forEach((function(i) {
                e[i] = !t || r.CSS.supports("touch-action", i)
              }
            )),
              e
          }();
          function Ee(e, t) {
            this.manager = e,
              this.set(t)
          }
          Ee.prototype = {
            set: function(e) {
              e == _e && (e = this.compute()),
              xe && this.manager.element.style && Te[e] && (this.manager.element.style[ye] = e),
                this.actions = e.toLowerCase().trim()
            },
            update: function() {
              this.set(this.manager.options.touchAction)
            },
            compute: function() {
              var e = [];
              return g(this.manager.recognizers, (function(t) {
                  w(t.options.enable, [t]) && (e = e.concat(t.getTouchAction()))
                }
              )),
                function(e) {
                  if (E(e, Ae))
                    return Ae;
                  var t = E(e, Se)
                    , i = E(e, Me);
                  return t && i ? Ae : t || i ? t ? Se : Me : E(e, we) ? we : be
                }(e.join(" "))
            },
            preventDefaults: function(e) {
              var t = e.srcEvent
                , i = e.offsetDirection;
              if (this.manager.session.prevented)
                t.preventDefault();
              else {
                var n = this.actions
                  , r = E(n, Ae) && !Te.none
                  , s = E(n, Me) && !Te["pan-y"]
                  , a = E(n, Se) && !Te["pan-x"];
                if (r) {
                  var o = 1 === e.pointers.length
                    , l = e.distance < 2
                    , h = e.deltaTime < 250;
                  if (o && l && h)
                    return
                }
                if (!a || !s)
                  return r || s && 6 & i || a && 24 & i ? this.preventSrc(t) : void 0
              }
            },
            preventSrc: function(e) {
              this.manager.session.prevented = !0,
                e.preventDefault()
            }
          };
          var Ce = 32;
          function Pe(e) {
            this.options = l({}, this.defaults, e || {}),
              this.id = L++,
              this.manager = null,
              this.options.enable = A(this.options.enable, !0),
              this.state = 1,
              this.simultaneous = {},
              this.requireFail = []
          }
          function De(e) {
            return 16 & e ? "cancel" : 8 & e ? "end" : 4 & e ? "move" : 2 & e ? "start" : ""
          }
          function Ie(e) {
            return 16 == e ? "down" : 8 == e ? "up" : 2 == e ? "left" : 4 == e ? "right" : ""
          }
          function Re(e, t) {
            var i = t.manager;
            return i ? i.get(e) : e
          }
          function Le() {
            Pe.apply(this, arguments)
          }
          function ke() {
            Le.apply(this, arguments),
              this.pX = null,
              this.pY = null
          }
          function Fe() {
            Le.apply(this, arguments)
          }
          function Be() {
            Pe.apply(this, arguments),
              this._timer = null,
              this._input = null
          }
          function Oe() {
            Le.apply(this, arguments)
          }
          function Ne() {
            Le.apply(this, arguments)
          }
          function ze() {
            Pe.apply(this, arguments),
              this.pTime = !1,
              this.pCenter = !1,
              this._timer = null,
              this._input = null,
              this.count = 0
          }
          function Ue(e, t) {
            return (t = t || {}).recognizers = A(t.recognizers, Ue.defaults.preset),
              new Ge(e,t)
          }
          function Ge(e, t) {
            this.options = l({}, Ue.defaults, t || {}),
              this.options.inputTarget = this.options.inputTarget || e,
              this.handlers = {},
              this.session = {},
              this.recognizers = [],
              this.oldCssProps = {},
              this.element = e,
              this.input = new (this.options.inputClass || (B ? re : O ? de : F ? fe : $))(this,H),
              this.touchAction = new Ee(this,this.options.touchAction),
              Ve(this, !0),
              g(this.options.recognizers, (function(e) {
                  var t = this.add(new e[0](e[1]));
                  e[2] && t.recognizeWith(e[2]),
                  e[3] && t.requireFailure(e[3])
                }
              ), this)
          }
          function Ve(e, t) {
            var i, n = e.element;
            n.style && (g(e.options.cssProps, (function(r, s) {
                i = R(n.style, s),
                  t ? (e.oldCssProps[i] = n.style[i],
                    n.style[i] = r) : n.style[i] = e.oldCssProps[i] || ""
              }
            )),
            t || (e.oldCssProps = {}))
          }
          Pe.prototype = {
            defaults: {},
            set: function(e) {
              return l(this.options, e),
              this.manager && this.manager.touchAction.update(),
                this
            },
            recognizeWith: function(e) {
              if (m(e, "recognizeWith", this))
                return this;
              var t = this.simultaneous;
              return t[(e = Re(e, this)).id] || (t[e.id] = e,
                e.recognizeWith(this)),
                this
            },
            dropRecognizeWith: function(e) {
              return m(e, "dropRecognizeWith", this) || (e = Re(e, this),
                delete this.simultaneous[e.id]),
                this
            },
            requireFailure: function(e) {
              if (m(e, "requireFailure", this))
                return this;
              var t = this.requireFail;
              return -1 === P(t, e = Re(e, this)) && (t.push(e),
                e.requireFailure(this)),
                this
            },
            dropRequireFailure: function(e) {
              if (m(e, "dropRequireFailure", this))
                return this;
              e = Re(e, this);
              var t = P(this.requireFail, e);
              return t > -1 && this.requireFail.splice(t, 1),
                this
            },
            hasRequireFailures: function() {
              return this.requireFail.length > 0
            },
            canRecognizeWith: function(e) {
              return !!this.simultaneous[e.id]
            },
            emit: function(e) {
              var t = this
                , i = this.state;
              function n(i) {
                t.manager.emit(i, e)
              }
              i < 8 && n(t.options.event + De(i)),
                n(t.options.event),
              e.additionalEvent && n(e.additionalEvent),
              i >= 8 && n(t.options.event + De(i))
            },
            tryEmit: function(e) {
              if (this.canEmit())
                return this.emit(e);
              this.state = Ce
            },
            canEmit: function() {
              for (var e = 0; e < this.requireFail.length; ) {
                if (!(33 & this.requireFail[e].state))
                  return !1;
                e++
              }
              return !0
            },
            recognize: function(e) {
              var t = l({}, e);
              if (!w(this.options.enable, [this, t]))
                return this.reset(),
                  void (this.state = Ce);
              56 & this.state && (this.state = 1),
                this.state = this.process(t),
              30 & this.state && this.tryEmit(t)
            },
            process: function(e) {},
            getTouchAction: function() {},
            reset: function() {}
          },
            _(Le, Pe, {
              defaults: {
                pointers: 1
              },
              attrTest: function(e) {
                var t = this.options.pointers;
                return 0 === t || e.pointers.length === t
              },
              process: function(e) {
                var t = this.state
                  , i = e.eventType
                  , n = 6 & t
                  , r = this.attrTest(e);
                return n && (8 & i || !r) ? 16 | t : n || r ? 4 & i ? 8 | t : 2 & t ? 4 | t : 2 : Ce
              }
            }),
            _(ke, Le, {
              defaults: {
                event: "pan",
                threshold: 10,
                pointers: 1,
                direction: 30
              },
              getTouchAction: function() {
                var e = this.options.direction
                  , t = [];
                return 6 & e && t.push(Me),
                24 & e && t.push(Se),
                  t
              },
              directionTest: function(e) {
                var t = this.options
                  , i = !0
                  , n = e.distance
                  , r = e.direction
                  , s = e.deltaX
                  , a = e.deltaY;
                return r & t.direction || (6 & t.direction ? (r = 0 === s ? 1 : s < 0 ? 2 : 4,
                  i = s != this.pX,
                  n = Math.abs(e.deltaX)) : (r = 0 === a ? 1 : a < 0 ? 8 : 16,
                  i = a != this.pY,
                  n = Math.abs(e.deltaY))),
                  e.direction = r,
                i && n > t.threshold && r & t.direction
              },
              attrTest: function(e) {
                return Le.prototype.attrTest.call(this, e) && (2 & this.state || !(2 & this.state) && this.directionTest(e))
              },
              emit: function(e) {
                this.pX = e.deltaX,
                  this.pY = e.deltaY;
                var t = Ie(e.direction);
                t && (e.additionalEvent = this.options.event + t),
                  this._super.emit.call(this, e)
              }
            }),
            _(Fe, Le, {
              defaults: {
                event: "pinch",
                threshold: 0,
                pointers: 2
              },
              getTouchAction: function() {
                return [Ae]
              },
              attrTest: function(e) {
                return this._super.attrTest.call(this, e) && (Math.abs(e.scale - 1) > this.options.threshold || 2 & this.state)
              },
              emit: function(e) {
                if (1 !== e.scale) {
                  var t = e.scale < 1 ? "in" : "out";
                  e.additionalEvent = this.options.event + t
                }
                this._super.emit.call(this, e)
              }
            }),
            _(Be, Pe, {
              defaults: {
                event: "press",
                pointers: 1,
                time: 251,
                threshold: 9
              },
              getTouchAction: function() {
                return [be]
              },
              process: function(e) {
                var t = this.options
                  , i = e.pointers.length === t.pointers
                  , n = e.distance < t.threshold
                  , r = e.deltaTime > t.time;
                if (this._input = e,
                !n || !i || 12 & e.eventType && !r)
                  this.reset();
                else if (1 & e.eventType)
                  this.reset(),
                    this._timer = f((function() {
                        this.state = 8,
                          this.tryEmit()
                      }
                    ), t.time, this);
                else if (4 & e.eventType)
                  return 8;
                return Ce
              },
              reset: function() {
                clearTimeout(this._timer)
              },
              emit: function(e) {
                8 === this.state && (e && 4 & e.eventType ? this.manager.emit(this.options.event + "up", e) : (this._input.timeStamp = p(),
                  this.manager.emit(this.options.event, this._input)))
              }
            }),
            _(Oe, Le, {
              defaults: {
                event: "rotate",
                threshold: 0,
                pointers: 2
              },
              getTouchAction: function() {
                return [Ae]
              },
              attrTest: function(e) {
                return this._super.attrTest.call(this, e) && (Math.abs(e.rotation) > this.options.threshold || 2 & this.state)
              }
            }),
            _(Ne, Le, {
              defaults: {
                event: "swipe",
                threshold: 10,
                velocity: .3,
                direction: 30,
                pointers: 1
              },
              getTouchAction: function() {
                return ke.prototype.getTouchAction.call(this)
              },
              attrTest: function(e) {
                var t, i = this.options.direction;
                return 30 & i ? t = e.overallVelocity : 6 & i ? t = e.overallVelocityX : 24 & i && (t = e.overallVelocityY),
                this._super.attrTest.call(this, e) && i & e.offsetDirection && e.distance > this.options.threshold && e.maxPointers == this.options.pointers && d(t) > this.options.velocity && 4 & e.eventType
              },
              emit: function(e) {
                var t = Ie(e.offsetDirection);
                t && this.manager.emit(this.options.event + t, e),
                  this.manager.emit(this.options.event, e)
              }
            }),
            _(ze, Pe, {
              defaults: {
                event: "tap",
                pointers: 1,
                taps: 1,
                interval: 300,
                time: 250,
                threshold: 9,
                posThreshold: 10
              },
              getTouchAction: function() {
                return [we]
              },
              process: function(e) {
                var t = this.options
                  , i = e.pointers.length === t.pointers
                  , n = e.distance < t.threshold
                  , r = e.deltaTime < t.time;
                if (this.reset(),
                1 & e.eventType && 0 === this.count)
                  return this.failTimeout();
                if (n && r && i) {
                  if (4 != e.eventType)
                    return this.failTimeout();
                  var s = !this.pTime || e.timeStamp - this.pTime < t.interval
                    , a = !this.pCenter || q(this.pCenter, e.center) < t.posThreshold;
                  if (this.pTime = e.timeStamp,
                    this.pCenter = e.center,
                    a && s ? this.count += 1 : this.count = 1,
                    this._input = e,
                  0 == this.count % t.taps)
                    return this.hasRequireFailures() ? (this._timer = f((function() {
                        this.state = 8,
                          this.tryEmit()
                      }
                    ), t.interval, this),
                      2) : 8
                }
                return Ce
              },
              failTimeout: function() {
                return this._timer = f((function() {
                    this.state = Ce
                  }
                ), this.options.interval, this),
                  Ce
              },
              reset: function() {
                clearTimeout(this._timer)
              },
              emit: function() {
                8 == this.state && (this._input.tapCount = this.count,
                  this.manager.emit(this.options.event, this._input))
              }
            }),
            Ue.VERSION = "2.0.7",
            Ue.defaults = {
              domEvents: !1,
              touchAction: _e,
              enable: !0,
              inputTarget: null,
              inputClass: null,
              preset: [[Oe, {
                enable: !1
              }], [Fe, {
                enable: !1
              }, ["rotate"]], [Ne, {
                direction: 6
              }], [ke, {
                direction: 6
              }, ["swipe"]], [ze], [ze, {
                event: "doubletap",
                taps: 2
              }, ["tap"]], [Be]],
              cssProps: {
                userSelect: "none",
                touchSelect: "none",
                touchCallout: "none",
                contentZooming: "none",
                userDrag: "none",
                tapHighlightColor: "rgba(0,0,0,0)"
              }
            },
            Ge.prototype = {
              set: function(e) {
                return l(this.options, e),
                e.touchAction && this.touchAction.update(),
                e.inputTarget && (this.input.destroy(),
                  this.input.target = e.inputTarget,
                  this.input.init()),
                  this
              },
              stop: function(e) {
                this.session.stopped = e ? 2 : 1
              },
              recognize: function(e) {
                var t = this.session;
                if (!t.stopped) {
                  var i;
                  this.touchAction.preventDefaults(e);
                  var n = this.recognizers
                    , r = t.curRecognizer;
                  (!r || r && 8 & r.state) && (r = t.curRecognizer = null);
                  for (var s = 0; s < n.length; )
                    i = n[s],
                      2 === t.stopped || r && i != r && !i.canRecognizeWith(r) ? i.reset() : i.recognize(e),
                    !r && 14 & i.state && (r = t.curRecognizer = i),
                      s++
                }
              },
              get: function(e) {
                if (e instanceof Pe)
                  return e;
                for (var t = this.recognizers, i = 0; i < t.length; i++)
                  if (t[i].options.event == e)
                    return t[i];
                return null
              },
              add: function(e) {
                if (m(e, "add", this))
                  return this;
                var t = this.get(e.options.event);
                return t && this.remove(t),
                  this.recognizers.push(e),
                  e.manager = this,
                  this.touchAction.update(),
                  e
              },
              remove: function(e) {
                if (m(e, "remove", this))
                  return this;
                if (e = this.get(e)) {
                  var t = this.recognizers
                    , i = P(t, e);
                  -1 !== i && (t.splice(i, 1),
                    this.touchAction.update())
                }
                return this
              },
              on: function(e, t) {
                if (e !== o && t !== o) {
                  var i = this.handlers;
                  return g(C(e), (function(e) {
                      i[e] = i[e] || [],
                        i[e].push(t)
                    }
                  )),
                    this
                }
              },
              off: function(e, t) {
                if (e !== o) {
                  var i = this.handlers;
                  return g(C(e), (function(e) {
                      t ? i[e] && i[e].splice(P(i[e], t), 1) : delete i[e]
                    }
                  )),
                    this
                }
              },
              emit: function(e, t) {
                this.options.domEvents && function(e, t) {
                  var i = s.createEvent("Event");
                  i.initEvent(e, !0, !0),
                    i.gesture = t,
                    t.target.dispatchEvent(i)
                }(e, t);
                var i = this.handlers[e] && this.handlers[e].slice();
                if (i && i.length) {
                  t.type = e,
                    t.preventDefault = function() {
                      t.srcEvent.preventDefault()
                    }
                  ;
                  for (var n = 0; n < i.length; )
                    i[n](t),
                      n++
                }
              },
              destroy: function() {
                this.element && Ve(this, !1),
                  this.handlers = {},
                  this.session = {},
                  this.input.destroy(),
                  this.element = null
              }
            },
            l(Ue, {
              INPUT_START: 1,
              INPUT_MOVE: 2,
              INPUT_END: 4,
              INPUT_CANCEL: 8,
              STATE_POSSIBLE: 1,
              STATE_BEGAN: 2,
              STATE_CHANGED: 4,
              STATE_ENDED: 8,
              STATE_RECOGNIZED: 8,
              STATE_CANCELLED: 16,
              STATE_FAILED: Ce,
              DIRECTION_NONE: 1,
              DIRECTION_LEFT: 2,
              DIRECTION_RIGHT: 4,
              DIRECTION_UP: 8,
              DIRECTION_DOWN: 16,
              DIRECTION_HORIZONTAL: 6,
              DIRECTION_VERTICAL: 24,
              DIRECTION_ALL: 30,
              Manager: Ge,
              Input: V,
              TouchAction: Ee,
              TouchInput: de,
              MouseInput: $,
              PointerEventInput: re,
              TouchMouseInput: fe,
              SingleTouchInput: le,
              Recognizer: Pe,
              AttrRecognizer: Le,
              Tap: ze,
              Pan: ke,
              Swipe: Ne,
              Pinch: Fe,
              Rotate: Oe,
              Press: Be,
              on: S,
              off: M,
              each: g,
              merge: x,
              extend: y,
              assign: l,
              inherit: _,
              bindFn: b,
              prefixed: R
            }),
            (void 0 !== r ? r : "undefined" != typeof self ? self : {}).Hammer = Ue,
          (n = function() {
            return Ue
          }
            .call(t, i, t, e)) === o || (e.exports = n)
        }(window, document)
      }
      ,
      248: function(module, exports, __webpack_require__) {
        var factory;
        "undefined" != typeof navigator && (factory = function() {
          "use strict";
          var svgNS = "http://www.w3.org/2000/svg"
            , locationHref = ""
            , _useWebWorker = !1
            , initialDefaultFrame = -999999
            , setWebWorker = function(e) {
            _useWebWorker = !!e
          }
            , getWebWorker = function() {
            return _useWebWorker
          }
            , setLocationHref = function(e) {
            locationHref = e
          }
            , getLocationHref = function() {
            return locationHref
          };
          function createTag(e) {
            return document.createElement(e)
          }
          function extendPrototype(e, t) {
            var i, n, r = e.length;
            for (i = 0; i < r; i += 1)
              for (var s in n = e[i].prototype)
                Object.prototype.hasOwnProperty.call(n, s) && (t.prototype[s] = n[s])
          }
          function getDescriptor(e, t) {
            return Object.getOwnPropertyDescriptor(e, t)
          }
          function createProxyFunction(e) {
            function t() {}
            return t.prototype = e,
              t
          }
          var audioControllerFactory = function() {
            function e(e) {
              this.audios = [],
                this.audioFactory = e,
                this._volume = 1,
                this._isMuted = !1
            }
            return e.prototype = {
              addAudio: function(e) {
                this.audios.push(e)
              },
              pause: function() {
                var e, t = this.audios.length;
                for (e = 0; e < t; e += 1)
                  this.audios[e].pause()
              },
              resume: function() {
                var e, t = this.audios.length;
                for (e = 0; e < t; e += 1)
                  this.audios[e].resume()
              },
              setRate: function(e) {
                var t, i = this.audios.length;
                for (t = 0; t < i; t += 1)
                  this.audios[t].setRate(e)
              },
              createAudio: function(e) {
                return this.audioFactory ? this.audioFactory(e) : window.Howl ? new window.Howl({
                  src: [e]
                }) : {
                  isPlaying: !1,
                  play: function() {
                    this.isPlaying = !0
                  },
                  seek: function() {
                    this.isPlaying = !1
                  },
                  playing: function() {},
                  rate: function() {},
                  setVolume: function() {}
                }
              },
              setAudioFactory: function(e) {
                this.audioFactory = e
              },
              setVolume: function(e) {
                this._volume = e,
                  this._updateVolume()
              },
              mute: function() {
                this._isMuted = !0,
                  this._updateVolume()
              },
              unmute: function() {
                this._isMuted = !1,
                  this._updateVolume()
              },
              getVolume: function() {
                return this._volume
              },
              _updateVolume: function() {
                var e, t = this.audios.length;
                for (e = 0; e < t; e += 1)
                  this.audios[e].volume(this._volume * (this._isMuted ? 0 : 1))
              }
            },
              function() {
                return new e
              }
          }()
            , createTypedArray = function() {
            function e(e, t) {
              var i, n = 0, r = [];
              switch (e) {
                case "int16":
                case "uint8c":
                  i = 1;
                  break;
                default:
                  i = 1.1
              }
              for (n = 0; n < t; n += 1)
                r.push(i);
              return r
            }
            return "function" == typeof Uint8ClampedArray && "function" == typeof Float32Array ? function(t, i) {
                return "float32" === t ? new Float32Array(i) : "int16" === t ? new Int16Array(i) : "uint8c" === t ? new Uint8ClampedArray(i) : e(t, i)
              }
              : e
          }();
          function createSizedArray(e) {
            return Array.apply(null, {
              length: e
            })
          }
          function _typeof$6(e) {
            return _typeof$6 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                return typeof e
              }
              : function(e) {
                return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
              }
              ,
              _typeof$6(e)
          }
          var subframeEnabled = !0
            , expressionsPlugin = null
            , idPrefix$1 = ""
            , isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent)
            , _shouldRoundValues = !1
            , bmPow = Math.pow
            , bmSqrt = Math.sqrt
            , bmFloor = Math.floor
            , bmMax = Math.max
            , bmMin = Math.min
            , BMMath = {};
          function ProjectInterface$1() {
            return {}
          }
          !function() {
            var e, t = ["abs", "acos", "acosh", "asin", "asinh", "atan", "atanh", "atan2", "ceil", "cbrt", "expm1", "clz32", "cos", "cosh", "exp", "floor", "fround", "hypot", "imul", "log", "log1p", "log2", "log10", "max", "min", "pow", "random", "round", "sign", "sin", "sinh", "sqrt", "tan", "tanh", "trunc", "E", "LN10", "LN2", "LOG10E", "LOG2E", "PI", "SQRT1_2", "SQRT2"], i = t.length;
            for (e = 0; e < i; e += 1)
              BMMath[t[e]] = Math[t[e]]
          }(),
            BMMath.random = Math.random,
            BMMath.abs = function(e) {
              if ("object" === _typeof$6(e) && e.length) {
                var t, i = createSizedArray(e.length), n = e.length;
                for (t = 0; t < n; t += 1)
                  i[t] = Math.abs(e[t]);
                return i
              }
              return Math.abs(e)
            }
          ;
          var defaultCurveSegments = 150
            , degToRads = Math.PI / 180
            , roundCorner = .5519;
          function roundValues(e) {
            _shouldRoundValues = !!e
          }
          function bmRnd(e) {
            return _shouldRoundValues ? Math.round(e) : e
          }
          function styleDiv(e) {
            e.style.position = "absolute",
              e.style.top = 0,
              e.style.left = 0,
              e.style.display = "block",
              e.style.transformOrigin = "0 0",
              e.style.webkitTransformOrigin = "0 0",
              e.style.backfaceVisibility = "visible",
              e.style.webkitBackfaceVisibility = "visible",
              e.style.transformStyle = "preserve-3d",
              e.style.webkitTransformStyle = "preserve-3d",
              e.style.mozTransformStyle = "preserve-3d"
          }
          function BMEnterFrameEvent(e, t, i, n) {
            this.type = e,
              this.currentTime = t,
              this.totalTime = i,
              this.direction = n < 0 ? -1 : 1
          }
          function BMCompleteEvent(e, t) {
            this.type = e,
              this.direction = t < 0 ? -1 : 1
          }
          function BMCompleteLoopEvent(e, t, i, n) {
            this.type = e,
              this.currentLoop = i,
              this.totalLoops = t,
              this.direction = n < 0 ? -1 : 1
          }
          function BMSegmentStartEvent(e, t, i) {
            this.type = e,
              this.firstFrame = t,
              this.totalFrames = i
          }
          function BMDestroyEvent(e, t) {
            this.type = e,
              this.target = t
          }
          function BMRenderFrameErrorEvent(e, t) {
            this.type = "renderFrameError",
              this.nativeError = e,
              this.currentTime = t
          }
          function BMConfigErrorEvent(e) {
            this.type = "configError",
              this.nativeError = e
          }
          function BMAnimationConfigErrorEvent(e, t) {
            this.type = e,
              this.nativeError = t
          }
          var createElementID = (_count = 0,
              function() {
                return idPrefix$1 + "__lottie_element_" + (_count += 1)
              }
          ), _count;
          function HSVtoRGB(e, t, i) {
            var n, r, s, a, o, l, h, c;
            switch (l = i * (1 - t),
              h = i * (1 - (o = 6 * e - (a = Math.floor(6 * e))) * t),
              c = i * (1 - (1 - o) * t),
            a % 6) {
              case 0:
                n = i,
                  r = c,
                  s = l;
                break;
              case 1:
                n = h,
                  r = i,
                  s = l;
                break;
              case 2:
                n = l,
                  r = i,
                  s = c;
                break;
              case 3:
                n = l,
                  r = h,
                  s = i;
                break;
              case 4:
                n = c,
                  r = l,
                  s = i;
                break;
              case 5:
                n = i,
                  r = l,
                  s = h
            }
            return [n, r, s]
          }
          function RGBtoHSV(e, t, i) {
            var n, r = Math.max(e, t, i), s = Math.min(e, t, i), a = r - s, o = 0 === r ? 0 : a / r, l = r / 255;
            switch (r) {
              case s:
                n = 0;
                break;
              case e:
                n = t - i + a * (t < i ? 6 : 0),
                  n /= 6 * a;
                break;
              case t:
                n = i - e + 2 * a,
                  n /= 6 * a;
                break;
              case i:
                n = e - t + 4 * a,
                  n /= 6 * a
            }
            return [n, o, l]
          }
          function addSaturationToRGB(e, t) {
            var i = RGBtoHSV(255 * e[0], 255 * e[1], 255 * e[2]);
            return i[1] += t,
              i[1] > 1 ? i[1] = 1 : i[1] <= 0 && (i[1] = 0),
              HSVtoRGB(i[0], i[1], i[2])
          }
          function addBrightnessToRGB(e, t) {
            var i = RGBtoHSV(255 * e[0], 255 * e[1], 255 * e[2]);
            return i[2] += t,
              i[2] > 1 ? i[2] = 1 : i[2] < 0 && (i[2] = 0),
              HSVtoRGB(i[0], i[1], i[2])
          }
          function addHueToRGB(e, t) {
            var i = RGBtoHSV(255 * e[0], 255 * e[1], 255 * e[2]);
            return i[0] += t / 360,
              i[0] > 1 ? i[0] -= 1 : i[0] < 0 && (i[0] += 1),
              HSVtoRGB(i[0], i[1], i[2])
          }
          var rgbToHex = function() {
            var e, t, i = [];
            for (e = 0; e < 256; e += 1)
              t = e.toString(16),
                i[e] = 1 === t.length ? "0" + t : t;
            return function(e, t, n) {
              return e < 0 && (e = 0),
              t < 0 && (t = 0),
              n < 0 && (n = 0),
              "#" + i[e] + i[t] + i[n]
            }
          }()
            , setSubframeEnabled = function(e) {
            subframeEnabled = !!e
          }
            , getSubframeEnabled = function() {
            return subframeEnabled
          }
            , setExpressionsPlugin = function(e) {
            expressionsPlugin = e
          }
            , getExpressionsPlugin = function() {
            return expressionsPlugin
          }
            , setDefaultCurveSegments = function(e) {
            defaultCurveSegments = e
          }
            , getDefaultCurveSegments = function() {
            return defaultCurveSegments
          }
            , setIdPrefix = function(e) {
            idPrefix$1 = e
          }
            , getIdPrefix = function() {
            return idPrefix$1
          };
          function createNS(e) {
            return document.createElementNS(svgNS, e)
          }
          function _typeof$5(e) {
            return _typeof$5 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                return typeof e
              }
              : function(e) {
                return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
              }
              ,
              _typeof$5(e)
          }
          var dataManager = function() {
            var e, t, i = 1, n = [], r = {
              onmessage: function() {},
              postMessage: function(t) {
                e({
                  data: t
                })
              }
            }, s = {
              postMessage: function(e) {
                r.onmessage({
                  data: e
                })
              }
            };
            function a() {
              t || (t = function(t) {
                  if (window.Worker && window.Blob && getWebWorker()) {
                    var i = new Blob(["var _workerSelf = self; self.onmessage = ", t.toString()],{
                      type: "text/javascript"
                    })
                      , n = URL.createObjectURL(i);
                    return new Worker(n)
                  }
                  return e = t,
                    r
                }((function(e) {
                    if (s.dataManager || (s.dataManager = function() {
                      function e(r, s) {
                        var a, o, l, h, c, u, d, p = r.length;
                        for (o = 0; o < p; o += 1)
                          if ("ks"in (a = r[o]) && !a.completed) {
                            if (a.completed = !0,
                            a.tt && (r[o - 1].td = a.tt),
                              a.hasMask) {
                              var f = a.masksProperties;
                              for (h = f.length,
                                     l = 0; l < h; l += 1)
                                if (f[l].pt.k.i)
                                  n(f[l].pt.k);
                                else
                                  for (u = f[l].pt.k.length,
                                         c = 0; c < u; c += 1)
                                    f[l].pt.k[c].s && n(f[l].pt.k[c].s[0]),
                                    f[l].pt.k[c].e && n(f[l].pt.k[c].e[0])
                            }
                            0 === a.ty ? (a.layers = t(a.refId, s),
                              e(a.layers, s)) : 4 === a.ty ? i(a.shapes) : 5 === a.ty && (0 === (d = a).t.a.length && d.t.p)
                          }
                      }
                      function t(e, t) {
                        var i = function(e, t) {
                          for (var i = 0, n = t.length; i < n; ) {
                            if (t[i].id === e)
                              return t[i];
                            i += 1
                          }
                          return null
                        }(e, t);
                        return i ? i.layers.__used ? JSON.parse(JSON.stringify(i.layers)) : (i.layers.__used = !0,
                          i.layers) : null
                      }
                      function i(e) {
                        var t, r, s;
                        for (t = e.length - 1; t >= 0; t -= 1)
                          if ("sh" === e[t].ty)
                            if (e[t].ks.k.i)
                              n(e[t].ks.k);
                            else
                              for (s = e[t].ks.k.length,
                                     r = 0; r < s; r += 1)
                                e[t].ks.k[r].s && n(e[t].ks.k[r].s[0]),
                                e[t].ks.k[r].e && n(e[t].ks.k[r].e[0]);
                          else
                            "gr" === e[t].ty && i(e[t].it)
                      }
                      function n(e) {
                        var t, i = e.i.length;
                        for (t = 0; t < i; t += 1)
                          e.i[t][0] += e.v[t][0],
                            e.i[t][1] += e.v[t][1],
                            e.o[t][0] += e.v[t][0],
                            e.o[t][1] += e.v[t][1]
                      }
                      function r(e, t) {
                        var i = t ? t.split(".") : [100, 100, 100];
                        return e[0] > i[0] || !(i[0] > e[0]) && (e[1] > i[1] || !(i[1] > e[1]) && (e[2] > i[2] || !(i[2] > e[2]) && null))
                      }
                      var s, a = function() {
                        var e = [4, 4, 14];
                        function t(e) {
                          var t, i, n, r = e.length;
                          for (t = 0; t < r; t += 1)
                            5 === e[t].ty && (void 0,
                              n = (i = e[t]).t.d,
                              i.t.d = {
                                k: [{
                                  s: n,
                                  t: 0
                                }]
                              })
                        }
                        return function(i) {
                          if (r(e, i.v) && (t(i.layers),
                            i.assets)) {
                            var n, s = i.assets.length;
                            for (n = 0; n < s; n += 1)
                              i.assets[n].layers && t(i.assets[n].layers)
                          }
                        }
                      }(), o = (s = [4, 7, 99],
                          function(e) {
                            if (e.chars && !r(s, e.v)) {
                              var t, n = e.chars.length;
                              for (t = 0; t < n; t += 1) {
                                var a = e.chars[t];
                                a.data && a.data.shapes && (i(a.data.shapes),
                                  a.data.ip = 0,
                                  a.data.op = 99999,
                                  a.data.st = 0,
                                  a.data.sr = 1,
                                  a.data.ks = {
                                    p: {
                                      k: [0, 0],
                                      a: 0
                                    },
                                    s: {
                                      k: [100, 100],
                                      a: 0
                                    },
                                    a: {
                                      k: [0, 0],
                                      a: 0
                                    },
                                    r: {
                                      k: 0,
                                      a: 0
                                    },
                                    o: {
                                      k: 100,
                                      a: 0
                                    }
                                  },
                                e.chars[t].t || (a.data.shapes.push({
                                  ty: "no"
                                }),
                                  a.data.shapes[0].it.push({
                                    p: {
                                      k: [0, 0],
                                      a: 0
                                    },
                                    s: {
                                      k: [100, 100],
                                      a: 0
                                    },
                                    a: {
                                      k: [0, 0],
                                      a: 0
                                    },
                                    r: {
                                      k: 0,
                                      a: 0
                                    },
                                    o: {
                                      k: 100,
                                      a: 0
                                    },
                                    sk: {
                                      k: 0,
                                      a: 0
                                    },
                                    sa: {
                                      k: 0,
                                      a: 0
                                    },
                                    ty: "tr"
                                  })))
                              }
                            }
                          }
                      ), l = function() {
                        var e = [5, 7, 15];
                        function t(e) {
                          var t, i, n = e.length;
                          for (t = 0; t < n; t += 1)
                            5 === e[t].ty && (i = void 0,
                            "number" == typeof (i = e[t].t.p).a && (i.a = {
                              a: 0,
                              k: i.a
                            }),
                            "number" == typeof i.p && (i.p = {
                              a: 0,
                              k: i.p
                            }),
                            "number" == typeof i.r && (i.r = {
                              a: 0,
                              k: i.r
                            }))
                        }
                        return function(i) {
                          if (r(e, i.v) && (t(i.layers),
                            i.assets)) {
                            var n, s = i.assets.length;
                            for (n = 0; n < s; n += 1)
                              i.assets[n].layers && t(i.assets[n].layers)
                          }
                        }
                      }(), h = function() {
                        var e = [4, 1, 9];
                        function t(e) {
                          var i, n, r, s = e.length;
                          for (i = 0; i < s; i += 1)
                            if ("gr" === e[i].ty)
                              t(e[i].it);
                            else if ("fl" === e[i].ty || "st" === e[i].ty)
                              if (e[i].c.k && e[i].c.k[0].i)
                                for (r = e[i].c.k.length,
                                       n = 0; n < r; n += 1)
                                  e[i].c.k[n].s && (e[i].c.k[n].s[0] /= 255,
                                    e[i].c.k[n].s[1] /= 255,
                                    e[i].c.k[n].s[2] /= 255,
                                    e[i].c.k[n].s[3] /= 255),
                                  e[i].c.k[n].e && (e[i].c.k[n].e[0] /= 255,
                                    e[i].c.k[n].e[1] /= 255,
                                    e[i].c.k[n].e[2] /= 255,
                                    e[i].c.k[n].e[3] /= 255);
                              else
                                e[i].c.k[0] /= 255,
                                  e[i].c.k[1] /= 255,
                                  e[i].c.k[2] /= 255,
                                  e[i].c.k[3] /= 255
                        }
                        function i(e) {
                          var i, n = e.length;
                          for (i = 0; i < n; i += 1)
                            4 === e[i].ty && t(e[i].shapes)
                        }
                        return function(t) {
                          if (r(e, t.v) && (i(t.layers),
                            t.assets)) {
                            var n, s = t.assets.length;
                            for (n = 0; n < s; n += 1)
                              t.assets[n].layers && i(t.assets[n].layers)
                          }
                        }
                      }(), c = function() {
                        var e = [4, 4, 18];
                        function t(e) {
                          var i, n, r;
                          for (i = e.length - 1; i >= 0; i -= 1)
                            if ("sh" === e[i].ty)
                              if (e[i].ks.k.i)
                                e[i].ks.k.c = e[i].closed;
                              else
                                for (r = e[i].ks.k.length,
                                       n = 0; n < r; n += 1)
                                  e[i].ks.k[n].s && (e[i].ks.k[n].s[0].c = e[i].closed),
                                  e[i].ks.k[n].e && (e[i].ks.k[n].e[0].c = e[i].closed);
                            else
                              "gr" === e[i].ty && t(e[i].it)
                        }
                        function i(e) {
                          var i, n, r, s, a, o, l = e.length;
                          for (n = 0; n < l; n += 1) {
                            if ((i = e[n]).hasMask) {
                              var h = i.masksProperties;
                              for (s = h.length,
                                     r = 0; r < s; r += 1)
                                if (h[r].pt.k.i)
                                  h[r].pt.k.c = h[r].cl;
                                else
                                  for (o = h[r].pt.k.length,
                                         a = 0; a < o; a += 1)
                                    h[r].pt.k[a].s && (h[r].pt.k[a].s[0].c = h[r].cl),
                                    h[r].pt.k[a].e && (h[r].pt.k[a].e[0].c = h[r].cl)
                            }
                            4 === i.ty && t(i.shapes)
                          }
                        }
                        return function(t) {
                          if (r(e, t.v) && (i(t.layers),
                            t.assets)) {
                            var n, s = t.assets.length;
                            for (n = 0; n < s; n += 1)
                              t.assets[n].layers && i(t.assets[n].layers)
                          }
                        }
                      }();
                      var u = {
                        completeData: function(i) {
                          i.__complete || (h(i),
                            a(i),
                            o(i),
                            l(i),
                            c(i),
                            e(i.layers, i.assets),
                            function(i, n) {
                              if (i) {
                                var r = 0
                                  , s = i.length;
                                for (r = 0; r < s; r += 1)
                                  1 === i[r].t && (i[r].data.layers = t(i[r].data.refId, n),
                                    e(i[r].data.layers, n))
                              }
                            }(i.chars, i.assets),
                            i.__complete = !0)
                        }
                      };
                      return u.checkColors = h,
                        u.checkChars = o,
                        u.checkPathProperties = l,
                        u.checkShapes = c,
                        u.completeLayers = e,
                        u
                    }()),
                    s.assetLoader || (s.assetLoader = function() {
                      function e(e) {
                        var t = e.getResponseHeader("content-type");
                        return t && "json" === e.responseType && -1 !== t.indexOf("json") || e.response && "object" === _typeof$5(e.response) ? e.response : e.response && "string" == typeof e.response ? JSON.parse(e.response) : e.responseText ? JSON.parse(e.responseText) : null
                      }
                      return {
                        load: function(t, i, n, r) {
                          var s, a = new XMLHttpRequest;
                          try {
                            a.responseType = "json"
                          } catch (e) {}
                          a.onreadystatechange = function() {
                            if (4 === a.readyState)
                              if (200 === a.status)
                                s = e(a),
                                  n(s);
                              else
                                try {
                                  s = e(a),
                                    n(s)
                                } catch (e) {
                                  r && r(e)
                                }
                          }
                          ;
                          try {
                            a.open("GET", t, !0)
                          } catch (e) {
                            a.open("GET", i + "/" + t, !0)
                          }
                          a.send()
                        }
                      }
                    }()),
                    "loadAnimation" === e.data.type)
                      s.assetLoader.load(e.data.path, e.data.fullPath, (function(t) {
                          s.dataManager.completeData(t),
                            s.postMessage({
                              id: e.data.id,
                              payload: t,
                              status: "success"
                            })
                        }
                      ), (function() {
                          s.postMessage({
                            id: e.data.id,
                            status: "error"
                          })
                        }
                      ));
                    else if ("complete" === e.data.type) {
                      var t = e.data.animation;
                      s.dataManager.completeData(t),
                        s.postMessage({
                          id: e.data.id,
                          payload: t,
                          status: "success"
                        })
                    } else
                      "loadData" === e.data.type && s.assetLoader.load(e.data.path, e.data.fullPath, (function(t) {
                          s.postMessage({
                            id: e.data.id,
                            payload: t,
                            status: "success"
                          })
                        }
                      ), (function() {
                          s.postMessage({
                            id: e.data.id,
                            status: "error"
                          })
                        }
                      ))
                  }
                )),
                  t.onmessage = function(e) {
                    var t = e.data
                      , i = t.id
                      , r = n[i];
                    n[i] = null,
                      "success" === t.status ? r.onComplete(t.payload) : r.onError && r.onError()
                  }
              )
            }
            function o(e, t) {
              var r = "processId_" + (i += 1);
              return n[r] = {
                onComplete: e,
                onError: t
              },
                r
            }
            return {
              loadAnimation: function(e, i, n) {
                a();
                var r = o(i, n);
                t.postMessage({
                  type: "loadAnimation",
                  path: e,
                  fullPath: window.location.origin + window.location.pathname,
                  id: r
                })
              },
              loadData: function(e, i, n) {
                a();
                var r = o(i, n);
                t.postMessage({
                  type: "loadData",
                  path: e,
                  fullPath: window.location.origin + window.location.pathname,
                  id: r
                })
              },
              completeAnimation: function(e, i, n) {
                a();
                var r = o(i, n);
                t.postMessage({
                  type: "complete",
                  animation: e,
                  id: r
                })
              }
            }
          }()
            , ImagePreloader = function() {
            var e = function() {
              var e = createTag("canvas");
              e.width = 1,
                e.height = 1;
              var t = e.getContext("2d");
              return t.fillStyle = "rgba(0,0,0,0)",
                t.fillRect(0, 0, 1, 1),
                e
            }();
            function t() {
              this.loadedAssets += 1,
              this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages && this.imagesLoadedCb && this.imagesLoadedCb(null)
            }
            function i() {
              this.loadedFootagesCount += 1,
              this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages && this.imagesLoadedCb && this.imagesLoadedCb(null)
            }
            function n(e, t, i) {
              var n = "";
              if (e.e)
                n = e.p;
              else if (t) {
                var r = e.p;
                -1 !== r.indexOf("images/") && (r = r.split("/")[1]),
                  n = t + r
              } else
                n = i,
                  n += e.u ? e.u : "",
                  n += e.p;
              return n
            }
            function r(e) {
              var t = 0
                , i = setInterval(function() {
                (e.getBBox().width || t > 500) && (this._imageLoaded(),
                  clearInterval(i)),
                  t += 1
              }
                .bind(this), 50)
            }
            function s(e) {
              var t = {
                assetData: e
              }
                , i = n(e, this.assetsPath, this.path);
              return dataManager.loadData(i, function(e) {
                t.img = e,
                  this._footageLoaded()
              }
                .bind(this), function() {
                t.img = {},
                  this._footageLoaded()
              }
                .bind(this)),
                t
            }
            function a() {
              this._imageLoaded = t.bind(this),
                this._footageLoaded = i.bind(this),
                this.testImageLoaded = r.bind(this),
                this.createFootageData = s.bind(this),
                this.assetsPath = "",
                this.path = "",
                this.totalImages = 0,
                this.totalFootages = 0,
                this.loadedAssets = 0,
                this.loadedFootagesCount = 0,
                this.imagesLoadedCb = null,
                this.images = []
            }
            return a.prototype = {
              loadAssets: function(e, t) {
                var i;
                this.imagesLoadedCb = t;
                var n = e.length;
                for (i = 0; i < n; i += 1)
                  e[i].layers || (e[i].t && "seq" !== e[i].t ? 3 === e[i].t && (this.totalFootages += 1,
                    this.images.push(this.createFootageData(e[i]))) : (this.totalImages += 1,
                    this.images.push(this._createImageData(e[i]))))
              },
              setAssetsPath: function(e) {
                this.assetsPath = e || ""
              },
              setPath: function(e) {
                this.path = e || ""
              },
              loadedImages: function() {
                return this.totalImages === this.loadedAssets
              },
              loadedFootages: function() {
                return this.totalFootages === this.loadedFootagesCount
              },
              destroy: function() {
                this.imagesLoadedCb = null,
                  this.images.length = 0
              },
              getAsset: function(e) {
                for (var t = 0, i = this.images.length; t < i; ) {
                  if (this.images[t].assetData === e)
                    return this.images[t].img;
                  t += 1
                }
                return null
              },
              createImgData: function(t) {
                var i = n(t, this.assetsPath, this.path)
                  , r = createTag("img");
                r.crossOrigin = "anonymous",
                  r.addEventListener("load", this._imageLoaded, !1),
                  r.addEventListener("error", function() {
                    s.img = e,
                      this._imageLoaded()
                  }
                    .bind(this), !1),
                  r.src = i;
                var s = {
                  img: r,
                  assetData: t
                };
                return s
              },
              createImageData: function(t) {
                var i = n(t, this.assetsPath, this.path)
                  , r = createNS("image");
                isSafari ? this.testImageLoaded(r) : r.addEventListener("load", this._imageLoaded, !1),
                  r.addEventListener("error", function() {
                    s.img = e,
                      this._imageLoaded()
                  }
                    .bind(this), !1),
                  r.setAttributeNS("http://www.w3.org/1999/xlink", "href", i),
                  this._elementHelper.append ? this._elementHelper.append(r) : this._elementHelper.appendChild(r);
                var s = {
                  img: r,
                  assetData: t
                };
                return s
              },
              imageLoaded: t,
              footageLoaded: i,
              setCacheType: function(e, t) {
                "svg" === e ? (this._elementHelper = t,
                  this._createImageData = this.createImageData.bind(this)) : this._createImageData = this.createImgData.bind(this)
              }
            },
              a
          }();
          function BaseEvent() {}
          BaseEvent.prototype = {
            triggerEvent: function(e, t) {
              if (this._cbs[e])
                for (var i = this._cbs[e], n = 0; n < i.length; n += 1)
                  i[n](t)
            },
            addEventListener: function(e, t) {
              return this._cbs[e] || (this._cbs[e] = []),
                this._cbs[e].push(t),
                function() {
                  this.removeEventListener(e, t)
                }
                  .bind(this)
            },
            removeEventListener: function(e, t) {
              if (t) {
                if (this._cbs[e]) {
                  for (var i = 0, n = this._cbs[e].length; i < n; )
                    this._cbs[e][i] === t && (this._cbs[e].splice(i, 1),
                      i -= 1,
                      n -= 1),
                      i += 1;
                  this._cbs[e].length || (this._cbs[e] = null)
                }
              } else
                this._cbs[e] = null
            }
          };
          var markerParser = function() {
            function e(e) {
              for (var t, i = e.split("\r\n"), n = {}, r = 0, s = 0; s < i.length; s += 1)
                2 === (t = i[s].split(":")).length && (n[t[0]] = t[1].trim(),
                  r += 1);
              if (0 === r)
                throw new Error;
              return n
            }
            return function(t) {
              for (var i = [], n = 0; n < t.length; n += 1) {
                var r = t[n]
                  , s = {
                  time: r.tm,
                  duration: r.dr
                };
                try {
                  s.payload = JSON.parse(t[n].cm)
                } catch (i) {
                  try {
                    s.payload = e(t[n].cm)
                  } catch (e) {
                    s.payload = {
                      name: t[n].cm
                    }
                  }
                }
                i.push(s)
              }
              return i
            }
          }()
            , ProjectInterface = function() {
            function e(e) {
              this.compositions.push(e)
            }
            return function() {
              function t(e) {
                for (var t = 0, i = this.compositions.length; t < i; ) {
                  if (this.compositions[t].data && this.compositions[t].data.nm === e)
                    return this.compositions[t].prepareFrame && this.compositions[t].data.xt && this.compositions[t].prepareFrame(this.currentFrame),
                      this.compositions[t].compInterface;
                  t += 1
                }
                return null
              }
              return t.compositions = [],
                t.currentFrame = 0,
                t.registerComposition = e,
                t
            }
          }()
            , renderers = {}
            , registerRenderer = function(e, t) {
            renderers[e] = t
          };
          function getRenderer(e) {
            return renderers[e]
          }
          function _typeof$4(e) {
            return _typeof$4 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                return typeof e
              }
              : function(e) {
                return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
              }
              ,
              _typeof$4(e)
          }
          var AnimationItem = function() {
            this._cbs = [],
              this.name = "",
              this.path = "",
              this.isLoaded = !1,
              this.currentFrame = 0,
              this.currentRawFrame = 0,
              this.firstFrame = 0,
              this.totalFrames = 0,
              this.frameRate = 0,
              this.frameMult = 0,
              this.playSpeed = 1,
              this.playDirection = 1,
              this.playCount = 0,
              this.animationData = {},
              this.assets = [],
              this.isPaused = !0,
              this.autoplay = !1,
              this.loop = !0,
              this.renderer = null,
              this.animationID = createElementID(),
              this.assetsPath = "",
              this.timeCompleted = 0,
              this.segmentPos = 0,
              this.isSubframeEnabled = getSubframeEnabled(),
              this.segments = [],
              this._idle = !0,
              this._completedLoop = !1,
              this.projectInterface = ProjectInterface(),
              this.imagePreloader = new ImagePreloader,
              this.audioController = audioControllerFactory(),
              this.markers = [],
              this.configAnimation = this.configAnimation.bind(this),
              this.onSetupError = this.onSetupError.bind(this),
              this.onSegmentComplete = this.onSegmentComplete.bind(this),
              this.drawnFrameEvent = new BMEnterFrameEvent("drawnFrame",0,0,0)
          };
          extendPrototype([BaseEvent], AnimationItem),
            AnimationItem.prototype.setParams = function(e) {
              (e.wrapper || e.container) && (this.wrapper = e.wrapper || e.container);
              var t = "svg";
              e.animType ? t = e.animType : e.renderer && (t = e.renderer);
              var i = getRenderer(t);
              this.renderer = new i(this,e.rendererSettings),
                this.imagePreloader.setCacheType(t, this.renderer.globalData.defs),
                this.renderer.setProjectInterface(this.projectInterface),
                this.animType = t,
                "" === e.loop || null === e.loop || void 0 === e.loop || !0 === e.loop ? this.loop = !0 : !1 === e.loop ? this.loop = !1 : this.loop = parseInt(e.loop, 10),
                this.autoplay = !("autoplay"in e) || e.autoplay,
                this.name = e.name ? e.name : "",
                this.autoloadSegments = !Object.prototype.hasOwnProperty.call(e, "autoloadSegments") || e.autoloadSegments,
                this.assetsPath = e.assetsPath,
                this.initialSegment = e.initialSegment,
              e.audioFactory && this.audioController.setAudioFactory(e.audioFactory),
                e.animationData ? this.setupAnimation(e.animationData) : e.path && (-1 !== e.path.lastIndexOf("\\") ? this.path = e.path.substr(0, e.path.lastIndexOf("\\") + 1) : this.path = e.path.substr(0, e.path.lastIndexOf("/") + 1),
                  this.fileName = e.path.substr(e.path.lastIndexOf("/") + 1),
                  this.fileName = this.fileName.substr(0, this.fileName.lastIndexOf(".json")),
                  dataManager.loadAnimation(e.path, this.configAnimation, this.onSetupError))
            }
            ,
            AnimationItem.prototype.onSetupError = function() {
              this.trigger("data_failed")
            }
            ,
            AnimationItem.prototype.setupAnimation = function(e) {
              dataManager.completeAnimation(e, this.configAnimation)
            }
            ,
            AnimationItem.prototype.setData = function(e, t) {
              t && "object" !== _typeof$4(t) && (t = JSON.parse(t));
              var i = {
                wrapper: e,
                animationData: t
              }
                , n = e.attributes;
              i.path = n.getNamedItem("data-animation-path") ? n.getNamedItem("data-animation-path").value : n.getNamedItem("data-bm-path") ? n.getNamedItem("data-bm-path").value : n.getNamedItem("bm-path") ? n.getNamedItem("bm-path").value : "",
                i.animType = n.getNamedItem("data-anim-type") ? n.getNamedItem("data-anim-type").value : n.getNamedItem("data-bm-type") ? n.getNamedItem("data-bm-type").value : n.getNamedItem("bm-type") ? n.getNamedItem("bm-type").value : n.getNamedItem("data-bm-renderer") ? n.getNamedItem("data-bm-renderer").value : n.getNamedItem("bm-renderer") ? n.getNamedItem("bm-renderer").value : "canvas";
              var r = n.getNamedItem("data-anim-loop") ? n.getNamedItem("data-anim-loop").value : n.getNamedItem("data-bm-loop") ? n.getNamedItem("data-bm-loop").value : n.getNamedItem("bm-loop") ? n.getNamedItem("bm-loop").value : "";
              "false" === r ? i.loop = !1 : "true" === r ? i.loop = !0 : "" !== r && (i.loop = parseInt(r, 10));
              var s = n.getNamedItem("data-anim-autoplay") ? n.getNamedItem("data-anim-autoplay").value : n.getNamedItem("data-bm-autoplay") ? n.getNamedItem("data-bm-autoplay").value : !n.getNamedItem("bm-autoplay") || n.getNamedItem("bm-autoplay").value;
              i.autoplay = "false" !== s,
                i.name = n.getNamedItem("data-name") ? n.getNamedItem("data-name").value : n.getNamedItem("data-bm-name") ? n.getNamedItem("data-bm-name").value : n.getNamedItem("bm-name") ? n.getNamedItem("bm-name").value : "",
              "false" === (n.getNamedItem("data-anim-prerender") ? n.getNamedItem("data-anim-prerender").value : n.getNamedItem("data-bm-prerender") ? n.getNamedItem("data-bm-prerender").value : n.getNamedItem("bm-prerender") ? n.getNamedItem("bm-prerender").value : "") && (i.prerender = !1),
                this.setParams(i)
            }
            ,
            AnimationItem.prototype.includeLayers = function(e) {
              e.op > this.animationData.op && (this.animationData.op = e.op,
                this.totalFrames = Math.floor(e.op - this.animationData.ip));
              var t, i, n = this.animationData.layers, r = n.length, s = e.layers, a = s.length;
              for (i = 0; i < a; i += 1)
                for (t = 0; t < r; ) {
                  if (n[t].id === s[i].id) {
                    n[t] = s[i];
                    break
                  }
                  t += 1
                }
              if ((e.chars || e.fonts) && (this.renderer.globalData.fontManager.addChars(e.chars),
                this.renderer.globalData.fontManager.addFonts(e.fonts, this.renderer.globalData.defs)),
                e.assets)
                for (r = e.assets.length,
                       t = 0; t < r; t += 1)
                  this.animationData.assets.push(e.assets[t]);
              this.animationData.__complete = !1,
                dataManager.completeAnimation(this.animationData, this.onSegmentComplete)
            }
            ,
            AnimationItem.prototype.onSegmentComplete = function(e) {
              this.animationData = e;
              var t = getExpressionsPlugin();
              t && t.initExpressions(this),
                this.loadNextSegment()
            }
            ,
            AnimationItem.prototype.loadNextSegment = function() {
              var e = this.animationData.segments;
              if (!e || 0 === e.length || !this.autoloadSegments)
                return this.trigger("data_ready"),
                  void (this.timeCompleted = this.totalFrames);
              var t = e.shift();
              this.timeCompleted = t.time * this.frameRate;
              var i = this.path + this.fileName + "_" + this.segmentPos + ".json";
              this.segmentPos += 1,
                dataManager.loadData(i, this.includeLayers.bind(this), function() {
                  this.trigger("data_failed")
                }
                  .bind(this))
            }
            ,
            AnimationItem.prototype.loadSegments = function() {
              this.animationData.segments || (this.timeCompleted = this.totalFrames),
                this.loadNextSegment()
            }
            ,
            AnimationItem.prototype.imagesLoaded = function() {
              this.trigger("loaded_images"),
                this.checkLoaded()
            }
            ,
            AnimationItem.prototype.preloadImages = function() {
              this.imagePreloader.setAssetsPath(this.assetsPath),
                this.imagePreloader.setPath(this.path),
                this.imagePreloader.loadAssets(this.animationData.assets, this.imagesLoaded.bind(this))
            }
            ,
            AnimationItem.prototype.configAnimation = function(e) {
              if (this.renderer)
                try {
                  this.animationData = e,
                    this.initialSegment ? (this.totalFrames = Math.floor(this.initialSegment[1] - this.initialSegment[0]),
                      this.firstFrame = Math.round(this.initialSegment[0])) : (this.totalFrames = Math.floor(this.animationData.op - this.animationData.ip),
                      this.firstFrame = Math.round(this.animationData.ip)),
                    this.renderer.configAnimation(e),
                  e.assets || (e.assets = []),
                    this.assets = this.animationData.assets,
                    this.frameRate = this.animationData.fr,
                    this.frameMult = this.animationData.fr / 1e3,
                    this.renderer.searchExtraCompositions(e.assets),
                    this.markers = markerParser(e.markers || []),
                    this.trigger("config_ready"),
                    this.preloadImages(),
                    this.loadSegments(),
                    this.updaFrameModifier(),
                    this.waitForFontsLoaded(),
                  this.isPaused && this.audioController.pause()
                } catch (e) {
                  this.triggerConfigError(e)
                }
            }
            ,
            AnimationItem.prototype.waitForFontsLoaded = function() {
              this.renderer && (this.renderer.globalData.fontManager.isLoaded ? this.checkLoaded() : setTimeout(this.waitForFontsLoaded.bind(this), 20))
            }
            ,
            AnimationItem.prototype.checkLoaded = function() {
              if (!this.isLoaded && this.renderer.globalData.fontManager.isLoaded && (this.imagePreloader.loadedImages() || "canvas" !== this.renderer.rendererType) && this.imagePreloader.loadedFootages()) {
                this.isLoaded = !0;
                var e = getExpressionsPlugin();
                e && e.initExpressions(this),
                  this.renderer.initItems(),
                  setTimeout(function() {
                    this.trigger("DOMLoaded")
                  }
                    .bind(this), 0),
                  this.gotoFrame(),
                this.autoplay && this.play()
              }
            }
            ,
            AnimationItem.prototype.resize = function() {
              this.renderer.updateContainerSize()
            }
            ,
            AnimationItem.prototype.setSubframe = function(e) {
              this.isSubframeEnabled = !!e
            }
            ,
            AnimationItem.prototype.gotoFrame = function() {
              this.currentFrame = this.isSubframeEnabled ? this.currentRawFrame : ~~this.currentRawFrame,
              this.timeCompleted !== this.totalFrames && this.currentFrame > this.timeCompleted && (this.currentFrame = this.timeCompleted),
                this.trigger("enterFrame"),
                this.renderFrame(),
                this.trigger("drawnFrame")
            }
            ,
            AnimationItem.prototype.renderFrame = function() {
              if (!1 !== this.isLoaded && this.renderer)
                try {
                  this.renderer.renderFrame(this.currentFrame + this.firstFrame)
                } catch (e) {
                  this.triggerRenderFrameError(e)
                }
            }
            ,
            AnimationItem.prototype.play = function(e) {
              e && this.name !== e || !0 === this.isPaused && (this.isPaused = !1,
                this.trigger("_pause"),
                this.audioController.resume(),
              this._idle && (this._idle = !1,
                this.trigger("_active")))
            }
            ,
            AnimationItem.prototype.pause = function(e) {
              e && this.name !== e || !1 === this.isPaused && (this.isPaused = !0,
                this.trigger("_play"),
                this._idle = !0,
                this.trigger("_idle"),
                this.audioController.pause())
            }
            ,
            AnimationItem.prototype.togglePause = function(e) {
              e && this.name !== e || (!0 === this.isPaused ? this.play() : this.pause())
            }
            ,
            AnimationItem.prototype.stop = function(e) {
              e && this.name !== e || (this.pause(),
                this.playCount = 0,
                this._completedLoop = !1,
                this.setCurrentRawFrameValue(0))
            }
            ,
            AnimationItem.prototype.getMarkerData = function(e) {
              for (var t, i = 0; i < this.markers.length; i += 1)
                if ((t = this.markers[i]).payload && t.payload.name === e)
                  return t;
              return null
            }
            ,
            AnimationItem.prototype.goToAndStop = function(e, t, i) {
              if (!i || this.name === i) {
                var n = Number(e);
                if (isNaN(n)) {
                  var r = this.getMarkerData(e);
                  r && this.goToAndStop(r.time, !0)
                } else
                  t ? this.setCurrentRawFrameValue(e) : this.setCurrentRawFrameValue(e * this.frameModifier);
                this.pause()
              }
            }
            ,
            AnimationItem.prototype.goToAndPlay = function(e, t, i) {
              if (!i || this.name === i) {
                var n = Number(e);
                if (isNaN(n)) {
                  var r = this.getMarkerData(e);
                  r && (r.duration ? this.playSegments([r.time, r.time + r.duration], !0) : this.goToAndStop(r.time, !0))
                } else
                  this.goToAndStop(n, t, i);
                this.play()
              }
            }
            ,
            AnimationItem.prototype.advanceTime = function(e) {
              if (!0 !== this.isPaused && !1 !== this.isLoaded) {
                var t = this.currentRawFrame + e * this.frameModifier
                  , i = !1;
                t >= this.totalFrames - 1 && this.frameModifier > 0 ? this.loop && this.playCount !== this.loop ? t >= this.totalFrames ? (this.playCount += 1,
                this.checkSegments(t % this.totalFrames) || (this.setCurrentRawFrameValue(t % this.totalFrames),
                  this._completedLoop = !0,
                  this.trigger("loopComplete"))) : this.setCurrentRawFrameValue(t) : this.checkSegments(t > this.totalFrames ? t % this.totalFrames : 0) || (i = !0,
                  t = this.totalFrames - 1) : t < 0 ? this.checkSegments(t % this.totalFrames) || (!this.loop || this.playCount-- <= 0 && !0 !== this.loop ? (i = !0,
                  t = 0) : (this.setCurrentRawFrameValue(this.totalFrames + t % this.totalFrames),
                  this._completedLoop ? this.trigger("loopComplete") : this._completedLoop = !0)) : this.setCurrentRawFrameValue(t),
                i && (this.setCurrentRawFrameValue(t),
                  this.pause(),
                  this.trigger("complete"))
              }
            }
            ,
            AnimationItem.prototype.adjustSegment = function(e, t) {
              this.playCount = 0,
                e[1] < e[0] ? (this.frameModifier > 0 && (this.playSpeed < 0 ? this.setSpeed(-this.playSpeed) : this.setDirection(-1)),
                  this.totalFrames = e[0] - e[1],
                  this.timeCompleted = this.totalFrames,
                  this.firstFrame = e[1],
                  this.setCurrentRawFrameValue(this.totalFrames - .001 - t)) : e[1] > e[0] && (this.frameModifier < 0 && (this.playSpeed < 0 ? this.setSpeed(-this.playSpeed) : this.setDirection(1)),
                  this.totalFrames = e[1] - e[0],
                  this.timeCompleted = this.totalFrames,
                  this.firstFrame = e[0],
                  this.setCurrentRawFrameValue(.001 + t)),
                this.trigger("segmentStart")
            }
            ,
            AnimationItem.prototype.setSegment = function(e, t) {
              var i = -1;
              this.isPaused && (this.currentRawFrame + this.firstFrame < e ? i = e : this.currentRawFrame + this.firstFrame > t && (i = t - e)),
                this.firstFrame = e,
                this.totalFrames = t - e,
                this.timeCompleted = this.totalFrames,
              -1 !== i && this.goToAndStop(i, !0)
            }
            ,
            AnimationItem.prototype.playSegments = function(e, t) {
              if (t && (this.segments.length = 0),
              "object" === _typeof$4(e[0])) {
                var i, n = e.length;
                for (i = 0; i < n; i += 1)
                  this.segments.push(e[i])
              } else
                this.segments.push(e);
              this.segments.length && t && this.adjustSegment(this.segments.shift(), 0),
              this.isPaused && this.play()
            }
            ,
            AnimationItem.prototype.resetSegments = function(e) {
              this.segments.length = 0,
                this.segments.push([this.animationData.ip, this.animationData.op]),
              e && this.checkSegments(0)
            }
            ,
            AnimationItem.prototype.checkSegments = function(e) {
              return !!this.segments.length && (this.adjustSegment(this.segments.shift(), e),
                !0)
            }
            ,
            AnimationItem.prototype.destroy = function(e) {
              e && this.name !== e || !this.renderer || (this.renderer.destroy(),
                this.imagePreloader.destroy(),
                this.trigger("destroy"),
                this._cbs = null,
                this.onEnterFrame = null,
                this.onLoopComplete = null,
                this.onComplete = null,
                this.onSegmentStart = null,
                this.onDestroy = null,
                this.renderer = null,
                this.renderer = null,
                this.imagePreloader = null,
                this.projectInterface = null)
            }
            ,
            AnimationItem.prototype.setCurrentRawFrameValue = function(e) {
              this.currentRawFrame = e,
                this.gotoFrame()
            }
            ,
            AnimationItem.prototype.setSpeed = function(e) {
              this.playSpeed = e,
                this.updaFrameModifier()
            }
            ,
            AnimationItem.prototype.setDirection = function(e) {
              this.playDirection = e < 0 ? -1 : 1,
                this.updaFrameModifier()
            }
            ,
            AnimationItem.prototype.setVolume = function(e, t) {
              t && this.name !== t || this.audioController.setVolume(e)
            }
            ,
            AnimationItem.prototype.getVolume = function() {
              return this.audioController.getVolume()
            }
            ,
            AnimationItem.prototype.mute = function(e) {
              e && this.name !== e || this.audioController.mute()
            }
            ,
            AnimationItem.prototype.unmute = function(e) {
              e && this.name !== e || this.audioController.unmute()
            }
            ,
            AnimationItem.prototype.updaFrameModifier = function() {
              this.frameModifier = this.frameMult * this.playSpeed * this.playDirection,
                this.audioController.setRate(this.playSpeed * this.playDirection)
            }
            ,
            AnimationItem.prototype.getPath = function() {
              return this.path
            }
            ,
            AnimationItem.prototype.getAssetsPath = function(e) {
              var t = "";
              if (e.e)
                t = e.p;
              else if (this.assetsPath) {
                var i = e.p;
                -1 !== i.indexOf("images/") && (i = i.split("/")[1]),
                  t = this.assetsPath + i
              } else
                t = this.path,
                  t += e.u ? e.u : "",
                  t += e.p;
              return t
            }
            ,
            AnimationItem.prototype.getAssetData = function(e) {
              for (var t = 0, i = this.assets.length; t < i; ) {
                if (e === this.assets[t].id)
                  return this.assets[t];
                t += 1
              }
              return null
            }
            ,
            AnimationItem.prototype.hide = function() {
              this.renderer.hide()
            }
            ,
            AnimationItem.prototype.show = function() {
              this.renderer.show()
            }
            ,
            AnimationItem.prototype.getDuration = function(e) {
              return e ? this.totalFrames : this.totalFrames / this.frameRate
            }
            ,
            AnimationItem.prototype.updateDocumentData = function(e, t, i) {
              try {
                this.renderer.getElementByPath(e).updateDocumentData(t, i)
              } catch (e) {}
            }
            ,
            AnimationItem.prototype.trigger = function(e) {
              if (this._cbs && this._cbs[e])
                switch (e) {
                  case "enterFrame":
                    this.triggerEvent(e, new BMEnterFrameEvent(e,this.currentFrame,this.totalFrames,this.frameModifier));
                    break;
                  case "drawnFrame":
                    this.drawnFrameEvent.currentTime = this.currentFrame,
                      this.drawnFrameEvent.totalTime = this.totalFrames,
                      this.drawnFrameEvent.direction = this.frameModifier,
                      this.triggerEvent(e, this.drawnFrameEvent);
                    break;
                  case "loopComplete":
                    this.triggerEvent(e, new BMCompleteLoopEvent(e,this.loop,this.playCount,this.frameMult));
                    break;
                  case "complete":
                    this.triggerEvent(e, new BMCompleteEvent(e,this.frameMult));
                    break;
                  case "segmentStart":
                    this.triggerEvent(e, new BMSegmentStartEvent(e,this.firstFrame,this.totalFrames));
                    break;
                  case "destroy":
                    this.triggerEvent(e, new BMDestroyEvent(e,this));
                    break;
                  default:
                    this.triggerEvent(e)
                }
              "enterFrame" === e && this.onEnterFrame && this.onEnterFrame.call(this, new BMEnterFrameEvent(e,this.currentFrame,this.totalFrames,this.frameMult)),
              "loopComplete" === e && this.onLoopComplete && this.onLoopComplete.call(this, new BMCompleteLoopEvent(e,this.loop,this.playCount,this.frameMult)),
              "complete" === e && this.onComplete && this.onComplete.call(this, new BMCompleteEvent(e,this.frameMult)),
              "segmentStart" === e && this.onSegmentStart && this.onSegmentStart.call(this, new BMSegmentStartEvent(e,this.firstFrame,this.totalFrames)),
              "destroy" === e && this.onDestroy && this.onDestroy.call(this, new BMDestroyEvent(e,this))
            }
            ,
            AnimationItem.prototype.triggerRenderFrameError = function(e) {
              var t = new BMRenderFrameErrorEvent(e,this.currentFrame);
              this.triggerEvent("error", t),
              this.onError && this.onError.call(this, t)
            }
            ,
            AnimationItem.prototype.triggerConfigError = function(e) {
              var t = new BMConfigErrorEvent(e,this.currentFrame);
              this.triggerEvent("error", t),
              this.onError && this.onError.call(this, t)
            }
          ;
          var animationManager = function() {
            var e = {}
              , t = []
              , i = 0
              , n = 0
              , r = 0
              , s = !0
              , a = !1;
            function o(e) {
              for (var i = 0, r = e.target; i < n; )
                t[i].animation === r && (t.splice(i, 1),
                  i -= 1,
                  n -= 1,
                r.isPaused || c()),
                  i += 1
            }
            function l(e, i) {
              if (!e)
                return null;
              for (var r = 0; r < n; ) {
                if (t[r].elem === e && null !== t[r].elem)
                  return t[r].animation;
                r += 1
              }
              var s = new AnimationItem;
              return u(s, e),
                s.setData(e, i),
                s
            }
            function h() {
              r += 1,
                f()
            }
            function c() {
              r -= 1
            }
            function u(e, i) {
              e.addEventListener("destroy", o),
                e.addEventListener("_active", h),
                e.addEventListener("_idle", c),
                t.push({
                  elem: i,
                  animation: e
                }),
                n += 1
            }
            function d(e) {
              var o, l = e - i;
              for (o = 0; o < n; o += 1)
                t[o].animation.advanceTime(l);
              i = e,
                r && !a ? window.requestAnimationFrame(d) : s = !0
            }
            function p(e) {
              i = e,
                window.requestAnimationFrame(d)
            }
            function f() {
              !a && r && s && (window.requestAnimationFrame(p),
                s = !1)
            }
            return e.registerAnimation = l,
              e.loadAnimation = function(e) {
                var t = new AnimationItem;
                return u(t, null),
                  t.setParams(e),
                  t
              }
              ,
              e.setSpeed = function(e, i) {
                var r;
                for (r = 0; r < n; r += 1)
                  t[r].animation.setSpeed(e, i)
              }
              ,
              e.setDirection = function(e, i) {
                var r;
                for (r = 0; r < n; r += 1)
                  t[r].animation.setDirection(e, i)
              }
              ,
              e.play = function(e) {
                var i;
                for (i = 0; i < n; i += 1)
                  t[i].animation.play(e)
              }
              ,
              e.pause = function(e) {
                var i;
                for (i = 0; i < n; i += 1)
                  t[i].animation.pause(e)
              }
              ,
              e.stop = function(e) {
                var i;
                for (i = 0; i < n; i += 1)
                  t[i].animation.stop(e)
              }
              ,
              e.togglePause = function(e) {
                var i;
                for (i = 0; i < n; i += 1)
                  t[i].animation.togglePause(e)
              }
              ,
              e.searchAnimations = function(e, t, i) {
                var n, r = [].concat([].slice.call(document.getElementsByClassName("lottie")), [].slice.call(document.getElementsByClassName("bodymovin"))), s = r.length;
                for (n = 0; n < s; n += 1)
                  i && r[n].setAttribute("data-bm-type", i),
                    l(r[n], e);
                if (t && 0 === s) {
                  i || (i = "svg");
                  var a = document.getElementsByTagName("body")[0];
                  a.innerText = "";
                  var o = createTag("div");
                  o.style.width = "100%",
                    o.style.height = "100%",
                    o.setAttribute("data-bm-type", i),
                    a.appendChild(o),
                    l(o, e)
                }
              }
              ,
              e.resize = function() {
                var e;
                for (e = 0; e < n; e += 1)
                  t[e].animation.resize()
              }
              ,
              e.goToAndStop = function(e, i, r) {
                var s;
                for (s = 0; s < n; s += 1)
                  t[s].animation.goToAndStop(e, i, r)
              }
              ,
              e.destroy = function(e) {
                var i;
                for (i = n - 1; i >= 0; i -= 1)
                  t[i].animation.destroy(e)
              }
              ,
              e.freeze = function() {
                a = !0
              }
              ,
              e.unfreeze = function() {
                a = !1,
                  f()
              }
              ,
              e.setVolume = function(e, i) {
                var r;
                for (r = 0; r < n; r += 1)
                  t[r].animation.setVolume(e, i)
              }
              ,
              e.mute = function(e) {
                var i;
                for (i = 0; i < n; i += 1)
                  t[i].animation.mute(e)
              }
              ,
              e.unmute = function(e) {
                var i;
                for (i = 0; i < n; i += 1)
                  t[i].animation.unmute(e)
              }
              ,
              e.getRegisteredAnimations = function() {
                var e, i = t.length, n = [];
                for (e = 0; e < i; e += 1)
                  n.push(t[e].animation);
                return n
              }
              ,
              e
          }()
            , BezierFactory = function() {
            var e = {
              getBezierEasing: function(e, i, n, r, s) {
                var a = s || ("bez_" + e + "_" + i + "_" + n + "_" + r).replace(/\./g, "p");
                if (t[a])
                  return t[a];
                var o = new h([e, i, n, r]);
                return t[a] = o,
                  o
              }
            }
              , t = {}
              , i = .1
              , n = "function" == typeof Float32Array;
            function r(e, t) {
              return 1 - 3 * t + 3 * e
            }
            function s(e, t) {
              return 3 * t - 6 * e
            }
            function a(e) {
              return 3 * e
            }
            function o(e, t, i) {
              return ((r(t, i) * e + s(t, i)) * e + a(t)) * e
            }
            function l(e, t, i) {
              return 3 * r(t, i) * e * e + 2 * s(t, i) * e + a(t)
            }
            function h(e) {
              this._p = e,
                this._mSampleValues = n ? new Float32Array(11) : new Array(11),
                this._precomputed = !1,
                this.get = this.get.bind(this)
            }
            return h.prototype = {
              get: function(e) {
                var t = this._p[0]
                  , i = this._p[1]
                  , n = this._p[2]
                  , r = this._p[3];
                return this._precomputed || this._precompute(),
                  t === i && n === r ? e : 0 === e ? 0 : 1 === e ? 1 : o(this._getTForX(e), i, r)
              },
              _precompute: function() {
                var e = this._p[0]
                  , t = this._p[1]
                  , i = this._p[2]
                  , n = this._p[3];
                this._precomputed = !0,
                e === t && i === n || this._calcSampleValues()
              },
              _calcSampleValues: function() {
                for (var e = this._p[0], t = this._p[2], n = 0; n < 11; ++n)
                  this._mSampleValues[n] = o(n * i, e, t)
              },
              _getTForX: function(e) {
                for (var t = this._p[0], n = this._p[2], r = this._mSampleValues, s = 0, a = 1; 10 !== a && r[a] <= e; ++a)
                  s += i;
                var h = s + (e - r[--a]) / (r[a + 1] - r[a]) * i
                  , c = l(h, t, n);
                return c >= .001 ? function(e, t, i, n) {
                  for (var r = 0; r < 4; ++r) {
                    var s = l(t, i, n);
                    if (0 === s)
                      return t;
                    t -= (o(t, i, n) - e) / s
                  }
                  return t
                }(e, h, t, n) : 0 === c ? h : function(e, t, i, n, r) {
                  var s, a, l = 0;
                  do {
                    (s = o(a = t + (i - t) / 2, n, r) - e) > 0 ? i = a : t = a
                  } while (Math.abs(s) > 1e-7 && ++l < 10);
                  return a
                }(e, s, s + i, t, n)
              }
            },
              e
          }()
            , pooling = {
            double: function(e) {
              return e.concat(createSizedArray(e.length))
            }
          }
            , poolFactory = function(e, t, i) {
            var n = 0
              , r = e
              , s = createSizedArray(r);
            return {
              newElement: function() {
                return n ? s[n -= 1] : t()
              },
              release: function(e) {
                n === r && (s = pooling.double(s),
                  r *= 2),
                i && i(e),
                  s[n] = e,
                  n += 1
              }
            }
          }
            , bezierLengthPool = poolFactory(8, (function() {
              return {
                addedLength: 0,
                percents: createTypedArray("float32", getDefaultCurveSegments()),
                lengths: createTypedArray("float32", getDefaultCurveSegments())
              }
            }
          ))
            , segmentsLengthPool = poolFactory(8, (function() {
              return {
                lengths: [],
                totalLength: 0
              }
            }
          ), (function(e) {
              var t, i = e.lengths.length;
              for (t = 0; t < i; t += 1)
                bezierLengthPool.release(e.lengths[t]);
              e.lengths.length = 0
            }
          ));
          function bezFunction() {
            var e = Math;
            function t(e, t, i, n, r, s) {
              var a = e * n + t * r + i * s - r * n - s * e - i * t;
              return a > -.001 && a < .001
            }
            var i = function(e, t, i, n) {
              var r, s, a, o, l, h, c = getDefaultCurveSegments(), u = 0, d = [], p = [], f = bezierLengthPool.newElement();
              for (a = i.length,
                     r = 0; r < c; r += 1) {
                for (l = r / (c - 1),
                       h = 0,
                       s = 0; s < a; s += 1)
                  o = bmPow(1 - l, 3) * e[s] + 3 * bmPow(1 - l, 2) * l * i[s] + 3 * (1 - l) * bmPow(l, 2) * n[s] + bmPow(l, 3) * t[s],
                    d[s] = o,
                  null !== p[s] && (h += bmPow(d[s] - p[s], 2)),
                    p[s] = d[s];
                h && (u += h = bmSqrt(h)),
                  f.percents[r] = l,
                  f.lengths[r] = u
              }
              return f.addedLength = u,
                f
            };
            function n(e) {
              this.segmentLength = 0,
                this.points = new Array(e)
            }
            function r(e, t) {
              this.partialLength = e,
                this.point = t
            }
            var s, a = (s = {},
                function(e, i, a, o) {
                  var l = (e[0] + "_" + e[1] + "_" + i[0] + "_" + i[1] + "_" + a[0] + "_" + a[1] + "_" + o[0] + "_" + o[1]).replace(/\./g, "p");
                  if (!s[l]) {
                    var h, c, u, d, p, f, m, g = getDefaultCurveSegments(), v = 0, y = null;
                    2 === e.length && (e[0] !== i[0] || e[1] !== i[1]) && t(e[0], e[1], i[0], i[1], e[0] + a[0], e[1] + a[1]) && t(e[0], e[1], i[0], i[1], i[0] + o[0], i[1] + o[1]) && (g = 2);
                    var x = new n(g);
                    for (u = a.length,
                           h = 0; h < g; h += 1) {
                      for (m = createSizedArray(u),
                             p = h / (g - 1),
                             f = 0,
                             c = 0; c < u; c += 1)
                        d = bmPow(1 - p, 3) * e[c] + 3 * bmPow(1 - p, 2) * p * (e[c] + a[c]) + 3 * (1 - p) * bmPow(p, 2) * (i[c] + o[c]) + bmPow(p, 3) * i[c],
                          m[c] = d,
                        null !== y && (f += bmPow(m[c] - y[c], 2));
                      v += f = bmSqrt(f),
                        x.points[h] = new r(f,m),
                        y = m
                    }
                    x.segmentLength = v,
                      s[l] = x
                  }
                  return s[l]
                }
            );
            function o(e, t) {
              var i = t.percents
                , n = t.lengths
                , r = i.length
                , s = bmFloor((r - 1) * e)
                , a = e * t.addedLength
                , o = 0;
              if (s === r - 1 || 0 === s || a === n[s])
                return i[s];
              for (var l = n[s] > a ? -1 : 1, h = !0; h; )
                if (n[s] <= a && n[s + 1] > a ? (o = (a - n[s]) / (n[s + 1] - n[s]),
                  h = !1) : s += l,
                s < 0 || s >= r - 1) {
                  if (s === r - 1)
                    return i[s];
                  h = !1
                }
              return i[s] + (i[s + 1] - i[s]) * o
            }
            var l = createTypedArray("float32", 8);
            return {
              getSegmentsLength: function(e) {
                var t, n = segmentsLengthPool.newElement(), r = e.c, s = e.v, a = e.o, o = e.i, l = e._length, h = n.lengths, c = 0;
                for (t = 0; t < l - 1; t += 1)
                  h[t] = i(s[t], s[t + 1], a[t], o[t + 1]),
                    c += h[t].addedLength;
                return r && l && (h[t] = i(s[t], s[0], a[t], o[0]),
                  c += h[t].addedLength),
                  n.totalLength = c,
                  n
              },
              getNewSegment: function(t, i, n, r, s, a, h) {
                s < 0 ? s = 0 : s > 1 && (s = 1);
                var c, u = o(s, h), d = o(a = a > 1 ? 1 : a, h), p = t.length, f = 1 - u, m = 1 - d, g = f * f * f, v = u * f * f * 3, y = u * u * f * 3, x = u * u * u, _ = f * f * m, b = u * f * m + f * u * m + f * f * d, w = u * u * m + f * u * d + u * f * d, A = u * u * d, S = f * m * m, M = u * m * m + f * d * m + f * m * d, T = u * d * m + f * d * d + u * m * d, E = u * d * d, C = m * m * m, P = d * m * m + m * d * m + m * m * d, D = d * d * m + m * d * d + d * m * d, I = d * d * d;
                for (c = 0; c < p; c += 1)
                  l[4 * c] = e.round(1e3 * (g * t[c] + v * n[c] + y * r[c] + x * i[c])) / 1e3,
                    l[4 * c + 1] = e.round(1e3 * (_ * t[c] + b * n[c] + w * r[c] + A * i[c])) / 1e3,
                    l[4 * c + 2] = e.round(1e3 * (S * t[c] + M * n[c] + T * r[c] + E * i[c])) / 1e3,
                    l[4 * c + 3] = e.round(1e3 * (C * t[c] + P * n[c] + D * r[c] + I * i[c])) / 1e3;
                return l
              },
              getPointInSegment: function(t, i, n, r, s, a) {
                var l = o(s, a)
                  , h = 1 - l;
                return [e.round(1e3 * (h * h * h * t[0] + (l * h * h + h * l * h + h * h * l) * n[0] + (l * l * h + h * l * l + l * h * l) * r[0] + l * l * l * i[0])) / 1e3, e.round(1e3 * (h * h * h * t[1] + (l * h * h + h * l * h + h * h * l) * n[1] + (l * l * h + h * l * l + l * h * l) * r[1] + l * l * l * i[1])) / 1e3]
              },
              buildBezierData: a,
              pointOnLine2D: t,
              pointOnLine3D: function(i, n, r, s, a, o, l, h, c) {
                if (0 === r && 0 === o && 0 === c)
                  return t(i, n, s, a, l, h);
                var u, d = e.sqrt(e.pow(s - i, 2) + e.pow(a - n, 2) + e.pow(o - r, 2)), p = e.sqrt(e.pow(l - i, 2) + e.pow(h - n, 2) + e.pow(c - r, 2)), f = e.sqrt(e.pow(l - s, 2) + e.pow(h - a, 2) + e.pow(c - o, 2));
                return (u = d > p ? d > f ? d - p - f : f - p - d : f > p ? f - p - d : p - d - f) > -1e-4 && u < 1e-4
              }
            }
          }
          var bez = bezFunction()
            , PropertyFactory = function() {
            var e = initialDefaultFrame
              , t = Math.abs;
            function i(e, t) {
              var i, r = this.offsetTime;
              "multidimensional" === this.propType && (i = createTypedArray("float32", this.pv.length));
              for (var s, a, o, l, h, c, u, d, p, f = t.lastIndex, m = f, g = this.keyframes.length - 1, v = !0; v; ) {
                if (s = this.keyframes[m],
                  a = this.keyframes[m + 1],
                m === g - 1 && e >= a.t - r) {
                  s.h && (s = a),
                    f = 0;
                  break
                }
                if (a.t - r > e) {
                  f = m;
                  break
                }
                m < g - 1 ? m += 1 : (f = 0,
                  v = !1)
              }
              o = this.keyframesMetadata[m] || {};
              var y, x, _, b, w, A, S, M, T, E, C = a.t - r, P = s.t - r;
              if (s.to) {
                o.bezierData || (o.bezierData = bez.buildBezierData(s.s, a.s || s.e, s.to, s.ti));
                var D = o.bezierData;
                if (e >= C || e < P) {
                  var I = e >= C ? D.points.length - 1 : 0;
                  for (h = D.points[I].point.length,
                         l = 0; l < h; l += 1)
                    i[l] = D.points[I].point[l]
                } else {
                  o.__fnct ? p = o.__fnct : (p = BezierFactory.getBezierEasing(s.o.x, s.o.y, s.i.x, s.i.y, s.n).get,
                    o.__fnct = p),
                    c = p((e - P) / (C - P));
                  var R, L = D.segmentLength * c, k = t.lastFrame < e && t._lastKeyframeIndex === m ? t._lastAddedLength : 0;
                  for (d = t.lastFrame < e && t._lastKeyframeIndex === m ? t._lastPoint : 0,
                         v = !0,
                         u = D.points.length; v; ) {
                    if (k += D.points[d].partialLength,
                    0 === L || 0 === c || d === D.points.length - 1) {
                      for (h = D.points[d].point.length,
                             l = 0; l < h; l += 1)
                        i[l] = D.points[d].point[l];
                      break
                    }
                    if (L >= k && L < k + D.points[d + 1].partialLength) {
                      for (R = (L - k) / D.points[d + 1].partialLength,
                             h = D.points[d].point.length,
                             l = 0; l < h; l += 1)
                        i[l] = D.points[d].point[l] + (D.points[d + 1].point[l] - D.points[d].point[l]) * R;
                      break
                    }
                    d < u - 1 ? d += 1 : v = !1
                  }
                  t._lastPoint = d,
                    t._lastAddedLength = k - D.points[d].partialLength,
                    t._lastKeyframeIndex = m
                }
              } else {
                var F, B, O, N, z;
                if (g = s.s.length,
                  y = a.s || s.e,
                this.sh && 1 !== s.h)
                  if (e >= C)
                    i[0] = y[0],
                      i[1] = y[1],
                      i[2] = y[2];
                  else if (e <= P)
                    i[0] = s.s[0],
                      i[1] = s.s[1],
                      i[2] = s.s[2];
                  else {
                    x = i,
                      _ = function(e, t, i) {
                        var n, r, s, a, o, l = [], h = e[0], c = e[1], u = e[2], d = e[3], p = t[0], f = t[1], m = t[2], g = t[3];
                        return (r = h * p + c * f + u * m + d * g) < 0 && (r = -r,
                          p = -p,
                          f = -f,
                          m = -m,
                          g = -g),
                          1 - r > 1e-6 ? (n = Math.acos(r),
                            s = Math.sin(n),
                            a = Math.sin((1 - i) * n) / s,
                            o = Math.sin(i * n) / s) : (a = 1 - i,
                            o = i),
                          l[0] = a * h + o * p,
                          l[1] = a * c + o * f,
                          l[2] = a * u + o * m,
                          l[3] = a * d + o * g,
                          l
                      }(n(s.s), n(y), (e - P) / (C - P)),
                      b = _[0],
                      w = _[1],
                      A = _[2],
                      S = _[3],
                      M = Math.atan2(2 * w * S - 2 * b * A, 1 - 2 * w * w - 2 * A * A),
                      T = Math.asin(2 * b * w + 2 * A * S),
                      E = Math.atan2(2 * b * S - 2 * w * A, 1 - 2 * b * b - 2 * A * A),
                      x[0] = M / degToRads,
                      x[1] = T / degToRads,
                      x[2] = E / degToRads
                  }
                else
                  for (m = 0; m < g; m += 1)
                    1 !== s.h && (e >= C ? c = 1 : e < P ? c = 0 : (s.o.x.constructor === Array ? (o.__fnct || (o.__fnct = []),
                      o.__fnct[m] ? p = o.__fnct[m] : (F = void 0 === s.o.x[m] ? s.o.x[0] : s.o.x[m],
                        B = void 0 === s.o.y[m] ? s.o.y[0] : s.o.y[m],
                        O = void 0 === s.i.x[m] ? s.i.x[0] : s.i.x[m],
                        N = void 0 === s.i.y[m] ? s.i.y[0] : s.i.y[m],
                        p = BezierFactory.getBezierEasing(F, B, O, N).get,
                        o.__fnct[m] = p)) : o.__fnct ? p = o.__fnct : (F = s.o.x,
                      B = s.o.y,
                      O = s.i.x,
                      N = s.i.y,
                      p = BezierFactory.getBezierEasing(F, B, O, N).get,
                      s.keyframeMetadata = p),
                      c = p((e - P) / (C - P)))),
                      y = a.s || s.e,
                      z = 1 === s.h ? s.s[m] : s.s[m] + (y[m] - s.s[m]) * c,
                      "multidimensional" === this.propType ? i[m] = z : i = z
              }
              return t.lastIndex = f,
                i
            }
            function n(e) {
              var t = e[0] * degToRads
                , i = e[1] * degToRads
                , n = e[2] * degToRads
                , r = Math.cos(t / 2)
                , s = Math.cos(i / 2)
                , a = Math.cos(n / 2)
                , o = Math.sin(t / 2)
                , l = Math.sin(i / 2)
                , h = Math.sin(n / 2);
              return [o * l * a + r * s * h, o * s * a + r * l * h, r * l * a - o * s * h, r * s * a - o * l * h]
            }
            function r() {
              var t = this.comp.renderedFrame - this.offsetTime
                , i = this.keyframes[0].t - this.offsetTime
                , n = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;
              if (!(t === this._caching.lastFrame || this._caching.lastFrame !== e && (this._caching.lastFrame >= n && t >= n || this._caching.lastFrame < i && t < i))) {
                this._caching.lastFrame >= t && (this._caching._lastKeyframeIndex = -1,
                  this._caching.lastIndex = 0);
                var r = this.interpolateValue(t, this._caching);
                this.pv = r
              }
              return this._caching.lastFrame = t,
                this.pv
            }
            function s(e) {
              var i;
              if ("unidimensional" === this.propType)
                i = e * this.mult,
                t(this.v - i) > 1e-5 && (this.v = i,
                  this._mdf = !0);
              else
                for (var n = 0, r = this.v.length; n < r; )
                  i = e[n] * this.mult,
                  t(this.v[n] - i) > 1e-5 && (this.v[n] = i,
                    this._mdf = !0),
                    n += 1
            }
            function a() {
              if (this.elem.globalData.frameId !== this.frameId && this.effectsSequence.length)
                if (this.lock)
                  this.setVValue(this.pv);
                else {
                  var e;
                  this.lock = !0,
                    this._mdf = this._isFirstFrame;
                  var t = this.effectsSequence.length
                    , i = this.kf ? this.pv : this.data.k;
                  for (e = 0; e < t; e += 1)
                    i = this.effectsSequence[e](i);
                  this.setVValue(i),
                    this._isFirstFrame = !1,
                    this.lock = !1,
                    this.frameId = this.elem.globalData.frameId
                }
            }
            function o(e) {
              this.effectsSequence.push(e),
                this.container.addDynamicProperty(this)
            }
            function l(e, t, i, n) {
              this.propType = "unidimensional",
                this.mult = i || 1,
                this.data = t,
                this.v = i ? t.k * i : t.k,
                this.pv = t.k,
                this._mdf = !1,
                this.elem = e,
                this.container = n,
                this.comp = e.comp,
                this.k = !1,
                this.kf = !1,
                this.vel = 0,
                this.effectsSequence = [],
                this._isFirstFrame = !0,
                this.getValue = a,
                this.setVValue = s,
                this.addEffect = o
            }
            function h(e, t, i, n) {
              var r;
              this.propType = "multidimensional",
                this.mult = i || 1,
                this.data = t,
                this._mdf = !1,
                this.elem = e,
                this.container = n,
                this.comp = e.comp,
                this.k = !1,
                this.kf = !1,
                this.frameId = -1;
              var l = t.k.length;
              for (this.v = createTypedArray("float32", l),
                     this.pv = createTypedArray("float32", l),
                     this.vel = createTypedArray("float32", l),
                     r = 0; r < l; r += 1)
                this.v[r] = t.k[r] * this.mult,
                  this.pv[r] = t.k[r];
              this._isFirstFrame = !0,
                this.effectsSequence = [],
                this.getValue = a,
                this.setVValue = s,
                this.addEffect = o
            }
            function c(t, n, l, h) {
              this.propType = "unidimensional",
                this.keyframes = n.k,
                this.keyframesMetadata = [],
                this.offsetTime = t.data.st,
                this.frameId = -1,
                this._caching = {
                  lastFrame: e,
                  lastIndex: 0,
                  value: 0,
                  _lastKeyframeIndex: -1
                },
                this.k = !0,
                this.kf = !0,
                this.data = n,
                this.mult = l || 1,
                this.elem = t,
                this.container = h,
                this.comp = t.comp,
                this.v = e,
                this.pv = e,
                this._isFirstFrame = !0,
                this.getValue = a,
                this.setVValue = s,
                this.interpolateValue = i,
                this.effectsSequence = [r.bind(this)],
                this.addEffect = o
            }
            function u(t, n, l, h) {
              var c;
              this.propType = "multidimensional";
              var u, d, p, f, m = n.k.length;
              for (c = 0; c < m - 1; c += 1)
                n.k[c].to && n.k[c].s && n.k[c + 1] && n.k[c + 1].s && (u = n.k[c].s,
                  d = n.k[c + 1].s,
                  p = n.k[c].to,
                  f = n.k[c].ti,
                (2 === u.length && (u[0] !== d[0] || u[1] !== d[1]) && bez.pointOnLine2D(u[0], u[1], d[0], d[1], u[0] + p[0], u[1] + p[1]) && bez.pointOnLine2D(u[0], u[1], d[0], d[1], d[0] + f[0], d[1] + f[1]) || 3 === u.length && (u[0] !== d[0] || u[1] !== d[1] || u[2] !== d[2]) && bez.pointOnLine3D(u[0], u[1], u[2], d[0], d[1], d[2], u[0] + p[0], u[1] + p[1], u[2] + p[2]) && bez.pointOnLine3D(u[0], u[1], u[2], d[0], d[1], d[2], d[0] + f[0], d[1] + f[1], d[2] + f[2])) && (n.k[c].to = null,
                  n.k[c].ti = null),
                u[0] === d[0] && u[1] === d[1] && 0 === p[0] && 0 === p[1] && 0 === f[0] && 0 === f[1] && (2 === u.length || u[2] === d[2] && 0 === p[2] && 0 === f[2]) && (n.k[c].to = null,
                  n.k[c].ti = null));
              this.effectsSequence = [r.bind(this)],
                this.data = n,
                this.keyframes = n.k,
                this.keyframesMetadata = [],
                this.offsetTime = t.data.st,
                this.k = !0,
                this.kf = !0,
                this._isFirstFrame = !0,
                this.mult = l || 1,
                this.elem = t,
                this.container = h,
                this.comp = t.comp,
                this.getValue = a,
                this.setVValue = s,
                this.interpolateValue = i,
                this.frameId = -1;
              var g = n.k[0].s.length;
              for (this.v = createTypedArray("float32", g),
                     this.pv = createTypedArray("float32", g),
                     c = 0; c < g; c += 1)
                this.v[c] = e,
                  this.pv[c] = e;
              this._caching = {
                lastFrame: e,
                lastIndex: 0,
                value: createTypedArray("float32", g)
              },
                this.addEffect = o
            }
            return {
              getProp: function(e, t, i, n, r) {
                var s;
                if (t.k.length)
                  if ("number" == typeof t.k[0])
                    s = new h(e,t,n,r);
                  else
                    switch (i) {
                      case 0:
                        s = new c(e,t,n,r);
                        break;
                      case 1:
                        s = new u(e,t,n,r)
                    }
                else
                  s = new l(e,t,n,r);
                return s.effectsSequence.length && r.addDynamicProperty(s),
                  s
              }
            }
          }();
          function DynamicPropertyContainer() {}
          DynamicPropertyContainer.prototype = {
            addDynamicProperty: function(e) {
              -1 === this.dynamicProperties.indexOf(e) && (this.dynamicProperties.push(e),
                this.container.addDynamicProperty(this),
                this._isAnimated = !0)
            },
            iterateDynamicProperties: function() {
              var e;
              this._mdf = !1;
              var t = this.dynamicProperties.length;
              for (e = 0; e < t; e += 1)
                this.dynamicProperties[e].getValue(),
                this.dynamicProperties[e]._mdf && (this._mdf = !0)
            },
            initDynamicPropertyContainer: function(e) {
              this.container = e,
                this.dynamicProperties = [],
                this._mdf = !1,
                this._isAnimated = !1
            }
          };
          var pointPool = poolFactory(8, (function() {
              return createTypedArray("float32", 2)
            }
          ));
          function ShapePath() {
            this.c = !1,
              this._length = 0,
              this._maxLength = 8,
              this.v = createSizedArray(this._maxLength),
              this.o = createSizedArray(this._maxLength),
              this.i = createSizedArray(this._maxLength)
          }
          ShapePath.prototype.setPathData = function(e, t) {
            this.c = e,
              this.setLength(t);
            for (var i = 0; i < t; )
              this.v[i] = pointPool.newElement(),
                this.o[i] = pointPool.newElement(),
                this.i[i] = pointPool.newElement(),
                i += 1
          }
            ,
            ShapePath.prototype.setLength = function(e) {
              for (; this._maxLength < e; )
                this.doubleArrayLength();
              this._length = e
            }
            ,
            ShapePath.prototype.doubleArrayLength = function() {
              this.v = this.v.concat(createSizedArray(this._maxLength)),
                this.i = this.i.concat(createSizedArray(this._maxLength)),
                this.o = this.o.concat(createSizedArray(this._maxLength)),
                this._maxLength *= 2
            }
            ,
            ShapePath.prototype.setXYAt = function(e, t, i, n, r) {
              var s;
              switch (this._length = Math.max(this._length, n + 1),
              this._length >= this._maxLength && this.doubleArrayLength(),
                i) {
                case "v":
                  s = this.v;
                  break;
                case "i":
                  s = this.i;
                  break;
                case "o":
                  s = this.o;
                  break;
                default:
                  s = []
              }
              (!s[n] || s[n] && !r) && (s[n] = pointPool.newElement()),
                s[n][0] = e,
                s[n][1] = t
            }
            ,
            ShapePath.prototype.setTripleAt = function(e, t, i, n, r, s, a, o) {
              this.setXYAt(e, t, "v", a, o),
                this.setXYAt(i, n, "o", a, o),
                this.setXYAt(r, s, "i", a, o)
            }
            ,
            ShapePath.prototype.reverse = function() {
              var e = new ShapePath;
              e.setPathData(this.c, this._length);
              var t = this.v
                , i = this.o
                , n = this.i
                , r = 0;
              this.c && (e.setTripleAt(t[0][0], t[0][1], n[0][0], n[0][1], i[0][0], i[0][1], 0, !1),
                r = 1);
              var s, a = this._length - 1, o = this._length;
              for (s = r; s < o; s += 1)
                e.setTripleAt(t[a][0], t[a][1], n[a][0], n[a][1], i[a][0], i[a][1], s, !1),
                  a -= 1;
              return e
            }
          ;
          var shapePool = (factory = poolFactory(4, (function() {
              return new ShapePath
            }
          ), (function(e) {
              var t, i = e._length;
              for (t = 0; t < i; t += 1)
                pointPool.release(e.v[t]),
                  pointPool.release(e.i[t]),
                  pointPool.release(e.o[t]),
                  e.v[t] = null,
                  e.i[t] = null,
                  e.o[t] = null;
              e._length = 0,
                e.c = !1
            }
          )),
            factory.clone = function(e) {
              var t, i = factory.newElement(), n = void 0 === e._length ? e.v.length : e._length;
              for (i.setLength(n),
                     i.c = e.c,
                     t = 0; t < n; t += 1)
                i.setTripleAt(e.v[t][0], e.v[t][1], e.o[t][0], e.o[t][1], e.i[t][0], e.i[t][1], t);
              return i
            }
            ,
            factory), factory;
          function ShapeCollection() {
            this._length = 0,
              this._maxLength = 4,
              this.shapes = createSizedArray(this._maxLength)
          }
          ShapeCollection.prototype.addShape = function(e) {
            this._length === this._maxLength && (this.shapes = this.shapes.concat(createSizedArray(this._maxLength)),
              this._maxLength *= 2),
              this.shapes[this._length] = e,
              this._length += 1
          }
            ,
            ShapeCollection.prototype.releaseShapes = function() {
              var e;
              for (e = 0; e < this._length; e += 1)
                shapePool.release(this.shapes[e]);
              this._length = 0
            }
          ;
          var shapeCollectionPool = (ob = {
            newShapeCollection: function() {
              return _length ? pool[_length -= 1] : new ShapeCollection
            },
            release: function(e) {
              var t, i = e._length;
              for (t = 0; t < i; t += 1)
                shapePool.release(e.shapes[t]);
              e._length = 0,
              _length === _maxLength && (pool = pooling.double(pool),
                _maxLength *= 2),
                pool[_length] = e,
                _length += 1
            }
          },
            _length = 0,
            _maxLength = 4,
            pool = createSizedArray(_maxLength),
            ob), ob, _length, _maxLength, pool, ShapePropertyFactory = function() {
            var e = -999999;
            function t(e, t, i) {
              var n, r, s, a, o, l, h, c, u, d = i.lastIndex, p = this.keyframes;
              if (e < p[0].t - this.offsetTime)
                n = p[0].s[0],
                  s = !0,
                  d = 0;
              else if (e >= p[p.length - 1].t - this.offsetTime)
                n = p[p.length - 1].s ? p[p.length - 1].s[0] : p[p.length - 2].e[0],
                  s = !0;
              else {
                for (var f, m, g, v = d, y = p.length - 1, x = !0; x && (f = p[v],
                  !((m = p[v + 1]).t - this.offsetTime > e)); )
                  v < y - 1 ? v += 1 : x = !1;
                if (g = this.keyframesMetadata[v] || {},
                  d = v,
                  !(s = 1 === f.h)) {
                  if (e >= m.t - this.offsetTime)
                    c = 1;
                  else if (e < f.t - this.offsetTime)
                    c = 0;
                  else {
                    var _;
                    g.__fnct ? _ = g.__fnct : (_ = BezierFactory.getBezierEasing(f.o.x, f.o.y, f.i.x, f.i.y).get,
                      g.__fnct = _),
                      c = _((e - (f.t - this.offsetTime)) / (m.t - this.offsetTime - (f.t - this.offsetTime)))
                  }
                  r = m.s ? m.s[0] : f.e[0]
                }
                n = f.s[0]
              }
              for (l = t._length,
                     h = n.i[0].length,
                     i.lastIndex = d,
                     a = 0; a < l; a += 1)
                for (o = 0; o < h; o += 1)
                  u = s ? n.i[a][o] : n.i[a][o] + (r.i[a][o] - n.i[a][o]) * c,
                    t.i[a][o] = u,
                    u = s ? n.o[a][o] : n.o[a][o] + (r.o[a][o] - n.o[a][o]) * c,
                    t.o[a][o] = u,
                    u = s ? n.v[a][o] : n.v[a][o] + (r.v[a][o] - n.v[a][o]) * c,
                    t.v[a][o] = u
            }
            function i() {
              var t = this.comp.renderedFrame - this.offsetTime
                , i = this.keyframes[0].t - this.offsetTime
                , n = this.keyframes[this.keyframes.length - 1].t - this.offsetTime
                , r = this._caching.lastFrame;
              return r !== e && (r < i && t < i || r > n && t > n) || (this._caching.lastIndex = r < t ? this._caching.lastIndex : 0,
                this.interpolateShape(t, this.pv, this._caching)),
                this._caching.lastFrame = t,
                this.pv
            }
            function n() {
              this.paths = this.localShapeCollection
            }
            function r(e) {
              (function(e, t) {
                  if (e._length !== t._length || e.c !== t.c)
                    return !1;
                  var i, n = e._length;
                  for (i = 0; i < n; i += 1)
                    if (e.v[i][0] !== t.v[i][0] || e.v[i][1] !== t.v[i][1] || e.o[i][0] !== t.o[i][0] || e.o[i][1] !== t.o[i][1] || e.i[i][0] !== t.i[i][0] || e.i[i][1] !== t.i[i][1])
                      return !1;
                  return !0
                }
              )(this.v, e) || (this.v = shapePool.clone(e),
                this.localShapeCollection.releaseShapes(),
                this.localShapeCollection.addShape(this.v),
                this._mdf = !0,
                this.paths = this.localShapeCollection)
            }
            function s() {
              if (this.elem.globalData.frameId !== this.frameId)
                if (this.effectsSequence.length)
                  if (this.lock)
                    this.setVValue(this.pv);
                  else {
                    var e, t;
                    this.lock = !0,
                      this._mdf = !1,
                      e = this.kf ? this.pv : this.data.ks ? this.data.ks.k : this.data.pt.k;
                    var i = this.effectsSequence.length;
                    for (t = 0; t < i; t += 1)
                      e = this.effectsSequence[t](e);
                    this.setVValue(e),
                      this.lock = !1,
                      this.frameId = this.elem.globalData.frameId
                  }
                else
                  this._mdf = !1
            }
            function a(e, t, i) {
              this.propType = "shape",
                this.comp = e.comp,
                this.container = e,
                this.elem = e,
                this.data = t,
                this.k = !1,
                this.kf = !1,
                this._mdf = !1;
              var r = 3 === i ? t.pt.k : t.ks.k;
              this.v = shapePool.clone(r),
                this.pv = shapePool.clone(this.v),
                this.localShapeCollection = shapeCollectionPool.newShapeCollection(),
                this.paths = this.localShapeCollection,
                this.paths.addShape(this.v),
                this.reset = n,
                this.effectsSequence = []
            }
            function o(e) {
              this.effectsSequence.push(e),
                this.container.addDynamicProperty(this)
            }
            function l(t, r, s) {
              this.propType = "shape",
                this.comp = t.comp,
                this.elem = t,
                this.container = t,
                this.offsetTime = t.data.st,
                this.keyframes = 3 === s ? r.pt.k : r.ks.k,
                this.keyframesMetadata = [],
                this.k = !0,
                this.kf = !0;
              var a = this.keyframes[0].s[0].i.length;
              this.v = shapePool.newElement(),
                this.v.setPathData(this.keyframes[0].s[0].c, a),
                this.pv = shapePool.clone(this.v),
                this.localShapeCollection = shapeCollectionPool.newShapeCollection(),
                this.paths = this.localShapeCollection,
                this.paths.addShape(this.v),
                this.lastFrame = e,
                this.reset = n,
                this._caching = {
                  lastFrame: e,
                  lastIndex: 0
                },
                this.effectsSequence = [i.bind(this)]
            }
            a.prototype.interpolateShape = t,
              a.prototype.getValue = s,
              a.prototype.setVValue = r,
              a.prototype.addEffect = o,
              l.prototype.getValue = s,
              l.prototype.interpolateShape = t,
              l.prototype.setVValue = r,
              l.prototype.addEffect = o;
            var h = function() {
              var e = roundCorner;
              function t(e, t) {
                this.v = shapePool.newElement(),
                  this.v.setPathData(!0, 4),
                  this.localShapeCollection = shapeCollectionPool.newShapeCollection(),
                  this.paths = this.localShapeCollection,
                  this.localShapeCollection.addShape(this.v),
                  this.d = t.d,
                  this.elem = e,
                  this.comp = e.comp,
                  this.frameId = -1,
                  this.initDynamicPropertyContainer(e),
                  this.p = PropertyFactory.getProp(e, t.p, 1, 0, this),
                  this.s = PropertyFactory.getProp(e, t.s, 1, 0, this),
                  this.dynamicProperties.length ? this.k = !0 : (this.k = !1,
                    this.convertEllToPath())
              }
              return t.prototype = {
                reset: n,
                getValue: function() {
                  this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId,
                    this.iterateDynamicProperties(),
                  this._mdf && this.convertEllToPath())
                },
                convertEllToPath: function() {
                  var t = this.p.v[0]
                    , i = this.p.v[1]
                    , n = this.s.v[0] / 2
                    , r = this.s.v[1] / 2
                    , s = 3 !== this.d
                    , a = this.v;
                  a.v[0][0] = t,
                    a.v[0][1] = i - r,
                    a.v[1][0] = s ? t + n : t - n,
                    a.v[1][1] = i,
                    a.v[2][0] = t,
                    a.v[2][1] = i + r,
                    a.v[3][0] = s ? t - n : t + n,
                    a.v[3][1] = i,
                    a.i[0][0] = s ? t - n * e : t + n * e,
                    a.i[0][1] = i - r,
                    a.i[1][0] = s ? t + n : t - n,
                    a.i[1][1] = i - r * e,
                    a.i[2][0] = s ? t + n * e : t - n * e,
                    a.i[2][1] = i + r,
                    a.i[3][0] = s ? t - n : t + n,
                    a.i[3][1] = i + r * e,
                    a.o[0][0] = s ? t + n * e : t - n * e,
                    a.o[0][1] = i - r,
                    a.o[1][0] = s ? t + n : t - n,
                    a.o[1][1] = i + r * e,
                    a.o[2][0] = s ? t - n * e : t + n * e,
                    a.o[2][1] = i + r,
                    a.o[3][0] = s ? t - n : t + n,
                    a.o[3][1] = i - r * e
                }
              },
                extendPrototype([DynamicPropertyContainer], t),
                t
            }()
              , c = function() {
              function e(e, t) {
                this.v = shapePool.newElement(),
                  this.v.setPathData(!0, 0),
                  this.elem = e,
                  this.comp = e.comp,
                  this.data = t,
                  this.frameId = -1,
                  this.d = t.d,
                  this.initDynamicPropertyContainer(e),
                  1 === t.sy ? (this.ir = PropertyFactory.getProp(e, t.ir, 0, 0, this),
                    this.is = PropertyFactory.getProp(e, t.is, 0, .01, this),
                    this.convertToPath = this.convertStarToPath) : this.convertToPath = this.convertPolygonToPath,
                  this.pt = PropertyFactory.getProp(e, t.pt, 0, 0, this),
                  this.p = PropertyFactory.getProp(e, t.p, 1, 0, this),
                  this.r = PropertyFactory.getProp(e, t.r, 0, degToRads, this),
                  this.or = PropertyFactory.getProp(e, t.or, 0, 0, this),
                  this.os = PropertyFactory.getProp(e, t.os, 0, .01, this),
                  this.localShapeCollection = shapeCollectionPool.newShapeCollection(),
                  this.localShapeCollection.addShape(this.v),
                  this.paths = this.localShapeCollection,
                  this.dynamicProperties.length ? this.k = !0 : (this.k = !1,
                    this.convertToPath())
              }
              return e.prototype = {
                reset: n,
                getValue: function() {
                  this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId,
                    this.iterateDynamicProperties(),
                  this._mdf && this.convertToPath())
                },
                convertStarToPath: function() {
                  var e, t, i, n, r = 2 * Math.floor(this.pt.v), s = 2 * Math.PI / r, a = !0, o = this.or.v, l = this.ir.v, h = this.os.v, c = this.is.v, u = 2 * Math.PI * o / (2 * r), d = 2 * Math.PI * l / (2 * r), p = -Math.PI / 2;
                  p += this.r.v;
                  var f = 3 === this.data.d ? -1 : 1;
                  for (this.v._length = 0,
                         e = 0; e < r; e += 1) {
                    i = a ? h : c,
                      n = a ? u : d;
                    var m = (t = a ? o : l) * Math.cos(p)
                      , g = t * Math.sin(p)
                      , v = 0 === m && 0 === g ? 0 : g / Math.sqrt(m * m + g * g)
                      , y = 0 === m && 0 === g ? 0 : -m / Math.sqrt(m * m + g * g);
                    m += +this.p.v[0],
                      g += +this.p.v[1],
                      this.v.setTripleAt(m, g, m - v * n * i * f, g - y * n * i * f, m + v * n * i * f, g + y * n * i * f, e, !0),
                      a = !a,
                      p += s * f
                  }
                },
                convertPolygonToPath: function() {
                  var e, t = Math.floor(this.pt.v), i = 2 * Math.PI / t, n = this.or.v, r = this.os.v, s = 2 * Math.PI * n / (4 * t), a = .5 * -Math.PI, o = 3 === this.data.d ? -1 : 1;
                  for (a += this.r.v,
                         this.v._length = 0,
                         e = 0; e < t; e += 1) {
                    var l = n * Math.cos(a)
                      , h = n * Math.sin(a)
                      , c = 0 === l && 0 === h ? 0 : h / Math.sqrt(l * l + h * h)
                      , u = 0 === l && 0 === h ? 0 : -l / Math.sqrt(l * l + h * h);
                    l += +this.p.v[0],
                      h += +this.p.v[1],
                      this.v.setTripleAt(l, h, l - c * s * r * o, h - u * s * r * o, l + c * s * r * o, h + u * s * r * o, e, !0),
                      a += i * o
                  }
                  this.paths.length = 0,
                    this.paths[0] = this.v
                }
              },
                extendPrototype([DynamicPropertyContainer], e),
                e
            }()
              , u = function() {
              function e(e, t) {
                this.v = shapePool.newElement(),
                  this.v.c = !0,
                  this.localShapeCollection = shapeCollectionPool.newShapeCollection(),
                  this.localShapeCollection.addShape(this.v),
                  this.paths = this.localShapeCollection,
                  this.elem = e,
                  this.comp = e.comp,
                  this.frameId = -1,
                  this.d = t.d,
                  this.initDynamicPropertyContainer(e),
                  this.p = PropertyFactory.getProp(e, t.p, 1, 0, this),
                  this.s = PropertyFactory.getProp(e, t.s, 1, 0, this),
                  this.r = PropertyFactory.getProp(e, t.r, 0, 0, this),
                  this.dynamicProperties.length ? this.k = !0 : (this.k = !1,
                    this.convertRectToPath())
              }
              return e.prototype = {
                convertRectToPath: function() {
                  var e = this.p.v[0]
                    , t = this.p.v[1]
                    , i = this.s.v[0] / 2
                    , n = this.s.v[1] / 2
                    , r = bmMin(i, n, this.r.v)
                    , s = r * (1 - roundCorner);
                  this.v._length = 0,
                    2 === this.d || 1 === this.d ? (this.v.setTripleAt(e + i, t - n + r, e + i, t - n + r, e + i, t - n + s, 0, !0),
                      this.v.setTripleAt(e + i, t + n - r, e + i, t + n - s, e + i, t + n - r, 1, !0),
                      0 !== r ? (this.v.setTripleAt(e + i - r, t + n, e + i - r, t + n, e + i - s, t + n, 2, !0),
                        this.v.setTripleAt(e - i + r, t + n, e - i + s, t + n, e - i + r, t + n, 3, !0),
                        this.v.setTripleAt(e - i, t + n - r, e - i, t + n - r, e - i, t + n - s, 4, !0),
                        this.v.setTripleAt(e - i, t - n + r, e - i, t - n + s, e - i, t - n + r, 5, !0),
                        this.v.setTripleAt(e - i + r, t - n, e - i + r, t - n, e - i + s, t - n, 6, !0),
                        this.v.setTripleAt(e + i - r, t - n, e + i - s, t - n, e + i - r, t - n, 7, !0)) : (this.v.setTripleAt(e - i, t + n, e - i + s, t + n, e - i, t + n, 2),
                        this.v.setTripleAt(e - i, t - n, e - i, t - n + s, e - i, t - n, 3))) : (this.v.setTripleAt(e + i, t - n + r, e + i, t - n + s, e + i, t - n + r, 0, !0),
                      0 !== r ? (this.v.setTripleAt(e + i - r, t - n, e + i - r, t - n, e + i - s, t - n, 1, !0),
                        this.v.setTripleAt(e - i + r, t - n, e - i + s, t - n, e - i + r, t - n, 2, !0),
                        this.v.setTripleAt(e - i, t - n + r, e - i, t - n + r, e - i, t - n + s, 3, !0),
                        this.v.setTripleAt(e - i, t + n - r, e - i, t + n - s, e - i, t + n - r, 4, !0),
                        this.v.setTripleAt(e - i + r, t + n, e - i + r, t + n, e - i + s, t + n, 5, !0),
                        this.v.setTripleAt(e + i - r, t + n, e + i - s, t + n, e + i - r, t + n, 6, !0),
                        this.v.setTripleAt(e + i, t + n - r, e + i, t + n - r, e + i, t + n - s, 7, !0)) : (this.v.setTripleAt(e - i, t - n, e - i + s, t - n, e - i, t - n, 1, !0),
                        this.v.setTripleAt(e - i, t + n, e - i, t + n - s, e - i, t + n, 2, !0),
                        this.v.setTripleAt(e + i, t + n, e + i - s, t + n, e + i, t + n, 3, !0)))
                },
                getValue: function() {
                  this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId,
                    this.iterateDynamicProperties(),
                  this._mdf && this.convertRectToPath())
                },
                reset: n
              },
                extendPrototype([DynamicPropertyContainer], e),
                e
            }();
            return {
              getShapeProp: function(e, t, i) {
                var n;
                return 3 === i || 4 === i ? n = (3 === i ? t.pt : t.ks).k.length ? new l(e,t,i) : new a(e,t,i) : 5 === i ? n = new u(e,t) : 6 === i ? n = new h(e,t) : 7 === i && (n = new c(e,t)),
                n.k && e.addDynamicProperty(n),
                  n
              },
              getConstructorFunction: function() {
                return a
              },
              getKeyframedConstructorFunction: function() {
                return l
              }
            }
          }(), Matrix = function() {
            var e = Math.cos
              , t = Math.sin
              , i = Math.tan
              , n = Math.round;
            function r() {
              return this.props[0] = 1,
                this.props[1] = 0,
                this.props[2] = 0,
                this.props[3] = 0,
                this.props[4] = 0,
                this.props[5] = 1,
                this.props[6] = 0,
                this.props[7] = 0,
                this.props[8] = 0,
                this.props[9] = 0,
                this.props[10] = 1,
                this.props[11] = 0,
                this.props[12] = 0,
                this.props[13] = 0,
                this.props[14] = 0,
                this.props[15] = 1,
                this
            }
            function s(i) {
              if (0 === i)
                return this;
              var n = e(i)
                , r = t(i);
              return this._t(n, -r, 0, 0, r, n, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
            }
            function a(i) {
              if (0 === i)
                return this;
              var n = e(i)
                , r = t(i);
              return this._t(1, 0, 0, 0, 0, n, -r, 0, 0, r, n, 0, 0, 0, 0, 1)
            }
            function o(i) {
              if (0 === i)
                return this;
              var n = e(i)
                , r = t(i);
              return this._t(n, 0, r, 0, 0, 1, 0, 0, -r, 0, n, 0, 0, 0, 0, 1)
            }
            function l(i) {
              if (0 === i)
                return this;
              var n = e(i)
                , r = t(i);
              return this._t(n, -r, 0, 0, r, n, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
            }
            function h(e, t) {
              return this._t(1, t, e, 1, 0, 0)
            }
            function c(e, t) {
              return this.shear(i(e), i(t))
            }
            function u(n, r) {
              var s = e(r)
                , a = t(r);
              return this._t(s, a, 0, 0, -a, s, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(1, 0, 0, 0, i(n), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(s, -a, 0, 0, a, s, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
            }
            function d(e, t, i) {
              return i || 0 === i || (i = 1),
                1 === e && 1 === t && 1 === i ? this : this._t(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1)
            }
            function p(e, t, i, n, r, s, a, o, l, h, c, u, d, p, f, m) {
              return this.props[0] = e,
                this.props[1] = t,
                this.props[2] = i,
                this.props[3] = n,
                this.props[4] = r,
                this.props[5] = s,
                this.props[6] = a,
                this.props[7] = o,
                this.props[8] = l,
                this.props[9] = h,
                this.props[10] = c,
                this.props[11] = u,
                this.props[12] = d,
                this.props[13] = p,
                this.props[14] = f,
                this.props[15] = m,
                this
            }
            function f(e, t, i) {
              return i = i || 0,
                0 !== e || 0 !== t || 0 !== i ? this._t(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, e, t, i, 1) : this
            }
            function m(e, t, i, n, r, s, a, o, l, h, c, u, d, p, f, m) {
              var g = this.props;
              if (1 === e && 0 === t && 0 === i && 0 === n && 0 === r && 1 === s && 0 === a && 0 === o && 0 === l && 0 === h && 1 === c && 0 === u)
                return g[12] = g[12] * e + g[15] * d,
                  g[13] = g[13] * s + g[15] * p,
                  g[14] = g[14] * c + g[15] * f,
                  g[15] *= m,
                  this._identityCalculated = !1,
                  this;
              var v = g[0]
                , y = g[1]
                , x = g[2]
                , _ = g[3]
                , b = g[4]
                , w = g[5]
                , A = g[6]
                , S = g[7]
                , M = g[8]
                , T = g[9]
                , E = g[10]
                , C = g[11]
                , P = g[12]
                , D = g[13]
                , I = g[14]
                , R = g[15];
              return g[0] = v * e + y * r + x * l + _ * d,
                g[1] = v * t + y * s + x * h + _ * p,
                g[2] = v * i + y * a + x * c + _ * f,
                g[3] = v * n + y * o + x * u + _ * m,
                g[4] = b * e + w * r + A * l + S * d,
                g[5] = b * t + w * s + A * h + S * p,
                g[6] = b * i + w * a + A * c + S * f,
                g[7] = b * n + w * o + A * u + S * m,
                g[8] = M * e + T * r + E * l + C * d,
                g[9] = M * t + T * s + E * h + C * p,
                g[10] = M * i + T * a + E * c + C * f,
                g[11] = M * n + T * o + E * u + C * m,
                g[12] = P * e + D * r + I * l + R * d,
                g[13] = P * t + D * s + I * h + R * p,
                g[14] = P * i + D * a + I * c + R * f,
                g[15] = P * n + D * o + I * u + R * m,
                this._identityCalculated = !1,
                this
            }
            function g() {
              return this._identityCalculated || (this._identity = !(1 !== this.props[0] || 0 !== this.props[1] || 0 !== this.props[2] || 0 !== this.props[3] || 0 !== this.props[4] || 1 !== this.props[5] || 0 !== this.props[6] || 0 !== this.props[7] || 0 !== this.props[8] || 0 !== this.props[9] || 1 !== this.props[10] || 0 !== this.props[11] || 0 !== this.props[12] || 0 !== this.props[13] || 0 !== this.props[14] || 1 !== this.props[15]),
                this._identityCalculated = !0),
                this._identity
            }
            function v(e) {
              for (var t = 0; t < 16; ) {
                if (e.props[t] !== this.props[t])
                  return !1;
                t += 1
              }
              return !0
            }
            function y(e) {
              var t;
              for (t = 0; t < 16; t += 1)
                e.props[t] = this.props[t];
              return e
            }
            function x(e) {
              var t;
              for (t = 0; t < 16; t += 1)
                this.props[t] = e[t]
            }
            function _(e, t, i) {
              return {
                x: e * this.props[0] + t * this.props[4] + i * this.props[8] + this.props[12],
                y: e * this.props[1] + t * this.props[5] + i * this.props[9] + this.props[13],
                z: e * this.props[2] + t * this.props[6] + i * this.props[10] + this.props[14]
              }
            }
            function b(e, t, i) {
              return e * this.props[0] + t * this.props[4] + i * this.props[8] + this.props[12]
            }
            function w(e, t, i) {
              return e * this.props[1] + t * this.props[5] + i * this.props[9] + this.props[13]
            }
            function A(e, t, i) {
              return e * this.props[2] + t * this.props[6] + i * this.props[10] + this.props[14]
            }
            function S() {
              var e = this.props[0] * this.props[5] - this.props[1] * this.props[4]
                , t = this.props[5] / e
                , i = -this.props[1] / e
                , n = -this.props[4] / e
                , r = this.props[0] / e
                , s = (this.props[4] * this.props[13] - this.props[5] * this.props[12]) / e
                , a = -(this.props[0] * this.props[13] - this.props[1] * this.props[12]) / e
                , o = new Matrix;
              return o.props[0] = t,
                o.props[1] = i,
                o.props[4] = n,
                o.props[5] = r,
                o.props[12] = s,
                o.props[13] = a,
                o
            }
            function M(e) {
              return this.getInverseMatrix().applyToPointArray(e[0], e[1], e[2] || 0)
            }
            function T(e) {
              var t, i = e.length, n = [];
              for (t = 0; t < i; t += 1)
                n[t] = M(e[t]);
              return n
            }
            function E(e, t, i) {
              var n = createTypedArray("float32", 6);
              if (this.isIdentity())
                n[0] = e[0],
                  n[1] = e[1],
                  n[2] = t[0],
                  n[3] = t[1],
                  n[4] = i[0],
                  n[5] = i[1];
              else {
                var r = this.props[0]
                  , s = this.props[1]
                  , a = this.props[4]
                  , o = this.props[5]
                  , l = this.props[12]
                  , h = this.props[13];
                n[0] = e[0] * r + e[1] * a + l,
                  n[1] = e[0] * s + e[1] * o + h,
                  n[2] = t[0] * r + t[1] * a + l,
                  n[3] = t[0] * s + t[1] * o + h,
                  n[4] = i[0] * r + i[1] * a + l,
                  n[5] = i[0] * s + i[1] * o + h
              }
              return n
            }
            function C(e, t, i) {
              return this.isIdentity() ? [e, t, i] : [e * this.props[0] + t * this.props[4] + i * this.props[8] + this.props[12], e * this.props[1] + t * this.props[5] + i * this.props[9] + this.props[13], e * this.props[2] + t * this.props[6] + i * this.props[10] + this.props[14]]
            }
            function P(e, t) {
              if (this.isIdentity())
                return e + "," + t;
              var i = this.props;
              return Math.round(100 * (e * i[0] + t * i[4] + i[12])) / 100 + "," + Math.round(100 * (e * i[1] + t * i[5] + i[13])) / 100
            }
            function D() {
              for (var e = 0, t = this.props, i = "matrix3d("; e < 16; )
                i += n(1e4 * t[e]) / 1e4,
                  i += 15 === e ? ")" : ",",
                  e += 1;
              return i
            }
            function I(e) {
              return e < 1e-6 && e > 0 || e > -1e-6 && e < 0 ? n(1e4 * e) / 1e4 : e
            }
            function R() {
              var e = this.props;
              return "matrix(" + I(e[0]) + "," + I(e[1]) + "," + I(e[4]) + "," + I(e[5]) + "," + I(e[12]) + "," + I(e[13]) + ")"
            }
            return function() {
              this.reset = r,
                this.rotate = s,
                this.rotateX = a,
                this.rotateY = o,
                this.rotateZ = l,
                this.skew = c,
                this.skewFromAxis = u,
                this.shear = h,
                this.scale = d,
                this.setTransform = p,
                this.translate = f,
                this.transform = m,
                this.applyToPoint = _,
                this.applyToX = b,
                this.applyToY = w,
                this.applyToZ = A,
                this.applyToPointArray = C,
                this.applyToTriplePoints = E,
                this.applyToPointStringified = P,
                this.toCSS = D,
                this.to2dCSS = R,
                this.clone = y,
                this.cloneFromProps = x,
                this.equals = v,
                this.inversePoints = T,
                this.inversePoint = M,
                this.getInverseMatrix = S,
                this._t = this.transform,
                this.isIdentity = g,
                this._identity = !0,
                this._identityCalculated = !1,
                this.props = createTypedArray("float32", 16),
                this.reset()
            }
          }();
          function _typeof$3(e) {
            return _typeof$3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                return typeof e
              }
              : function(e) {
                return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
              }
              ,
              _typeof$3(e)
          }
          var lottie = {}
            , standalone = "__[STANDALONE]__"
            , animationData = "__[ANIMATIONDATA]__"
            , renderer = "";
          function setLocation(e) {
            setLocationHref(e)
          }
          function searchAnimations() {
            !0 === standalone ? animationManager.searchAnimations(animationData, standalone, renderer) : animationManager.searchAnimations()
          }
          function setSubframeRendering(e) {
            setSubframeEnabled(e)
          }
          function setPrefix(e) {
            setIdPrefix(e)
          }
          function loadAnimation(e) {
            return !0 === standalone && (e.animationData = JSON.parse(animationData)),
              animationManager.loadAnimation(e)
          }
          function setQuality(e) {
            if ("string" == typeof e)
              switch (e) {
                case "high":
                  setDefaultCurveSegments(200);
                  break;
                default:
                case "medium":
                  setDefaultCurveSegments(50);
                  break;
                case "low":
                  setDefaultCurveSegments(10)
              }
            else
              !isNaN(e) && e > 1 && setDefaultCurveSegments(e);
            getDefaultCurveSegments() >= 50 ? roundValues(!1) : roundValues(!0)
          }
          function inBrowser() {
            return "undefined" != typeof navigator
          }
          function installPlugin(e, t) {
            "expressions" === e && setExpressionsPlugin(t)
          }
          function getFactory(e) {
            switch (e) {
              case "propertyFactory":
                return PropertyFactory;
              case "shapePropertyFactory":
                return ShapePropertyFactory;
              case "matrix":
                return Matrix;
              default:
                return null
            }
          }
          function checkReady() {
            "complete" === document.readyState && (clearInterval(readyStateCheckInterval),
              searchAnimations())
          }
          function getQueryVariable(e) {
            for (var t = queryString.split("&"), i = 0; i < t.length; i += 1) {
              var n = t[i].split("=");
              if (decodeURIComponent(n[0]) == e)
                return decodeURIComponent(n[1])
            }
            return null
          }
          lottie.play = animationManager.play,
            lottie.pause = animationManager.pause,
            lottie.setLocationHref = setLocation,
            lottie.togglePause = animationManager.togglePause,
            lottie.setSpeed = animationManager.setSpeed,
            lottie.setDirection = animationManager.setDirection,
            lottie.stop = animationManager.stop,
            lottie.searchAnimations = searchAnimations,
            lottie.registerAnimation = animationManager.registerAnimation,
            lottie.loadAnimation = loadAnimation,
            lottie.setSubframeRendering = setSubframeRendering,
            lottie.resize = animationManager.resize,
            lottie.goToAndStop = animationManager.goToAndStop,
            lottie.destroy = animationManager.destroy,
            lottie.setQuality = setQuality,
            lottie.inBrowser = inBrowser,
            lottie.installPlugin = installPlugin,
            lottie.freeze = animationManager.freeze,
            lottie.unfreeze = animationManager.unfreeze,
            lottie.setVolume = animationManager.setVolume,
            lottie.mute = animationManager.mute,
            lottie.unmute = animationManager.unmute,
            lottie.getRegisteredAnimations = animationManager.getRegisteredAnimations,
            lottie.useWebWorker = setWebWorker,
            lottie.setIDPrefix = setPrefix,
            lottie.__getFactory = getFactory,
            lottie.version = "5.9.4";
          var queryString = "";
          if (standalone) {
            var scripts = document.getElementsByTagName("script")
              , index = scripts.length - 1
              , myScript = scripts[index] || {
              src: ""
            };
            queryString = myScript.src ? myScript.src.replace(/^[^\?]+\??/, "") : "",
              renderer = getQueryVariable("renderer")
          }
          var readyStateCheckInterval = setInterval(checkReady, 100);
          try {
            "object" !== _typeof$3(exports) && __webpack_require__.amdO
          } catch (e) {}
          var ShapeModifiers = function() {
            var e = {}
              , t = {};
            return e.registerModifier = function(e, i) {
              t[e] || (t[e] = i)
            }
              ,
              e.getModifier = function(e, i, n) {
                return new t[e](i,n)
              }
              ,
              e
          }();
          function ShapeModifier() {}
          function TrimModifier() {}
          function PuckerAndBloatModifier() {}
          ShapeModifier.prototype.initModifierProperties = function() {}
            ,
            ShapeModifier.prototype.addShapeToModifier = function() {}
            ,
            ShapeModifier.prototype.addShape = function(e) {
              if (!this.closed) {
                e.sh.container.addDynamicProperty(e.sh);
                var t = {
                  shape: e.sh,
                  data: e,
                  localShapeCollection: shapeCollectionPool.newShapeCollection()
                };
                this.shapes.push(t),
                  this.addShapeToModifier(t),
                this._isAnimated && e.setAsAnimated()
              }
            }
            ,
            ShapeModifier.prototype.init = function(e, t) {
              this.shapes = [],
                this.elem = e,
                this.initDynamicPropertyContainer(e),
                this.initModifierProperties(e, t),
                this.frameId = initialDefaultFrame,
                this.closed = !1,
                this.k = !1,
                this.dynamicProperties.length ? this.k = !0 : this.getValue(!0)
            }
            ,
            ShapeModifier.prototype.processKeys = function() {
              this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId,
                this.iterateDynamicProperties())
            }
            ,
            extendPrototype([DynamicPropertyContainer], ShapeModifier),
            extendPrototype([ShapeModifier], TrimModifier),
            TrimModifier.prototype.initModifierProperties = function(e, t) {
              this.s = PropertyFactory.getProp(e, t.s, 0, .01, this),
                this.e = PropertyFactory.getProp(e, t.e, 0, .01, this),
                this.o = PropertyFactory.getProp(e, t.o, 0, 0, this),
                this.sValue = 0,
                this.eValue = 0,
                this.getValue = this.processKeys,
                this.m = t.m,
                this._isAnimated = !!this.s.effectsSequence.length || !!this.e.effectsSequence.length || !!this.o.effectsSequence.length
            }
            ,
            TrimModifier.prototype.addShapeToModifier = function(e) {
              e.pathsData = []
            }
            ,
            TrimModifier.prototype.calculateShapeEdges = function(e, t, i, n, r) {
              var s = [];
              t <= 1 ? s.push({
                s: e,
                e: t
              }) : e >= 1 ? s.push({
                s: e - 1,
                e: t - 1
              }) : (s.push({
                s: e,
                e: 1
              }),
                s.push({
                  s: 0,
                  e: t - 1
                }));
              var a, o, l = [], h = s.length;
              for (a = 0; a < h; a += 1) {
                var c, u;
                (o = s[a]).e * r < n || o.s * r > n + i || (c = o.s * r <= n ? 0 : (o.s * r - n) / i,
                  u = o.e * r >= n + i ? 1 : (o.e * r - n) / i,
                  l.push([c, u]))
              }
              return l.length || l.push([0, 0]),
                l
            }
            ,
            TrimModifier.prototype.releasePathsData = function(e) {
              var t, i = e.length;
              for (t = 0; t < i; t += 1)
                segmentsLengthPool.release(e[t]);
              return e.length = 0,
                e
            }
            ,
            TrimModifier.prototype.processShapes = function(e) {
              var t, i, n, r;
              if (this._mdf || e) {
                var s = this.o.v % 360 / 360;
                if (s < 0 && (s += 1),
                (t = this.s.v > 1 ? 1 + s : this.s.v < 0 ? 0 + s : this.s.v + s) > (i = this.e.v > 1 ? 1 + s : this.e.v < 0 ? 0 + s : this.e.v + s)) {
                  var a = t;
                  t = i,
                    i = a
                }
                t = 1e-4 * Math.round(1e4 * t),
                  i = 1e-4 * Math.round(1e4 * i),
                  this.sValue = t,
                  this.eValue = i
              } else
                t = this.sValue,
                  i = this.eValue;
              var o, l, h, c, u, d = this.shapes.length, p = 0;
              if (i === t)
                for (r = 0; r < d; r += 1)
                  this.shapes[r].localShapeCollection.releaseShapes(),
                    this.shapes[r].shape._mdf = !0,
                    this.shapes[r].shape.paths = this.shapes[r].localShapeCollection,
                  this._mdf && (this.shapes[r].pathsData.length = 0);
              else if (1 === i && 0 === t || 0 === i && 1 === t) {
                if (this._mdf)
                  for (r = 0; r < d; r += 1)
                    this.shapes[r].pathsData.length = 0,
                      this.shapes[r].shape._mdf = !0
              } else {
                var f, m, g = [];
                for (r = 0; r < d; r += 1)
                  if ((f = this.shapes[r]).shape._mdf || this._mdf || e || 2 === this.m) {
                    if (l = (n = f.shape.paths)._length,
                      u = 0,
                    !f.shape._mdf && f.pathsData.length)
                      u = f.totalShapeLength;
                    else {
                      for (h = this.releasePathsData(f.pathsData),
                             o = 0; o < l; o += 1)
                        c = bez.getSegmentsLength(n.shapes[o]),
                          h.push(c),
                          u += c.totalLength;
                      f.totalShapeLength = u,
                        f.pathsData = h
                    }
                    p += u,
                      f.shape._mdf = !0
                  } else
                    f.shape.paths = f.localShapeCollection;
                var v, y = t, x = i, _ = 0;
                for (r = d - 1; r >= 0; r -= 1)
                  if ((f = this.shapes[r]).shape._mdf) {
                    for ((m = f.localShapeCollection).releaseShapes(),
                           2 === this.m && d > 1 ? (v = this.calculateShapeEdges(t, i, f.totalShapeLength, _, p),
                             _ += f.totalShapeLength) : v = [[y, x]],
                           l = v.length,
                           o = 0; o < l; o += 1) {
                      y = v[o][0],
                        x = v[o][1],
                        g.length = 0,
                        x <= 1 ? g.push({
                          s: f.totalShapeLength * y,
                          e: f.totalShapeLength * x
                        }) : y >= 1 ? g.push({
                          s: f.totalShapeLength * (y - 1),
                          e: f.totalShapeLength * (x - 1)
                        }) : (g.push({
                          s: f.totalShapeLength * y,
                          e: f.totalShapeLength
                        }),
                          g.push({
                            s: 0,
                            e: f.totalShapeLength * (x - 1)
                          }));
                      var b = this.addShapes(f, g[0]);
                      if (g[0].s !== g[0].e) {
                        if (g.length > 1)
                          if (f.shape.paths.shapes[f.shape.paths._length - 1].c) {
                            var w = b.pop();
                            this.addPaths(b, m),
                              b = this.addShapes(f, g[1], w)
                          } else
                            this.addPaths(b, m),
                              b = this.addShapes(f, g[1]);
                        this.addPaths(b, m)
                      }
                    }
                    f.shape.paths = m
                  }
              }
            }
            ,
            TrimModifier.prototype.addPaths = function(e, t) {
              var i, n = e.length;
              for (i = 0; i < n; i += 1)
                t.addShape(e[i])
            }
            ,
            TrimModifier.prototype.addSegment = function(e, t, i, n, r, s, a) {
              r.setXYAt(t[0], t[1], "o", s),
                r.setXYAt(i[0], i[1], "i", s + 1),
              a && r.setXYAt(e[0], e[1], "v", s),
                r.setXYAt(n[0], n[1], "v", s + 1)
            }
            ,
            TrimModifier.prototype.addSegmentFromArray = function(e, t, i, n) {
              t.setXYAt(e[1], e[5], "o", i),
                t.setXYAt(e[2], e[6], "i", i + 1),
              n && t.setXYAt(e[0], e[4], "v", i),
                t.setXYAt(e[3], e[7], "v", i + 1)
            }
            ,
            TrimModifier.prototype.addShapes = function(e, t, i) {
              var n, r, s, a, o, l, h, c, u = e.pathsData, d = e.shape.paths.shapes, p = e.shape.paths._length, f = 0, m = [], g = !0;
              for (i ? (o = i._length,
                c = i._length) : (i = shapePool.newElement(),
                o = 0,
                c = 0),
                     m.push(i),
                     n = 0; n < p; n += 1) {
                for (l = u[n].lengths,
                       i.c = d[n].c,
                       s = d[n].c ? l.length : l.length + 1,
                       r = 1; r < s; r += 1)
                  if (f + (a = l[r - 1]).addedLength < t.s)
                    f += a.addedLength,
                      i.c = !1;
                  else {
                    if (f > t.e) {
                      i.c = !1;
                      break
                    }
                    t.s <= f && t.e >= f + a.addedLength ? (this.addSegment(d[n].v[r - 1], d[n].o[r - 1], d[n].i[r], d[n].v[r], i, o, g),
                      g = !1) : (h = bez.getNewSegment(d[n].v[r - 1], d[n].v[r], d[n].o[r - 1], d[n].i[r], (t.s - f) / a.addedLength, (t.e - f) / a.addedLength, l[r - 1]),
                      this.addSegmentFromArray(h, i, o, g),
                      g = !1,
                      i.c = !1),
                      f += a.addedLength,
                      o += 1
                  }
                if (d[n].c && l.length) {
                  if (a = l[r - 1],
                  f <= t.e) {
                    var v = l[r - 1].addedLength;
                    t.s <= f && t.e >= f + v ? (this.addSegment(d[n].v[r - 1], d[n].o[r - 1], d[n].i[0], d[n].v[0], i, o, g),
                      g = !1) : (h = bez.getNewSegment(d[n].v[r - 1], d[n].v[0], d[n].o[r - 1], d[n].i[0], (t.s - f) / v, (t.e - f) / v, l[r - 1]),
                      this.addSegmentFromArray(h, i, o, g),
                      g = !1,
                      i.c = !1)
                  } else
                    i.c = !1;
                  f += a.addedLength,
                    o += 1
                }
                if (i._length && (i.setXYAt(i.v[c][0], i.v[c][1], "i", c),
                  i.setXYAt(i.v[i._length - 1][0], i.v[i._length - 1][1], "o", i._length - 1)),
                f > t.e)
                  break;
                n < p - 1 && (i = shapePool.newElement(),
                  g = !0,
                  m.push(i),
                  o = 0)
              }
              return m
            }
            ,
            extendPrototype([ShapeModifier], PuckerAndBloatModifier),
            PuckerAndBloatModifier.prototype.initModifierProperties = function(e, t) {
              this.getValue = this.processKeys,
                this.amount = PropertyFactory.getProp(e, t.a, 0, null, this),
                this._isAnimated = !!this.amount.effectsSequence.length
            }
            ,
            PuckerAndBloatModifier.prototype.processPath = function(e, t) {
              var i = t / 100
                , n = [0, 0]
                , r = e._length
                , s = 0;
              for (s = 0; s < r; s += 1)
                n[0] += e.v[s][0],
                  n[1] += e.v[s][1];
              n[0] /= r,
                n[1] /= r;
              var a, o, l, h, c, u, d = shapePool.newElement();
              for (d.c = e.c,
                     s = 0; s < r; s += 1)
                a = e.v[s][0] + (n[0] - e.v[s][0]) * i,
                  o = e.v[s][1] + (n[1] - e.v[s][1]) * i,
                  l = e.o[s][0] + (n[0] - e.o[s][0]) * -i,
                  h = e.o[s][1] + (n[1] - e.o[s][1]) * -i,
                  c = e.i[s][0] + (n[0] - e.i[s][0]) * -i,
                  u = e.i[s][1] + (n[1] - e.i[s][1]) * -i,
                  d.setTripleAt(a, o, l, h, c, u, s);
              return d
            }
            ,
            PuckerAndBloatModifier.prototype.processShapes = function(e) {
              var t, i, n, r, s, a, o = this.shapes.length, l = this.amount.v;
              if (0 !== l)
                for (i = 0; i < o; i += 1) {
                  if (a = (s = this.shapes[i]).localShapeCollection,
                  s.shape._mdf || this._mdf || e)
                    for (a.releaseShapes(),
                           s.shape._mdf = !0,
                           t = s.shape.paths.shapes,
                           r = s.shape.paths._length,
                           n = 0; n < r; n += 1)
                      a.addShape(this.processPath(t[n], l));
                  s.shape.paths = s.localShapeCollection
                }
              this.dynamicProperties.length || (this._mdf = !1)
            }
          ;
          var TransformPropertyFactory = function() {
            var e = [0, 0];
            function t(e, t, i) {
              if (this.elem = e,
                this.frameId = -1,
                this.propType = "transform",
                this.data = t,
                this.v = new Matrix,
                this.pre = new Matrix,
                this.appliedTransformations = 0,
                this.initDynamicPropertyContainer(i || e),
                t.p && t.p.s ? (this.px = PropertyFactory.getProp(e, t.p.x, 0, 0, this),
                  this.py = PropertyFactory.getProp(e, t.p.y, 0, 0, this),
                t.p.z && (this.pz = PropertyFactory.getProp(e, t.p.z, 0, 0, this))) : this.p = PropertyFactory.getProp(e, t.p || {
                  k: [0, 0, 0]
                }, 1, 0, this),
                t.rx) {
                if (this.rx = PropertyFactory.getProp(e, t.rx, 0, degToRads, this),
                  this.ry = PropertyFactory.getProp(e, t.ry, 0, degToRads, this),
                  this.rz = PropertyFactory.getProp(e, t.rz, 0, degToRads, this),
                  t.or.k[0].ti) {
                  var n, r = t.or.k.length;
                  for (n = 0; n < r; n += 1)
                    t.or.k[n].to = null,
                      t.or.k[n].ti = null
                }
                this.or = PropertyFactory.getProp(e, t.or, 1, degToRads, this),
                  this.or.sh = !0
              } else
                this.r = PropertyFactory.getProp(e, t.r || {
                  k: 0
                }, 0, degToRads, this);
              t.sk && (this.sk = PropertyFactory.getProp(e, t.sk, 0, degToRads, this),
                this.sa = PropertyFactory.getProp(e, t.sa, 0, degToRads, this)),
                this.a = PropertyFactory.getProp(e, t.a || {
                  k: [0, 0, 0]
                }, 1, 0, this),
                this.s = PropertyFactory.getProp(e, t.s || {
                  k: [100, 100, 100]
                }, 1, .01, this),
                t.o ? this.o = PropertyFactory.getProp(e, t.o, 0, .01, e) : this.o = {
                  _mdf: !1,
                  v: 1
                },
                this._isDirty = !0,
              this.dynamicProperties.length || this.getValue(!0)
            }
            return t.prototype = {
              applyToMatrix: function(e) {
                var t = this._mdf;
                this.iterateDynamicProperties(),
                  this._mdf = this._mdf || t,
                this.a && e.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]),
                this.s && e.scale(this.s.v[0], this.s.v[1], this.s.v[2]),
                this.sk && e.skewFromAxis(-this.sk.v, this.sa.v),
                  this.r ? e.rotate(-this.r.v) : e.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]),
                  this.data.p.s ? this.data.p.z ? e.translate(this.px.v, this.py.v, -this.pz.v) : e.translate(this.px.v, this.py.v, 0) : e.translate(this.p.v[0], this.p.v[1], -this.p.v[2])
              },
              getValue: function(t) {
                if (this.elem.globalData.frameId !== this.frameId) {
                  if (this._isDirty && (this.precalculateMatrix(),
                    this._isDirty = !1),
                    this.iterateDynamicProperties(),
                  this._mdf || t) {
                    var i;
                    if (this.v.cloneFromProps(this.pre.props),
                    this.appliedTransformations < 1 && this.v.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]),
                    this.appliedTransformations < 2 && this.v.scale(this.s.v[0], this.s.v[1], this.s.v[2]),
                    this.sk && this.appliedTransformations < 3 && this.v.skewFromAxis(-this.sk.v, this.sa.v),
                      this.r && this.appliedTransformations < 4 ? this.v.rotate(-this.r.v) : !this.r && this.appliedTransformations < 4 && this.v.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]),
                      this.autoOriented) {
                      var n, r;
                      if (i = this.elem.globalData.frameRate,
                      this.p && this.p.keyframes && this.p.getValueAtTime)
                        this.p._caching.lastFrame + this.p.offsetTime <= this.p.keyframes[0].t ? (n = this.p.getValueAtTime((this.p.keyframes[0].t + .01) / i, 0),
                          r = this.p.getValueAtTime(this.p.keyframes[0].t / i, 0)) : this.p._caching.lastFrame + this.p.offsetTime >= this.p.keyframes[this.p.keyframes.length - 1].t ? (n = this.p.getValueAtTime(this.p.keyframes[this.p.keyframes.length - 1].t / i, 0),
                          r = this.p.getValueAtTime((this.p.keyframes[this.p.keyframes.length - 1].t - .05) / i, 0)) : (n = this.p.pv,
                          r = this.p.getValueAtTime((this.p._caching.lastFrame + this.p.offsetTime - .01) / i, this.p.offsetTime));
                      else if (this.px && this.px.keyframes && this.py.keyframes && this.px.getValueAtTime && this.py.getValueAtTime) {
                        n = [],
                          r = [];
                        var s = this.px
                          , a = this.py;
                        s._caching.lastFrame + s.offsetTime <= s.keyframes[0].t ? (n[0] = s.getValueAtTime((s.keyframes[0].t + .01) / i, 0),
                          n[1] = a.getValueAtTime((a.keyframes[0].t + .01) / i, 0),
                          r[0] = s.getValueAtTime(s.keyframes[0].t / i, 0),
                          r[1] = a.getValueAtTime(a.keyframes[0].t / i, 0)) : s._caching.lastFrame + s.offsetTime >= s.keyframes[s.keyframes.length - 1].t ? (n[0] = s.getValueAtTime(s.keyframes[s.keyframes.length - 1].t / i, 0),
                          n[1] = a.getValueAtTime(a.keyframes[a.keyframes.length - 1].t / i, 0),
                          r[0] = s.getValueAtTime((s.keyframes[s.keyframes.length - 1].t - .01) / i, 0),
                          r[1] = a.getValueAtTime((a.keyframes[a.keyframes.length - 1].t - .01) / i, 0)) : (n = [s.pv, a.pv],
                          r[0] = s.getValueAtTime((s._caching.lastFrame + s.offsetTime - .01) / i, s.offsetTime),
                          r[1] = a.getValueAtTime((a._caching.lastFrame + a.offsetTime - .01) / i, a.offsetTime))
                      } else
                        n = r = e;
                      this.v.rotate(-Math.atan2(n[1] - r[1], n[0] - r[0]))
                    }
                    this.data.p && this.data.p.s ? this.data.p.z ? this.v.translate(this.px.v, this.py.v, -this.pz.v) : this.v.translate(this.px.v, this.py.v, 0) : this.v.translate(this.p.v[0], this.p.v[1], -this.p.v[2])
                  }
                  this.frameId = this.elem.globalData.frameId
                }
              },
              precalculateMatrix: function() {
                if (!this.a.k && (this.pre.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]),
                  this.appliedTransformations = 1,
                  !this.s.effectsSequence.length)) {
                  if (this.pre.scale(this.s.v[0], this.s.v[1], this.s.v[2]),
                    this.appliedTransformations = 2,
                    this.sk) {
                    if (this.sk.effectsSequence.length || this.sa.effectsSequence.length)
                      return;
                    this.pre.skewFromAxis(-this.sk.v, this.sa.v),
                      this.appliedTransformations = 3
                  }
                  this.r ? this.r.effectsSequence.length || (this.pre.rotate(-this.r.v),
                    this.appliedTransformations = 4) : this.rz.effectsSequence.length || this.ry.effectsSequence.length || this.rx.effectsSequence.length || this.or.effectsSequence.length || (this.pre.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]),
                    this.appliedTransformations = 4)
                }
              },
              autoOrient: function() {}
            },
              extendPrototype([DynamicPropertyContainer], t),
              t.prototype.addDynamicProperty = function(e) {
                this._addDynamicProperty(e),
                  this.elem.addDynamicProperty(e),
                  this._isDirty = !0
              }
              ,
              t.prototype._addDynamicProperty = DynamicPropertyContainer.prototype.addDynamicProperty,
              {
                getTransformProperty: function(e, i, n) {
                  return new t(e,i,n)
                }
              }
          }();
          function RepeaterModifier() {}
          function RoundCornersModifier() {}
          function getFontProperties(e) {
            for (var t = e.fStyle ? e.fStyle.split(" ") : [], i = "normal", n = "normal", r = t.length, s = 0; s < r; s += 1)
              switch (t[s].toLowerCase()) {
                case "italic":
                  n = "italic";
                  break;
                case "bold":
                  i = "700";
                  break;
                case "black":
                  i = "900";
                  break;
                case "medium":
                  i = "500";
                  break;
                case "regular":
                case "normal":
                  i = "400";
                  break;
                case "light":
                case "thin":
                  i = "200"
              }
            return {
              style: n,
              weight: e.fWeight || i
            }
          }
          extendPrototype([ShapeModifier], RepeaterModifier),
            RepeaterModifier.prototype.initModifierProperties = function(e, t) {
              this.getValue = this.processKeys,
                this.c = PropertyFactory.getProp(e, t.c, 0, null, this),
                this.o = PropertyFactory.getProp(e, t.o, 0, null, this),
                this.tr = TransformPropertyFactory.getTransformProperty(e, t.tr, this),
                this.so = PropertyFactory.getProp(e, t.tr.so, 0, .01, this),
                this.eo = PropertyFactory.getProp(e, t.tr.eo, 0, .01, this),
                this.data = t,
              this.dynamicProperties.length || this.getValue(!0),
                this._isAnimated = !!this.dynamicProperties.length,
                this.pMatrix = new Matrix,
                this.rMatrix = new Matrix,
                this.sMatrix = new Matrix,
                this.tMatrix = new Matrix,
                this.matrix = new Matrix
            }
            ,
            RepeaterModifier.prototype.applyTransforms = function(e, t, i, n, r, s) {
              var a = s ? -1 : 1
                , o = n.s.v[0] + (1 - n.s.v[0]) * (1 - r)
                , l = n.s.v[1] + (1 - n.s.v[1]) * (1 - r);
              e.translate(n.p.v[0] * a * r, n.p.v[1] * a * r, n.p.v[2]),
                t.translate(-n.a.v[0], -n.a.v[1], n.a.v[2]),
                t.rotate(-n.r.v * a * r),
                t.translate(n.a.v[0], n.a.v[1], n.a.v[2]),
                i.translate(-n.a.v[0], -n.a.v[1], n.a.v[2]),
                i.scale(s ? 1 / o : o, s ? 1 / l : l),
                i.translate(n.a.v[0], n.a.v[1], n.a.v[2])
            }
            ,
            RepeaterModifier.prototype.init = function(e, t, i, n) {
              for (this.elem = e,
                     this.arr = t,
                     this.pos = i,
                     this.elemsData = n,
                     this._currentCopies = 0,
                     this._elements = [],
                     this._groups = [],
                     this.frameId = -1,
                     this.initDynamicPropertyContainer(e),
                     this.initModifierProperties(e, t[i]); i > 0; )
                i -= 1,
                  this._elements.unshift(t[i]);
              this.dynamicProperties.length ? this.k = !0 : this.getValue(!0)
            }
            ,
            RepeaterModifier.prototype.resetElements = function(e) {
              var t, i = e.length;
              for (t = 0; t < i; t += 1)
                e[t]._processed = !1,
                "gr" === e[t].ty && this.resetElements(e[t].it)
            }
            ,
            RepeaterModifier.prototype.cloneElements = function(e) {
              var t = JSON.parse(JSON.stringify(e));
              return this.resetElements(t),
                t
            }
            ,
            RepeaterModifier.prototype.changeGroupRender = function(e, t) {
              var i, n = e.length;
              for (i = 0; i < n; i += 1)
                e[i]._render = t,
                "gr" === e[i].ty && this.changeGroupRender(e[i].it, t)
            }
            ,
            RepeaterModifier.prototype.processShapes = function(e) {
              var t, i, n, r, s, a = !1;
              if (this._mdf || e) {
                var o, l = Math.ceil(this.c.v);
                if (this._groups.length < l) {
                  for (; this._groups.length < l; ) {
                    var h = {
                      it: this.cloneElements(this._elements),
                      ty: "gr"
                    };
                    h.it.push({
                      a: {
                        a: 0,
                        ix: 1,
                        k: [0, 0]
                      },
                      nm: "Transform",
                      o: {
                        a: 0,
                        ix: 7,
                        k: 100
                      },
                      p: {
                        a: 0,
                        ix: 2,
                        k: [0, 0]
                      },
                      r: {
                        a: 1,
                        ix: 6,
                        k: [{
                          s: 0,
                          e: 0,
                          t: 0
                        }, {
                          s: 0,
                          e: 0,
                          t: 1
                        }]
                      },
                      s: {
                        a: 0,
                        ix: 3,
                        k: [100, 100]
                      },
                      sa: {
                        a: 0,
                        ix: 5,
                        k: 0
                      },
                      sk: {
                        a: 0,
                        ix: 4,
                        k: 0
                      },
                      ty: "tr"
                    }),
                      this.arr.splice(0, 0, h),
                      this._groups.splice(0, 0, h),
                      this._currentCopies += 1
                  }
                  this.elem.reloadShapes(),
                    a = !0
                }
                for (s = 0,
                       n = 0; n <= this._groups.length - 1; n += 1) {
                  if (o = s < l,
                    this._groups[n]._render = o,
                    this.changeGroupRender(this._groups[n].it, o),
                    !o) {
                    var c = this.elemsData[n].it
                      , u = c[c.length - 1];
                    0 !== u.transform.op.v ? (u.transform.op._mdf = !0,
                      u.transform.op.v = 0) : u.transform.op._mdf = !1
                  }
                  s += 1
                }
                this._currentCopies = l;
                var d = this.o.v
                  , p = d % 1
                  , f = d > 0 ? Math.floor(d) : Math.ceil(d)
                  , m = this.pMatrix.props
                  , g = this.rMatrix.props
                  , v = this.sMatrix.props;
                this.pMatrix.reset(),
                  this.rMatrix.reset(),
                  this.sMatrix.reset(),
                  this.tMatrix.reset(),
                  this.matrix.reset();
                var y, x, _ = 0;
                if (d > 0) {
                  for (; _ < f; )
                    this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !1),
                      _ += 1;
                  p && (this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, p, !1),
                    _ += p)
                } else if (d < 0) {
                  for (; _ > f; )
                    this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !0),
                      _ -= 1;
                  p && (this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, -p, !0),
                    _ -= p)
                }
                for (n = 1 === this.data.m ? 0 : this._currentCopies - 1,
                       r = 1 === this.data.m ? 1 : -1,
                       s = this._currentCopies; s; ) {
                  if (x = (i = (t = this.elemsData[n].it)[t.length - 1].transform.mProps.v.props).length,
                    t[t.length - 1].transform.mProps._mdf = !0,
                    t[t.length - 1].transform.op._mdf = !0,
                    t[t.length - 1].transform.op.v = 1 === this._currentCopies ? this.so.v : this.so.v + (this.eo.v - this.so.v) * (n / (this._currentCopies - 1)),
                  0 !== _) {
                    for ((0 !== n && 1 === r || n !== this._currentCopies - 1 && -1 === r) && this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !1),
                           this.matrix.transform(g[0], g[1], g[2], g[3], g[4], g[5], g[6], g[7], g[8], g[9], g[10], g[11], g[12], g[13], g[14], g[15]),
                           this.matrix.transform(v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7], v[8], v[9], v[10], v[11], v[12], v[13], v[14], v[15]),
                           this.matrix.transform(m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7], m[8], m[9], m[10], m[11], m[12], m[13], m[14], m[15]),
                           y = 0; y < x; y += 1)
                      i[y] = this.matrix.props[y];
                    this.matrix.reset()
                  } else
                    for (this.matrix.reset(),
                           y = 0; y < x; y += 1)
                      i[y] = this.matrix.props[y];
                  _ += 1,
                    s -= 1,
                    n += r
                }
              } else
                for (s = this._currentCopies,
                       n = 0,
                       r = 1; s; )
                  i = (t = this.elemsData[n].it)[t.length - 1].transform.mProps.v.props,
                    t[t.length - 1].transform.mProps._mdf = !1,
                    t[t.length - 1].transform.op._mdf = !1,
                    s -= 1,
                    n += r;
              return a
            }
            ,
            RepeaterModifier.prototype.addShape = function() {}
            ,
            extendPrototype([ShapeModifier], RoundCornersModifier),
            RoundCornersModifier.prototype.initModifierProperties = function(e, t) {
              this.getValue = this.processKeys,
                this.rd = PropertyFactory.getProp(e, t.r, 0, null, this),
                this._isAnimated = !!this.rd.effectsSequence.length
            }
            ,
            RoundCornersModifier.prototype.processPath = function(e, t) {
              var i, n = shapePool.newElement();
              n.c = e.c;
              var r, s, a, o, l, h, c, u, d, p, f, m, g = e._length, v = 0;
              for (i = 0; i < g; i += 1)
                r = e.v[i],
                  a = e.o[i],
                  s = e.i[i],
                  r[0] === a[0] && r[1] === a[1] && r[0] === s[0] && r[1] === s[1] ? 0 !== i && i !== g - 1 || e.c ? (o = 0 === i ? e.v[g - 1] : e.v[i - 1],
                    h = (l = Math.sqrt(Math.pow(r[0] - o[0], 2) + Math.pow(r[1] - o[1], 2))) ? Math.min(l / 2, t) / l : 0,
                    c = f = r[0] + (o[0] - r[0]) * h,
                    u = m = r[1] - (r[1] - o[1]) * h,
                    d = c - (c - r[0]) * roundCorner,
                    p = u - (u - r[1]) * roundCorner,
                    n.setTripleAt(c, u, d, p, f, m, v),
                    v += 1,
                    o = i === g - 1 ? e.v[0] : e.v[i + 1],
                    h = (l = Math.sqrt(Math.pow(r[0] - o[0], 2) + Math.pow(r[1] - o[1], 2))) ? Math.min(l / 2, t) / l : 0,
                    c = d = r[0] + (o[0] - r[0]) * h,
                    u = p = r[1] + (o[1] - r[1]) * h,
                    f = c - (c - r[0]) * roundCorner,
                    m = u - (u - r[1]) * roundCorner,
                    n.setTripleAt(c, u, d, p, f, m, v),
                    v += 1) : (n.setTripleAt(r[0], r[1], a[0], a[1], s[0], s[1], v),
                    v += 1) : (n.setTripleAt(e.v[i][0], e.v[i][1], e.o[i][0], e.o[i][1], e.i[i][0], e.i[i][1], v),
                    v += 1);
              return n
            }
            ,
            RoundCornersModifier.prototype.processShapes = function(e) {
              var t, i, n, r, s, a, o = this.shapes.length, l = this.rd.v;
              if (0 !== l)
                for (i = 0; i < o; i += 1) {
                  if (a = (s = this.shapes[i]).localShapeCollection,
                  s.shape._mdf || this._mdf || e)
                    for (a.releaseShapes(),
                           s.shape._mdf = !0,
                           t = s.shape.paths.shapes,
                           r = s.shape.paths._length,
                           n = 0; n < r; n += 1)
                      a.addShape(this.processPath(t[n], l));
                  s.shape.paths = s.localShapeCollection
                }
              this.dynamicProperties.length || (this._mdf = !1)
            }
          ;
          var FontManager = function() {
            var e = {
              w: 0,
              size: 0,
              shapes: [],
              data: {
                shapes: []
              }
            }
              , t = [];
            t = t.concat([2304, 2305, 2306, 2307, 2362, 2363, 2364, 2364, 2366, 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2387, 2388, 2389, 2390, 2391, 2402, 2403]);
            var i = ["d83cdffb", "d83cdffc", "d83cdffd", "d83cdffe", "d83cdfff"]
              , n = [65039, 8205];
            function r(e, t) {
              var i = createTag("span");
              i.setAttribute("aria-hidden", !0),
                i.style.fontFamily = t;
              var n = createTag("span");
              n.innerText = "giItT1WQy@!-/#",
                i.style.position = "absolute",
                i.style.left = "-10000px",
                i.style.top = "-10000px",
                i.style.fontSize = "300px",
                i.style.fontVariant = "normal",
                i.style.fontStyle = "normal",
                i.style.fontWeight = "normal",
                i.style.letterSpacing = "0",
                i.appendChild(n),
                document.body.appendChild(i);
              var r = n.offsetWidth;
              return n.style.fontFamily = function(e) {
                var t, i = e.split(","), n = i.length, r = [];
                for (t = 0; t < n; t += 1)
                  "sans-serif" !== i[t] && "monospace" !== i[t] && r.push(i[t]);
                return r.join(",")
              }(e) + ", " + t,
                {
                  node: n,
                  w: r,
                  parent: i
                }
            }
            function s(e, t) {
              var i, n = document.body && t ? "svg" : "canvas", r = getFontProperties(e);
              if ("svg" === n) {
                var s = createNS("text");
                s.style.fontSize = "100px",
                  s.setAttribute("font-family", e.fFamily),
                  s.setAttribute("font-style", r.style),
                  s.setAttribute("font-weight", r.weight),
                  s.textContent = "1",
                  e.fClass ? (s.style.fontFamily = "inherit",
                    s.setAttribute("class", e.fClass)) : s.style.fontFamily = e.fFamily,
                  t.appendChild(s),
                  i = s
              } else {
                var a = new OffscreenCanvas(500,500).getContext("2d");
                a.font = r.style + " " + r.weight + " 100px " + e.fFamily,
                  i = a
              }
              return {
                measureText: function(e) {
                  return "svg" === n ? (i.textContent = e,
                    i.getComputedTextLength()) : i.measureText(e).width
                }
              }
            }
            var a = function() {
              this.fonts = [],
                this.chars = null,
                this.typekitLoaded = 0,
                this.isLoaded = !1,
                this._warned = !1,
                this.initTime = Date.now(),
                this.setIsLoadedBinded = this.setIsLoaded.bind(this),
                this.checkLoadedFontsBinded = this.checkLoadedFonts.bind(this)
            };
            a.isModifier = function(e, t) {
              var n = e.toString(16) + t.toString(16);
              return -1 !== i.indexOf(n)
            }
              ,
              a.isZeroWidthJoiner = function(e, t) {
                return t ? e === n[0] && t === n[1] : e === n[1]
              }
              ,
              a.isCombinedCharacter = function(e) {
                return -1 !== t.indexOf(e)
              }
            ;
            var o = {
              addChars: function(e) {
                if (e) {
                  var t;
                  this.chars || (this.chars = []);
                  var i, n, r = e.length, s = this.chars.length;
                  for (t = 0; t < r; t += 1) {
                    for (i = 0,
                           n = !1; i < s; )
                      this.chars[i].style === e[t].style && this.chars[i].fFamily === e[t].fFamily && this.chars[i].ch === e[t].ch && (n = !0),
                        i += 1;
                    n || (this.chars.push(e[t]),
                      s += 1)
                  }
                }
              },
              addFonts: function(e, t) {
                if (e) {
                  if (this.chars)
                    return this.isLoaded = !0,
                      void (this.fonts = e.list);
                  if (!document.body)
                    return this.isLoaded = !0,
                      e.list.forEach((function(e) {
                          e.helper = s(e),
                            e.cache = {}
                        }
                      )),
                      void (this.fonts = e.list);
                  var i, n = e.list, a = n.length, o = a;
                  for (i = 0; i < a; i += 1) {
                    var l, h, c = !0;
                    if (n[i].loaded = !1,
                      n[i].monoCase = r(n[i].fFamily, "monospace"),
                      n[i].sansCase = r(n[i].fFamily, "sans-serif"),
                      n[i].fPath) {
                      if ("p" === n[i].fOrigin || 3 === n[i].origin) {
                        if ((l = document.querySelectorAll('style[f-forigin="p"][f-family="' + n[i].fFamily + '"], style[f-origin="3"][f-family="' + n[i].fFamily + '"]')).length > 0 && (c = !1),
                          c) {
                          var u = createTag("style");
                          u.setAttribute("f-forigin", n[i].fOrigin),
                            u.setAttribute("f-origin", n[i].origin),
                            u.setAttribute("f-family", n[i].fFamily),
                            u.type = "text/css",
                            u.innerText = "@font-face {font-family: " + n[i].fFamily + "; font-style: normal; src: url('" + n[i].fPath + "');}",
                            t.appendChild(u)
                        }
                      } else if ("g" === n[i].fOrigin || 1 === n[i].origin) {
                        for (l = document.querySelectorAll('link[f-forigin="g"], link[f-origin="1"]'),
                               h = 0; h < l.length; h += 1)
                          -1 !== l[h].href.indexOf(n[i].fPath) && (c = !1);
                        if (c) {
                          var d = createTag("link");
                          d.setAttribute("f-forigin", n[i].fOrigin),
                            d.setAttribute("f-origin", n[i].origin),
                            d.type = "text/css",
                            d.rel = "stylesheet",
                            d.href = n[i].fPath,
                            document.body.appendChild(d)
                        }
                      } else if ("t" === n[i].fOrigin || 2 === n[i].origin) {
                        for (l = document.querySelectorAll('script[f-forigin="t"], script[f-origin="2"]'),
                               h = 0; h < l.length; h += 1)
                          n[i].fPath === l[h].src && (c = !1);
                        if (c) {
                          var p = createTag("link");
                          p.setAttribute("f-forigin", n[i].fOrigin),
                            p.setAttribute("f-origin", n[i].origin),
                            p.setAttribute("rel", "stylesheet"),
                            p.setAttribute("href", n[i].fPath),
                            t.appendChild(p)
                        }
                      }
                    } else
                      n[i].loaded = !0,
                        o -= 1;
                    n[i].helper = s(n[i], t),
                      n[i].cache = {},
                      this.fonts.push(n[i])
                  }
                  0 === o ? this.isLoaded = !0 : setTimeout(this.checkLoadedFonts.bind(this), 100)
                } else
                  this.isLoaded = !0
              },
              getCharData: function(t, i, n) {
                for (var r = 0, s = this.chars.length; r < s; ) {
                  if (this.chars[r].ch === t && this.chars[r].style === i && this.chars[r].fFamily === n)
                    return this.chars[r];
                  r += 1
                }
                return ("string" == typeof t && 13 !== t.charCodeAt(0) || !t) && console && console.warn && !this._warned && (this._warned = !0,
                  console.warn("Missing character from exported characters list: ", t, i, n)),
                  e
              },
              getFontByName: function(e) {
                for (var t = 0, i = this.fonts.length; t < i; ) {
                  if (this.fonts[t].fName === e)
                    return this.fonts[t];
                  t += 1
                }
                return this.fonts[0]
              },
              measureText: function(e, t, i) {
                var n = this.getFontByName(t)
                  , r = e.charCodeAt(0);
                if (!n.cache[r + 1]) {
                  var s = n.helper;
                  if (" " === e) {
                    var a = s.measureText("|" + e + "|")
                      , o = s.measureText("||");
                    n.cache[r + 1] = (a - o) / 100
                  } else
                    n.cache[r + 1] = s.measureText(e) / 100
                }
                return n.cache[r + 1] * i
              },
              checkLoadedFonts: function() {
                var e, t, i, n = this.fonts.length, r = n;
                for (e = 0; e < n; e += 1)
                  this.fonts[e].loaded ? r -= 1 : "n" === this.fonts[e].fOrigin || 0 === this.fonts[e].origin ? this.fonts[e].loaded = !0 : (t = this.fonts[e].monoCase.node,
                    i = this.fonts[e].monoCase.w,
                    t.offsetWidth !== i ? (r -= 1,
                      this.fonts[e].loaded = !0) : (t = this.fonts[e].sansCase.node,
                      i = this.fonts[e].sansCase.w,
                    t.offsetWidth !== i && (r -= 1,
                      this.fonts[e].loaded = !0)),
                  this.fonts[e].loaded && (this.fonts[e].sansCase.parent.parentNode.removeChild(this.fonts[e].sansCase.parent),
                    this.fonts[e].monoCase.parent.parentNode.removeChild(this.fonts[e].monoCase.parent)));
                0 !== r && Date.now() - this.initTime < 5e3 ? setTimeout(this.checkLoadedFontsBinded, 20) : setTimeout(this.setIsLoadedBinded, 10)
              },
              setIsLoaded: function() {
                this.isLoaded = !0
              }
            };
            return a.prototype = o,
              a
          }();
          function RenderableElement() {}
          RenderableElement.prototype = {
            initRenderable: function() {
              this.isInRange = !1,
                this.hidden = !1,
                this.isTransparent = !1,
                this.renderableComponents = []
            },
            addRenderableComponent: function(e) {
              -1 === this.renderableComponents.indexOf(e) && this.renderableComponents.push(e)
            },
            removeRenderableComponent: function(e) {
              -1 !== this.renderableComponents.indexOf(e) && this.renderableComponents.splice(this.renderableComponents.indexOf(e), 1)
            },
            prepareRenderableFrame: function(e) {
              this.checkLayerLimits(e)
            },
            checkTransparency: function() {
              this.finalTransform.mProp.o.v <= 0 ? !this.isTransparent && this.globalData.renderConfig.hideOnTransparent && (this.isTransparent = !0,
                this.hide()) : this.isTransparent && (this.isTransparent = !1,
                this.show())
            },
            checkLayerLimits: function(e) {
              this.data.ip - this.data.st <= e && this.data.op - this.data.st > e ? !0 !== this.isInRange && (this.globalData._mdf = !0,
                this._mdf = !0,
                this.isInRange = !0,
                this.show()) : !1 !== this.isInRange && (this.globalData._mdf = !0,
                this.isInRange = !1,
                this.hide())
            },
            renderRenderable: function() {
              var e, t = this.renderableComponents.length;
              for (e = 0; e < t; e += 1)
                this.renderableComponents[e].renderFrame(this._isFirstFrame)
            },
            sourceRectAtTime: function() {
              return {
                top: 0,
                left: 0,
                width: 100,
                height: 100
              }
            },
            getLayerSize: function() {
              return 5 === this.data.ty ? {
                w: this.data.textData.width,
                h: this.data.textData.height
              } : {
                w: this.data.width,
                h: this.data.height
              }
            }
          };
          var MaskManagerInterface = function() {
            function e(e, t) {
              this._mask = e,
                this._data = t
            }
            return Object.defineProperty(e.prototype, "maskPath", {
              get: function() {
                return this._mask.prop.k && this._mask.prop.getValue(),
                  this._mask.prop
              }
            }),
              Object.defineProperty(e.prototype, "maskOpacity", {
                get: function() {
                  return this._mask.op.k && this._mask.op.getValue(),
                  100 * this._mask.op.v
                }
              }),
              function(t) {
                var i, n = createSizedArray(t.viewData.length), r = t.viewData.length;
                for (i = 0; i < r; i += 1)
                  n[i] = new e(t.viewData[i],t.masksProperties[i]);
                return function(e) {
                  for (i = 0; i < r; ) {
                    if (t.masksProperties[i].nm === e)
                      return n[i];
                    i += 1
                  }
                  return null
                }
              }
          }(), ExpressionPropertyInterface = function() {
            var e = {
              pv: 0,
              v: 0,
              mult: 1
            }
              , t = {
              pv: [0, 0, 0],
              v: [0, 0, 0],
              mult: 1
            };
            function i(e, t, i) {
              Object.defineProperty(e, "velocity", {
                get: function() {
                  return t.getVelocityAtTime(t.comp.currentFrame)
                }
              }),
                e.numKeys = t.keyframes ? t.keyframes.length : 0,
                e.key = function(n) {
                  if (!e.numKeys)
                    return 0;
                  var r;
                  r = "s"in t.keyframes[n - 1] ? t.keyframes[n - 1].s : "e"in t.keyframes[n - 2] ? t.keyframes[n - 2].e : t.keyframes[n - 2].s;
                  var s = "unidimensional" === i ? new Number(r) : Object.assign({}, r);
                  return s.time = t.keyframes[n - 1].t / t.elem.comp.globalData.frameRate,
                    s.value = "unidimensional" === i ? r[0] : r,
                    s
                }
                ,
                e.valueAtTime = t.getValueAtTime,
                e.speedAtTime = t.getSpeedAtTime,
                e.velocityAtTime = t.getVelocityAtTime,
                e.propertyGroup = t.propertyGroup
            }
            function n() {
              return e
            }
            return function(r) {
              return r ? "unidimensional" === r.propType ? function(t) {
                t && "pv"in t || (t = e);
                var n = 1 / t.mult
                  , r = t.pv * n
                  , s = new Number(r);
                return s.value = r,
                  i(s, t, "unidimensional"),
                  function() {
                    return t.k && t.getValue(),
                      r = t.v * n,
                    s.value !== r && ((s = new Number(r)).value = r,
                      i(s, t, "unidimensional")),
                      s
                  }
              }(r) : function(e) {
                e && "pv"in e || (e = t);
                var n = 1 / e.mult
                  , r = e.data && e.data.l || e.pv.length
                  , s = createTypedArray("float32", r)
                  , a = createTypedArray("float32", r);
                return s.value = a,
                  i(s, e, "multidimensional"),
                  function() {
                    e.k && e.getValue();
                    for (var t = 0; t < r; t += 1)
                      a[t] = e.v[t] * n,
                        s[t] = a[t];
                    return s
                  }
              }(r) : n
            }
          }(), TransformExpressionInterface = function(e) {
            function t(e) {
              switch (e) {
                case "scale":
                case "Scale":
                case "ADBE Scale":
                case 6:
                  return t.scale;
                case "rotation":
                case "Rotation":
                case "ADBE Rotation":
                case "ADBE Rotate Z":
                case 10:
                  return t.rotation;
                case "ADBE Rotate X":
                  return t.xRotation;
                case "ADBE Rotate Y":
                  return t.yRotation;
                case "position":
                case "Position":
                case "ADBE Position":
                case 2:
                  return t.position;
                case "ADBE Position_0":
                  return t.xPosition;
                case "ADBE Position_1":
                  return t.yPosition;
                case "ADBE Position_2":
                  return t.zPosition;
                case "anchorPoint":
                case "AnchorPoint":
                case "Anchor Point":
                case "ADBE AnchorPoint":
                case 1:
                  return t.anchorPoint;
                case "opacity":
                case "Opacity":
                case 11:
                  return t.opacity;
                default:
                  return null
              }
            }
            var i, n, r, s;
            return Object.defineProperty(t, "rotation", {
              get: ExpressionPropertyInterface(e.r || e.rz)
            }),
              Object.defineProperty(t, "zRotation", {
                get: ExpressionPropertyInterface(e.rz || e.r)
              }),
              Object.defineProperty(t, "xRotation", {
                get: ExpressionPropertyInterface(e.rx)
              }),
              Object.defineProperty(t, "yRotation", {
                get: ExpressionPropertyInterface(e.ry)
              }),
              Object.defineProperty(t, "scale", {
                get: ExpressionPropertyInterface(e.s)
              }),
              e.p ? s = ExpressionPropertyInterface(e.p) : (i = ExpressionPropertyInterface(e.px),
                n = ExpressionPropertyInterface(e.py),
              e.pz && (r = ExpressionPropertyInterface(e.pz))),
              Object.defineProperty(t, "position", {
                get: function() {
                  return e.p ? s() : [i(), n(), r ? r() : 0]
                }
              }),
              Object.defineProperty(t, "xPosition", {
                get: ExpressionPropertyInterface(e.px)
              }),
              Object.defineProperty(t, "yPosition", {
                get: ExpressionPropertyInterface(e.py)
              }),
              Object.defineProperty(t, "zPosition", {
                get: ExpressionPropertyInterface(e.pz)
              }),
              Object.defineProperty(t, "anchorPoint", {
                get: ExpressionPropertyInterface(e.a)
              }),
              Object.defineProperty(t, "opacity", {
                get: ExpressionPropertyInterface(e.o)
              }),
              Object.defineProperty(t, "skew", {
                get: ExpressionPropertyInterface(e.sk)
              }),
              Object.defineProperty(t, "skewAxis", {
                get: ExpressionPropertyInterface(e.sa)
              }),
              Object.defineProperty(t, "orientation", {
                get: ExpressionPropertyInterface(e.or)
              }),
              t
          }, LayerExpressionInterface = function() {
            function e(e) {
              var t = new Matrix;
              return void 0 !== e ? this._elem.finalTransform.mProp.getValueAtTime(e).clone(t) : this._elem.finalTransform.mProp.applyToMatrix(t),
                t
            }
            function t(e, t) {
              var i = this.getMatrix(t);
              return i.props[12] = 0,
                i.props[13] = 0,
                i.props[14] = 0,
                this.applyPoint(i, e)
            }
            function i(e, t) {
              var i = this.getMatrix(t);
              return this.applyPoint(i, e)
            }
            function n(e, t) {
              var i = this.getMatrix(t);
              return i.props[12] = 0,
                i.props[13] = 0,
                i.props[14] = 0,
                this.invertPoint(i, e)
            }
            function r(e, t) {
              var i = this.getMatrix(t);
              return this.invertPoint(i, e)
            }
            function s(e, t) {
              if (this._elem.hierarchy && this._elem.hierarchy.length) {
                var i, n = this._elem.hierarchy.length;
                for (i = 0; i < n; i += 1)
                  this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(e)
              }
              return e.applyToPointArray(t[0], t[1], t[2] || 0)
            }
            function a(e, t) {
              if (this._elem.hierarchy && this._elem.hierarchy.length) {
                var i, n = this._elem.hierarchy.length;
                for (i = 0; i < n; i += 1)
                  this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(e)
              }
              return e.inversePoint(t)
            }
            function o(e) {
              var t = new Matrix;
              if (t.reset(),
                this._elem.finalTransform.mProp.applyToMatrix(t),
              this._elem.hierarchy && this._elem.hierarchy.length) {
                var i, n = this._elem.hierarchy.length;
                for (i = 0; i < n; i += 1)
                  this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(t);
                return t.inversePoint(e)
              }
              return t.inversePoint(e)
            }
            function l() {
              return [1, 1, 1, 1]
            }
            return function(h) {
              var c;
              function u(e) {
                switch (e) {
                  case "ADBE Root Vectors Group":
                  case "Contents":
                  case 2:
                    return u.shapeInterface;
                  case 1:
                  case 6:
                  case "Transform":
                  case "transform":
                  case "ADBE Transform Group":
                    return c;
                  case 4:
                  case "ADBE Effect Parade":
                  case "effects":
                  case "Effects":
                    return u.effect;
                  case "ADBE Text Properties":
                    return u.textInterface;
                  default:
                    return null
                }
              }
              u.getMatrix = e,
                u.invertPoint = a,
                u.applyPoint = s,
                u.toWorld = i,
                u.toWorldVec = t,
                u.fromWorld = r,
                u.fromWorldVec = n,
                u.toComp = i,
                u.fromComp = o,
                u.sampleImage = l,
                u.sourceRectAtTime = h.sourceRectAtTime.bind(h),
                u._elem = h;
              var d = getDescriptor(c = TransformExpressionInterface(h.finalTransform.mProp), "anchorPoint");
              return Object.defineProperties(u, {
                hasParent: {
                  get: function() {
                    return h.hierarchy.length
                  }
                },
                parent: {
                  get: function() {
                    return h.hierarchy[0].layerInterface
                  }
                },
                rotation: getDescriptor(c, "rotation"),
                scale: getDescriptor(c, "scale"),
                position: getDescriptor(c, "position"),
                opacity: getDescriptor(c, "opacity"),
                anchorPoint: d,
                anchor_point: d,
                transform: {
                  get: function() {
                    return c
                  }
                },
                active: {
                  get: function() {
                    return h.isInRange
                  }
                }
              }),
                u.startTime = h.data.st,
                u.index = h.data.ind,
                u.source = h.data.refId,
                u.height = 0 === h.data.ty ? h.data.h : 100,
                u.width = 0 === h.data.ty ? h.data.w : 100,
                u.inPoint = h.data.ip / h.comp.globalData.frameRate,
                u.outPoint = h.data.op / h.comp.globalData.frameRate,
                u._name = h.data.nm,
                u.registerMaskInterface = function(e) {
                  u.mask = new MaskManagerInterface(e,h)
                }
                ,
                u.registerEffectsInterface = function(e) {
                  u.effect = e
                }
                ,
                u
            }
          }(), propertyGroupFactory = function(e, t) {
            return function(i) {
              return (i = void 0 === i ? 1 : i) <= 0 ? e : t(i - 1)
            }
          }, PropertyInterface = function(e, t) {
            var i = {
              _name: e
            };
            return function(e) {
              return (e = void 0 === e ? 1 : e) <= 0 ? i : t(e - 1)
            }
          }, EffectsExpressionInterface = function() {
            function e(i, n, r, s) {
              function a(e) {
                for (var t = i.ef, n = 0, r = t.length; n < r; ) {
                  if (e === t[n].nm || e === t[n].mn || e === t[n].ix)
                    return 5 === t[n].ty ? h[n] : h[n]();
                  n += 1
                }
                throw new Error
              }
              var o, l = propertyGroupFactory(a, r), h = [], c = i.ef.length;
              for (o = 0; o < c; o += 1)
                5 === i.ef[o].ty ? h.push(e(i.ef[o], n.effectElements[o], n.effectElements[o].propertyGroup, s)) : h.push(t(n.effectElements[o], i.ef[o].ty, s, l));
              return "ADBE Color Control" === i.mn && Object.defineProperty(a, "color", {
                get: function() {
                  return h[0]()
                }
              }),
                Object.defineProperties(a, {
                  numProperties: {
                    get: function() {
                      return i.np
                    }
                  },
                  _name: {
                    value: i.nm
                  },
                  propertyGroup: {
                    value: l
                  }
                }),
                a.enabled = 0 !== i.en,
                a.active = a.enabled,
                a
            }
            function t(e, t, i, n) {
              var r = ExpressionPropertyInterface(e.p);
              return e.p.setGroupProperty && e.p.setGroupProperty(PropertyInterface("", n)),
                function() {
                  return 10 === t ? i.comp.compInterface(e.p.v) : r()
                }
            }
            return {
              createEffectsInterface: function(t, i) {
                if (t.effectsManager) {
                  var n, r = [], s = t.data.ef, a = t.effectsManager.effectElements.length;
                  for (n = 0; n < a; n += 1)
                    r.push(e(s[n], t.effectsManager.effectElements[n], i, t));
                  var o = t.data.ef || []
                    , l = function(e) {
                    for (n = 0,
                           a = o.length; n < a; ) {
                      if (e === o[n].nm || e === o[n].mn || e === o[n].ix)
                        return r[n];
                      n += 1
                    }
                    return null
                  };
                  return Object.defineProperty(l, "numProperties", {
                    get: function() {
                      return o.length
                    }
                  }),
                    l
                }
                return null
              }
            }
          }(), CompExpressionInterface = function(e) {
            function t(t) {
              for (var i = 0, n = e.layers.length; i < n; ) {
                if (e.layers[i].nm === t || e.layers[i].ind === t)
                  return e.elements[i].layerInterface;
                i += 1
              }
              return null
            }
            return Object.defineProperty(t, "_name", {
              value: e.data.nm
            }),
              t.layer = t,
              t.pixelAspect = 1,
              t.height = e.data.h || e.globalData.compSize.h,
              t.width = e.data.w || e.globalData.compSize.w,
              t.pixelAspect = 1,
              t.frameDuration = 1 / e.globalData.frameRate,
              t.displayStartTime = 0,
              t.numLayers = e.layers.length,
              t
          }, ShapePathInterface = function(e, t, i) {
            var n = t.sh;
            function r(e) {
              return "Shape" === e || "shape" === e || "Path" === e || "path" === e || "ADBE Vector Shape" === e || 2 === e ? r.path : null
            }
            var s = propertyGroupFactory(r, i);
            return n.setGroupProperty(PropertyInterface("Path", s)),
              Object.defineProperties(r, {
                path: {
                  get: function() {
                    return n.k && n.getValue(),
                      n
                  }
                },
                shape: {
                  get: function() {
                    return n.k && n.getValue(),
                      n
                  }
                },
                _name: {
                  value: e.nm
                },
                ix: {
                  value: e.ix
                },
                propertyIndex: {
                  value: e.ix
                },
                mn: {
                  value: e.mn
                },
                propertyGroup: {
                  value: i
                }
              }),
              r
          }, ShapeExpressionInterface = function() {
            function e(e, a, d) {
              var p, f = [], m = e ? e.length : 0;
              for (p = 0; p < m; p += 1)
                "gr" === e[p].ty ? f.push(t(e[p], a[p], d)) : "fl" === e[p].ty ? f.push(i(e[p], a[p], d)) : "st" === e[p].ty ? f.push(r(e[p], a[p], d)) : "tm" === e[p].ty ? f.push(s(e[p], a[p], d)) : "tr" === e[p].ty || ("el" === e[p].ty ? f.push(o(e[p], a[p], d)) : "sr" === e[p].ty ? f.push(l(e[p], a[p], d)) : "sh" === e[p].ty ? f.push(ShapePathInterface(e[p], a[p], d)) : "rc" === e[p].ty ? f.push(h(e[p], a[p], d)) : "rd" === e[p].ty ? f.push(c(e[p], a[p], d)) : "rp" === e[p].ty ? f.push(u(e[p], a[p], d)) : "gf" === e[p].ty ? f.push(n(e[p], a[p], d)) : f.push((e[p],
                    a[p],
                    function() {
                      return null
                    }
                )));
              return f
            }
            function t(t, i, n) {
              var r = function(e) {
                switch (e) {
                  case "ADBE Vectors Group":
                  case "Contents":
                  case 2:
                    return r.content;
                  default:
                    return r.transform
                }
              };
              r.propertyGroup = propertyGroupFactory(r, n);
              var s = function(t, i, n) {
                var r, s = function(e) {
                  for (var t = 0, i = r.length; t < i; ) {
                    if (r[t]._name === e || r[t].mn === e || r[t].propertyIndex === e || r[t].ix === e || r[t].ind === e)
                      return r[t];
                    t += 1
                  }
                  return "number" == typeof e ? r[e - 1] : null
                };
                s.propertyGroup = propertyGroupFactory(s, n),
                  r = e(t.it, i.it, s.propertyGroup),
                  s.numProperties = r.length;
                var o = a(t.it[t.it.length - 1], i.it[i.it.length - 1], s.propertyGroup);
                return s.transform = o,
                  s.propertyIndex = t.cix,
                  s._name = t.nm,
                  s
              }(t, i, r.propertyGroup)
                , o = a(t.it[t.it.length - 1], i.it[i.it.length - 1], r.propertyGroup);
              return r.content = s,
                r.transform = o,
                Object.defineProperty(r, "_name", {
                  get: function() {
                    return t.nm
                  }
                }),
                r.numProperties = t.np,
                r.propertyIndex = t.ix,
                r.nm = t.nm,
                r.mn = t.mn,
                r
            }
            function i(e, t, i) {
              function n(e) {
                return "Color" === e || "color" === e ? n.color : "Opacity" === e || "opacity" === e ? n.opacity : null
              }
              return Object.defineProperties(n, {
                color: {
                  get: ExpressionPropertyInterface(t.c)
                },
                opacity: {
                  get: ExpressionPropertyInterface(t.o)
                },
                _name: {
                  value: e.nm
                },
                mn: {
                  value: e.mn
                }
              }),
                t.c.setGroupProperty(PropertyInterface("Color", i)),
                t.o.setGroupProperty(PropertyInterface("Opacity", i)),
                n
            }
            function n(e, t, i) {
              function n(e) {
                return "Start Point" === e || "start point" === e ? n.startPoint : "End Point" === e || "end point" === e ? n.endPoint : "Opacity" === e || "opacity" === e ? n.opacity : null
              }
              return Object.defineProperties(n, {
                startPoint: {
                  get: ExpressionPropertyInterface(t.s)
                },
                endPoint: {
                  get: ExpressionPropertyInterface(t.e)
                },
                opacity: {
                  get: ExpressionPropertyInterface(t.o)
                },
                type: {
                  get: function() {
                    return "a"
                  }
                },
                _name: {
                  value: e.nm
                },
                mn: {
                  value: e.mn
                }
              }),
                t.s.setGroupProperty(PropertyInterface("Start Point", i)),
                t.e.setGroupProperty(PropertyInterface("End Point", i)),
                t.o.setGroupProperty(PropertyInterface("Opacity", i)),
                n
            }
            function r(e, t, i) {
              var n, r = propertyGroupFactory(h, i), s = propertyGroupFactory(l, r);
              function a(i) {
                Object.defineProperty(l, e.d[i].nm, {
                  get: ExpressionPropertyInterface(t.d.dataProps[i].p)
                })
              }
              var o = e.d ? e.d.length : 0
                , l = {};
              for (n = 0; n < o; n += 1)
                a(n),
                  t.d.dataProps[n].p.setGroupProperty(s);
              function h(e) {
                return "Color" === e || "color" === e ? h.color : "Opacity" === e || "opacity" === e ? h.opacity : "Stroke Width" === e || "stroke width" === e ? h.strokeWidth : null
              }
              return Object.defineProperties(h, {
                color: {
                  get: ExpressionPropertyInterface(t.c)
                },
                opacity: {
                  get: ExpressionPropertyInterface(t.o)
                },
                strokeWidth: {
                  get: ExpressionPropertyInterface(t.w)
                },
                dash: {
                  get: function() {
                    return l
                  }
                },
                _name: {
                  value: e.nm
                },
                mn: {
                  value: e.mn
                }
              }),
                t.c.setGroupProperty(PropertyInterface("Color", r)),
                t.o.setGroupProperty(PropertyInterface("Opacity", r)),
                t.w.setGroupProperty(PropertyInterface("Stroke Width", r)),
                h
            }
            function s(e, t, i) {
              function n(t) {
                return t === e.e.ix || "End" === t || "end" === t ? n.end : t === e.s.ix ? n.start : t === e.o.ix ? n.offset : null
              }
              var r = propertyGroupFactory(n, i);
              return n.propertyIndex = e.ix,
                t.s.setGroupProperty(PropertyInterface("Start", r)),
                t.e.setGroupProperty(PropertyInterface("End", r)),
                t.o.setGroupProperty(PropertyInterface("Offset", r)),
                n.propertyIndex = e.ix,
                n.propertyGroup = i,
                Object.defineProperties(n, {
                  start: {
                    get: ExpressionPropertyInterface(t.s)
                  },
                  end: {
                    get: ExpressionPropertyInterface(t.e)
                  },
                  offset: {
                    get: ExpressionPropertyInterface(t.o)
                  },
                  _name: {
                    value: e.nm
                  }
                }),
                n.mn = e.mn,
                n
            }
            function a(e, t, i) {
              function n(t) {
                return e.a.ix === t || "Anchor Point" === t ? n.anchorPoint : e.o.ix === t || "Opacity" === t ? n.opacity : e.p.ix === t || "Position" === t ? n.position : e.r.ix === t || "Rotation" === t || "ADBE Vector Rotation" === t ? n.rotation : e.s.ix === t || "Scale" === t ? n.scale : e.sk && e.sk.ix === t || "Skew" === t ? n.skew : e.sa && e.sa.ix === t || "Skew Axis" === t ? n.skewAxis : null
              }
              var r = propertyGroupFactory(n, i);
              return t.transform.mProps.o.setGroupProperty(PropertyInterface("Opacity", r)),
                t.transform.mProps.p.setGroupProperty(PropertyInterface("Position", r)),
                t.transform.mProps.a.setGroupProperty(PropertyInterface("Anchor Point", r)),
                t.transform.mProps.s.setGroupProperty(PropertyInterface("Scale", r)),
                t.transform.mProps.r.setGroupProperty(PropertyInterface("Rotation", r)),
              t.transform.mProps.sk && (t.transform.mProps.sk.setGroupProperty(PropertyInterface("Skew", r)),
                t.transform.mProps.sa.setGroupProperty(PropertyInterface("Skew Angle", r))),
                t.transform.op.setGroupProperty(PropertyInterface("Opacity", r)),
                Object.defineProperties(n, {
                  opacity: {
                    get: ExpressionPropertyInterface(t.transform.mProps.o)
                  },
                  position: {
                    get: ExpressionPropertyInterface(t.transform.mProps.p)
                  },
                  anchorPoint: {
                    get: ExpressionPropertyInterface(t.transform.mProps.a)
                  },
                  scale: {
                    get: ExpressionPropertyInterface(t.transform.mProps.s)
                  },
                  rotation: {
                    get: ExpressionPropertyInterface(t.transform.mProps.r)
                  },
                  skew: {
                    get: ExpressionPropertyInterface(t.transform.mProps.sk)
                  },
                  skewAxis: {
                    get: ExpressionPropertyInterface(t.transform.mProps.sa)
                  },
                  _name: {
                    value: e.nm
                  }
                }),
                n.ty = "tr",
                n.mn = e.mn,
                n.propertyGroup = i,
                n
            }
            function o(e, t, i) {
              function n(t) {
                return e.p.ix === t ? n.position : e.s.ix === t ? n.size : null
              }
              var r = propertyGroupFactory(n, i);
              n.propertyIndex = e.ix;
              var s = "tm" === t.sh.ty ? t.sh.prop : t.sh;
              return s.s.setGroupProperty(PropertyInterface("Size", r)),
                s.p.setGroupProperty(PropertyInterface("Position", r)),
                Object.defineProperties(n, {
                  size: {
                    get: ExpressionPropertyInterface(s.s)
                  },
                  position: {
                    get: ExpressionPropertyInterface(s.p)
                  },
                  _name: {
                    value: e.nm
                  }
                }),
                n.mn = e.mn,
                n
            }
            function l(e, t, i) {
              function n(t) {
                return e.p.ix === t ? n.position : e.r.ix === t ? n.rotation : e.pt.ix === t ? n.points : e.or.ix === t || "ADBE Vector Star Outer Radius" === t ? n.outerRadius : e.os.ix === t ? n.outerRoundness : !e.ir || e.ir.ix !== t && "ADBE Vector Star Inner Radius" !== t ? e.is && e.is.ix === t ? n.innerRoundness : null : n.innerRadius
              }
              var r = propertyGroupFactory(n, i)
                , s = "tm" === t.sh.ty ? t.sh.prop : t.sh;
              return n.propertyIndex = e.ix,
                s.or.setGroupProperty(PropertyInterface("Outer Radius", r)),
                s.os.setGroupProperty(PropertyInterface("Outer Roundness", r)),
                s.pt.setGroupProperty(PropertyInterface("Points", r)),
                s.p.setGroupProperty(PropertyInterface("Position", r)),
                s.r.setGroupProperty(PropertyInterface("Rotation", r)),
              e.ir && (s.ir.setGroupProperty(PropertyInterface("Inner Radius", r)),
                s.is.setGroupProperty(PropertyInterface("Inner Roundness", r))),
                Object.defineProperties(n, {
                  position: {
                    get: ExpressionPropertyInterface(s.p)
                  },
                  rotation: {
                    get: ExpressionPropertyInterface(s.r)
                  },
                  points: {
                    get: ExpressionPropertyInterface(s.pt)
                  },
                  outerRadius: {
                    get: ExpressionPropertyInterface(s.or)
                  },
                  outerRoundness: {
                    get: ExpressionPropertyInterface(s.os)
                  },
                  innerRadius: {
                    get: ExpressionPropertyInterface(s.ir)
                  },
                  innerRoundness: {
                    get: ExpressionPropertyInterface(s.is)
                  },
                  _name: {
                    value: e.nm
                  }
                }),
                n.mn = e.mn,
                n
            }
            function h(e, t, i) {
              function n(t) {
                return e.p.ix === t ? n.position : e.r.ix === t ? n.roundness : e.s.ix === t || "Size" === t || "ADBE Vector Rect Size" === t ? n.size : null
              }
              var r = propertyGroupFactory(n, i)
                , s = "tm" === t.sh.ty ? t.sh.prop : t.sh;
              return n.propertyIndex = e.ix,
                s.p.setGroupProperty(PropertyInterface("Position", r)),
                s.s.setGroupProperty(PropertyInterface("Size", r)),
                s.r.setGroupProperty(PropertyInterface("Rotation", r)),
                Object.defineProperties(n, {
                  position: {
                    get: ExpressionPropertyInterface(s.p)
                  },
                  roundness: {
                    get: ExpressionPropertyInterface(s.r)
                  },
                  size: {
                    get: ExpressionPropertyInterface(s.s)
                  },
                  _name: {
                    value: e.nm
                  }
                }),
                n.mn = e.mn,
                n
            }
            function c(e, t, i) {
              function n(t) {
                return e.r.ix === t || "Round Corners 1" === t ? n.radius : null
              }
              var r = propertyGroupFactory(n, i)
                , s = t;
              return n.propertyIndex = e.ix,
                s.rd.setGroupProperty(PropertyInterface("Radius", r)),
                Object.defineProperties(n, {
                  radius: {
                    get: ExpressionPropertyInterface(s.rd)
                  },
                  _name: {
                    value: e.nm
                  }
                }),
                n.mn = e.mn,
                n
            }
            function u(e, t, i) {
              function n(t) {
                return e.c.ix === t || "Copies" === t ? n.copies : e.o.ix === t || "Offset" === t ? n.offset : null
              }
              var r = propertyGroupFactory(n, i)
                , s = t;
              return n.propertyIndex = e.ix,
                s.c.setGroupProperty(PropertyInterface("Copies", r)),
                s.o.setGroupProperty(PropertyInterface("Offset", r)),
                Object.defineProperties(n, {
                  copies: {
                    get: ExpressionPropertyInterface(s.c)
                  },
                  offset: {
                    get: ExpressionPropertyInterface(s.o)
                  },
                  _name: {
                    value: e.nm
                  }
                }),
                n.mn = e.mn,
                n
            }
            return function(t, i, n) {
              var r;
              function s(e) {
                if ("number" == typeof e)
                  return 0 === (e = void 0 === e ? 1 : e) ? n : r[e - 1];
                for (var t = 0, i = r.length; t < i; ) {
                  if (r[t]._name === e)
                    return r[t];
                  t += 1
                }
                return null
              }
              return s.propertyGroup = propertyGroupFactory(s, (function() {
                  return n
                }
              )),
                r = e(t, i, s.propertyGroup),
                s.numProperties = r.length,
                s._name = "Contents",
                s
            }
          }(), TextExpressionInterface = function(e) {
            var t, i;
            function n(e) {
              return "ADBE Text Document" === e ? n.sourceText : null
            }
            return Object.defineProperty(n, "sourceText", {
              get: function() {
                e.textProperty.getValue();
                var n = e.textProperty.currentData.t;
                return n !== t && (e.textProperty.currentData.t = t,
                  (i = new String(n)).value = n || new String(n)),
                  i
              }
            }),
              n
          }, getBlendMode = (blendModeEnums = {
              0: "source-over",
              1: "multiply",
              2: "screen",
              3: "overlay",
              4: "darken",
              5: "lighten",
              6: "color-dodge",
              7: "color-burn",
              8: "hard-light",
              9: "soft-light",
              10: "difference",
              11: "exclusion",
              12: "hue",
              13: "saturation",
              14: "color",
              15: "luminosity"
            },
              function(e) {
                return blendModeEnums[e] || ""
              }
          ), blendModeEnums;
          function SliderEffect(e, t, i) {
            this.p = PropertyFactory.getProp(t, e.v, 0, 0, i)
          }
          function AngleEffect(e, t, i) {
            this.p = PropertyFactory.getProp(t, e.v, 0, 0, i)
          }
          function ColorEffect(e, t, i) {
            this.p = PropertyFactory.getProp(t, e.v, 1, 0, i)
          }
          function PointEffect(e, t, i) {
            this.p = PropertyFactory.getProp(t, e.v, 1, 0, i)
          }
          function LayerIndexEffect(e, t, i) {
            this.p = PropertyFactory.getProp(t, e.v, 0, 0, i)
          }
          function MaskIndexEffect(e, t, i) {
            this.p = PropertyFactory.getProp(t, e.v, 0, 0, i)
          }
          function CheckboxEffect(e, t, i) {
            this.p = PropertyFactory.getProp(t, e.v, 0, 0, i)
          }
          function NoValueEffect() {
            this.p = {}
          }
          function EffectsManager(e, t) {
            var i, n = e.ef || [];
            this.effectElements = [];
            var r, s = n.length;
            for (i = 0; i < s; i += 1)
              r = new GroupEffect(n[i],t),
                this.effectElements.push(r)
          }
          function GroupEffect(e, t) {
            this.init(e, t)
          }
          function BaseElement() {}
          function FrameElement() {}
          function _typeof$2(e) {
            return _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                return typeof e
              }
              : function(e) {
                return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
              }
              ,
              _typeof$2(e)
          }
          extendPrototype([DynamicPropertyContainer], GroupEffect),
            GroupEffect.prototype.getValue = GroupEffect.prototype.iterateDynamicProperties,
            GroupEffect.prototype.init = function(e, t) {
              var i;
              this.data = e,
                this.effectElements = [],
                this.initDynamicPropertyContainer(t);
              var n, r = this.data.ef.length, s = this.data.ef;
              for (i = 0; i < r; i += 1) {
                switch (n = null,
                  s[i].ty) {
                  case 0:
                    n = new SliderEffect(s[i],t,this);
                    break;
                  case 1:
                    n = new AngleEffect(s[i],t,this);
                    break;
                  case 2:
                    n = new ColorEffect(s[i],t,this);
                    break;
                  case 3:
                    n = new PointEffect(s[i],t,this);
                    break;
                  case 4:
                  case 7:
                    n = new CheckboxEffect(s[i],t,this);
                    break;
                  case 10:
                    n = new LayerIndexEffect(s[i],t,this);
                    break;
                  case 11:
                    n = new MaskIndexEffect(s[i],t,this);
                    break;
                  case 5:
                    n = new EffectsManager(s[i],t,this);
                    break;
                  default:
                    n = new NoValueEffect(s[i],t,this)
                }
                n && this.effectElements.push(n)
              }
            }
            ,
            BaseElement.prototype = {
              checkMasks: function() {
                if (!this.data.hasMask)
                  return !1;
                for (var e = 0, t = this.data.masksProperties.length; e < t; ) {
                  if ("n" !== this.data.masksProperties[e].mode && !1 !== this.data.masksProperties[e].cl)
                    return !0;
                  e += 1
                }
                return !1
              },
              initExpressions: function() {
                this.layerInterface = LayerExpressionInterface(this),
                this.data.hasMask && this.maskManager && this.layerInterface.registerMaskInterface(this.maskManager);
                var e = EffectsExpressionInterface.createEffectsInterface(this, this.layerInterface);
                this.layerInterface.registerEffectsInterface(e),
                  0 === this.data.ty || this.data.xt ? this.compInterface = CompExpressionInterface(this) : 4 === this.data.ty ? (this.layerInterface.shapeInterface = ShapeExpressionInterface(this.shapesData, this.itemsData, this.layerInterface),
                    this.layerInterface.content = this.layerInterface.shapeInterface) : 5 === this.data.ty && (this.layerInterface.textInterface = TextExpressionInterface(this),
                    this.layerInterface.text = this.layerInterface.textInterface)
              },
              setBlendMode: function() {
                var e = getBlendMode(this.data.bm);
                (this.baseElement || this.layerElement).style["mix-blend-mode"] = e
              },
              initBaseData: function(e, t, i) {
                this.globalData = t,
                  this.comp = i,
                  this.data = e,
                  this.layerId = createElementID(),
                this.data.sr || (this.data.sr = 1),
                  this.effectsManager = new EffectsManager(this.data,this,this.dynamicProperties)
              },
              getType: function() {
                return this.type
              },
              sourceRectAtTime: function() {}
            },
            FrameElement.prototype = {
              initFrame: function() {
                this._isFirstFrame = !1,
                  this.dynamicProperties = [],
                  this._mdf = !1
              },
              prepareProperties: function(e, t) {
                var i, n = this.dynamicProperties.length;
                for (i = 0; i < n; i += 1)
                  (t || this._isParent && "transform" === this.dynamicProperties[i].propType) && (this.dynamicProperties[i].getValue(),
                  this.dynamicProperties[i]._mdf && (this.globalData._mdf = !0,
                    this._mdf = !0))
              },
              addDynamicProperty: function(e) {
                -1 === this.dynamicProperties.indexOf(e) && this.dynamicProperties.push(e)
              }
            };
          var FootageInterface = (dataInterfaceFactory = function(e) {
              function t(e) {
                return "Outline" === e ? t.outlineInterface() : null
              }
              return t._name = "Outline",
                t.outlineInterface = function(e) {
                  var t = ""
                    , i = e.getFootageData();
                  function n(e) {
                    if (i[e])
                      return t = e,
                        "object" === _typeof$2(i = i[e]) ? n : i;
                    var r = e.indexOf(t);
                    if (-1 !== r) {
                      var s = parseInt(e.substr(r + t.length), 10);
                      return "object" === _typeof$2(i = i[s]) ? n : i
                    }
                    return ""
                  }
                  return function() {
                    return t = "",
                      i = e.getFootageData(),
                      n
                  }
                }(e),
                t
            }
              ,
              function(e) {
                function t(e) {
                  return "Data" === e ? t.dataInterface : null
                }
                return t._name = "Data",
                  t.dataInterface = dataInterfaceFactory(e),
                  t
              }
          ), dataInterfaceFactory;
          function FootageElement(e, t, i) {
            this.initFrame(),
              this.initRenderable(),
              this.assetData = t.getAssetData(e.refId),
              this.footageData = t.imageLoader.getAsset(this.assetData),
              this.initBaseData(e, t, i)
          }
          function AudioElement(e, t, i) {
            this.initFrame(),
              this.initRenderable(),
              this.assetData = t.getAssetData(e.refId),
              this.initBaseData(e, t, i),
              this._isPlaying = !1,
              this._canPlay = !1;
            var n = this.globalData.getAssetsPath(this.assetData);
            this.audio = this.globalData.audioController.createAudio(n),
              this._currentTime = 0,
              this.globalData.audioController.addAudio(this),
              this._volumeMultiplier = 1,
              this._volume = 1,
              this._previousVolume = null,
              this.tm = e.tm ? PropertyFactory.getProp(this, e.tm, 0, t.frameRate, this) : {
                _placeholder: !0
              },
              this.lv = PropertyFactory.getProp(this, e.au && e.au.lv ? e.au.lv : {
                k: [100]
              }, 1, .01, this)
          }
          function BaseRenderer() {}
          function TransformElement() {}
          function MaskElement(e, t, i) {
            this.data = e,
              this.element = t,
              this.globalData = i,
              this.storedData = [],
              this.masksProperties = this.data.masksProperties || [],
              this.maskElement = null;
            var n, r, s = this.globalData.defs, a = this.masksProperties ? this.masksProperties.length : 0;
            this.viewData = createSizedArray(a),
              this.solidPath = "";
            var o, l, h, c, u, d, p = this.masksProperties, f = 0, m = [], g = createElementID(), v = "clipPath", y = "clip-path";
            for (n = 0; n < a; n += 1)
              if (("a" !== p[n].mode && "n" !== p[n].mode || p[n].inv || 100 !== p[n].o.k || p[n].o.x) && (v = "mask",
                y = "mask"),
                "s" !== p[n].mode && "i" !== p[n].mode || 0 !== f ? h = null : ((h = createNS("rect")).setAttribute("fill", "#ffffff"),
                  h.setAttribute("width", this.element.comp.data.w || 0),
                  h.setAttribute("height", this.element.comp.data.h || 0),
                  m.push(h)),
                r = createNS("path"),
              "n" === p[n].mode)
                this.viewData[n] = {
                  op: PropertyFactory.getProp(this.element, p[n].o, 0, .01, this.element),
                  prop: ShapePropertyFactory.getShapeProp(this.element, p[n], 3),
                  elem: r,
                  lastPath: ""
                },
                  s.appendChild(r);
              else {
                var x;
                if (f += 1,
                  r.setAttribute("fill", "s" === p[n].mode ? "#000000" : "#ffffff"),
                  r.setAttribute("clip-rule", "nonzero"),
                  0 !== p[n].x.k ? (v = "mask",
                    y = "mask",
                    d = PropertyFactory.getProp(this.element, p[n].x, 0, null, this.element),
                    x = createElementID(),
                    (c = createNS("filter")).setAttribute("id", x),
                    (u = createNS("feMorphology")).setAttribute("operator", "erode"),
                    u.setAttribute("in", "SourceGraphic"),
                    u.setAttribute("radius", "0"),
                    c.appendChild(u),
                    s.appendChild(c),
                    r.setAttribute("stroke", "s" === p[n].mode ? "#000000" : "#ffffff")) : (u = null,
                    d = null),
                  this.storedData[n] = {
                    elem: r,
                    x: d,
                    expan: u,
                    lastPath: "",
                    lastOperator: "",
                    filterId: x,
                    lastRadius: 0
                  },
                "i" === p[n].mode) {
                  l = m.length;
                  var _ = createNS("g");
                  for (o = 0; o < l; o += 1)
                    _.appendChild(m[o]);
                  var b = createNS("mask");
                  b.setAttribute("mask-type", "alpha"),
                    b.setAttribute("id", g + "_" + f),
                    b.appendChild(r),
                    s.appendChild(b),
                    _.setAttribute("mask", "url(" + getLocationHref() + "#" + g + "_" + f + ")"),
                    m.length = 0,
                    m.push(_)
                } else
                  m.push(r);
                p[n].inv && !this.solidPath && (this.solidPath = this.createLayerSolidPath()),
                  this.viewData[n] = {
                    elem: r,
                    lastPath: "",
                    op: PropertyFactory.getProp(this.element, p[n].o, 0, .01, this.element),
                    prop: ShapePropertyFactory.getShapeProp(this.element, p[n], 3),
                    invRect: h
                  },
                this.viewData[n].prop.k || this.drawPath(p[n], this.viewData[n].prop.v, this.viewData[n])
              }
            for (this.maskElement = createNS(v),
                   a = m.length,
                   n = 0; n < a; n += 1)
              this.maskElement.appendChild(m[n]);
            f > 0 && (this.maskElement.setAttribute("id", g),
              this.element.maskedElement.setAttribute(y, "url(" + getLocationHref() + "#" + g + ")"),
              s.appendChild(this.maskElement)),
            this.viewData.length && this.element.addRenderableComponent(this)
          }
          FootageElement.prototype.prepareFrame = function() {}
            ,
            extendPrototype([RenderableElement, BaseElement, FrameElement], FootageElement),
            FootageElement.prototype.getBaseElement = function() {
              return null
            }
            ,
            FootageElement.prototype.renderFrame = function() {}
            ,
            FootageElement.prototype.destroy = function() {}
            ,
            FootageElement.prototype.initExpressions = function() {
              this.layerInterface = FootageInterface(this)
            }
            ,
            FootageElement.prototype.getFootageData = function() {
              return this.footageData
            }
            ,
            AudioElement.prototype.prepareFrame = function(e) {
              if (this.prepareRenderableFrame(e, !0),
                this.prepareProperties(e, !0),
                this.tm._placeholder)
                this._currentTime = e / this.data.sr;
              else {
                var t = this.tm.v;
                this._currentTime = t
              }
              this._volume = this.lv.v[0];
              var i = this._volume * this._volumeMultiplier;
              this._previousVolume !== i && (this._previousVolume = i,
                this.audio.volume(i))
            }
            ,
            extendPrototype([RenderableElement, BaseElement, FrameElement], AudioElement),
            AudioElement.prototype.renderFrame = function() {
              this.isInRange && this._canPlay && (this._isPlaying ? (!this.audio.playing() || Math.abs(this._currentTime / this.globalData.frameRate - this.audio.seek()) > .1) && this.audio.seek(this._currentTime / this.globalData.frameRate) : (this.audio.play(),
                this.audio.seek(this._currentTime / this.globalData.frameRate),
                this._isPlaying = !0))
            }
            ,
            AudioElement.prototype.show = function() {}
            ,
            AudioElement.prototype.hide = function() {
              this.audio.pause(),
                this._isPlaying = !1
            }
            ,
            AudioElement.prototype.pause = function() {
              this.audio.pause(),
                this._isPlaying = !1,
                this._canPlay = !1
            }
            ,
            AudioElement.prototype.resume = function() {
              this._canPlay = !0
            }
            ,
            AudioElement.prototype.setRate = function(e) {
              this.audio.rate(e)
            }
            ,
            AudioElement.prototype.volume = function(e) {
              this._volumeMultiplier = e,
                this._previousVolume = e * this._volume,
                this.audio.volume(this._previousVolume)
            }
            ,
            AudioElement.prototype.getBaseElement = function() {
              return null
            }
            ,
            AudioElement.prototype.destroy = function() {}
            ,
            AudioElement.prototype.sourceRectAtTime = function() {}
            ,
            AudioElement.prototype.initExpressions = function() {}
            ,
            BaseRenderer.prototype.checkLayers = function(e) {
              var t, i, n = this.layers.length;
              for (this.completeLayers = !0,
                     t = n - 1; t >= 0; t -= 1)
                this.elements[t] || (i = this.layers[t]).ip - i.st <= e - this.layers[t].st && i.op - i.st > e - this.layers[t].st && this.buildItem(t),
                  this.completeLayers = !!this.elements[t] && this.completeLayers;
              this.checkPendingElements()
            }
            ,
            BaseRenderer.prototype.createItem = function(e) {
              switch (e.ty) {
                case 2:
                  return this.createImage(e);
                case 0:
                  return this.createComp(e);
                case 1:
                  return this.createSolid(e);
                case 3:
                default:
                  return this.createNull(e);
                case 4:
                  return this.createShape(e);
                case 5:
                  return this.createText(e);
                case 6:
                  return this.createAudio(e);
                case 13:
                  return this.createCamera(e);
                case 15:
                  return this.createFootage(e)
              }
            }
            ,
            BaseRenderer.prototype.createCamera = function() {
              throw new Error("You're using a 3d camera. Try the html renderer.")
            }
            ,
            BaseRenderer.prototype.createAudio = function(e) {
              return new AudioElement(e,this.globalData,this)
            }
            ,
            BaseRenderer.prototype.createFootage = function(e) {
              return new FootageElement(e,this.globalData,this)
            }
            ,
            BaseRenderer.prototype.buildAllItems = function() {
              var e, t = this.layers.length;
              for (e = 0; e < t; e += 1)
                this.buildItem(e);
              this.checkPendingElements()
            }
            ,
            BaseRenderer.prototype.includeLayers = function(e) {
              var t;
              this.completeLayers = !1;
              var i, n = e.length, r = this.layers.length;
              for (t = 0; t < n; t += 1)
                for (i = 0; i < r; ) {
                  if (this.layers[i].id === e[t].id) {
                    this.layers[i] = e[t];
                    break
                  }
                  i += 1
                }
            }
            ,
            BaseRenderer.prototype.setProjectInterface = function(e) {
              this.globalData.projectInterface = e
            }
            ,
            BaseRenderer.prototype.initItems = function() {
              this.globalData.progressiveLoad || this.buildAllItems()
            }
            ,
            BaseRenderer.prototype.buildElementParenting = function(e, t, i) {
              for (var n = this.elements, r = this.layers, s = 0, a = r.length; s < a; )
                r[s].ind == t && (n[s] && !0 !== n[s] ? (i.push(n[s]),
                  n[s].setAsParent(),
                  void 0 !== r[s].parent ? this.buildElementParenting(e, r[s].parent, i) : e.setHierarchy(i)) : (this.buildItem(s),
                  this.addPendingElement(e))),
                  s += 1
            }
            ,
            BaseRenderer.prototype.addPendingElement = function(e) {
              this.pendingElements.push(e)
            }
            ,
            BaseRenderer.prototype.searchExtraCompositions = function(e) {
              var t, i = e.length;
              for (t = 0; t < i; t += 1)
                if (e[t].xt) {
                  var n = this.createComp(e[t]);
                  n.initExpressions(),
                    this.globalData.projectInterface.registerComposition(n)
                }
            }
            ,
            BaseRenderer.prototype.getElementByPath = function(e) {
              var t, i = e.shift();
              if ("number" == typeof i)
                t = this.elements[i];
              else {
                var n, r = this.elements.length;
                for (n = 0; n < r; n += 1)
                  if (this.elements[n].data.nm === i) {
                    t = this.elements[n];
                    break
                  }
              }
              return 0 === e.length ? t : t.getElementByPath(e)
            }
            ,
            BaseRenderer.prototype.setupGlobalData = function(e, t) {
              this.globalData.fontManager = new FontManager,
                this.globalData.fontManager.addChars(e.chars),
                this.globalData.fontManager.addFonts(e.fonts, t),
                this.globalData.getAssetData = this.animationItem.getAssetData.bind(this.animationItem),
                this.globalData.getAssetsPath = this.animationItem.getAssetsPath.bind(this.animationItem),
                this.globalData.imageLoader = this.animationItem.imagePreloader,
                this.globalData.audioController = this.animationItem.audioController,
                this.globalData.frameId = 0,
                this.globalData.frameRate = e.fr,
                this.globalData.nm = e.nm,
                this.globalData.compSize = {
                  w: e.w,
                  h: e.h
                }
            }
            ,
            TransformElement.prototype = {
              initTransform: function() {
                this.finalTransform = {
                  mProp: this.data.ks ? TransformPropertyFactory.getTransformProperty(this, this.data.ks, this) : {
                    o: 0
                  },
                  _matMdf: !1,
                  _opMdf: !1,
                  mat: new Matrix
                },
                this.data.ao && (this.finalTransform.mProp.autoOriented = !0),
                  this.data.ty
              },
              renderTransform: function() {
                if (this.finalTransform._opMdf = this.finalTransform.mProp.o._mdf || this._isFirstFrame,
                  this.finalTransform._matMdf = this.finalTransform.mProp._mdf || this._isFirstFrame,
                  this.hierarchy) {
                  var e, t = this.finalTransform.mat, i = 0, n = this.hierarchy.length;
                  if (!this.finalTransform._matMdf)
                    for (; i < n; ) {
                      if (this.hierarchy[i].finalTransform.mProp._mdf) {
                        this.finalTransform._matMdf = !0;
                        break
                      }
                      i += 1
                    }
                  if (this.finalTransform._matMdf)
                    for (e = this.finalTransform.mProp.v.props,
                           t.cloneFromProps(e),
                           i = 0; i < n; i += 1)
                      e = this.hierarchy[i].finalTransform.mProp.v.props,
                        t.transform(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8], e[9], e[10], e[11], e[12], e[13], e[14], e[15])
                }
              },
              globalToLocal: function(e) {
                var t = [];
                t.push(this.finalTransform);
                for (var i, n = !0, r = this.comp; n; )
                  r.finalTransform ? (r.data.hasMask && t.splice(0, 0, r.finalTransform),
                    r = r.comp) : n = !1;
                var s, a = t.length;
                for (i = 0; i < a; i += 1)
                  s = t[i].mat.applyToPointArray(0, 0, 0),
                    e = [e[0] - s[0], e[1] - s[1], 0];
                return e
              },
              mHelper: new Matrix
            },
            MaskElement.prototype.getMaskProperty = function(e) {
              return this.viewData[e].prop
            }
            ,
            MaskElement.prototype.renderFrame = function(e) {
              var t, i = this.element.finalTransform.mat, n = this.masksProperties.length;
              for (t = 0; t < n; t += 1)
                if ((this.viewData[t].prop._mdf || e) && this.drawPath(this.masksProperties[t], this.viewData[t].prop.v, this.viewData[t]),
                (this.viewData[t].op._mdf || e) && this.viewData[t].elem.setAttribute("fill-opacity", this.viewData[t].op.v),
                "n" !== this.masksProperties[t].mode && (this.viewData[t].invRect && (this.element.finalTransform.mProp._mdf || e) && this.viewData[t].invRect.setAttribute("transform", i.getInverseMatrix().to2dCSS()),
                this.storedData[t].x && (this.storedData[t].x._mdf || e))) {
                  var r = this.storedData[t].expan;
                  this.storedData[t].x.v < 0 ? ("erode" !== this.storedData[t].lastOperator && (this.storedData[t].lastOperator = "erode",
                    this.storedData[t].elem.setAttribute("filter", "url(" + getLocationHref() + "#" + this.storedData[t].filterId + ")")),
                    r.setAttribute("radius", -this.storedData[t].x.v)) : ("dilate" !== this.storedData[t].lastOperator && (this.storedData[t].lastOperator = "dilate",
                    this.storedData[t].elem.setAttribute("filter", null)),
                    this.storedData[t].elem.setAttribute("stroke-width", 2 * this.storedData[t].x.v))
                }
            }
            ,
            MaskElement.prototype.getMaskelement = function() {
              return this.maskElement
            }
            ,
            MaskElement.prototype.createLayerSolidPath = function() {
              var e = "M0,0 ";
              return e += " h" + this.globalData.compSize.w,
                e += " v" + this.globalData.compSize.h,
              (e += " h-" + this.globalData.compSize.w) + " v-" + this.globalData.compSize.h + " "
            }
            ,
            MaskElement.prototype.drawPath = function(e, t, i) {
              var n, r, s = " M" + t.v[0][0] + "," + t.v[0][1];
              for (r = t._length,
                     n = 1; n < r; n += 1)
                s += " C" + t.o[n - 1][0] + "," + t.o[n - 1][1] + " " + t.i[n][0] + "," + t.i[n][1] + " " + t.v[n][0] + "," + t.v[n][1];
              if (t.c && r > 1 && (s += " C" + t.o[n - 1][0] + "," + t.o[n - 1][1] + " " + t.i[0][0] + "," + t.i[0][1] + " " + t.v[0][0] + "," + t.v[0][1]),
              i.lastPath !== s) {
                var a = "";
                i.elem && (t.c && (a = e.inv ? this.solidPath + s : s),
                  i.elem.setAttribute("d", a)),
                  i.lastPath = s
              }
            }
            ,
            MaskElement.prototype.destroy = function() {
              this.element = null,
                this.globalData = null,
                this.maskElement = null,
                this.data = null,
                this.masksProperties = null
            }
          ;
          var filtersFactory = {
            createFilter: function(e, t) {
              var i = createNS("filter");
              return i.setAttribute("id", e),
              !0 !== t && (i.setAttribute("filterUnits", "objectBoundingBox"),
                i.setAttribute("x", "0%"),
                i.setAttribute("y", "0%"),
                i.setAttribute("width", "100%"),
                i.setAttribute("height", "100%")),
                i
            },
            createAlphaToLuminanceFilter: function() {
              var e = createNS("feColorMatrix");
              return e.setAttribute("type", "matrix"),
                e.setAttribute("color-interpolation-filters", "sRGB"),
                e.setAttribute("values", "0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 1 1"),
                e
            }
          }
            , featureSupport = function() {
            var e = {
              maskType: !0
            };
            return (/MSIE 10/i.test(navigator.userAgent) || /MSIE 9/i.test(navigator.userAgent) || /rv:11.0/i.test(navigator.userAgent) || /Edge\/\d./i.test(navigator.userAgent)) && (e.maskType = !1),
              e
          }()
            , registeredEffects = {}
            , idPrefix = "filter_result_";
          function SVGEffects(e) {
            var t, i, n = "SourceGraphic", r = e.data.ef ? e.data.ef.length : 0, s = createElementID(), a = filtersFactory.createFilter(s, !0), o = 0;
            for (this.filters = [],
                   t = 0; t < r; t += 1) {
              i = null;
              var l = e.data.ef[t].ty;
              registeredEffects[l] && (i = new (0,
                registeredEffects[l].effect)(a,e.effectsManager.effectElements[t],e,idPrefix + o,n),
                n = idPrefix + o,
              registeredEffects[l].countsAsEffect && (o += 1)),
              i && this.filters.push(i)
            }
            o && (e.globalData.defs.appendChild(a),
              e.layerElement.setAttribute("filter", "url(" + getLocationHref() + "#" + s + ")")),
            this.filters.length && e.addRenderableComponent(this)
          }
          function registerEffect(e, t, i) {
            registeredEffects[e] = {
              effect: t,
              countsAsEffect: i
            }
          }
          function SVGBaseElement() {}
          function HierarchyElement() {}
          function RenderableDOMElement() {}
          function IImageElement(e, t, i) {
            this.assetData = t.getAssetData(e.refId),
              this.initElement(e, t, i),
              this.sourceRect = {
                top: 0,
                left: 0,
                width: this.assetData.w,
                height: this.assetData.h
              }
          }
          function ProcessedElement(e, t) {
            this.elem = e,
              this.pos = t
          }
          function IShapeElement() {}
          SVGEffects.prototype.renderFrame = function(e) {
            var t, i = this.filters.length;
            for (t = 0; t < i; t += 1)
              this.filters[t].renderFrame(e)
          }
            ,
            SVGBaseElement.prototype = {
              initRendererElement: function() {
                this.layerElement = createNS("g")
              },
              createContainerElements: function() {
                this.matteElement = createNS("g"),
                  this.transformedElement = this.layerElement,
                  this.maskedElement = this.layerElement,
                  this._sizeChanged = !1;
                var e, t, i, n = null;
                if (this.data.td) {
                  if (3 == this.data.td || 1 == this.data.td) {
                    var r = createNS("mask");
                    r.setAttribute("id", this.layerId),
                      r.setAttribute("mask-type", 3 == this.data.td ? "luminance" : "alpha"),
                      r.appendChild(this.layerElement),
                      n = r,
                      this.globalData.defs.appendChild(r),
                    featureSupport.maskType || 1 != this.data.td || (r.setAttribute("mask-type", "luminance"),
                      e = createElementID(),
                      t = filtersFactory.createFilter(e),
                      this.globalData.defs.appendChild(t),
                      t.appendChild(filtersFactory.createAlphaToLuminanceFilter()),
                      (i = createNS("g")).appendChild(this.layerElement),
                      n = i,
                      r.appendChild(i),
                      i.setAttribute("filter", "url(" + getLocationHref() + "#" + e + ")"))
                  } else if (2 == this.data.td) {
                    var s = createNS("mask");
                    s.setAttribute("id", this.layerId),
                      s.setAttribute("mask-type", "alpha");
                    var a = createNS("g");
                    s.appendChild(a),
                      e = createElementID(),
                      t = filtersFactory.createFilter(e);
                    var o = createNS("feComponentTransfer");
                    o.setAttribute("in", "SourceGraphic"),
                      t.appendChild(o);
                    var l = createNS("feFuncA");
                    l.setAttribute("type", "table"),
                      l.setAttribute("tableValues", "1.0 0.0"),
                      o.appendChild(l),
                      this.globalData.defs.appendChild(t);
                    var h = createNS("rect");
                    h.setAttribute("width", this.comp.data.w),
                      h.setAttribute("height", this.comp.data.h),
                      h.setAttribute("x", "0"),
                      h.setAttribute("y", "0"),
                      h.setAttribute("fill", "#ffffff"),
                      h.setAttribute("opacity", "0"),
                      a.setAttribute("filter", "url(" + getLocationHref() + "#" + e + ")"),
                      a.appendChild(h),
                      a.appendChild(this.layerElement),
                      n = a,
                    featureSupport.maskType || (s.setAttribute("mask-type", "luminance"),
                      t.appendChild(filtersFactory.createAlphaToLuminanceFilter()),
                      i = createNS("g"),
                      a.appendChild(h),
                      i.appendChild(this.layerElement),
                      n = i,
                      a.appendChild(i)),
                      this.globalData.defs.appendChild(s)
                  }
                } else
                  this.data.tt ? (this.matteElement.appendChild(this.layerElement),
                    n = this.matteElement,
                    this.baseElement = this.matteElement) : this.baseElement = this.layerElement;
                if (this.data.ln && this.layerElement.setAttribute("id", this.data.ln),
                this.data.cl && this.layerElement.setAttribute("class", this.data.cl),
                0 === this.data.ty && !this.data.hd) {
                  var c = createNS("clipPath")
                    , u = createNS("path");
                  u.setAttribute("d", "M0,0 L" + this.data.w + ",0 L" + this.data.w + "," + this.data.h + " L0," + this.data.h + "z");
                  var d = createElementID();
                  if (c.setAttribute("id", d),
                    c.appendChild(u),
                    this.globalData.defs.appendChild(c),
                    this.checkMasks()) {
                    var p = createNS("g");
                    p.setAttribute("clip-path", "url(" + getLocationHref() + "#" + d + ")"),
                      p.appendChild(this.layerElement),
                      this.transformedElement = p,
                      n ? n.appendChild(this.transformedElement) : this.baseElement = this.transformedElement
                  } else
                    this.layerElement.setAttribute("clip-path", "url(" + getLocationHref() + "#" + d + ")")
                }
                0 !== this.data.bm && this.setBlendMode()
              },
              renderElement: function() {
                this.finalTransform._matMdf && this.transformedElement.setAttribute("transform", this.finalTransform.mat.to2dCSS()),
                this.finalTransform._opMdf && this.transformedElement.setAttribute("opacity", this.finalTransform.mProp.o.v)
              },
              destroyBaseElement: function() {
                this.layerElement = null,
                  this.matteElement = null,
                  this.maskManager.destroy()
              },
              getBaseElement: function() {
                return this.data.hd ? null : this.baseElement
              },
              createRenderableComponents: function() {
                this.maskManager = new MaskElement(this.data,this,this.globalData),
                  this.renderableEffectsManager = new SVGEffects(this)
              },
              setMatte: function(e) {
                this.matteElement && this.matteElement.setAttribute("mask", "url(" + getLocationHref() + "#" + e + ")")
              }
            },
            HierarchyElement.prototype = {
              initHierarchy: function() {
                this.hierarchy = [],
                  this._isParent = !1,
                  this.checkParenting()
              },
              setHierarchy: function(e) {
                this.hierarchy = e
              },
              setAsParent: function() {
                this._isParent = !0
              },
              checkParenting: function() {
                void 0 !== this.data.parent && this.comp.buildElementParenting(this, this.data.parent, [])
              }
            },
            extendPrototype([RenderableElement, createProxyFunction({
              initElement: function(e, t, i) {
                this.initFrame(),
                  this.initBaseData(e, t, i),
                  this.initTransform(e, t, i),
                  this.initHierarchy(),
                  this.initRenderable(),
                  this.initRendererElement(),
                  this.createContainerElements(),
                  this.createRenderableComponents(),
                  this.createContent(),
                  this.hide()
              },
              hide: function() {
                this.hidden || this.isInRange && !this.isTransparent || ((this.baseElement || this.layerElement).style.display = "none",
                  this.hidden = !0)
              },
              show: function() {
                this.isInRange && !this.isTransparent && (this.data.hd || ((this.baseElement || this.layerElement).style.display = "block"),
                  this.hidden = !1,
                  this._isFirstFrame = !0)
              },
              renderFrame: function() {
                this.data.hd || this.hidden || (this.renderTransform(),
                  this.renderRenderable(),
                  this.renderElement(),
                  this.renderInnerContent(),
                this._isFirstFrame && (this._isFirstFrame = !1))
              },
              renderInnerContent: function() {},
              prepareFrame: function(e) {
                this._mdf = !1,
                  this.prepareRenderableFrame(e),
                  this.prepareProperties(e, this.isInRange),
                  this.checkTransparency()
              },
              destroy: function() {
                this.innerElem = null,
                  this.destroyBaseElement()
              }
            })], RenderableDOMElement),
            extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], IImageElement),
            IImageElement.prototype.createContent = function() {
              var e = this.globalData.getAssetsPath(this.assetData);
              this.innerElem = createNS("image"),
                this.innerElem.setAttribute("width", this.assetData.w + "px"),
                this.innerElem.setAttribute("height", this.assetData.h + "px"),
                this.innerElem.setAttribute("preserveAspectRatio", this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio),
                this.innerElem.setAttributeNS("http://www.w3.org/1999/xlink", "href", e),
                this.layerElement.appendChild(this.innerElem)
            }
            ,
            IImageElement.prototype.sourceRectAtTime = function() {
              return this.sourceRect
            }
            ,
            IShapeElement.prototype = {
              addShapeToModifiers: function(e) {
                var t, i = this.shapeModifiers.length;
                for (t = 0; t < i; t += 1)
                  this.shapeModifiers[t].addShape(e)
              },
              isShapeInAnimatedModifiers: function(e) {
                for (var t = this.shapeModifiers.length; 0 < t; )
                  if (this.shapeModifiers[0].isAnimatedWithShape(e))
                    return !0;
                return !1
              },
              renderModifiers: function() {
                if (this.shapeModifiers.length) {
                  var e, t = this.shapes.length;
                  for (e = 0; e < t; e += 1)
                    this.shapes[e].sh.reset();
                  for (e = (t = this.shapeModifiers.length) - 1; e >= 0 && !this.shapeModifiers[e].processShapes(this._isFirstFrame); e -= 1)
                    ;
                }
              },
              searchProcessedElement: function(e) {
                for (var t = this.processedElements, i = 0, n = t.length; i < n; ) {
                  if (t[i].elem === e)
                    return t[i].pos;
                  i += 1
                }
                return 0
              },
              addProcessedElement: function(e, t) {
                for (var i = this.processedElements, n = i.length; n; )
                  if (i[n -= 1].elem === e)
                    return void (i[n].pos = t);
                i.push(new ProcessedElement(e,t))
              },
              prepareFrame: function(e) {
                this.prepareRenderableFrame(e),
                  this.prepareProperties(e, this.isInRange)
              }
            };
          var lineCapEnum = {
            1: "butt",
            2: "round",
            3: "square"
          }
            , lineJoinEnum = {
            1: "miter",
            2: "round",
            3: "bevel"
          };
          function SVGShapeData(e, t, i) {
            this.caches = [],
              this.styles = [],
              this.transformers = e,
              this.lStr = "",
              this.sh = i,
              this.lvl = t,
              this._isAnimated = !!i.k;
            for (var n = 0, r = e.length; n < r; ) {
              if (e[n].mProps.dynamicProperties.length) {
                this._isAnimated = !0;
                break
              }
              n += 1
            }
          }
          function SVGStyleData(e, t) {
            this.data = e,
              this.type = e.ty,
              this.d = "",
              this.lvl = t,
              this._mdf = !1,
              this.closed = !0 === e.hd,
              this.pElem = createNS("path"),
              this.msElem = null
          }
          function DashProperty(e, t, i, n) {
            var r;
            this.elem = e,
              this.frameId = -1,
              this.dataProps = createSizedArray(t.length),
              this.renderer = i,
              this.k = !1,
              this.dashStr = "",
              this.dashArray = createTypedArray("float32", t.length ? t.length - 1 : 0),
              this.dashoffset = createTypedArray("float32", 1),
              this.initDynamicPropertyContainer(n);
            var s, a = t.length || 0;
            for (r = 0; r < a; r += 1)
              s = PropertyFactory.getProp(e, t[r].v, 0, 0, this),
                this.k = s.k || this.k,
                this.dataProps[r] = {
                  n: t[r].n,
                  p: s
                };
            this.k || this.getValue(!0),
              this._isAnimated = this.k
          }
          function SVGStrokeStyleData(e, t, i) {
            this.initDynamicPropertyContainer(e),
              this.getValue = this.iterateDynamicProperties,
              this.o = PropertyFactory.getProp(e, t.o, 0, .01, this),
              this.w = PropertyFactory.getProp(e, t.w, 0, null, this),
              this.d = new DashProperty(e,t.d || {},"svg",this),
              this.c = PropertyFactory.getProp(e, t.c, 1, 255, this),
              this.style = i,
              this._isAnimated = !!this._isAnimated
          }
          function SVGFillStyleData(e, t, i) {
            this.initDynamicPropertyContainer(e),
              this.getValue = this.iterateDynamicProperties,
              this.o = PropertyFactory.getProp(e, t.o, 0, .01, this),
              this.c = PropertyFactory.getProp(e, t.c, 1, 255, this),
              this.style = i
          }
          function SVGNoStyleData(e, t, i) {
            this.initDynamicPropertyContainer(e),
              this.getValue = this.iterateDynamicProperties,
              this.style = i
          }
          function GradientProperty(e, t, i) {
            this.data = t,
              this.c = createTypedArray("uint8c", 4 * t.p);
            var n = t.k.k[0].s ? t.k.k[0].s.length - 4 * t.p : t.k.k.length - 4 * t.p;
            this.o = createTypedArray("float32", n),
              this._cmdf = !1,
              this._omdf = !1,
              this._collapsable = this.checkCollapsable(),
              this._hasOpacity = n,
              this.initDynamicPropertyContainer(i),
              this.prop = PropertyFactory.getProp(e, t.k, 1, null, this),
              this.k = this.prop.k,
              this.getValue(!0)
          }
          function SVGGradientFillStyleData(e, t, i) {
            this.initDynamicPropertyContainer(e),
              this.getValue = this.iterateDynamicProperties,
              this.initGradientData(e, t, i)
          }
          function SVGGradientStrokeStyleData(e, t, i) {
            this.initDynamicPropertyContainer(e),
              this.getValue = this.iterateDynamicProperties,
              this.w = PropertyFactory.getProp(e, t.w, 0, null, this),
              this.d = new DashProperty(e,t.d || {},"svg",this),
              this.initGradientData(e, t, i),
              this._isAnimated = !!this._isAnimated
          }
          function ShapeGroupData() {
            this.it = [],
              this.prevViewData = [],
              this.gr = createNS("g")
          }
          function SVGTransformData(e, t, i) {
            this.transform = {
              mProps: e,
              op: t,
              container: i
            },
              this.elements = [],
              this._isAnimated = this.transform.mProps.dynamicProperties.length || this.transform.op.effectsSequence.length
          }
          SVGShapeData.prototype.setAsAnimated = function() {
            this._isAnimated = !0
          }
            ,
            SVGStyleData.prototype.reset = function() {
              this.d = "",
                this._mdf = !1
            }
            ,
            DashProperty.prototype.getValue = function(e) {
              if ((this.elem.globalData.frameId !== this.frameId || e) && (this.frameId = this.elem.globalData.frameId,
                this.iterateDynamicProperties(),
                this._mdf = this._mdf || e,
                this._mdf)) {
                var t = 0
                  , i = this.dataProps.length;
                for ("svg" === this.renderer && (this.dashStr = ""),
                       t = 0; t < i; t += 1)
                  "o" !== this.dataProps[t].n ? "svg" === this.renderer ? this.dashStr += " " + this.dataProps[t].p.v : this.dashArray[t] = this.dataProps[t].p.v : this.dashoffset[0] = this.dataProps[t].p.v
              }
            }
            ,
            extendPrototype([DynamicPropertyContainer], DashProperty),
            extendPrototype([DynamicPropertyContainer], SVGStrokeStyleData),
            extendPrototype([DynamicPropertyContainer], SVGFillStyleData),
            extendPrototype([DynamicPropertyContainer], SVGNoStyleData),
            GradientProperty.prototype.comparePoints = function(e, t) {
              for (var i = 0, n = this.o.length / 2; i < n; ) {
                if (Math.abs(e[4 * i] - e[4 * t + 2 * i]) > .01)
                  return !1;
                i += 1
              }
              return !0
            }
            ,
            GradientProperty.prototype.checkCollapsable = function() {
              if (this.o.length / 2 != this.c.length / 4)
                return !1;
              if (this.data.k.k[0].s)
                for (var e = 0, t = this.data.k.k.length; e < t; ) {
                  if (!this.comparePoints(this.data.k.k[e].s, this.data.p))
                    return !1;
                  e += 1
                }
              else if (!this.comparePoints(this.data.k.k, this.data.p))
                return !1;
              return !0
            }
            ,
            GradientProperty.prototype.getValue = function(e) {
              if (this.prop.getValue(),
                this._mdf = !1,
                this._cmdf = !1,
                this._omdf = !1,
              this.prop._mdf || e) {
                var t, i, n, r = 4 * this.data.p;
                for (t = 0; t < r; t += 1)
                  i = t % 4 == 0 ? 100 : 255,
                    n = Math.round(this.prop.v[t] * i),
                  this.c[t] !== n && (this.c[t] = n,
                    this._cmdf = !e);
                if (this.o.length)
                  for (r = this.prop.v.length,
                         t = 4 * this.data.p; t < r; t += 1)
                    i = t % 2 == 0 ? 100 : 1,
                      n = t % 2 == 0 ? Math.round(100 * this.prop.v[t]) : this.prop.v[t],
                    this.o[t - 4 * this.data.p] !== n && (this.o[t - 4 * this.data.p] = n,
                      this._omdf = !e);
                this._mdf = !e
              }
            }
            ,
            extendPrototype([DynamicPropertyContainer], GradientProperty),
            SVGGradientFillStyleData.prototype.initGradientData = function(e, t, i) {
              this.o = PropertyFactory.getProp(e, t.o, 0, .01, this),
                this.s = PropertyFactory.getProp(e, t.s, 1, null, this),
                this.e = PropertyFactory.getProp(e, t.e, 1, null, this),
                this.h = PropertyFactory.getProp(e, t.h || {
                  k: 0
                }, 0, .01, this),
                this.a = PropertyFactory.getProp(e, t.a || {
                  k: 0
                }, 0, degToRads, this),
                this.g = new GradientProperty(e,t.g,this),
                this.style = i,
                this.stops = [],
                this.setGradientData(i.pElem, t),
                this.setGradientOpacity(t, i),
                this._isAnimated = !!this._isAnimated
            }
            ,
            SVGGradientFillStyleData.prototype.setGradientData = function(e, t) {
              var i = createElementID()
                , n = createNS(1 === t.t ? "linearGradient" : "radialGradient");
              n.setAttribute("id", i),
                n.setAttribute("spreadMethod", "pad"),
                n.setAttribute("gradientUnits", "userSpaceOnUse");
              var r, s, a, o = [];
              for (a = 4 * t.g.p,
                     s = 0; s < a; s += 4)
                r = createNS("stop"),
                  n.appendChild(r),
                  o.push(r);
              e.setAttribute("gf" === t.ty ? "fill" : "stroke", "url(" + getLocationHref() + "#" + i + ")"),
                this.gf = n,
                this.cst = o
            }
            ,
            SVGGradientFillStyleData.prototype.setGradientOpacity = function(e, t) {
              if (this.g._hasOpacity && !this.g._collapsable) {
                var i, n, r, s = createNS("mask"), a = createNS("path");
                s.appendChild(a);
                var o = createElementID()
                  , l = createElementID();
                s.setAttribute("id", l);
                var h = createNS(1 === e.t ? "linearGradient" : "radialGradient");
                h.setAttribute("id", o),
                  h.setAttribute("spreadMethod", "pad"),
                  h.setAttribute("gradientUnits", "userSpaceOnUse"),
                  r = e.g.k.k[0].s ? e.g.k.k[0].s.length : e.g.k.k.length;
                var c = this.stops;
                for (n = 4 * e.g.p; n < r; n += 2)
                  (i = createNS("stop")).setAttribute("stop-color", "rgb(255,255,255)"),
                    h.appendChild(i),
                    c.push(i);
                a.setAttribute("gf" === e.ty ? "fill" : "stroke", "url(" + getLocationHref() + "#" + o + ")"),
                "gs" === e.ty && (a.setAttribute("stroke-linecap", lineCapEnum[e.lc || 2]),
                  a.setAttribute("stroke-linejoin", lineJoinEnum[e.lj || 2]),
                1 === e.lj && a.setAttribute("stroke-miterlimit", e.ml)),
                  this.of = h,
                  this.ms = s,
                  this.ost = c,
                  this.maskId = l,
                  t.msElem = a
              }
            }
            ,
            extendPrototype([DynamicPropertyContainer], SVGGradientFillStyleData),
            extendPrototype([SVGGradientFillStyleData, DynamicPropertyContainer], SVGGradientStrokeStyleData);
          var buildShapeString = function(e, t, i, n) {
            if (0 === t)
              return "";
            var r, s = e.o, a = e.i, o = e.v, l = " M" + n.applyToPointStringified(o[0][0], o[0][1]);
            for (r = 1; r < t; r += 1)
              l += " C" + n.applyToPointStringified(s[r - 1][0], s[r - 1][1]) + " " + n.applyToPointStringified(a[r][0], a[r][1]) + " " + n.applyToPointStringified(o[r][0], o[r][1]);
            return i && t && (l += " C" + n.applyToPointStringified(s[r - 1][0], s[r - 1][1]) + " " + n.applyToPointStringified(a[0][0], a[0][1]) + " " + n.applyToPointStringified(o[0][0], o[0][1]),
              l += "z"),
              l
          }
            , SVGElementsRenderer = function() {
            var e = new Matrix
              , t = new Matrix;
            function i(e, t, i) {
              (i || t.transform.op._mdf) && t.transform.container.setAttribute("opacity", t.transform.op.v),
              (i || t.transform.mProps._mdf) && t.transform.container.setAttribute("transform", t.transform.mProps.v.to2dCSS())
            }
            function n() {}
            function r(i, n, r) {
              var s, a, o, l, h, c, u, d, p, f, m, g = n.styles.length, v = n.lvl;
              for (c = 0; c < g; c += 1) {
                if (l = n.sh._mdf || r,
                n.styles[c].lvl < v) {
                  for (d = t.reset(),
                         f = v - n.styles[c].lvl,
                         m = n.transformers.length - 1; !l && f > 0; )
                    l = n.transformers[m].mProps._mdf || l,
                      f -= 1,
                      m -= 1;
                  if (l)
                    for (f = v - n.styles[c].lvl,
                           m = n.transformers.length - 1; f > 0; )
                      p = n.transformers[m].mProps.v.props,
                        d.transform(p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7], p[8], p[9], p[10], p[11], p[12], p[13], p[14], p[15]),
                        f -= 1,
                        m -= 1
                } else
                  d = e;
                if (a = (u = n.sh.paths)._length,
                  l) {
                  for (o = "",
                         s = 0; s < a; s += 1)
                    (h = u.shapes[s]) && h._length && (o += buildShapeString(h, h._length, h.c, d));
                  n.caches[c] = o
                } else
                  o = n.caches[c];
                n.styles[c].d += !0 === i.hd ? "" : o,
                  n.styles[c]._mdf = l || n.styles[c]._mdf
              }
            }
            function s(e, t, i) {
              var n = t.style;
              (t.c._mdf || i) && n.pElem.setAttribute("fill", "rgb(" + bmFloor(t.c.v[0]) + "," + bmFloor(t.c.v[1]) + "," + bmFloor(t.c.v[2]) + ")"),
              (t.o._mdf || i) && n.pElem.setAttribute("fill-opacity", t.o.v)
            }
            function a(e, t, i) {
              o(e, t, i),
                l(0, t, i)
            }
            function o(e, t, i) {
              var n, r, s, a, o, l = t.gf, h = t.g._hasOpacity, c = t.s.v, u = t.e.v;
              if (t.o._mdf || i) {
                var d = "gf" === e.ty ? "fill-opacity" : "stroke-opacity";
                t.style.pElem.setAttribute(d, t.o.v)
              }
              if (t.s._mdf || i) {
                var p = 1 === e.t ? "x1" : "cx"
                  , f = "x1" === p ? "y1" : "cy";
                l.setAttribute(p, c[0]),
                  l.setAttribute(f, c[1]),
                h && !t.g._collapsable && (t.of.setAttribute(p, c[0]),
                  t.of.setAttribute(f, c[1]))
              }
              if (t.g._cmdf || i) {
                n = t.cst;
                var m = t.g.c;
                for (s = n.length,
                       r = 0; r < s; r += 1)
                  (a = n[r]).setAttribute("offset", m[4 * r] + "%"),
                    a.setAttribute("stop-color", "rgb(" + m[4 * r + 1] + "," + m[4 * r + 2] + "," + m[4 * r + 3] + ")")
              }
              if (h && (t.g._omdf || i)) {
                var g = t.g.o;
                for (s = (n = t.g._collapsable ? t.cst : t.ost).length,
                       r = 0; r < s; r += 1)
                  a = n[r],
                  t.g._collapsable || a.setAttribute("offset", g[2 * r] + "%"),
                    a.setAttribute("stop-opacity", g[2 * r + 1])
              }
              if (1 === e.t)
                (t.e._mdf || i) && (l.setAttribute("x2", u[0]),
                  l.setAttribute("y2", u[1]),
                h && !t.g._collapsable && (t.of.setAttribute("x2", u[0]),
                  t.of.setAttribute("y2", u[1])));
              else if ((t.s._mdf || t.e._mdf || i) && (o = Math.sqrt(Math.pow(c[0] - u[0], 2) + Math.pow(c[1] - u[1], 2)),
                l.setAttribute("r", o),
              h && !t.g._collapsable && t.of.setAttribute("r", o)),
              t.e._mdf || t.h._mdf || t.a._mdf || i) {
                o || (o = Math.sqrt(Math.pow(c[0] - u[0], 2) + Math.pow(c[1] - u[1], 2)));
                var v = Math.atan2(u[1] - c[1], u[0] - c[0])
                  , y = t.h.v;
                y >= 1 ? y = .99 : y <= -1 && (y = -.99);
                var x = o * y
                  , _ = Math.cos(v + t.a.v) * x + c[0]
                  , b = Math.sin(v + t.a.v) * x + c[1];
                l.setAttribute("fx", _),
                  l.setAttribute("fy", b),
                h && !t.g._collapsable && (t.of.setAttribute("fx", _),
                  t.of.setAttribute("fy", b))
              }
            }
            function l(e, t, i) {
              var n = t.style
                , r = t.d;
              r && (r._mdf || i) && r.dashStr && (n.pElem.setAttribute("stroke-dasharray", r.dashStr),
                n.pElem.setAttribute("stroke-dashoffset", r.dashoffset[0])),
              t.c && (t.c._mdf || i) && n.pElem.setAttribute("stroke", "rgb(" + bmFloor(t.c.v[0]) + "," + bmFloor(t.c.v[1]) + "," + bmFloor(t.c.v[2]) + ")"),
              (t.o._mdf || i) && n.pElem.setAttribute("stroke-opacity", t.o.v),
              (t.w._mdf || i) && (n.pElem.setAttribute("stroke-width", t.w.v),
              n.msElem && n.msElem.setAttribute("stroke-width", t.w.v))
            }
            return {
              createRenderFunction: function(e) {
                switch (e.ty) {
                  case "fl":
                    return s;
                  case "gf":
                    return o;
                  case "gs":
                    return a;
                  case "st":
                    return l;
                  case "sh":
                  case "el":
                  case "rc":
                  case "sr":
                    return r;
                  case "tr":
                    return i;
                  case "no":
                    return n;
                  default:
                    return null
                }
              }
            }
          }();
          function SVGShapeElement(e, t, i) {
            this.shapes = [],
              this.shapesData = e.shapes,
              this.stylesList = [],
              this.shapeModifiers = [],
              this.itemsData = [],
              this.processedElements = [],
              this.animatedContents = [],
              this.initElement(e, t, i),
              this.prevViewData = []
          }
          function LetterProps(e, t, i, n, r, s) {
            this.o = e,
              this.sw = t,
              this.sc = i,
              this.fc = n,
              this.m = r,
              this.p = s,
              this._mdf = {
                o: !0,
                sw: !!t,
                sc: !!i,
                fc: !!n,
                m: !0,
                p: !0
              }
          }
          function TextProperty(e, t) {
            this._frameId = initialDefaultFrame,
              this.pv = "",
              this.v = "",
              this.kf = !1,
              this._isFirstFrame = !0,
              this._mdf = !1,
              this.data = t,
              this.elem = e,
              this.comp = this.elem.comp,
              this.keysIndex = 0,
              this.canResize = !1,
              this.minimumFontSize = 1,
              this.effectsSequence = [],
              this.currentData = {
                ascent: 0,
                boxWidth: this.defaultBoxWidth,
                f: "",
                fStyle: "",
                fWeight: "",
                fc: "",
                j: "",
                justifyOffset: "",
                l: [],
                lh: 0,
                lineWidths: [],
                ls: "",
                of: "",
                s: "",
                sc: "",
                sw: 0,
                t: 0,
                tr: 0,
                sz: 0,
                ps: null,
                fillColorAnim: !1,
                strokeColorAnim: !1,
                strokeWidthAnim: !1,
                yOffset: 0,
                finalSize: 0,
                finalText: [],
                finalLineHeight: 0,
                __complete: !1
              },
              this.copyData(this.currentData, this.data.d.k[0].s),
            this.searchProperty() || this.completeTextData(this.currentData)
          }
          extendPrototype([BaseElement, TransformElement, SVGBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableDOMElement], SVGShapeElement),
            SVGShapeElement.prototype.initSecondaryElement = function() {}
            ,
            SVGShapeElement.prototype.identityMatrix = new Matrix,
            SVGShapeElement.prototype.buildExpressionInterface = function() {}
            ,
            SVGShapeElement.prototype.createContent = function() {
              this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], !0),
                this.filterUniqueShapes()
            }
            ,
            SVGShapeElement.prototype.filterUniqueShapes = function() {
              var e, t, i, n, r = this.shapes.length, s = this.stylesList.length, a = [], o = !1;
              for (i = 0; i < s; i += 1) {
                for (n = this.stylesList[i],
                       o = !1,
                       a.length = 0,
                       e = 0; e < r; e += 1)
                  -1 !== (t = this.shapes[e]).styles.indexOf(n) && (a.push(t),
                    o = t._isAnimated || o);
                a.length > 1 && o && this.setShapesAsAnimated(a)
              }
            }
            ,
            SVGShapeElement.prototype.setShapesAsAnimated = function(e) {
              var t, i = e.length;
              for (t = 0; t < i; t += 1)
                e[t].setAsAnimated()
            }
            ,
            SVGShapeElement.prototype.createStyleElement = function(e, t) {
              var i, n = new SVGStyleData(e,t), r = n.pElem;
              return "st" === e.ty ? i = new SVGStrokeStyleData(this,e,n) : "fl" === e.ty ? i = new SVGFillStyleData(this,e,n) : "gf" === e.ty || "gs" === e.ty ? (i = new ("gf" === e.ty ? SVGGradientFillStyleData : SVGGradientStrokeStyleData)(this,e,n),
                this.globalData.defs.appendChild(i.gf),
              i.maskId && (this.globalData.defs.appendChild(i.ms),
                this.globalData.defs.appendChild(i.of),
                r.setAttribute("mask", "url(" + getLocationHref() + "#" + i.maskId + ")"))) : "no" === e.ty && (i = new SVGNoStyleData(this,e,n)),
              "st" !== e.ty && "gs" !== e.ty || (r.setAttribute("stroke-linecap", lineCapEnum[e.lc || 2]),
                r.setAttribute("stroke-linejoin", lineJoinEnum[e.lj || 2]),
                r.setAttribute("fill-opacity", "0"),
              1 === e.lj && r.setAttribute("stroke-miterlimit", e.ml)),
              2 === e.r && r.setAttribute("fill-rule", "evenodd"),
              e.ln && r.setAttribute("id", e.ln),
              e.cl && r.setAttribute("class", e.cl),
              e.bm && (r.style["mix-blend-mode"] = getBlendMode(e.bm)),
                this.stylesList.push(n),
                this.addToAnimatedContents(e, i),
                i
            }
            ,
            SVGShapeElement.prototype.createGroupElement = function(e) {
              var t = new ShapeGroupData;
              return e.ln && t.gr.setAttribute("id", e.ln),
              e.cl && t.gr.setAttribute("class", e.cl),
              e.bm && (t.gr.style["mix-blend-mode"] = getBlendMode(e.bm)),
                t
            }
            ,
            SVGShapeElement.prototype.createTransformElement = function(e, t) {
              var i = TransformPropertyFactory.getTransformProperty(this, e, this)
                , n = new SVGTransformData(i,i.o,t);
              return this.addToAnimatedContents(e, n),
                n
            }
            ,
            SVGShapeElement.prototype.createShapeElement = function(e, t, i) {
              var n = 4;
              "rc" === e.ty ? n = 5 : "el" === e.ty ? n = 6 : "sr" === e.ty && (n = 7);
              var r = new SVGShapeData(t,i,ShapePropertyFactory.getShapeProp(this, e, n, this));
              return this.shapes.push(r),
                this.addShapeToModifiers(r),
                this.addToAnimatedContents(e, r),
                r
            }
            ,
            SVGShapeElement.prototype.addToAnimatedContents = function(e, t) {
              for (var i = 0, n = this.animatedContents.length; i < n; ) {
                if (this.animatedContents[i].element === t)
                  return;
                i += 1
              }
              this.animatedContents.push({
                fn: SVGElementsRenderer.createRenderFunction(e),
                element: t,
                data: e
              })
            }
            ,
            SVGShapeElement.prototype.setElementStyles = function(e) {
              var t, i = e.styles, n = this.stylesList.length;
              for (t = 0; t < n; t += 1)
                this.stylesList[t].closed || i.push(this.stylesList[t])
            }
            ,
            SVGShapeElement.prototype.reloadShapes = function() {
              var e;
              this._isFirstFrame = !0;
              var t = this.itemsData.length;
              for (e = 0; e < t; e += 1)
                this.prevViewData[e] = this.itemsData[e];
              for (this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], !0),
                     this.filterUniqueShapes(),
                     t = this.dynamicProperties.length,
                     e = 0; e < t; e += 1)
                this.dynamicProperties[e].getValue();
              this.renderModifiers()
            }
            ,
            SVGShapeElement.prototype.searchShapes = function(e, t, i, n, r, s, a) {
              var o, l, h, c, u, d, p = [].concat(s), f = e.length - 1, m = [], g = [];
              for (o = f; o >= 0; o -= 1) {
                if ((d = this.searchProcessedElement(e[o])) ? t[o] = i[d - 1] : e[o]._render = a,
                "fl" === e[o].ty || "st" === e[o].ty || "gf" === e[o].ty || "gs" === e[o].ty || "no" === e[o].ty)
                  d ? t[o].style.closed = !1 : t[o] = this.createStyleElement(e[o], r),
                  e[o]._render && t[o].style.pElem.parentNode !== n && n.appendChild(t[o].style.pElem),
                    m.push(t[o].style);
                else if ("gr" === e[o].ty) {
                  if (d)
                    for (h = t[o].it.length,
                           l = 0; l < h; l += 1)
                      t[o].prevViewData[l] = t[o].it[l];
                  else
                    t[o] = this.createGroupElement(e[o]);
                  this.searchShapes(e[o].it, t[o].it, t[o].prevViewData, t[o].gr, r + 1, p, a),
                  e[o]._render && t[o].gr.parentNode !== n && n.appendChild(t[o].gr)
                } else
                  "tr" === e[o].ty ? (d || (t[o] = this.createTransformElement(e[o], n)),
                    c = t[o].transform,
                    p.push(c)) : "sh" === e[o].ty || "rc" === e[o].ty || "el" === e[o].ty || "sr" === e[o].ty ? (d || (t[o] = this.createShapeElement(e[o], p, r)),
                    this.setElementStyles(t[o])) : "tm" === e[o].ty || "rd" === e[o].ty || "ms" === e[o].ty || "pb" === e[o].ty ? (d ? (u = t[o]).closed = !1 : ((u = ShapeModifiers.getModifier(e[o].ty)).init(this, e[o]),
                    t[o] = u,
                    this.shapeModifiers.push(u)),
                    g.push(u)) : "rp" === e[o].ty && (d ? (u = t[o]).closed = !0 : (u = ShapeModifiers.getModifier(e[o].ty),
                    t[o] = u,
                    u.init(this, e, o, t),
                    this.shapeModifiers.push(u),
                    a = !1),
                    g.push(u));
                this.addProcessedElement(e[o], o + 1)
              }
              for (f = m.length,
                     o = 0; o < f; o += 1)
                m[o].closed = !0;
              for (f = g.length,
                     o = 0; o < f; o += 1)
                g[o].closed = !0
            }
            ,
            SVGShapeElement.prototype.renderInnerContent = function() {
              var e;
              this.renderModifiers();
              var t = this.stylesList.length;
              for (e = 0; e < t; e += 1)
                this.stylesList[e].reset();
              for (this.renderShape(),
                     e = 0; e < t; e += 1)
                (this.stylesList[e]._mdf || this._isFirstFrame) && (this.stylesList[e].msElem && (this.stylesList[e].msElem.setAttribute("d", this.stylesList[e].d),
                  this.stylesList[e].d = "M0 0" + this.stylesList[e].d),
                  this.stylesList[e].pElem.setAttribute("d", this.stylesList[e].d || "M0 0"))
            }
            ,
            SVGShapeElement.prototype.renderShape = function() {
              var e, t, i = this.animatedContents.length;
              for (e = 0; e < i; e += 1)
                t = this.animatedContents[e],
                (this._isFirstFrame || t.element._isAnimated) && !0 !== t.data && t.fn(t.data, t.element, this._isFirstFrame)
            }
            ,
            SVGShapeElement.prototype.destroy = function() {
              this.destroyBaseElement(),
                this.shapesData = null,
                this.itemsData = null
            }
            ,
            LetterProps.prototype.update = function(e, t, i, n, r, s) {
              this._mdf.o = !1,
                this._mdf.sw = !1,
                this._mdf.sc = !1,
                this._mdf.fc = !1,
                this._mdf.m = !1,
                this._mdf.p = !1;
              var a = !1;
              return this.o !== e && (this.o = e,
                this._mdf.o = !0,
                a = !0),
              this.sw !== t && (this.sw = t,
                this._mdf.sw = !0,
                a = !0),
              this.sc !== i && (this.sc = i,
                this._mdf.sc = !0,
                a = !0),
              this.fc !== n && (this.fc = n,
                this._mdf.fc = !0,
                a = !0),
              this.m !== r && (this.m = r,
                this._mdf.m = !0,
                a = !0),
              !s.length || this.p[0] === s[0] && this.p[1] === s[1] && this.p[4] === s[4] && this.p[5] === s[5] && this.p[12] === s[12] && this.p[13] === s[13] || (this.p = s,
                this._mdf.p = !0,
                a = !0),
                a
            }
            ,
            TextProperty.prototype.defaultBoxWidth = [0, 0],
            TextProperty.prototype.copyData = function(e, t) {
              for (var i in t)
                Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
              return e
            }
            ,
            TextProperty.prototype.setCurrentData = function(e) {
              e.__complete || this.completeTextData(e),
                this.currentData = e,
                this.currentData.boxWidth = this.currentData.boxWidth || this.defaultBoxWidth,
                this._mdf = !0
            }
            ,
            TextProperty.prototype.searchProperty = function() {
              return this.searchKeyframes()
            }
            ,
            TextProperty.prototype.searchKeyframes = function() {
              return this.kf = this.data.d.k.length > 1,
              this.kf && this.addEffect(this.getKeyframeValue.bind(this)),
                this.kf
            }
            ,
            TextProperty.prototype.addEffect = function(e) {
              this.effectsSequence.push(e),
                this.elem.addDynamicProperty(this)
            }
            ,
            TextProperty.prototype.getValue = function(e) {
              if (this.elem.globalData.frameId !== this.frameId && this.effectsSequence.length || e) {
                this.currentData.t = this.data.d.k[this.keysIndex].s.t;
                var t = this.currentData
                  , i = this.keysIndex;
                if (this.lock)
                  this.setCurrentData(this.currentData);
                else {
                  var n;
                  this.lock = !0,
                    this._mdf = !1;
                  var r = this.effectsSequence.length
                    , s = e || this.data.d.k[this.keysIndex].s;
                  for (n = 0; n < r; n += 1)
                    s = i !== this.keysIndex ? this.effectsSequence[n](s, s.t) : this.effectsSequence[n](this.currentData, s.t);
                  t !== s && this.setCurrentData(s),
                    this.v = this.currentData,
                    this.pv = this.v,
                    this.lock = !1,
                    this.frameId = this.elem.globalData.frameId
                }
              }
            }
            ,
            TextProperty.prototype.getKeyframeValue = function() {
              for (var e = this.data.d.k, t = this.elem.comp.renderedFrame, i = 0, n = e.length; i <= n - 1 && !(i === n - 1 || e[i + 1].t > t); )
                i += 1;
              return this.keysIndex !== i && (this.keysIndex = i),
                this.data.d.k[this.keysIndex].s
            }
            ,
            TextProperty.prototype.buildFinalText = function(e) {
              for (var t, i, n = [], r = 0, s = e.length, a = !1; r < s; )
                t = e.charCodeAt(r),
                  FontManager.isCombinedCharacter(t) ? n[n.length - 1] += e.charAt(r) : t >= 55296 && t <= 56319 ? (i = e.charCodeAt(r + 1)) >= 56320 && i <= 57343 ? (a || FontManager.isModifier(t, i) ? (n[n.length - 1] += e.substr(r, 2),
                    a = !1) : n.push(e.substr(r, 2)),
                    r += 1) : n.push(e.charAt(r)) : t > 56319 ? (i = e.charCodeAt(r + 1),
                    FontManager.isZeroWidthJoiner(t, i) ? (a = !0,
                      n[n.length - 1] += e.substr(r, 2),
                      r += 1) : n.push(e.charAt(r))) : FontManager.isZeroWidthJoiner(t) ? (n[n.length - 1] += e.charAt(r),
                    a = !0) : n.push(e.charAt(r)),
                  r += 1;
              return n
            }
            ,
            TextProperty.prototype.completeTextData = function(e) {
              e.__complete = !0;
              var t, i, n, r, s, a, o, l = this.elem.globalData.fontManager, h = this.data, c = [], u = 0, d = h.m.g, p = 0, f = 0, m = 0, g = [], v = 0, y = 0, x = l.getFontByName(e.f), _ = 0, b = getFontProperties(x);
              e.fWeight = b.weight,
                e.fStyle = b.style,
                e.finalSize = e.s,
                e.finalText = this.buildFinalText(e.t),
                i = e.finalText.length,
                e.finalLineHeight = e.lh;
              var w, A = e.tr / 1e3 * e.finalSize;
              if (e.sz)
                for (var S, M, T = !0, E = e.sz[0], C = e.sz[1]; T; ) {
                  S = 0,
                    v = 0,
                    i = (M = this.buildFinalText(e.t)).length,
                    A = e.tr / 1e3 * e.finalSize;
                  var P = -1;
                  for (t = 0; t < i; t += 1)
                    w = M[t].charCodeAt(0),
                      n = !1,
                      " " === M[t] ? P = t : 13 !== w && 3 !== w || (v = 0,
                        n = !0,
                        S += e.finalLineHeight || 1.2 * e.finalSize),
                      l.chars ? (o = l.getCharData(M[t], x.fStyle, x.fFamily),
                        _ = n ? 0 : o.w * e.finalSize / 100) : _ = l.measureText(M[t], e.f, e.finalSize),
                      v + _ > E && " " !== M[t] ? (-1 === P ? i += 1 : t = P,
                        S += e.finalLineHeight || 1.2 * e.finalSize,
                        M.splice(t, P === t ? 1 : 0, "\r"),
                        P = -1,
                        v = 0) : (v += _,
                        v += A);
                  S += x.ascent * e.finalSize / 100,
                    this.canResize && e.finalSize > this.minimumFontSize && C < S ? (e.finalSize -= 1,
                      e.finalLineHeight = e.finalSize * e.lh / e.s) : (e.finalText = M,
                      i = e.finalText.length,
                      T = !1)
                }
              v = -A,
                _ = 0;
              var D, I = 0;
              for (t = 0; t < i; t += 1)
                if (n = !1,
                  13 === (w = (D = e.finalText[t]).charCodeAt(0)) || 3 === w ? (I = 0,
                    g.push(v),
                    y = v > y ? v : y,
                    v = -2 * A,
                    r = "",
                    n = !0,
                    m += 1) : r = D,
                  l.chars ? (o = l.getCharData(D, x.fStyle, l.getFontByName(e.f).fFamily),
                    _ = n ? 0 : o.w * e.finalSize / 100) : _ = l.measureText(r, e.f, e.finalSize),
                  " " === D ? I += _ + A : (v += _ + A + I,
                    I = 0),
                  c.push({
                    l: _,
                    an: _,
                    add: p,
                    n,
                    anIndexes: [],
                    val: r,
                    line: m,
                    animatorJustifyOffset: 0
                  }),
                2 == d) {
                  if (p += _,
                  "" === r || " " === r || t === i - 1) {
                    for ("" !== r && " " !== r || (p -= _); f <= t; )
                      c[f].an = p,
                        c[f].ind = u,
                        c[f].extra = _,
                        f += 1;
                    u += 1,
                      p = 0
                  }
                } else if (3 == d) {
                  if (p += _,
                  "" === r || t === i - 1) {
                    for ("" === r && (p -= _); f <= t; )
                      c[f].an = p,
                        c[f].ind = u,
                        c[f].extra = _,
                        f += 1;
                    p = 0,
                      u += 1
                  }
                } else
                  c[u].ind = u,
                    c[u].extra = 0,
                    u += 1;
              if (e.l = c,
                y = v > y ? v : y,
                g.push(v),
                e.sz)
                e.boxWidth = e.sz[0],
                  e.justifyOffset = 0;
              else
                switch (e.boxWidth = y,
                  e.j) {
                  case 1:
                    e.justifyOffset = -e.boxWidth;
                    break;
                  case 2:
                    e.justifyOffset = -e.boxWidth / 2;
                    break;
                  default:
                    e.justifyOffset = 0
                }
              e.lineWidths = g;
              var R, L, k, F, B = h.a;
              a = B.length;
              var O = [];
              for (s = 0; s < a; s += 1) {
                for ((R = B[s]).a.sc && (e.strokeColorAnim = !0),
                     R.a.sw && (e.strokeWidthAnim = !0),
                     (R.a.fc || R.a.fh || R.a.fs || R.a.fb) && (e.fillColorAnim = !0),
                       F = 0,
                       k = R.s.b,
                       t = 0; t < i; t += 1)
                  (L = c[t]).anIndexes[s] = F,
                  (1 == k && "" !== L.val || 2 == k && "" !== L.val && " " !== L.val || 3 == k && (L.n || " " == L.val || t == i - 1) || 4 == k && (L.n || t == i - 1)) && (1 === R.s.rn && O.push(F),
                    F += 1);
                h.a[s].s.totalChars = F;
                var N, z = -1;
                if (1 === R.s.rn)
                  for (t = 0; t < i; t += 1)
                    z != (L = c[t]).anIndexes[s] && (z = L.anIndexes[s],
                      N = O.splice(Math.floor(Math.random() * O.length), 1)[0]),
                      L.anIndexes[s] = N
              }
              e.yOffset = e.finalLineHeight || 1.2 * e.finalSize,
                e.ls = e.ls || 0,
                e.ascent = x.ascent * e.finalSize / 100
            }
            ,
            TextProperty.prototype.updateDocumentData = function(e, t) {
              t = void 0 === t ? this.keysIndex : t;
              var i = this.copyData({}, this.data.d.k[t].s);
              i = this.copyData(i, e),
                this.data.d.k[t].s = i,
                this.recalculate(t),
                this.elem.addDynamicProperty(this)
            }
            ,
            TextProperty.prototype.recalculate = function(e) {
              var t = this.data.d.k[e].s;
              t.__complete = !1,
                this.keysIndex = 0,
                this._isFirstFrame = !0,
                this.getValue(t)
            }
            ,
            TextProperty.prototype.canResizeFont = function(e) {
              this.canResize = e,
                this.recalculate(this.keysIndex),
                this.elem.addDynamicProperty(this)
            }
            ,
            TextProperty.prototype.setMinimumFontSize = function(e) {
              this.minimumFontSize = Math.floor(e) || 1,
                this.recalculate(this.keysIndex),
                this.elem.addDynamicProperty(this)
            }
          ;
          var TextSelectorProp = function() {
            var e = Math.max
              , t = Math.min
              , i = Math.floor;
            function n(e, t) {
              this._currentTextLength = -1,
                this.k = !1,
                this.data = t,
                this.elem = e,
                this.comp = e.comp,
                this.finalS = 0,
                this.finalE = 0,
                this.initDynamicPropertyContainer(e),
                this.s = PropertyFactory.getProp(e, t.s || {
                  k: 0
                }, 0, 0, this),
                this.e = "e"in t ? PropertyFactory.getProp(e, t.e, 0, 0, this) : {
                  v: 100
                },
                this.o = PropertyFactory.getProp(e, t.o || {
                  k: 0
                }, 0, 0, this),
                this.xe = PropertyFactory.getProp(e, t.xe || {
                  k: 0
                }, 0, 0, this),
                this.ne = PropertyFactory.getProp(e, t.ne || {
                  k: 0
                }, 0, 0, this),
                this.sm = PropertyFactory.getProp(e, t.sm || {
                  k: 100
                }, 0, 0, this),
                this.a = PropertyFactory.getProp(e, t.a, 0, .01, this),
              this.dynamicProperties.length || this.getValue()
            }
            return n.prototype = {
              getMult: function(n) {
                this._currentTextLength !== this.elem.textProperty.currentData.l.length && this.getValue();
                var r = 0
                  , s = 0
                  , a = 1
                  , o = 1;
                this.ne.v > 0 ? r = this.ne.v / 100 : s = -this.ne.v / 100,
                  this.xe.v > 0 ? a = 1 - this.xe.v / 100 : o = 1 + this.xe.v / 100;
                var l = BezierFactory.getBezierEasing(r, s, a, o).get
                  , h = 0
                  , c = this.finalS
                  , u = this.finalE
                  , d = this.data.sh;
                if (2 === d)
                  h = l(h = u === c ? n >= u ? 1 : 0 : e(0, t(.5 / (u - c) + (n - c) / (u - c), 1)));
                else if (3 === d)
                  h = l(h = u === c ? n >= u ? 0 : 1 : 1 - e(0, t(.5 / (u - c) + (n - c) / (u - c), 1)));
                else if (4 === d)
                  u === c ? h = 0 : (h = e(0, t(.5 / (u - c) + (n - c) / (u - c), 1))) < .5 ? h *= 2 : h = 1 - 2 * (h - .5),
                    h = l(h);
                else if (5 === d) {
                  if (u === c)
                    h = 0;
                  else {
                    var p = u - c
                      , f = -p / 2 + (n = t(e(0, n + .5 - c), u - c))
                      , m = p / 2;
                    h = Math.sqrt(1 - f * f / (m * m))
                  }
                  h = l(h)
                } else
                  6 === d ? (u === c ? h = 0 : (n = t(e(0, n + .5 - c), u - c),
                    h = (1 + Math.cos(Math.PI + 2 * Math.PI * n / (u - c))) / 2),
                    h = l(h)) : (n >= i(c) && (h = e(0, t(n - c < 0 ? t(u, 1) - (c - n) : u - n, 1))),
                    h = l(h));
                if (100 !== this.sm.v) {
                  var g = .01 * this.sm.v;
                  0 === g && (g = 1e-8);
                  var v = .5 - .5 * g;
                  h < v ? h = 0 : (h = (h - v) / g) > 1 && (h = 1)
                }
                return h * this.a.v
              },
              getValue: function(e) {
                this.iterateDynamicProperties(),
                  this._mdf = e || this._mdf,
                  this._currentTextLength = this.elem.textProperty.currentData.l.length || 0,
                e && 2 === this.data.r && (this.e.v = this._currentTextLength);
                var t = 2 === this.data.r ? 1 : 100 / this.data.totalChars
                  , i = this.o.v / t
                  , n = this.s.v / t + i
                  , r = this.e.v / t + i;
                if (n > r) {
                  var s = n;
                  n = r,
                    r = s
                }
                this.finalS = n,
                  this.finalE = r
              }
            },
              extendPrototype([DynamicPropertyContainer], n),
              {
                getTextSelectorProp: function(e, t, i) {
                  return new n(e,t,i)
                }
              }
          }();
          function TextAnimatorDataProperty(e, t, i) {
            var n = {
              propType: !1
            }
              , r = PropertyFactory.getProp
              , s = t.a;
            this.a = {
              r: s.r ? r(e, s.r, 0, degToRads, i) : n,
              rx: s.rx ? r(e, s.rx, 0, degToRads, i) : n,
              ry: s.ry ? r(e, s.ry, 0, degToRads, i) : n,
              sk: s.sk ? r(e, s.sk, 0, degToRads, i) : n,
              sa: s.sa ? r(e, s.sa, 0, degToRads, i) : n,
              s: s.s ? r(e, s.s, 1, .01, i) : n,
              a: s.a ? r(e, s.a, 1, 0, i) : n,
              o: s.o ? r(e, s.o, 0, .01, i) : n,
              p: s.p ? r(e, s.p, 1, 0, i) : n,
              sw: s.sw ? r(e, s.sw, 0, 0, i) : n,
              sc: s.sc ? r(e, s.sc, 1, 0, i) : n,
              fc: s.fc ? r(e, s.fc, 1, 0, i) : n,
              fh: s.fh ? r(e, s.fh, 0, 0, i) : n,
              fs: s.fs ? r(e, s.fs, 0, .01, i) : n,
              fb: s.fb ? r(e, s.fb, 0, .01, i) : n,
              t: s.t ? r(e, s.t, 0, 0, i) : n
            },
              this.s = TextSelectorProp.getTextSelectorProp(e, t.s, i),
              this.s.t = t.s.t
          }
          function TextAnimatorProperty(e, t, i) {
            this._isFirstFrame = !0,
              this._hasMaskedPath = !1,
              this._frameId = -1,
              this._textData = e,
              this._renderType = t,
              this._elem = i,
              this._animatorsData = createSizedArray(this._textData.a.length),
              this._pathData = {},
              this._moreOptions = {
                alignment: {}
              },
              this.renderedLetters = [],
              this.lettersChangedFlag = !1,
              this.initDynamicPropertyContainer(i)
          }
          function ITextElement() {}
          TextAnimatorProperty.prototype.searchProperties = function() {
            var e, t, i = this._textData.a.length, n = PropertyFactory.getProp;
            for (e = 0; e < i; e += 1)
              t = this._textData.a[e],
                this._animatorsData[e] = new TextAnimatorDataProperty(this._elem,t,this);
            this._textData.p && "m"in this._textData.p ? (this._pathData = {
              a: n(this._elem, this._textData.p.a, 0, 0, this),
              f: n(this._elem, this._textData.p.f, 0, 0, this),
              l: n(this._elem, this._textData.p.l, 0, 0, this),
              r: n(this._elem, this._textData.p.r, 0, 0, this),
              p: n(this._elem, this._textData.p.p, 0, 0, this),
              m: this._elem.maskManager.getMaskProperty(this._textData.p.m)
            },
              this._hasMaskedPath = !0) : this._hasMaskedPath = !1,
              this._moreOptions.alignment = n(this._elem, this._textData.m.a, 1, 0, this)
          }
            ,
            TextAnimatorProperty.prototype.getMeasures = function(e, t) {
              if (this.lettersChangedFlag = t,
              this._mdf || this._isFirstFrame || t || this._hasMaskedPath && this._pathData.m._mdf) {
                this._isFirstFrame = !1;
                var i, n, r, s, a, o, l, h, c, u, d, p, f, m, g, v, y, x, _, b = this._moreOptions.alignment.v, w = this._animatorsData, A = this._textData, S = this.mHelper, M = this._renderType, T = this.renderedLetters.length, E = e.l;
                if (this._hasMaskedPath) {
                  if (_ = this._pathData.m,
                  !this._pathData.n || this._pathData._mdf) {
                    var C, P = _.v;
                    for (this._pathData.r.v && (P = P.reverse()),
                           a = {
                             tLength: 0,
                             segments: []
                           },
                           s = P._length - 1,
                           v = 0,
                           r = 0; r < s; r += 1)
                      C = bez.buildBezierData(P.v[r], P.v[r + 1], [P.o[r][0] - P.v[r][0], P.o[r][1] - P.v[r][1]], [P.i[r + 1][0] - P.v[r + 1][0], P.i[r + 1][1] - P.v[r + 1][1]]),
                        a.tLength += C.segmentLength,
                        a.segments.push(C),
                        v += C.segmentLength;
                    r = s,
                    _.v.c && (C = bez.buildBezierData(P.v[r], P.v[0], [P.o[r][0] - P.v[r][0], P.o[r][1] - P.v[r][1]], [P.i[0][0] - P.v[0][0], P.i[0][1] - P.v[0][1]]),
                      a.tLength += C.segmentLength,
                      a.segments.push(C),
                      v += C.segmentLength),
                      this._pathData.pi = a
                  }
                  if (a = this._pathData.pi,
                    o = this._pathData.f.v,
                    d = 0,
                    u = 1,
                    h = 0,
                    c = !0,
                    m = a.segments,
                  o < 0 && _.v.c)
                    for (a.tLength < Math.abs(o) && (o = -Math.abs(o) % a.tLength),
                           u = (f = m[d = m.length - 1].points).length - 1; o < 0; )
                      o += f[u].partialLength,
                      (u -= 1) < 0 && (u = (f = m[d -= 1].points).length - 1);
                  p = (f = m[d].points)[u - 1],
                    g = (l = f[u]).partialLength
                }
                s = E.length,
                  i = 0,
                  n = 0;
                var D, I, R, L, k, F = 1.2 * e.finalSize * .714, B = !0;
                R = w.length;
                var O, N, z, U, G, V, H, W, j, X, Y, q, Q = -1, K = o, J = d, Z = u, $ = -1, ee = "", te = this.defaultPropsArray;
                if (2 === e.j || 1 === e.j) {
                  var ie = 0
                    , ne = 0
                    , re = 2 === e.j ? -.5 : -1
                    , se = 0
                    , ae = !0;
                  for (r = 0; r < s; r += 1)
                    if (E[r].n) {
                      for (ie && (ie += ne); se < r; )
                        E[se].animatorJustifyOffset = ie,
                          se += 1;
                      ie = 0,
                        ae = !0
                    } else {
                      for (I = 0; I < R; I += 1)
                        (D = w[I].a).t.propType && (ae && 2 === e.j && (ne += D.t.v * re),
                          (k = w[I].s.getMult(E[r].anIndexes[I], A.a[I].s.totalChars)).length ? ie += D.t.v * k[0] * re : ie += D.t.v * k * re);
                      ae = !1
                    }
                  for (ie && (ie += ne); se < r; )
                    E[se].animatorJustifyOffset = ie,
                      se += 1
                }
                for (r = 0; r < s; r += 1) {
                  if (S.reset(),
                    U = 1,
                    E[r].n)
                    i = 0,
                      n += e.yOffset,
                      n += B ? 1 : 0,
                      o = K,
                      B = !1,
                    this._hasMaskedPath && (u = Z,
                      p = (f = m[d = J].points)[u - 1],
                      g = (l = f[u]).partialLength,
                      h = 0),
                      ee = "",
                      Y = "",
                      j = "",
                      q = "",
                      te = this.defaultPropsArray;
                  else {
                    if (this._hasMaskedPath) {
                      if ($ !== E[r].line) {
                        switch (e.j) {
                          case 1:
                            o += v - e.lineWidths[E[r].line];
                            break;
                          case 2:
                            o += (v - e.lineWidths[E[r].line]) / 2
                        }
                        $ = E[r].line
                      }
                      Q !== E[r].ind && (E[Q] && (o += E[Q].extra),
                        o += E[r].an / 2,
                        Q = E[r].ind),
                        o += b[0] * E[r].an * .005;
                      var oe = 0;
                      for (I = 0; I < R; I += 1)
                        (D = w[I].a).p.propType && ((k = w[I].s.getMult(E[r].anIndexes[I], A.a[I].s.totalChars)).length ? oe += D.p.v[0] * k[0] : oe += D.p.v[0] * k),
                        D.a.propType && ((k = w[I].s.getMult(E[r].anIndexes[I], A.a[I].s.totalChars)).length ? oe += D.a.v[0] * k[0] : oe += D.a.v[0] * k);
                      for (c = !0,
                           this._pathData.a.v && (o = .5 * E[0].an + (v - this._pathData.f.v - .5 * E[0].an - .5 * E[E.length - 1].an) * Q / (s - 1),
                             o += this._pathData.f.v); c; )
                        h + g >= o + oe || !f ? (y = (o + oe - h) / l.partialLength,
                          N = p.point[0] + (l.point[0] - p.point[0]) * y,
                          z = p.point[1] + (l.point[1] - p.point[1]) * y,
                          S.translate(-b[0] * E[r].an * .005, -b[1] * F * .01),
                          c = !1) : f && (h += l.partialLength,
                        (u += 1) >= f.length && (u = 0,
                          m[d += 1] ? f = m[d].points : _.v.c ? (u = 0,
                            f = m[d = 0].points) : (h -= l.partialLength,
                            f = null)),
                        f && (p = l,
                          g = (l = f[u]).partialLength));
                      O = E[r].an / 2 - E[r].add,
                        S.translate(-O, 0, 0)
                    } else
                      O = E[r].an / 2 - E[r].add,
                        S.translate(-O, 0, 0),
                        S.translate(-b[0] * E[r].an * .005, -b[1] * F * .01, 0);
                    for (I = 0; I < R; I += 1)
                      (D = w[I].a).t.propType && (k = w[I].s.getMult(E[r].anIndexes[I], A.a[I].s.totalChars),
                      0 === i && 0 === e.j || (this._hasMaskedPath ? k.length ? o += D.t.v * k[0] : o += D.t.v * k : k.length ? i += D.t.v * k[0] : i += D.t.v * k));
                    for (e.strokeWidthAnim && (V = e.sw || 0),
                         e.strokeColorAnim && (G = e.sc ? [e.sc[0], e.sc[1], e.sc[2]] : [0, 0, 0]),
                         e.fillColorAnim && e.fc && (H = [e.fc[0], e.fc[1], e.fc[2]]),
                           I = 0; I < R; I += 1)
                      (D = w[I].a).a.propType && ((k = w[I].s.getMult(E[r].anIndexes[I], A.a[I].s.totalChars)).length ? S.translate(-D.a.v[0] * k[0], -D.a.v[1] * k[1], D.a.v[2] * k[2]) : S.translate(-D.a.v[0] * k, -D.a.v[1] * k, D.a.v[2] * k));
                    for (I = 0; I < R; I += 1)
                      (D = w[I].a).s.propType && ((k = w[I].s.getMult(E[r].anIndexes[I], A.a[I].s.totalChars)).length ? S.scale(1 + (D.s.v[0] - 1) * k[0], 1 + (D.s.v[1] - 1) * k[1], 1) : S.scale(1 + (D.s.v[0] - 1) * k, 1 + (D.s.v[1] - 1) * k, 1));
                    for (I = 0; I < R; I += 1) {
                      if (D = w[I].a,
                        k = w[I].s.getMult(E[r].anIndexes[I], A.a[I].s.totalChars),
                      D.sk.propType && (k.length ? S.skewFromAxis(-D.sk.v * k[0], D.sa.v * k[1]) : S.skewFromAxis(-D.sk.v * k, D.sa.v * k)),
                      D.r.propType && (k.length ? S.rotateZ(-D.r.v * k[2]) : S.rotateZ(-D.r.v * k)),
                      D.ry.propType && (k.length ? S.rotateY(D.ry.v * k[1]) : S.rotateY(D.ry.v * k)),
                      D.rx.propType && (k.length ? S.rotateX(D.rx.v * k[0]) : S.rotateX(D.rx.v * k)),
                      D.o.propType && (k.length ? U += (D.o.v * k[0] - U) * k[0] : U += (D.o.v * k - U) * k),
                      e.strokeWidthAnim && D.sw.propType && (k.length ? V += D.sw.v * k[0] : V += D.sw.v * k),
                      e.strokeColorAnim && D.sc.propType)
                        for (W = 0; W < 3; W += 1)
                          k.length ? G[W] += (D.sc.v[W] - G[W]) * k[0] : G[W] += (D.sc.v[W] - G[W]) * k;
                      if (e.fillColorAnim && e.fc) {
                        if (D.fc.propType)
                          for (W = 0; W < 3; W += 1)
                            k.length ? H[W] += (D.fc.v[W] - H[W]) * k[0] : H[W] += (D.fc.v[W] - H[W]) * k;
                        D.fh.propType && (H = k.length ? addHueToRGB(H, D.fh.v * k[0]) : addHueToRGB(H, D.fh.v * k)),
                        D.fs.propType && (H = k.length ? addSaturationToRGB(H, D.fs.v * k[0]) : addSaturationToRGB(H, D.fs.v * k)),
                        D.fb.propType && (H = k.length ? addBrightnessToRGB(H, D.fb.v * k[0]) : addBrightnessToRGB(H, D.fb.v * k))
                      }
                    }
                    for (I = 0; I < R; I += 1)
                      (D = w[I].a).p.propType && (k = w[I].s.getMult(E[r].anIndexes[I], A.a[I].s.totalChars),
                        this._hasMaskedPath ? k.length ? S.translate(0, D.p.v[1] * k[0], -D.p.v[2] * k[1]) : S.translate(0, D.p.v[1] * k, -D.p.v[2] * k) : k.length ? S.translate(D.p.v[0] * k[0], D.p.v[1] * k[1], -D.p.v[2] * k[2]) : S.translate(D.p.v[0] * k, D.p.v[1] * k, -D.p.v[2] * k));
                    if (e.strokeWidthAnim && (j = V < 0 ? 0 : V),
                    e.strokeColorAnim && (X = "rgb(" + Math.round(255 * G[0]) + "," + Math.round(255 * G[1]) + "," + Math.round(255 * G[2]) + ")"),
                    e.fillColorAnim && e.fc && (Y = "rgb(" + Math.round(255 * H[0]) + "," + Math.round(255 * H[1]) + "," + Math.round(255 * H[2]) + ")"),
                      this._hasMaskedPath) {
                      if (S.translate(0, -e.ls),
                        S.translate(0, b[1] * F * .01 + n, 0),
                        this._pathData.p.v) {
                        x = (l.point[1] - p.point[1]) / (l.point[0] - p.point[0]);
                        var le = 180 * Math.atan(x) / Math.PI;
                        l.point[0] < p.point[0] && (le += 180),
                          S.rotate(-le * Math.PI / 180)
                      }
                      S.translate(N, z, 0),
                        o -= b[0] * E[r].an * .005,
                      E[r + 1] && Q !== E[r + 1].ind && (o += E[r].an / 2,
                        o += .001 * e.tr * e.finalSize)
                    } else {
                      switch (S.translate(i, n, 0),
                      e.ps && S.translate(e.ps[0], e.ps[1] + e.ascent, 0),
                        e.j) {
                        case 1:
                          S.translate(E[r].animatorJustifyOffset + e.justifyOffset + (e.boxWidth - e.lineWidths[E[r].line]), 0, 0);
                          break;
                        case 2:
                          S.translate(E[r].animatorJustifyOffset + e.justifyOffset + (e.boxWidth - e.lineWidths[E[r].line]) / 2, 0, 0)
                      }
                      S.translate(0, -e.ls),
                        S.translate(O, 0, 0),
                        S.translate(b[0] * E[r].an * .005, b[1] * F * .01, 0),
                        i += E[r].l + .001 * e.tr * e.finalSize
                    }
                    "html" === M ? ee = S.toCSS() : "svg" === M ? ee = S.to2dCSS() : te = [S.props[0], S.props[1], S.props[2], S.props[3], S.props[4], S.props[5], S.props[6], S.props[7], S.props[8], S.props[9], S.props[10], S.props[11], S.props[12], S.props[13], S.props[14], S.props[15]],
                      q = U
                  }
                  T <= r ? (L = new LetterProps(q,j,X,Y,ee,te),
                    this.renderedLetters.push(L),
                    T += 1,
                    this.lettersChangedFlag = !0) : (L = this.renderedLetters[r],
                    this.lettersChangedFlag = L.update(q, j, X, Y, ee, te) || this.lettersChangedFlag)
                }
              }
            }
            ,
            TextAnimatorProperty.prototype.getValue = function() {
              this._elem.globalData.frameId !== this._frameId && (this._frameId = this._elem.globalData.frameId,
                this.iterateDynamicProperties())
            }
            ,
            TextAnimatorProperty.prototype.mHelper = new Matrix,
            TextAnimatorProperty.prototype.defaultPropsArray = [],
            extendPrototype([DynamicPropertyContainer], TextAnimatorProperty),
            ITextElement.prototype.initElement = function(e, t, i) {
              this.lettersChangedFlag = !0,
                this.initFrame(),
                this.initBaseData(e, t, i),
                this.textProperty = new TextProperty(this,e.t,this.dynamicProperties),
                this.textAnimator = new TextAnimatorProperty(e.t,this.renderType,this),
                this.initTransform(e, t, i),
                this.initHierarchy(),
                this.initRenderable(),
                this.initRendererElement(),
                this.createContainerElements(),
                this.createRenderableComponents(),
                this.createContent(),
                this.hide(),
                this.textAnimator.searchProperties(this.dynamicProperties)
            }
            ,
            ITextElement.prototype.prepareFrame = function(e) {
              this._mdf = !1,
                this.prepareRenderableFrame(e),
                this.prepareProperties(e, this.isInRange),
              (this.textProperty._mdf || this.textProperty._isFirstFrame) && (this.buildNewText(),
                this.textProperty._isFirstFrame = !1,
                this.textProperty._mdf = !1)
            }
            ,
            ITextElement.prototype.createPathShape = function(e, t) {
              var i, n, r = t.length, s = "";
              for (i = 0; i < r; i += 1)
                "sh" === t[i].ty && (n = t[i].ks.k,
                  s += buildShapeString(n, n.i.length, !0, e));
              return s
            }
            ,
            ITextElement.prototype.updateDocumentData = function(e, t) {
              this.textProperty.updateDocumentData(e, t)
            }
            ,
            ITextElement.prototype.canResizeFont = function(e) {
              this.textProperty.canResizeFont(e)
            }
            ,
            ITextElement.prototype.setMinimumFontSize = function(e) {
              this.textProperty.setMinimumFontSize(e)
            }
            ,
            ITextElement.prototype.applyTextPropertiesToMatrix = function(e, t, i, n, r) {
              switch (e.ps && t.translate(e.ps[0], e.ps[1] + e.ascent, 0),
                t.translate(0, -e.ls, 0),
                e.j) {
                case 1:
                  t.translate(e.justifyOffset + (e.boxWidth - e.lineWidths[i]), 0, 0);
                  break;
                case 2:
                  t.translate(e.justifyOffset + (e.boxWidth - e.lineWidths[i]) / 2, 0, 0)
              }
              t.translate(n, r, 0)
            }
            ,
            ITextElement.prototype.buildColor = function(e) {
              return "rgb(" + Math.round(255 * e[0]) + "," + Math.round(255 * e[1]) + "," + Math.round(255 * e[2]) + ")"
            }
            ,
            ITextElement.prototype.emptyProp = new LetterProps,
            ITextElement.prototype.destroy = function() {}
          ;
          var emptyShapeData = {
            shapes: []
          };
          function SVGTextLottieElement(e, t, i) {
            this.textSpans = [],
              this.renderType = "svg",
              this.initElement(e, t, i)
          }
          function ISolidElement(e, t, i) {
            this.initElement(e, t, i)
          }
          function NullElement(e, t, i) {
            this.initFrame(),
              this.initBaseData(e, t, i),
              this.initFrame(),
              this.initTransform(e, t, i),
              this.initHierarchy()
          }
          function SVGRendererBase() {}
          function ICompElement() {}
          function SVGCompElement(e, t, i) {
            this.layers = e.layers,
              this.supports3d = !0,
              this.completeLayers = !1,
              this.pendingElements = [],
              this.elements = this.layers ? createSizedArray(this.layers.length) : [],
              this.initElement(e, t, i),
              this.tm = e.tm ? PropertyFactory.getProp(this, e.tm, 0, t.frameRate, this) : {
                _placeholder: !0
              }
          }
          function SVGRenderer(e, t) {
            this.animationItem = e,
              this.layers = null,
              this.renderedFrame = -1,
              this.svgElement = createNS("svg");
            var i = "";
            if (t && t.title) {
              var n = createNS("title")
                , r = createElementID();
              n.setAttribute("id", r),
                n.textContent = t.title,
                this.svgElement.appendChild(n),
                i += r
            }
            if (t && t.description) {
              var s = createNS("desc")
                , a = createElementID();
              s.setAttribute("id", a),
                s.textContent = t.description,
                this.svgElement.appendChild(s),
                i += " " + a
            }
            i && this.svgElement.setAttribute("aria-labelledby", i);
            var o = createNS("defs");
            this.svgElement.appendChild(o);
            var l = createNS("g");
            this.svgElement.appendChild(l),
              this.layerElement = l,
              this.renderConfig = {
                preserveAspectRatio: t && t.preserveAspectRatio || "xMidYMid meet",
                imagePreserveAspectRatio: t && t.imagePreserveAspectRatio || "xMidYMid slice",
                contentVisibility: t && t.contentVisibility || "visible",
                progressiveLoad: t && t.progressiveLoad || !1,
                hideOnTransparent: !(t && !1 === t.hideOnTransparent),
                viewBoxOnly: t && t.viewBoxOnly || !1,
                viewBoxSize: t && t.viewBoxSize || !1,
                className: t && t.className || "",
                id: t && t.id || "",
                focusable: t && t.focusable,
                filterSize: {
                  width: t && t.filterSize && t.filterSize.width || "100%",
                  height: t && t.filterSize && t.filterSize.height || "100%",
                  x: t && t.filterSize && t.filterSize.x || "0%",
                  y: t && t.filterSize && t.filterSize.y || "0%"
                },
                width: t && t.width,
                height: t && t.height
              },
              this.globalData = {
                _mdf: !1,
                frameNum: -1,
                defs: o,
                renderConfig: this.renderConfig
              },
              this.elements = [],
              this.pendingElements = [],
              this.destroyed = !1,
              this.rendererType = "svg"
          }
          function CVContextData() {
            var e;
            for (this.saved = [],
                   this.cArrPos = 0,
                   this.cTr = new Matrix,
                   this.cO = 1,
                   this.savedOp = createTypedArray("float32", 15),
                   e = 0; e < 15; e += 1)
              this.saved[e] = createTypedArray("float32", 16);
            this._length = 15
          }
          function ShapeTransformManager() {
            this.sequences = {},
              this.sequenceList = [],
              this.transform_key_count = 0
          }
          function CVEffects() {}
          function CVMaskElement(e, t) {
            var i;
            this.data = e,
              this.element = t,
              this.masksProperties = this.data.masksProperties || [],
              this.viewData = createSizedArray(this.masksProperties.length);
            var n = this.masksProperties.length
              , r = !1;
            for (i = 0; i < n; i += 1)
              "n" !== this.masksProperties[i].mode && (r = !0),
                this.viewData[i] = ShapePropertyFactory.getShapeProp(this.element, this.masksProperties[i], 3);
            this.hasMasks = r,
            r && this.element.addRenderableComponent(this)
          }
          function CVBaseElement() {}
          function CVShapeData(e, t, i, n) {
            this.styledShapes = [],
              this.tr = [0, 0, 0, 0, 0, 0];
            var r, s = 4;
            "rc" === t.ty ? s = 5 : "el" === t.ty ? s = 6 : "sr" === t.ty && (s = 7),
              this.sh = ShapePropertyFactory.getShapeProp(e, t, s, e);
            var a, o = i.length;
            for (r = 0; r < o; r += 1)
              i[r].closed || (a = {
                transforms: n.addTransformSequence(i[r].transforms),
                trNodes: []
              },
                this.styledShapes.push(a),
                i[r].elements.push(a))
          }
          function CVShapeElement(e, t, i) {
            this.shapes = [],
              this.shapesData = e.shapes,
              this.stylesList = [],
              this.itemsData = [],
              this.prevViewData = [],
              this.shapeModifiers = [],
              this.processedElements = [],
              this.transformsManager = new ShapeTransformManager,
              this.initElement(e, t, i)
          }
          function CVTextElement(e, t, i) {
            this.textSpans = [],
              this.yOffset = 0,
              this.fillColorAnim = !1,
              this.strokeColorAnim = !1,
              this.strokeWidthAnim = !1,
              this.stroke = !1,
              this.fill = !1,
              this.justifyOffset = 0,
              this.currentRender = null,
              this.renderType = "canvas",
              this.values = {
                fill: "rgba(0,0,0,0)",
                stroke: "rgba(0,0,0,0)",
                sWidth: 0,
                fValue: ""
              },
              this.initElement(e, t, i)
          }
          function CVImageElement(e, t, i) {
            this.assetData = t.getAssetData(e.refId),
              this.img = t.imageLoader.getAsset(this.assetData),
              this.initElement(e, t, i)
          }
          function CVSolidElement(e, t, i) {
            this.initElement(e, t, i)
          }
          function CanvasRendererBase(e, t) {
            this.animationItem = e,
              this.renderConfig = {
                clearCanvas: !t || void 0 === t.clearCanvas || t.clearCanvas,
                context: t && t.context || null,
                progressiveLoad: t && t.progressiveLoad || !1,
                preserveAspectRatio: t && t.preserveAspectRatio || "xMidYMid meet",
                imagePreserveAspectRatio: t && t.imagePreserveAspectRatio || "xMidYMid slice",
                contentVisibility: t && t.contentVisibility || "visible",
                className: t && t.className || "",
                id: t && t.id || ""
              },
              this.renderConfig.dpr = t && t.dpr || 1,
            this.animationItem.wrapper && (this.renderConfig.dpr = t && t.dpr || window.devicePixelRatio || 1),
              this.renderedFrame = -1,
              this.globalData = {
                frameNum: -1,
                _mdf: !1,
                renderConfig: this.renderConfig,
                currentGlobalAlpha: -1
              },
              this.contextData = new CVContextData,
              this.elements = [],
              this.pendingElements = [],
              this.transformMat = new Matrix,
              this.completeLayers = !1,
              this.rendererType = "canvas"
          }
          function CVCompElement(e, t, i) {
            this.completeLayers = !1,
              this.layers = e.layers,
              this.pendingElements = [],
              this.elements = createSizedArray(this.layers.length),
              this.initElement(e, t, i),
              this.tm = e.tm ? PropertyFactory.getProp(this, e.tm, 0, t.frameRate, this) : {
                _placeholder: !0
              }
          }
          function CanvasRenderer(e, t) {
            this.animationItem = e,
              this.renderConfig = {
                clearCanvas: !t || void 0 === t.clearCanvas || t.clearCanvas,
                context: t && t.context || null,
                progressiveLoad: t && t.progressiveLoad || !1,
                preserveAspectRatio: t && t.preserveAspectRatio || "xMidYMid meet",
                imagePreserveAspectRatio: t && t.imagePreserveAspectRatio || "xMidYMid slice",
                contentVisibility: t && t.contentVisibility || "visible",
                className: t && t.className || "",
                id: t && t.id || ""
              },
              this.renderConfig.dpr = t && t.dpr || 1,
            this.animationItem.wrapper && (this.renderConfig.dpr = t && t.dpr || window.devicePixelRatio || 1),
              this.renderedFrame = -1,
              this.globalData = {
                frameNum: -1,
                _mdf: !1,
                renderConfig: this.renderConfig,
                currentGlobalAlpha: -1
              },
              this.contextData = new CVContextData,
              this.elements = [],
              this.pendingElements = [],
              this.transformMat = new Matrix,
              this.completeLayers = !1,
              this.rendererType = "canvas"
          }
          function HBaseElement() {}
          function HSolidElement(e, t, i) {
            this.initElement(e, t, i)
          }
          function HShapeElement(e, t, i) {
            this.shapes = [],
              this.shapesData = e.shapes,
              this.stylesList = [],
              this.shapeModifiers = [],
              this.itemsData = [],
              this.processedElements = [],
              this.animatedContents = [],
              this.shapesContainer = createNS("g"),
              this.initElement(e, t, i),
              this.prevViewData = [],
              this.currentBBox = {
                x: 999999,
                y: -999999,
                h: 0,
                w: 0
              }
          }
          function HTextElement(e, t, i) {
            this.textSpans = [],
              this.textPaths = [],
              this.currentBBox = {
                x: 999999,
                y: -999999,
                h: 0,
                w: 0
              },
              this.renderType = "svg",
              this.isMasked = !1,
              this.initElement(e, t, i)
          }
          function HCameraElement(e, t, i) {
            this.initFrame(),
              this.initBaseData(e, t, i),
              this.initHierarchy();
            var n = PropertyFactory.getProp;
            if (this.pe = n(this, e.pe, 0, 0, this),
              e.ks.p.s ? (this.px = n(this, e.ks.p.x, 1, 0, this),
                this.py = n(this, e.ks.p.y, 1, 0, this),
                this.pz = n(this, e.ks.p.z, 1, 0, this)) : this.p = n(this, e.ks.p, 1, 0, this),
            e.ks.a && (this.a = n(this, e.ks.a, 1, 0, this)),
            e.ks.or.k.length && e.ks.or.k[0].to) {
              var r, s = e.ks.or.k.length;
              for (r = 0; r < s; r += 1)
                e.ks.or.k[r].to = null,
                  e.ks.or.k[r].ti = null
            }
            this.or = n(this, e.ks.or, 1, degToRads, this),
              this.or.sh = !0,
              this.rx = n(this, e.ks.rx, 0, degToRads, this),
              this.ry = n(this, e.ks.ry, 0, degToRads, this),
              this.rz = n(this, e.ks.rz, 0, degToRads, this),
              this.mat = new Matrix,
              this._prevMat = new Matrix,
              this._isFirstFrame = !0,
              this.finalTransform = {
                mProp: this
              }
          }
          function HImageElement(e, t, i) {
            this.assetData = t.getAssetData(e.refId),
              this.initElement(e, t, i)
          }
          function HybridRendererBase(e, t) {
            this.animationItem = e,
              this.layers = null,
              this.renderedFrame = -1,
              this.renderConfig = {
                className: t && t.className || "",
                imagePreserveAspectRatio: t && t.imagePreserveAspectRatio || "xMidYMid slice",
                hideOnTransparent: !(t && !1 === t.hideOnTransparent),
                filterSize: {
                  width: t && t.filterSize && t.filterSize.width || "400%",
                  height: t && t.filterSize && t.filterSize.height || "400%",
                  x: t && t.filterSize && t.filterSize.x || "-100%",
                  y: t && t.filterSize && t.filterSize.y || "-100%"
                }
              },
              this.globalData = {
                _mdf: !1,
                frameNum: -1,
                renderConfig: this.renderConfig
              },
              this.pendingElements = [],
              this.elements = [],
              this.threeDElements = [],
              this.destroyed = !1,
              this.camera = null,
              this.supports3d = !0,
              this.rendererType = "html"
          }
          function HCompElement(e, t, i) {
            this.layers = e.layers,
              this.supports3d = !e.hasMask,
              this.completeLayers = !1,
              this.pendingElements = [],
              this.elements = this.layers ? createSizedArray(this.layers.length) : [],
              this.initElement(e, t, i),
              this.tm = e.tm ? PropertyFactory.getProp(this, e.tm, 0, t.frameRate, this) : {
                _placeholder: !0
              }
          }
          function HybridRenderer(e, t) {
            this.animationItem = e,
              this.layers = null,
              this.renderedFrame = -1,
              this.renderConfig = {
                className: t && t.className || "",
                imagePreserveAspectRatio: t && t.imagePreserveAspectRatio || "xMidYMid slice",
                hideOnTransparent: !(t && !1 === t.hideOnTransparent),
                filterSize: {
                  width: t && t.filterSize && t.filterSize.width || "400%",
                  height: t && t.filterSize && t.filterSize.height || "400%",
                  x: t && t.filterSize && t.filterSize.x || "-100%",
                  y: t && t.filterSize && t.filterSize.y || "-100%"
                }
              },
              this.globalData = {
                _mdf: !1,
                frameNum: -1,
                renderConfig: this.renderConfig
              },
              this.pendingElements = [],
              this.elements = [],
              this.threeDElements = [],
              this.destroyed = !1,
              this.camera = null,
              this.supports3d = !0,
              this.rendererType = "html"
          }
          extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], SVGTextLottieElement),
            SVGTextLottieElement.prototype.createContent = function() {
              this.data.singleShape && !this.globalData.fontManager.chars && (this.textContainer = createNS("text"))
            }
            ,
            SVGTextLottieElement.prototype.buildTextContents = function(e) {
              for (var t = 0, i = e.length, n = [], r = ""; t < i; )
                e[t] === String.fromCharCode(13) || e[t] === String.fromCharCode(3) ? (n.push(r),
                  r = "") : r += e[t],
                  t += 1;
              return n.push(r),
                n
            }
            ,
            SVGTextLottieElement.prototype.buildShapeData = function(e, t) {
              if (e.shapes && e.shapes.length) {
                var i = e.shapes[0];
                if (i.it) {
                  var n = i.it[i.it.length - 1];
                  n.s && (n.s.k[0] = t,
                    n.s.k[1] = t)
                }
              }
              return e
            }
            ,
            SVGTextLottieElement.prototype.buildNewText = function() {
              var e, t;
              this.addDynamicProperty(this);
              var i = this.textProperty.currentData;
              this.renderedLetters = createSizedArray(i ? i.l.length : 0),
                i.fc ? this.layerElement.setAttribute("fill", this.buildColor(i.fc)) : this.layerElement.setAttribute("fill", "rgba(0,0,0,0)"),
              i.sc && (this.layerElement.setAttribute("stroke", this.buildColor(i.sc)),
                this.layerElement.setAttribute("stroke-width", i.sw)),
                this.layerElement.setAttribute("font-size", i.finalSize);
              var n = this.globalData.fontManager.getFontByName(i.f);
              if (n.fClass)
                this.layerElement.setAttribute("class", n.fClass);
              else {
                this.layerElement.setAttribute("font-family", n.fFamily);
                var r = i.fWeight
                  , s = i.fStyle;
                this.layerElement.setAttribute("font-style", s),
                  this.layerElement.setAttribute("font-weight", r)
              }
              this.layerElement.setAttribute("aria-label", i.t);
              var a, o = i.l || [], l = !!this.globalData.fontManager.chars;
              t = o.length;
              var h = this.mHelper
                , c = this.data.singleShape
                , u = 0
                , d = 0
                , p = !0
                , f = .001 * i.tr * i.finalSize;
              if (!c || l || i.sz) {
                var m, g = this.textSpans.length;
                for (e = 0; e < t; e += 1) {
                  if (this.textSpans[e] || (this.textSpans[e] = {
                    span: null,
                    childSpan: null,
                    glyph: null
                  }),
                  !l || !c || 0 === e) {
                    if (a = g > e ? this.textSpans[e].span : createNS(l ? "g" : "text"),
                    g <= e) {
                      if (a.setAttribute("stroke-linecap", "butt"),
                        a.setAttribute("stroke-linejoin", "round"),
                        a.setAttribute("stroke-miterlimit", "4"),
                        this.textSpans[e].span = a,
                        l) {
                        var v = createNS("g");
                        a.appendChild(v),
                          this.textSpans[e].childSpan = v
                      }
                      this.textSpans[e].span = a,
                        this.layerElement.appendChild(a)
                    }
                    a.style.display = "inherit"
                  }
                  if (h.reset(),
                  c && (o[e].n && (u = -f,
                    d += i.yOffset,
                    d += p ? 1 : 0,
                    p = !1),
                    this.applyTextPropertiesToMatrix(i, h, o[e].line, u, d),
                    u += o[e].l || 0,
                    u += f),
                    l) {
                    var y;
                    if (1 === (m = this.globalData.fontManager.getCharData(i.finalText[e], n.fStyle, this.globalData.fontManager.getFontByName(i.f).fFamily)).t)
                      y = new SVGCompElement(m.data,this.globalData,this);
                    else {
                      var x = emptyShapeData;
                      m.data && m.data.shapes && (x = this.buildShapeData(m.data, i.finalSize)),
                        y = new SVGShapeElement(x,this.globalData,this)
                    }
                    if (this.textSpans[e].glyph) {
                      var _ = this.textSpans[e].glyph;
                      this.textSpans[e].childSpan.removeChild(_.layerElement),
                        _.destroy()
                    }
                    this.textSpans[e].glyph = y,
                      y._debug = !0,
                      y.prepareFrame(0),
                      y.renderFrame(),
                      this.textSpans[e].childSpan.appendChild(y.layerElement),
                    1 === m.t && this.textSpans[e].childSpan.setAttribute("transform", "scale(" + i.finalSize / 100 + "," + i.finalSize / 100 + ")")
                  } else
                    c && a.setAttribute("transform", "translate(" + h.props[12] + "," + h.props[13] + ")"),
                      a.textContent = o[e].val,
                      a.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve")
                }
                c && a && a.setAttribute("d", "")
              } else {
                var b = this.textContainer
                  , w = "start";
                switch (i.j) {
                  case 1:
                    w = "end";
                    break;
                  case 2:
                    w = "middle";
                    break;
                  default:
                    w = "start"
                }
                b.setAttribute("text-anchor", w),
                  b.setAttribute("letter-spacing", f);
                var A = this.buildTextContents(i.finalText);
                for (t = A.length,
                       d = i.ps ? i.ps[1] + i.ascent : 0,
                       e = 0; e < t; e += 1)
                  (a = this.textSpans[e].span || createNS("tspan")).textContent = A[e],
                    a.setAttribute("x", 0),
                    a.setAttribute("y", d),
                    a.style.display = "inherit",
                    b.appendChild(a),
                  this.textSpans[e] || (this.textSpans[e] = {
                    span: null,
                    glyph: null
                  }),
                    this.textSpans[e].span = a,
                    d += i.finalLineHeight;
                this.layerElement.appendChild(b)
              }
              for (; e < this.textSpans.length; )
                this.textSpans[e].span.style.display = "none",
                  e += 1;
              this._sizeChanged = !0
            }
            ,
            SVGTextLottieElement.prototype.sourceRectAtTime = function() {
              if (this.prepareFrame(this.comp.renderedFrame - this.data.st),
                this.renderInnerContent(),
                this._sizeChanged) {
                this._sizeChanged = !1;
                var e = this.layerElement.getBBox();
                this.bbox = {
                  top: e.y,
                  left: e.x,
                  width: e.width,
                  height: e.height
                }
              }
              return this.bbox
            }
            ,
            SVGTextLottieElement.prototype.getValue = function() {
              var e, t, i = this.textSpans.length;
              for (this.renderedFrame = this.comp.renderedFrame,
                     e = 0; e < i; e += 1)
                (t = this.textSpans[e].glyph) && (t.prepareFrame(this.comp.renderedFrame - this.data.st),
                t._mdf && (this._mdf = !0))
            }
            ,
            SVGTextLottieElement.prototype.renderInnerContent = function() {
              if ((!this.data.singleShape || this._mdf) && (this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag),
              this.lettersChangedFlag || this.textAnimator.lettersChangedFlag)) {
                var e, t;
                this._sizeChanged = !0;
                var i, n, r, s = this.textAnimator.renderedLetters, a = this.textProperty.currentData.l;
                for (t = a.length,
                       e = 0; e < t; e += 1)
                  a[e].n || (i = s[e],
                    n = this.textSpans[e].span,
                  (r = this.textSpans[e].glyph) && r.renderFrame(),
                  i._mdf.m && n.setAttribute("transform", i.m),
                  i._mdf.o && n.setAttribute("opacity", i.o),
                  i._mdf.sw && n.setAttribute("stroke-width", i.sw),
                  i._mdf.sc && n.setAttribute("stroke", i.sc),
                  i._mdf.fc && n.setAttribute("fill", i.fc))
              }
            }
            ,
            extendPrototype([IImageElement], ISolidElement),
            ISolidElement.prototype.createContent = function() {
              var e = createNS("rect");
              e.setAttribute("width", this.data.sw),
                e.setAttribute("height", this.data.sh),
                e.setAttribute("fill", this.data.sc),
                this.layerElement.appendChild(e)
            }
            ,
            NullElement.prototype.prepareFrame = function(e) {
              this.prepareProperties(e, !0)
            }
            ,
            NullElement.prototype.renderFrame = function() {}
            ,
            NullElement.prototype.getBaseElement = function() {
              return null
            }
            ,
            NullElement.prototype.destroy = function() {}
            ,
            NullElement.prototype.sourceRectAtTime = function() {}
            ,
            NullElement.prototype.hide = function() {}
            ,
            extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement], NullElement),
            extendPrototype([BaseRenderer], SVGRendererBase),
            SVGRendererBase.prototype.createNull = function(e) {
              return new NullElement(e,this.globalData,this)
            }
            ,
            SVGRendererBase.prototype.createShape = function(e) {
              return new SVGShapeElement(e,this.globalData,this)
            }
            ,
            SVGRendererBase.prototype.createText = function(e) {
              return new SVGTextLottieElement(e,this.globalData,this)
            }
            ,
            SVGRendererBase.prototype.createImage = function(e) {
              return new IImageElement(e,this.globalData,this)
            }
            ,
            SVGRendererBase.prototype.createSolid = function(e) {
              return new ISolidElement(e,this.globalData,this)
            }
            ,
            SVGRendererBase.prototype.configAnimation = function(e) {
              this.svgElement.setAttribute("xmlns", "http://www.w3.org/2000/svg"),
                this.renderConfig.viewBoxSize ? this.svgElement.setAttribute("viewBox", this.renderConfig.viewBoxSize) : this.svgElement.setAttribute("viewBox", "0 0 " + e.w + " " + e.h),
              this.renderConfig.viewBoxOnly || (this.svgElement.setAttribute("width", e.w),
                this.svgElement.setAttribute("height", e.h),
                this.svgElement.style.width = "100%",
                this.svgElement.style.height = "100%",
                this.svgElement.style.transform = "translate3d(0,0,0)",
                this.svgElement.style.contentVisibility = this.renderConfig.contentVisibility),
              this.renderConfig.width && this.svgElement.setAttribute("width", this.renderConfig.width),
              this.renderConfig.height && this.svgElement.setAttribute("height", this.renderConfig.height),
              this.renderConfig.className && this.svgElement.setAttribute("class", this.renderConfig.className),
              this.renderConfig.id && this.svgElement.setAttribute("id", this.renderConfig.id),
              void 0 !== this.renderConfig.focusable && this.svgElement.setAttribute("focusable", this.renderConfig.focusable),
                this.svgElement.setAttribute("preserveAspectRatio", this.renderConfig.preserveAspectRatio),
                this.animationItem.wrapper.appendChild(this.svgElement);
              var t = this.globalData.defs;
              this.setupGlobalData(e, t),
                this.globalData.progressiveLoad = this.renderConfig.progressiveLoad,
                this.data = e;
              var i = createNS("clipPath")
                , n = createNS("rect");
              n.setAttribute("width", e.w),
                n.setAttribute("height", e.h),
                n.setAttribute("x", 0),
                n.setAttribute("y", 0);
              var r = createElementID();
              i.setAttribute("id", r),
                i.appendChild(n),
                this.layerElement.setAttribute("clip-path", "url(" + getLocationHref() + "#" + r + ")"),
                t.appendChild(i),
                this.layers = e.layers,
                this.elements = createSizedArray(e.layers.length)
            }
            ,
            SVGRendererBase.prototype.destroy = function() {
              var e;
              this.animationItem.wrapper && (this.animationItem.wrapper.innerText = ""),
                this.layerElement = null,
                this.globalData.defs = null;
              var t = this.layers ? this.layers.length : 0;
              for (e = 0; e < t; e += 1)
                this.elements[e] && this.elements[e].destroy();
              this.elements.length = 0,
                this.destroyed = !0,
                this.animationItem = null
            }
            ,
            SVGRendererBase.prototype.updateContainerSize = function() {}
            ,
            SVGRendererBase.prototype.buildItem = function(e) {
              var t = this.elements;
              if (!t[e] && 99 !== this.layers[e].ty) {
                t[e] = !0;
                var i = this.createItem(this.layers[e]);
                t[e] = i,
                getExpressionsPlugin() && (0 === this.layers[e].ty && this.globalData.projectInterface.registerComposition(i),
                  i.initExpressions()),
                  this.appendElementInPos(i, e),
                this.layers[e].tt && (this.elements[e - 1] && !0 !== this.elements[e - 1] ? i.setMatte(t[e - 1].layerId) : (this.buildItem(e - 1),
                  this.addPendingElement(i)))
              }
            }
            ,
            SVGRendererBase.prototype.checkPendingElements = function() {
              for (; this.pendingElements.length; ) {
                var e = this.pendingElements.pop();
                if (e.checkParenting(),
                  e.data.tt)
                  for (var t = 0, i = this.elements.length; t < i; ) {
                    if (this.elements[t] === e) {
                      e.setMatte(this.elements[t - 1].layerId);
                      break
                    }
                    t += 1
                  }
              }
            }
            ,
            SVGRendererBase.prototype.renderFrame = function(e) {
              if (this.renderedFrame !== e && !this.destroyed) {
                var t;
                null === e ? e = this.renderedFrame : this.renderedFrame = e,
                  this.globalData.frameNum = e,
                  this.globalData.frameId += 1,
                  this.globalData.projectInterface.currentFrame = e,
                  this.globalData._mdf = !1;
                var i = this.layers.length;
                for (this.completeLayers || this.checkLayers(e),
                       t = i - 1; t >= 0; t -= 1)
                  (this.completeLayers || this.elements[t]) && this.elements[t].prepareFrame(e - this.layers[t].st);
                if (this.globalData._mdf)
                  for (t = 0; t < i; t += 1)
                    (this.completeLayers || this.elements[t]) && this.elements[t].renderFrame()
              }
            }
            ,
            SVGRendererBase.prototype.appendElementInPos = function(e, t) {
              var i = e.getBaseElement();
              if (i) {
                for (var n, r = 0; r < t; )
                  this.elements[r] && !0 !== this.elements[r] && this.elements[r].getBaseElement() && (n = this.elements[r].getBaseElement()),
                    r += 1;
                n ? this.layerElement.insertBefore(i, n) : this.layerElement.appendChild(i)
              }
            }
            ,
            SVGRendererBase.prototype.hide = function() {
              this.layerElement.style.display = "none"
            }
            ,
            SVGRendererBase.prototype.show = function() {
              this.layerElement.style.display = "block"
            }
            ,
            extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement, RenderableDOMElement], ICompElement),
            ICompElement.prototype.initElement = function(e, t, i) {
              this.initFrame(),
                this.initBaseData(e, t, i),
                this.initTransform(e, t, i),
                this.initRenderable(),
                this.initHierarchy(),
                this.initRendererElement(),
                this.createContainerElements(),
                this.createRenderableComponents(),
              !this.data.xt && t.progressiveLoad || this.buildAllItems(),
                this.hide()
            }
            ,
            ICompElement.prototype.prepareFrame = function(e) {
              if (this._mdf = !1,
                this.prepareRenderableFrame(e),
                this.prepareProperties(e, this.isInRange),
              this.isInRange || this.data.xt) {
                if (this.tm._placeholder)
                  this.renderedFrame = e / this.data.sr;
                else {
                  var t = this.tm.v;
                  t === this.data.op && (t = this.data.op - 1),
                    this.renderedFrame = t
                }
                var i, n = this.elements.length;
                for (this.completeLayers || this.checkLayers(this.renderedFrame),
                       i = n - 1; i >= 0; i -= 1)
                  (this.completeLayers || this.elements[i]) && (this.elements[i].prepareFrame(this.renderedFrame - this.layers[i].st),
                  this.elements[i]._mdf && (this._mdf = !0))
              }
            }
            ,
            ICompElement.prototype.renderInnerContent = function() {
              var e, t = this.layers.length;
              for (e = 0; e < t; e += 1)
                (this.completeLayers || this.elements[e]) && this.elements[e].renderFrame()
            }
            ,
            ICompElement.prototype.setElements = function(e) {
              this.elements = e
            }
            ,
            ICompElement.prototype.getElements = function() {
              return this.elements
            }
            ,
            ICompElement.prototype.destroyElements = function() {
              var e, t = this.layers.length;
              for (e = 0; e < t; e += 1)
                this.elements[e] && this.elements[e].destroy()
            }
            ,
            ICompElement.prototype.destroy = function() {
              this.destroyElements(),
                this.destroyBaseElement()
            }
            ,
            extendPrototype([SVGRendererBase, ICompElement, SVGBaseElement], SVGCompElement),
            SVGCompElement.prototype.createComp = function(e) {
              return new SVGCompElement(e,this.globalData,this)
            }
            ,
            extendPrototype([SVGRendererBase], SVGRenderer),
            SVGRenderer.prototype.createComp = function(e) {
              return new SVGCompElement(e,this.globalData,this)
            }
            ,
            CVContextData.prototype.duplicate = function() {
              var e = 2 * this._length
                , t = this.savedOp;
              this.savedOp = createTypedArray("float32", e),
                this.savedOp.set(t);
              var i = 0;
              for (i = this._length; i < e; i += 1)
                this.saved[i] = createTypedArray("float32", 16);
              this._length = e
            }
            ,
            CVContextData.prototype.reset = function() {
              this.cArrPos = 0,
                this.cTr.reset(),
                this.cO = 1
            }
            ,
            ShapeTransformManager.prototype = {
              addTransformSequence: function(e) {
                var t, i = e.length, n = "_";
                for (t = 0; t < i; t += 1)
                  n += e[t].transform.key + "_";
                var r = this.sequences[n];
                return r || (r = {
                  transforms: [].concat(e),
                  finalTransform: new Matrix,
                  _mdf: !1
                },
                  this.sequences[n] = r,
                  this.sequenceList.push(r)),
                  r
              },
              processSequence: function(e, t) {
                for (var i, n = 0, r = e.transforms.length, s = t; n < r && !t; ) {
                  if (e.transforms[n].transform.mProps._mdf) {
                    s = !0;
                    break
                  }
                  n += 1
                }
                if (s)
                  for (e.finalTransform.reset(),
                         n = r - 1; n >= 0; n -= 1)
                    i = e.transforms[n].transform.mProps.v.props,
                      e.finalTransform.transform(i[0], i[1], i[2], i[3], i[4], i[5], i[6], i[7], i[8], i[9], i[10], i[11], i[12], i[13], i[14], i[15]);
                e._mdf = s
              },
              processSequences: function(e) {
                var t, i = this.sequenceList.length;
                for (t = 0; t < i; t += 1)
                  this.processSequence(this.sequenceList[t], e)
              },
              getNewKey: function() {
                return this.transform_key_count += 1,
                "_" + this.transform_key_count
              }
            },
            CVEffects.prototype.renderFrame = function() {}
            ,
            CVMaskElement.prototype.renderFrame = function() {
              if (this.hasMasks) {
                var e, t, i, n, r = this.element.finalTransform.mat, s = this.element.canvasContext, a = this.masksProperties.length;
                for (s.beginPath(),
                       e = 0; e < a; e += 1)
                  if ("n" !== this.masksProperties[e].mode) {
                    var o;
                    this.masksProperties[e].inv && (s.moveTo(0, 0),
                      s.lineTo(this.element.globalData.compSize.w, 0),
                      s.lineTo(this.element.globalData.compSize.w, this.element.globalData.compSize.h),
                      s.lineTo(0, this.element.globalData.compSize.h),
                      s.lineTo(0, 0)),
                      n = this.viewData[e].v,
                      t = r.applyToPointArray(n.v[0][0], n.v[0][1], 0),
                      s.moveTo(t[0], t[1]);
                    var l = n._length;
                    for (o = 1; o < l; o += 1)
                      i = r.applyToTriplePoints(n.o[o - 1], n.i[o], n.v[o]),
                        s.bezierCurveTo(i[0], i[1], i[2], i[3], i[4], i[5]);
                    i = r.applyToTriplePoints(n.o[o - 1], n.i[0], n.v[0]),
                      s.bezierCurveTo(i[0], i[1], i[2], i[3], i[4], i[5])
                  }
                this.element.globalData.renderer.save(!0),
                  s.clip()
              }
            }
            ,
            CVMaskElement.prototype.getMaskProperty = MaskElement.prototype.getMaskProperty,
            CVMaskElement.prototype.destroy = function() {
              this.element = null
            }
            ,
            CVBaseElement.prototype = {
              createElements: function() {},
              initRendererElement: function() {},
              createContainerElements: function() {
                this.canvasContext = this.globalData.canvasContext,
                  this.renderableEffectsManager = new CVEffects(this)
              },
              createContent: function() {},
              setBlendMode: function() {
                var e = this.globalData;
                if (e.blendMode !== this.data.bm) {
                  e.blendMode = this.data.bm;
                  var t = getBlendMode(this.data.bm);
                  e.canvasContext.globalCompositeOperation = t
                }
              },
              createRenderableComponents: function() {
                this.maskManager = new CVMaskElement(this.data,this)
              },
              hideElement: function() {
                this.hidden || this.isInRange && !this.isTransparent || (this.hidden = !0)
              },
              showElement: function() {
                this.isInRange && !this.isTransparent && (this.hidden = !1,
                  this._isFirstFrame = !0,
                  this.maskManager._isFirstFrame = !0)
              },
              renderFrame: function() {
                if (!this.hidden && !this.data.hd) {
                  this.renderTransform(),
                    this.renderRenderable(),
                    this.setBlendMode();
                  var e = 0 === this.data.ty;
                  this.globalData.renderer.save(e),
                    this.globalData.renderer.ctxTransform(this.finalTransform.mat.props),
                    this.globalData.renderer.ctxOpacity(this.finalTransform.mProp.o.v),
                    this.renderInnerContent(),
                    this.globalData.renderer.restore(e),
                  this.maskManager.hasMasks && this.globalData.renderer.restore(!0),
                  this._isFirstFrame && (this._isFirstFrame = !1)
                }
              },
              destroy: function() {
                this.canvasContext = null,
                  this.data = null,
                  this.globalData = null,
                  this.maskManager.destroy()
              },
              mHelper: new Matrix
            },
            CVBaseElement.prototype.hide = CVBaseElement.prototype.hideElement,
            CVBaseElement.prototype.show = CVBaseElement.prototype.showElement,
            CVShapeData.prototype.setAsAnimated = SVGShapeData.prototype.setAsAnimated,
            extendPrototype([BaseElement, TransformElement, CVBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableElement], CVShapeElement),
            CVShapeElement.prototype.initElement = RenderableDOMElement.prototype.initElement,
            CVShapeElement.prototype.transformHelper = {
              opacity: 1,
              _opMdf: !1
            },
            CVShapeElement.prototype.dashResetter = [],
            CVShapeElement.prototype.createContent = function() {
              this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, !0, [])
            }
            ,
            CVShapeElement.prototype.createStyleElement = function(e, t) {
              var i = {
                data: e,
                type: e.ty,
                preTransforms: this.transformsManager.addTransformSequence(t),
                transforms: [],
                elements: [],
                closed: !0 === e.hd
              }
                , n = {};
              if ("fl" === e.ty || "st" === e.ty ? (n.c = PropertyFactory.getProp(this, e.c, 1, 255, this),
              n.c.k || (i.co = "rgb(" + bmFloor(n.c.v[0]) + "," + bmFloor(n.c.v[1]) + "," + bmFloor(n.c.v[2]) + ")")) : "gf" !== e.ty && "gs" !== e.ty || (n.s = PropertyFactory.getProp(this, e.s, 1, null, this),
                n.e = PropertyFactory.getProp(this, e.e, 1, null, this),
                n.h = PropertyFactory.getProp(this, e.h || {
                  k: 0
                }, 0, .01, this),
                n.a = PropertyFactory.getProp(this, e.a || {
                  k: 0
                }, 0, degToRads, this),
                n.g = new GradientProperty(this,e.g,this)),
                n.o = PropertyFactory.getProp(this, e.o, 0, .01, this),
              "st" === e.ty || "gs" === e.ty) {
                if (i.lc = lineCapEnum[e.lc || 2],
                  i.lj = lineJoinEnum[e.lj || 2],
                1 == e.lj && (i.ml = e.ml),
                  n.w = PropertyFactory.getProp(this, e.w, 0, null, this),
                n.w.k || (i.wi = n.w.v),
                  e.d) {
                  var r = new DashProperty(this,e.d,"canvas",this);
                  n.d = r,
                  n.d.k || (i.da = n.d.dashArray,
                    i.do = n.d.dashoffset[0])
                }
              } else
                i.r = 2 === e.r ? "evenodd" : "nonzero";
              return this.stylesList.push(i),
                n.style = i,
                n
            }
            ,
            CVShapeElement.prototype.createGroupElement = function() {
              return {
                it: [],
                prevViewData: []
              }
            }
            ,
            CVShapeElement.prototype.createTransformElement = function(e) {
              return {
                transform: {
                  opacity: 1,
                  _opMdf: !1,
                  key: this.transformsManager.getNewKey(),
                  op: PropertyFactory.getProp(this, e.o, 0, .01, this),
                  mProps: TransformPropertyFactory.getTransformProperty(this, e, this)
                }
              }
            }
            ,
            CVShapeElement.prototype.createShapeElement = function(e) {
              var t = new CVShapeData(this,e,this.stylesList,this.transformsManager);
              return this.shapes.push(t),
                this.addShapeToModifiers(t),
                t
            }
            ,
            CVShapeElement.prototype.reloadShapes = function() {
              var e;
              this._isFirstFrame = !0;
              var t = this.itemsData.length;
              for (e = 0; e < t; e += 1)
                this.prevViewData[e] = this.itemsData[e];
              for (this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, !0, []),
                     t = this.dynamicProperties.length,
                     e = 0; e < t; e += 1)
                this.dynamicProperties[e].getValue();
              this.renderModifiers(),
                this.transformsManager.processSequences(this._isFirstFrame)
            }
            ,
            CVShapeElement.prototype.addTransformToStyleList = function(e) {
              var t, i = this.stylesList.length;
              for (t = 0; t < i; t += 1)
                this.stylesList[t].closed || this.stylesList[t].transforms.push(e)
            }
            ,
            CVShapeElement.prototype.removeTransformFromStyleList = function() {
              var e, t = this.stylesList.length;
              for (e = 0; e < t; e += 1)
                this.stylesList[e].closed || this.stylesList[e].transforms.pop()
            }
            ,
            CVShapeElement.prototype.closeStyles = function(e) {
              var t, i = e.length;
              for (t = 0; t < i; t += 1)
                e[t].closed = !0
            }
            ,
            CVShapeElement.prototype.searchShapes = function(e, t, i, n, r) {
              var s, a, o, l, h, c, u = e.length - 1, d = [], p = [], f = [].concat(r);
              for (s = u; s >= 0; s -= 1) {
                if ((l = this.searchProcessedElement(e[s])) ? t[s] = i[l - 1] : e[s]._shouldRender = n,
                "fl" === e[s].ty || "st" === e[s].ty || "gf" === e[s].ty || "gs" === e[s].ty)
                  l ? t[s].style.closed = !1 : t[s] = this.createStyleElement(e[s], f),
                    d.push(t[s].style);
                else if ("gr" === e[s].ty) {
                  if (l)
                    for (o = t[s].it.length,
                           a = 0; a < o; a += 1)
                      t[s].prevViewData[a] = t[s].it[a];
                  else
                    t[s] = this.createGroupElement(e[s]);
                  this.searchShapes(e[s].it, t[s].it, t[s].prevViewData, n, f)
                } else
                  "tr" === e[s].ty ? (l || (c = this.createTransformElement(e[s]),
                    t[s] = c),
                    f.push(t[s]),
                    this.addTransformToStyleList(t[s])) : "sh" === e[s].ty || "rc" === e[s].ty || "el" === e[s].ty || "sr" === e[s].ty ? l || (t[s] = this.createShapeElement(e[s])) : "tm" === e[s].ty || "rd" === e[s].ty || "pb" === e[s].ty ? (l ? (h = t[s]).closed = !1 : ((h = ShapeModifiers.getModifier(e[s].ty)).init(this, e[s]),
                    t[s] = h,
                    this.shapeModifiers.push(h)),
                    p.push(h)) : "rp" === e[s].ty && (l ? (h = t[s]).closed = !0 : (h = ShapeModifiers.getModifier(e[s].ty),
                    t[s] = h,
                    h.init(this, e, s, t),
                    this.shapeModifiers.push(h),
                    n = !1),
                    p.push(h));
                this.addProcessedElement(e[s], s + 1)
              }
              for (this.removeTransformFromStyleList(),
                     this.closeStyles(d),
                     u = p.length,
                     s = 0; s < u; s += 1)
                p[s].closed = !0
            }
            ,
            CVShapeElement.prototype.renderInnerContent = function() {
              this.transformHelper.opacity = 1,
                this.transformHelper._opMdf = !1,
                this.renderModifiers(),
                this.transformsManager.processSequences(this._isFirstFrame),
                this.renderShape(this.transformHelper, this.shapesData, this.itemsData, !0)
            }
            ,
            CVShapeElement.prototype.renderShapeTransform = function(e, t) {
              (e._opMdf || t.op._mdf || this._isFirstFrame) && (t.opacity = e.opacity,
                t.opacity *= t.op.v,
                t._opMdf = !0)
            }
            ,
            CVShapeElement.prototype.drawLayer = function() {
              var e, t, i, n, r, s, a, o, l, h = this.stylesList.length, c = this.globalData.renderer, u = this.globalData.canvasContext;
              for (e = 0; e < h; e += 1)
                if (("st" !== (o = (l = this.stylesList[e]).type) && "gs" !== o || 0 !== l.wi) && l.data._shouldRender && 0 !== l.coOp && 0 !== this.globalData.currentGlobalAlpha) {
                  for (c.save(),
                         s = l.elements,
                         "st" === o || "gs" === o ? (u.strokeStyle = "st" === o ? l.co : l.grd,
                           u.lineWidth = l.wi,
                           u.lineCap = l.lc,
                           u.lineJoin = l.lj,
                           u.miterLimit = l.ml || 0) : u.fillStyle = "fl" === o ? l.co : l.grd,
                         c.ctxOpacity(l.coOp),
                       "st" !== o && "gs" !== o && u.beginPath(),
                         c.ctxTransform(l.preTransforms.finalTransform.props),
                         i = s.length,
                         t = 0; t < i; t += 1) {
                    for ("st" !== o && "gs" !== o || (u.beginPath(),
                    l.da && (u.setLineDash(l.da),
                      u.lineDashOffset = l.do)),
                           r = (a = s[t].trNodes).length,
                           n = 0; n < r; n += 1)
                      "m" === a[n].t ? u.moveTo(a[n].p[0], a[n].p[1]) : "c" === a[n].t ? u.bezierCurveTo(a[n].pts[0], a[n].pts[1], a[n].pts[2], a[n].pts[3], a[n].pts[4], a[n].pts[5]) : u.closePath();
                    "st" !== o && "gs" !== o || (u.stroke(),
                    l.da && u.setLineDash(this.dashResetter))
                  }
                  "st" !== o && "gs" !== o && u.fill(l.r),
                    c.restore()
                }
            }
            ,
            CVShapeElement.prototype.renderShape = function(e, t, i, n) {
              var r, s;
              for (s = e,
                     r = t.length - 1; r >= 0; r -= 1)
                "tr" === t[r].ty ? (s = i[r].transform,
                  this.renderShapeTransform(e, s)) : "sh" === t[r].ty || "el" === t[r].ty || "rc" === t[r].ty || "sr" === t[r].ty ? this.renderPath(t[r], i[r]) : "fl" === t[r].ty ? this.renderFill(t[r], i[r], s) : "st" === t[r].ty ? this.renderStroke(t[r], i[r], s) : "gf" === t[r].ty || "gs" === t[r].ty ? this.renderGradientFill(t[r], i[r], s) : "gr" === t[r].ty ? this.renderShape(s, t[r].it, i[r].it) : t[r].ty;
              n && this.drawLayer()
            }
            ,
            CVShapeElement.prototype.renderStyledShape = function(e, t) {
              if (this._isFirstFrame || t._mdf || e.transforms._mdf) {
                var i, n, r, s = e.trNodes, a = t.paths, o = a._length;
                s.length = 0;
                var l = e.transforms.finalTransform;
                for (r = 0; r < o; r += 1) {
                  var h = a.shapes[r];
                  if (h && h.v) {
                    for (n = h._length,
                           i = 1; i < n; i += 1)
                      1 === i && s.push({
                        t: "m",
                        p: l.applyToPointArray(h.v[0][0], h.v[0][1], 0)
                      }),
                        s.push({
                          t: "c",
                          pts: l.applyToTriplePoints(h.o[i - 1], h.i[i], h.v[i])
                        });
                    1 === n && s.push({
                      t: "m",
                      p: l.applyToPointArray(h.v[0][0], h.v[0][1], 0)
                    }),
                    h.c && n && (s.push({
                      t: "c",
                      pts: l.applyToTriplePoints(h.o[i - 1], h.i[0], h.v[0])
                    }),
                      s.push({
                        t: "z"
                      }))
                  }
                }
                e.trNodes = s
              }
            }
            ,
            CVShapeElement.prototype.renderPath = function(e, t) {
              if (!0 !== e.hd && e._shouldRender) {
                var i, n = t.styledShapes.length;
                for (i = 0; i < n; i += 1)
                  this.renderStyledShape(t.styledShapes[i], t.sh)
              }
            }
            ,
            CVShapeElement.prototype.renderFill = function(e, t, i) {
              var n = t.style;
              (t.c._mdf || this._isFirstFrame) && (n.co = "rgb(" + bmFloor(t.c.v[0]) + "," + bmFloor(t.c.v[1]) + "," + bmFloor(t.c.v[2]) + ")"),
              (t.o._mdf || i._opMdf || this._isFirstFrame) && (n.coOp = t.o.v * i.opacity)
            }
            ,
            CVShapeElement.prototype.renderGradientFill = function(e, t, i) {
              var n, r = t.style;
              if (!r.grd || t.g._mdf || t.s._mdf || t.e._mdf || 1 !== e.t && (t.h._mdf || t.a._mdf)) {
                var s, a = this.globalData.canvasContext, o = t.s.v, l = t.e.v;
                if (1 === e.t)
                  n = a.createLinearGradient(o[0], o[1], l[0], l[1]);
                else {
                  var h = Math.sqrt(Math.pow(o[0] - l[0], 2) + Math.pow(o[1] - l[1], 2))
                    , c = Math.atan2(l[1] - o[1], l[0] - o[0])
                    , u = t.h.v;
                  u >= 1 ? u = .99 : u <= -1 && (u = -.99);
                  var d = h * u
                    , p = Math.cos(c + t.a.v) * d + o[0]
                    , f = Math.sin(c + t.a.v) * d + o[1];
                  n = a.createRadialGradient(p, f, 0, o[0], o[1], h)
                }
                var m = e.g.p
                  , g = t.g.c
                  , v = 1;
                for (s = 0; s < m; s += 1)
                  t.g._hasOpacity && t.g._collapsable && (v = t.g.o[2 * s + 1]),
                    n.addColorStop(g[4 * s] / 100, "rgba(" + g[4 * s + 1] + "," + g[4 * s + 2] + "," + g[4 * s + 3] + "," + v + ")");
                r.grd = n
              }
              r.coOp = t.o.v * i.opacity
            }
            ,
            CVShapeElement.prototype.renderStroke = function(e, t, i) {
              var n = t.style
                , r = t.d;
              r && (r._mdf || this._isFirstFrame) && (n.da = r.dashArray,
                n.do = r.dashoffset[0]),
              (t.c._mdf || this._isFirstFrame) && (n.co = "rgb(" + bmFloor(t.c.v[0]) + "," + bmFloor(t.c.v[1]) + "," + bmFloor(t.c.v[2]) + ")"),
              (t.o._mdf || i._opMdf || this._isFirstFrame) && (n.coOp = t.o.v * i.opacity),
              (t.w._mdf || this._isFirstFrame) && (n.wi = t.w.v)
            }
            ,
            CVShapeElement.prototype.destroy = function() {
              this.shapesData = null,
                this.globalData = null,
                this.canvasContext = null,
                this.stylesList.length = 0,
                this.itemsData.length = 0
            }
            ,
            extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement, ITextElement], CVTextElement),
            CVTextElement.prototype.tHelper = createTag("canvas").getContext("2d"),
            CVTextElement.prototype.buildNewText = function() {
              var e = this.textProperty.currentData;
              this.renderedLetters = createSizedArray(e.l ? e.l.length : 0);
              var t = !1;
              e.fc ? (t = !0,
                this.values.fill = this.buildColor(e.fc)) : this.values.fill = "rgba(0,0,0,0)",
                this.fill = t;
              var i = !1;
              e.sc && (i = !0,
                this.values.stroke = this.buildColor(e.sc),
                this.values.sWidth = e.sw);
              var n, r, s, a, o, l, h, c, u, d, p, f, m = this.globalData.fontManager.getFontByName(e.f), g = e.l, v = this.mHelper;
              this.stroke = i,
                this.values.fValue = e.finalSize + "px " + this.globalData.fontManager.getFontByName(e.f).fFamily,
                r = e.finalText.length;
              var y = this.data.singleShape
                , x = .001 * e.tr * e.finalSize
                , _ = 0
                , b = 0
                , w = !0
                , A = 0;
              for (n = 0; n < r; n += 1) {
                a = (s = this.globalData.fontManager.getCharData(e.finalText[n], m.fStyle, this.globalData.fontManager.getFontByName(e.f).fFamily)) && s.data || {},
                  v.reset(),
                y && g[n].n && (_ = -x,
                  b += e.yOffset,
                  b += w ? 1 : 0,
                  w = !1),
                  u = (h = a.shapes ? a.shapes[0].it : []).length,
                  v.scale(e.finalSize / 100, e.finalSize / 100),
                y && this.applyTextPropertiesToMatrix(e, v, g[n].line, _, b),
                  p = createSizedArray(u - 1);
                var S = 0;
                for (c = 0; c < u; c += 1)
                  if ("sh" === h[c].ty) {
                    for (l = h[c].ks.k.i.length,
                           d = h[c].ks.k,
                           f = [],
                           o = 1; o < l; o += 1)
                      1 === o && f.push(v.applyToX(d.v[0][0], d.v[0][1], 0), v.applyToY(d.v[0][0], d.v[0][1], 0)),
                        f.push(v.applyToX(d.o[o - 1][0], d.o[o - 1][1], 0), v.applyToY(d.o[o - 1][0], d.o[o - 1][1], 0), v.applyToX(d.i[o][0], d.i[o][1], 0), v.applyToY(d.i[o][0], d.i[o][1], 0), v.applyToX(d.v[o][0], d.v[o][1], 0), v.applyToY(d.v[o][0], d.v[o][1], 0));
                    f.push(v.applyToX(d.o[o - 1][0], d.o[o - 1][1], 0), v.applyToY(d.o[o - 1][0], d.o[o - 1][1], 0), v.applyToX(d.i[0][0], d.i[0][1], 0), v.applyToY(d.i[0][0], d.i[0][1], 0), v.applyToX(d.v[0][0], d.v[0][1], 0), v.applyToY(d.v[0][0], d.v[0][1], 0)),
                      p[S] = f,
                      S += 1
                  }
                y && (_ += g[n].l,
                  _ += x),
                  this.textSpans[A] ? this.textSpans[A].elem = p : this.textSpans[A] = {
                    elem: p
                  },
                  A += 1
              }
            }
            ,
            CVTextElement.prototype.renderInnerContent = function() {
              var e, t, i, n, r, s, a = this.canvasContext;
              a.font = this.values.fValue,
                a.lineCap = "butt",
                a.lineJoin = "miter",
                a.miterLimit = 4,
              this.data.singleShape || this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
              var o, l = this.textAnimator.renderedLetters, h = this.textProperty.currentData.l;
              t = h.length;
              var c, u, d = null, p = null, f = null;
              for (e = 0; e < t; e += 1)
                if (!h[e].n) {
                  if ((o = l[e]) && (this.globalData.renderer.save(),
                    this.globalData.renderer.ctxTransform(o.p),
                    this.globalData.renderer.ctxOpacity(o.o)),
                    this.fill) {
                    for (o && o.fc ? d !== o.fc && (d = o.fc,
                      a.fillStyle = o.fc) : d !== this.values.fill && (d = this.values.fill,
                      a.fillStyle = this.values.fill),
                           n = (c = this.textSpans[e].elem).length,
                           this.globalData.canvasContext.beginPath(),
                           i = 0; i < n; i += 1)
                      for (s = (u = c[i]).length,
                             this.globalData.canvasContext.moveTo(u[0], u[1]),
                             r = 2; r < s; r += 6)
                        this.globalData.canvasContext.bezierCurveTo(u[r], u[r + 1], u[r + 2], u[r + 3], u[r + 4], u[r + 5]);
                    this.globalData.canvasContext.closePath(),
                      this.globalData.canvasContext.fill()
                  }
                  if (this.stroke) {
                    for (o && o.sw ? f !== o.sw && (f = o.sw,
                      a.lineWidth = o.sw) : f !== this.values.sWidth && (f = this.values.sWidth,
                      a.lineWidth = this.values.sWidth),
                           o && o.sc ? p !== o.sc && (p = o.sc,
                             a.strokeStyle = o.sc) : p !== this.values.stroke && (p = this.values.stroke,
                             a.strokeStyle = this.values.stroke),
                           n = (c = this.textSpans[e].elem).length,
                           this.globalData.canvasContext.beginPath(),
                           i = 0; i < n; i += 1)
                      for (s = (u = c[i]).length,
                             this.globalData.canvasContext.moveTo(u[0], u[1]),
                             r = 2; r < s; r += 6)
                        this.globalData.canvasContext.bezierCurveTo(u[r], u[r + 1], u[r + 2], u[r + 3], u[r + 4], u[r + 5]);
                    this.globalData.canvasContext.closePath(),
                      this.globalData.canvasContext.stroke()
                  }
                  o && this.globalData.renderer.restore()
                }
            }
            ,
            extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVImageElement),
            CVImageElement.prototype.initElement = SVGShapeElement.prototype.initElement,
            CVImageElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame,
            CVImageElement.prototype.createContent = function() {
              if (this.img.width && (this.assetData.w !== this.img.width || this.assetData.h !== this.img.height)) {
                var e = createTag("canvas");
                e.width = this.assetData.w,
                  e.height = this.assetData.h;
                var t, i, n = e.getContext("2d"), r = this.img.width, s = this.img.height, a = r / s, o = this.assetData.w / this.assetData.h, l = this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio;
                a > o && "xMidYMid slice" === l || a < o && "xMidYMid slice" !== l ? t = (i = s) * o : i = (t = r) / o,
                  n.drawImage(this.img, (r - t) / 2, (s - i) / 2, t, i, 0, 0, this.assetData.w, this.assetData.h),
                  this.img = e
              }
            }
            ,
            CVImageElement.prototype.renderInnerContent = function() {
              this.canvasContext.drawImage(this.img, 0, 0)
            }
            ,
            CVImageElement.prototype.destroy = function() {
              this.img = null
            }
            ,
            extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVSolidElement),
            CVSolidElement.prototype.initElement = SVGShapeElement.prototype.initElement,
            CVSolidElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame,
            CVSolidElement.prototype.renderInnerContent = function() {
              var e = this.canvasContext;
              e.fillStyle = this.data.sc,
                e.fillRect(0, 0, this.data.sw, this.data.sh)
            }
            ,
            extendPrototype([BaseRenderer], CanvasRendererBase),
            CanvasRendererBase.prototype.createShape = function(e) {
              return new CVShapeElement(e,this.globalData,this)
            }
            ,
            CanvasRendererBase.prototype.createText = function(e) {
              return new CVTextElement(e,this.globalData,this)
            }
            ,
            CanvasRendererBase.prototype.createImage = function(e) {
              return new CVImageElement(e,this.globalData,this)
            }
            ,
            CanvasRendererBase.prototype.createSolid = function(e) {
              return new CVSolidElement(e,this.globalData,this)
            }
            ,
            CanvasRendererBase.prototype.createNull = SVGRenderer.prototype.createNull,
            CanvasRendererBase.prototype.ctxTransform = function(e) {
              if (1 !== e[0] || 0 !== e[1] || 0 !== e[4] || 1 !== e[5] || 0 !== e[12] || 0 !== e[13])
                if (this.renderConfig.clearCanvas) {
                  this.transformMat.cloneFromProps(e);
                  var t = this.contextData.cTr.props;
                  this.transformMat.transform(t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8], t[9], t[10], t[11], t[12], t[13], t[14], t[15]),
                    this.contextData.cTr.cloneFromProps(this.transformMat.props);
                  var i = this.contextData.cTr.props;
                  this.canvasContext.setTransform(i[0], i[1], i[4], i[5], i[12], i[13])
                } else
                  this.canvasContext.transform(e[0], e[1], e[4], e[5], e[12], e[13])
            }
            ,
            CanvasRendererBase.prototype.ctxOpacity = function(e) {
              if (!this.renderConfig.clearCanvas)
                return this.canvasContext.globalAlpha *= e < 0 ? 0 : e,
                  void (this.globalData.currentGlobalAlpha = this.contextData.cO);
              this.contextData.cO *= e < 0 ? 0 : e,
              this.globalData.currentGlobalAlpha !== this.contextData.cO && (this.canvasContext.globalAlpha = this.contextData.cO,
                this.globalData.currentGlobalAlpha = this.contextData.cO)
            }
          ,
          CanvasRendererBase.prototype.reset = function() {
            this.renderConfig.clearCanvas ? this.contextData.reset() : this.canvasContext.restore()
          }
          ,
          CanvasRendererBase.prototype.save = function(e) {
            if (this.renderConfig.clearCanvas) {
              e && this.canvasContext.save();
              var t, i = this.contextData.cTr.props;
              this.contextData._length <= this.contextData.cArrPos && this.contextData.duplicate();
              var n = this.contextData.saved[this.contextData.cArrPos];
              for (t = 0; t < 16; t += 1)
                n[t] = i[t];
              this.contextData.savedOp[this.contextData.cArrPos] = this.contextData.cO,
                this.contextData.cArrPos += 1
            } else
              this.canvasContext.save()
          }
          ,
          CanvasRendererBase.prototype.restore = function(e) {
            if (this.renderConfig.clearCanvas) {
              e && (this.canvasContext.restore(),
                this.globalData.blendMode = "source-over"),
                this.contextData.cArrPos -= 1;
              var t, i = this.contextData.saved[this.contextData.cArrPos], n = this.contextData.cTr.props;
              for (t = 0; t < 16; t += 1)
                n[t] = i[t];
              this.canvasContext.setTransform(i[0], i[1], i[4], i[5], i[12], i[13]),
                i = this.contextData.savedOp[this.contextData.cArrPos],
                this.contextData.cO = i,
              this.globalData.currentGlobalAlpha !== i && (this.canvasContext.globalAlpha = i,
                this.globalData.currentGlobalAlpha = i)
            } else
              this.canvasContext.restore()
          }
          ,
          CanvasRendererBase.prototype.configAnimation = function(e) {
            if (this.animationItem.wrapper) {
              this.animationItem.container = createTag("canvas");
              var t = this.animationItem.container.style;
              t.width = "100%",
                t.height = "100%";
              var i = "0px 0px 0px";
              t.transformOrigin = i,
                t.mozTransformOrigin = i,
                t.webkitTransformOrigin = i,
                t["-webkit-transform"] = i,
                t.contentVisibility = this.renderConfig.contentVisibility,
                this.animationItem.wrapper.appendChild(this.animationItem.container),
                this.canvasContext = this.animationItem.container.getContext("2d"),
              this.renderConfig.className && this.animationItem.container.setAttribute("class", this.renderConfig.className),
              this.renderConfig.id && this.animationItem.container.setAttribute("id", this.renderConfig.id)
            } else
              this.canvasContext = this.renderConfig.context;
            this.data = e,
              this.layers = e.layers,
              this.transformCanvas = {
                w: e.w,
                h: e.h,
                sx: 0,
                sy: 0,
                tx: 0,
                ty: 0
              },
              this.setupGlobalData(e, document.body),
              this.globalData.canvasContext = this.canvasContext,
              this.globalData.renderer = this,
              this.globalData.isDashed = !1,
              this.globalData.progressiveLoad = this.renderConfig.progressiveLoad,
              this.globalData.transformCanvas = this.transformCanvas,
              this.elements = createSizedArray(e.layers.length),
              this.updateContainerSize()
          }
          ,
          CanvasRendererBase.prototype.updateContainerSize = function() {
            var e, t, i, n;
            if (this.reset(),
              this.animationItem.wrapper && this.animationItem.container ? (e = this.animationItem.wrapper.offsetWidth,
                t = this.animationItem.wrapper.offsetHeight,
                this.animationItem.container.setAttribute("width", e * this.renderConfig.dpr),
                this.animationItem.container.setAttribute("height", t * this.renderConfig.dpr)) : (e = this.canvasContext.canvas.width * this.renderConfig.dpr,
                t = this.canvasContext.canvas.height * this.renderConfig.dpr),
            -1 !== this.renderConfig.preserveAspectRatio.indexOf("meet") || -1 !== this.renderConfig.preserveAspectRatio.indexOf("slice")) {
              var r = this.renderConfig.preserveAspectRatio.split(" ")
                , s = r[1] || "meet"
                , a = r[0] || "xMidYMid"
                , o = a.substr(0, 4)
                , l = a.substr(4);
              i = e / t,
                (n = this.transformCanvas.w / this.transformCanvas.h) > i && "meet" === s || n < i && "slice" === s ? (this.transformCanvas.sx = e / (this.transformCanvas.w / this.renderConfig.dpr),
                  this.transformCanvas.sy = e / (this.transformCanvas.w / this.renderConfig.dpr)) : (this.transformCanvas.sx = t / (this.transformCanvas.h / this.renderConfig.dpr),
                  this.transformCanvas.sy = t / (this.transformCanvas.h / this.renderConfig.dpr)),
                this.transformCanvas.tx = "xMid" === o && (n < i && "meet" === s || n > i && "slice" === s) ? (e - this.transformCanvas.w * (t / this.transformCanvas.h)) / 2 * this.renderConfig.dpr : "xMax" === o && (n < i && "meet" === s || n > i && "slice" === s) ? (e - this.transformCanvas.w * (t / this.transformCanvas.h)) * this.renderConfig.dpr : 0,
                this.transformCanvas.ty = "YMid" === l && (n > i && "meet" === s || n < i && "slice" === s) ? (t - this.transformCanvas.h * (e / this.transformCanvas.w)) / 2 * this.renderConfig.dpr : "YMax" === l && (n > i && "meet" === s || n < i && "slice" === s) ? (t - this.transformCanvas.h * (e / this.transformCanvas.w)) * this.renderConfig.dpr : 0
            } else
              "none" === this.renderConfig.preserveAspectRatio ? (this.transformCanvas.sx = e / (this.transformCanvas.w / this.renderConfig.dpr),
                this.transformCanvas.sy = t / (this.transformCanvas.h / this.renderConfig.dpr),
                this.transformCanvas.tx = 0,
                this.transformCanvas.ty = 0) : (this.transformCanvas.sx = this.renderConfig.dpr,
                this.transformCanvas.sy = this.renderConfig.dpr,
                this.transformCanvas.tx = 0,
                this.transformCanvas.ty = 0);
            this.transformCanvas.props = [this.transformCanvas.sx, 0, 0, 0, 0, this.transformCanvas.sy, 0, 0, 0, 0, 1, 0, this.transformCanvas.tx, this.transformCanvas.ty, 0, 1],
              this.ctxTransform(this.transformCanvas.props),
              this.canvasContext.beginPath(),
              this.canvasContext.rect(0, 0, this.transformCanvas.w, this.transformCanvas.h),
              this.canvasContext.closePath(),
              this.canvasContext.clip(),
              this.renderFrame(this.renderedFrame, !0)
          }
          ,
          CanvasRendererBase.prototype.destroy = function() {
            var e;
            for (this.renderConfig.clearCanvas && this.animationItem.wrapper && (this.animationItem.wrapper.innerText = ""),
                   e = (this.layers ? this.layers.length : 0) - 1; e >= 0; e -= 1)
              this.elements[e] && this.elements[e].destroy();
            this.elements.length = 0,
              this.globalData.canvasContext = null,
              this.animationItem.container = null,
              this.destroyed = !0
          }
          ,
          CanvasRendererBase.prototype.renderFrame = function(e, t) {
            if ((this.renderedFrame !== e || !0 !== this.renderConfig.clearCanvas || t) && !this.destroyed && -1 !== e) {
              var i;
              this.renderedFrame = e,
                this.globalData.frameNum = e - this.animationItem._isFirstFrame,
                this.globalData.frameId += 1,
                this.globalData._mdf = !this.renderConfig.clearCanvas || t,
                this.globalData.projectInterface.currentFrame = e;
              var n = this.layers.length;
              for (this.completeLayers || this.checkLayers(e),
                     i = 0; i < n; i += 1)
                (this.completeLayers || this.elements[i]) && this.elements[i].prepareFrame(e - this.layers[i].st);
              if (this.globalData._mdf) {
                for (!0 === this.renderConfig.clearCanvas ? this.canvasContext.clearRect(0, 0, this.transformCanvas.w, this.transformCanvas.h) : this.save(),
                       i = n - 1; i >= 0; i -= 1)
                  (this.completeLayers || this.elements[i]) && this.elements[i].renderFrame();
                !0 !== this.renderConfig.clearCanvas && this.restore()
              }
            }
          }
          ,
          CanvasRendererBase.prototype.buildItem = function(e) {
            var t = this.elements;
            if (!t[e] && 99 !== this.layers[e].ty) {
              var i = this.createItem(this.layers[e], this, this.globalData);
              t[e] = i,
                i.initExpressions()
            }
          }
          ,
          CanvasRendererBase.prototype.checkPendingElements = function() {
            for (; this.pendingElements.length; )
              this.pendingElements.pop().checkParenting()
          }
          ,
          CanvasRendererBase.prototype.hide = function() {
            this.animationItem.container.style.display = "none"
          }
          ,
          CanvasRendererBase.prototype.show = function() {
            this.animationItem.container.style.display = "block"
          }
          ,
          extendPrototype([CanvasRendererBase, ICompElement, CVBaseElement], CVCompElement),
          CVCompElement.prototype.renderInnerContent = function() {
            var e, t = this.canvasContext;
            for (t.beginPath(),
                   t.moveTo(0, 0),
                   t.lineTo(this.data.w, 0),
                   t.lineTo(this.data.w, this.data.h),
                   t.lineTo(0, this.data.h),
                   t.lineTo(0, 0),
                   t.clip(),
                   e = this.layers.length - 1; e >= 0; e -= 1)
              (this.completeLayers || this.elements[e]) && this.elements[e].renderFrame()
          }
          ,
          CVCompElement.prototype.destroy = function() {
            var e;
            for (e = this.layers.length - 1; e >= 0; e -= 1)
              this.elements[e] && this.elements[e].destroy();
            this.layers = null,
              this.elements = null
          }
          ,
          CVCompElement.prototype.createComp = function(e) {
            return new CVCompElement(e,this.globalData,this)
          }
          ,
          extendPrototype([CanvasRendererBase], CanvasRenderer),
          CanvasRenderer.prototype.createComp = function(e) {
            return new CVCompElement(e,this.globalData,this)
          }
          ,
          HBaseElement.prototype = {
            checkBlendMode: function() {},
            initRendererElement: function() {
              this.baseElement = createTag(this.data.tg || "div"),
                this.data.hasMask ? (this.svgElement = createNS("svg"),
                  this.layerElement = createNS("g"),
                  this.maskedElement = this.layerElement,
                  this.svgElement.appendChild(this.layerElement),
                  this.baseElement.appendChild(this.svgElement)) : this.layerElement = this.baseElement,
                styleDiv(this.baseElement)
            },
            createContainerElements: function() {
              this.renderableEffectsManager = new CVEffects(this),
                this.transformedElement = this.baseElement,
                this.maskedElement = this.layerElement,
              this.data.ln && this.layerElement.setAttribute("id", this.data.ln),
              this.data.cl && this.layerElement.setAttribute("class", this.data.cl),
              0 !== this.data.bm && this.setBlendMode()
            },
            renderElement: function() {
              var e = this.transformedElement ? this.transformedElement.style : {};
              if (this.finalTransform._matMdf) {
                var t = this.finalTransform.mat.toCSS();
                e.transform = t,
                  e.webkitTransform = t
              }
              this.finalTransform._opMdf && (e.opacity = this.finalTransform.mProp.o.v)
            },
            renderFrame: function() {
              this.data.hd || this.hidden || (this.renderTransform(),
                this.renderRenderable(),
                this.renderElement(),
                this.renderInnerContent(),
              this._isFirstFrame && (this._isFirstFrame = !1))
            },
            destroy: function() {
              this.layerElement = null,
                this.transformedElement = null,
              this.matteElement && (this.matteElement = null),
              this.maskManager && (this.maskManager.destroy(),
                this.maskManager = null)
            },
            createRenderableComponents: function() {
              this.maskManager = new MaskElement(this.data,this,this.globalData)
            },
            addEffects: function() {},
            setMatte: function() {}
          },
          HBaseElement.prototype.getBaseElement = SVGBaseElement.prototype.getBaseElement,
          HBaseElement.prototype.destroyBaseElement = HBaseElement.prototype.destroy,
          HBaseElement.prototype.buildElementParenting = BaseRenderer.prototype.buildElementParenting,
          extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], HSolidElement),
          HSolidElement.prototype.createContent = function() {
            var e;
            this.data.hasMask ? ((e = createNS("rect")).setAttribute("width", this.data.sw),
              e.setAttribute("height", this.data.sh),
              e.setAttribute("fill", this.data.sc),
              this.svgElement.setAttribute("width", this.data.sw),
              this.svgElement.setAttribute("height", this.data.sh)) : ((e = createTag("div")).style.width = this.data.sw + "px",
              e.style.height = this.data.sh + "px",
              e.style.backgroundColor = this.data.sc),
              this.layerElement.appendChild(e)
          }
          ,
          extendPrototype([BaseElement, TransformElement, HSolidElement, SVGShapeElement, HBaseElement, HierarchyElement, FrameElement, RenderableElement], HShapeElement),
          HShapeElement.prototype._renderShapeFrame = HShapeElement.prototype.renderInnerContent,
          HShapeElement.prototype.createContent = function() {
            var e;
            if (this.baseElement.style.fontSize = 0,
              this.data.hasMask)
              this.layerElement.appendChild(this.shapesContainer),
                e = this.svgElement;
            else {
              e = createNS("svg");
              var t = this.comp.data ? this.comp.data : this.globalData.compSize;
              e.setAttribute("width", t.w),
                e.setAttribute("height", t.h),
                e.appendChild(this.shapesContainer),
                this.layerElement.appendChild(e)
            }
            this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.shapesContainer, 0, [], !0),
              this.filterUniqueShapes(),
              this.shapeCont = e
          }
          ,
          HShapeElement.prototype.getTransformedPoint = function(e, t) {
            var i, n = e.length;
            for (i = 0; i < n; i += 1)
              t = e[i].mProps.v.applyToPointArray(t[0], t[1], 0);
            return t
          }
          ,
          HShapeElement.prototype.calculateShapeBoundingBox = function(e, t) {
            var i, n, r, s, a, o = e.sh.v, l = e.transformers, h = o._length;
            if (!(h <= 1)) {
              for (i = 0; i < h - 1; i += 1)
                n = this.getTransformedPoint(l, o.v[i]),
                  r = this.getTransformedPoint(l, o.o[i]),
                  s = this.getTransformedPoint(l, o.i[i + 1]),
                  a = this.getTransformedPoint(l, o.v[i + 1]),
                  this.checkBounds(n, r, s, a, t);
              o.c && (n = this.getTransformedPoint(l, o.v[i]),
                r = this.getTransformedPoint(l, o.o[i]),
                s = this.getTransformedPoint(l, o.i[0]),
                a = this.getTransformedPoint(l, o.v[0]),
                this.checkBounds(n, r, s, a, t))
            }
          }
          ,
          HShapeElement.prototype.checkBounds = function(e, t, i, n, r) {
            this.getBoundsOfCurve(e, t, i, n);
            var s = this.shapeBoundingBox;
            r.x = bmMin(s.left, r.x),
              r.xMax = bmMax(s.right, r.xMax),
              r.y = bmMin(s.top, r.y),
              r.yMax = bmMax(s.bottom, r.yMax)
          }
          ,
          HShapeElement.prototype.shapeBoundingBox = {
            left: 0,
            right: 0,
            top: 0,
            bottom: 0
          },
          HShapeElement.prototype.tempBoundingBox = {
            x: 0,
            xMax: 0,
            y: 0,
            yMax: 0,
            width: 0,
            height: 0
          },
          HShapeElement.prototype.getBoundsOfCurve = function(e, t, i, n) {
            for (var r, s, a, o, l, h, c, u = [[e[0], n[0]], [e[1], n[1]]], d = 0; d < 2; ++d)
              s = 6 * e[d] - 12 * t[d] + 6 * i[d],
                r = -3 * e[d] + 9 * t[d] - 9 * i[d] + 3 * n[d],
                a = 3 * t[d] - 3 * e[d],
                s |= 0,
                a |= 0,
              0 == (r |= 0) && 0 === s || (0 === r ? (o = -a / s) > 0 && o < 1 && u[d].push(this.calculateF(o, e, t, i, n, d)) : (l = s * s - 4 * a * r) >= 0 && ((h = (-s + bmSqrt(l)) / (2 * r)) > 0 && h < 1 && u[d].push(this.calculateF(h, e, t, i, n, d)),
              (c = (-s - bmSqrt(l)) / (2 * r)) > 0 && c < 1 && u[d].push(this.calculateF(c, e, t, i, n, d))));
            this.shapeBoundingBox.left = bmMin.apply(null, u[0]),
              this.shapeBoundingBox.top = bmMin.apply(null, u[1]),
              this.shapeBoundingBox.right = bmMax.apply(null, u[0]),
              this.shapeBoundingBox.bottom = bmMax.apply(null, u[1])
          }
          ,
          HShapeElement.prototype.calculateF = function(e, t, i, n, r, s) {
            return bmPow(1 - e, 3) * t[s] + 3 * bmPow(1 - e, 2) * e * i[s] + 3 * (1 - e) * bmPow(e, 2) * n[s] + bmPow(e, 3) * r[s]
          }
          ,
          HShapeElement.prototype.calculateBoundingBox = function(e, t) {
            var i, n = e.length;
            for (i = 0; i < n; i += 1)
              e[i] && e[i].sh ? this.calculateShapeBoundingBox(e[i], t) : e[i] && e[i].it && this.calculateBoundingBox(e[i].it, t)
          }
          ,
          HShapeElement.prototype.currentBoxContains = function(e) {
            return this.currentBBox.x <= e.x && this.currentBBox.y <= e.y && this.currentBBox.width + this.currentBBox.x >= e.x + e.width && this.currentBBox.height + this.currentBBox.y >= e.y + e.height
          }
          ,
          HShapeElement.prototype.renderInnerContent = function() {
            if (this._renderShapeFrame(),
            !this.hidden && (this._isFirstFrame || this._mdf)) {
              var e = this.tempBoundingBox
                , t = 999999;
              if (e.x = t,
                e.xMax = -t,
                e.y = t,
                e.yMax = -t,
                this.calculateBoundingBox(this.itemsData, e),
                e.width = e.xMax < e.x ? 0 : e.xMax - e.x,
                e.height = e.yMax < e.y ? 0 : e.yMax - e.y,
                this.currentBoxContains(e))
                return;
              var i = !1;
              if (this.currentBBox.w !== e.width && (this.currentBBox.w = e.width,
                this.shapeCont.setAttribute("width", e.width),
                i = !0),
              this.currentBBox.h !== e.height && (this.currentBBox.h = e.height,
                this.shapeCont.setAttribute("height", e.height),
                i = !0),
              i || this.currentBBox.x !== e.x || this.currentBBox.y !== e.y) {
                this.currentBBox.w = e.width,
                  this.currentBBox.h = e.height,
                  this.currentBBox.x = e.x,
                  this.currentBBox.y = e.y,
                  this.shapeCont.setAttribute("viewBox", this.currentBBox.x + " " + this.currentBBox.y + " " + this.currentBBox.w + " " + this.currentBBox.h);
                var n = this.shapeCont.style
                  , r = "translate(" + this.currentBBox.x + "px," + this.currentBBox.y + "px)";
                n.transform = r,
                  n.webkitTransform = r
              }
            }
          }
          ,
          extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], HTextElement),
          HTextElement.prototype.createContent = function() {
            if (this.isMasked = this.checkMasks(),
              this.isMasked) {
              this.renderType = "svg",
                this.compW = this.comp.data.w,
                this.compH = this.comp.data.h,
                this.svgElement.setAttribute("width", this.compW),
                this.svgElement.setAttribute("height", this.compH);
              var e = createNS("g");
              this.maskedElement.appendChild(e),
                this.innerElem = e
            } else
              this.renderType = "html",
                this.innerElem = this.layerElement;
            this.checkParenting()
          }
          ,
          HTextElement.prototype.buildNewText = function() {
            var e = this.textProperty.currentData;
            this.renderedLetters = createSizedArray(e.l ? e.l.length : 0);
            var t = this.innerElem.style
              , i = e.fc ? this.buildColor(e.fc) : "rgba(0,0,0,0)";
            t.fill = i,
              t.color = i,
            e.sc && (t.stroke = this.buildColor(e.sc),
              t.strokeWidth = e.sw + "px");
            var n, r, s = this.globalData.fontManager.getFontByName(e.f);
            if (!this.globalData.fontManager.chars)
              if (t.fontSize = e.finalSize + "px",
                t.lineHeight = e.finalSize + "px",
                s.fClass)
                this.innerElem.className = s.fClass;
              else {
                t.fontFamily = s.fFamily;
                var a = e.fWeight
                  , o = e.fStyle;
                t.fontStyle = o,
                  t.fontWeight = a
              }
            var l, h, c, u = e.l;
            r = u.length;
            var d, p = this.mHelper, f = "", m = 0;
            for (n = 0; n < r; n += 1) {
              if (this.globalData.fontManager.chars ? (this.textPaths[m] ? l = this.textPaths[m] : ((l = createNS("path")).setAttribute("stroke-linecap", lineCapEnum[1]),
                l.setAttribute("stroke-linejoin", lineJoinEnum[2]),
                l.setAttribute("stroke-miterlimit", "4")),
              this.isMasked || (this.textSpans[m] ? c = (h = this.textSpans[m]).children[0] : ((h = createTag("div")).style.lineHeight = 0,
                (c = createNS("svg")).appendChild(l),
                styleDiv(h)))) : this.isMasked ? l = this.textPaths[m] ? this.textPaths[m] : createNS("text") : this.textSpans[m] ? (h = this.textSpans[m],
                l = this.textPaths[m]) : (styleDiv(h = createTag("span")),
                styleDiv(l = createTag("span")),
                h.appendChild(l)),
                this.globalData.fontManager.chars) {
                var g, v = this.globalData.fontManager.getCharData(e.finalText[n], s.fStyle, this.globalData.fontManager.getFontByName(e.f).fFamily);
                if (g = v ? v.data : null,
                  p.reset(),
                g && g.shapes && g.shapes.length && (d = g.shapes[0].it,
                  p.scale(e.finalSize / 100, e.finalSize / 100),
                  f = this.createPathShape(p, d),
                  l.setAttribute("d", f)),
                  this.isMasked)
                  this.innerElem.appendChild(l);
                else {
                  if (this.innerElem.appendChild(h),
                  g && g.shapes) {
                    document.body.appendChild(c);
                    var y = c.getBBox();
                    c.setAttribute("width", y.width + 2),
                      c.setAttribute("height", y.height + 2),
                      c.setAttribute("viewBox", y.x - 1 + " " + (y.y - 1) + " " + (y.width + 2) + " " + (y.height + 2));
                    var x = c.style
                      , _ = "translate(" + (y.x - 1) + "px," + (y.y - 1) + "px)";
                    x.transform = _,
                      x.webkitTransform = _,
                      u[n].yOffset = y.y - 1
                  } else
                    c.setAttribute("width", 1),
                      c.setAttribute("height", 1);
                  h.appendChild(c)
                }
              } else if (l.textContent = u[n].val,
                l.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve"),
                this.isMasked)
                this.innerElem.appendChild(l);
              else {
                this.innerElem.appendChild(h);
                var b = l.style
                  , w = "translate3d(0," + -e.finalSize / 1.2 + "px,0)";
                b.transform = w,
                  b.webkitTransform = w
              }
              this.isMasked ? this.textSpans[m] = l : this.textSpans[m] = h,
                this.textSpans[m].style.display = "block",
                this.textPaths[m] = l,
                m += 1
            }
            for (; m < this.textSpans.length; )
              this.textSpans[m].style.display = "none",
                m += 1
          }
          ,
          HTextElement.prototype.renderInnerContent = function() {
            var e;
            if (this.data.singleShape) {
              if (!this._isFirstFrame && !this.lettersChangedFlag)
                return;
              if (this.isMasked && this.finalTransform._matMdf) {
                this.svgElement.setAttribute("viewBox", -this.finalTransform.mProp.p.v[0] + " " + -this.finalTransform.mProp.p.v[1] + " " + this.compW + " " + this.compH),
                  e = this.svgElement.style;
                var t = "translate(" + -this.finalTransform.mProp.p.v[0] + "px," + -this.finalTransform.mProp.p.v[1] + "px)";
                e.transform = t,
                  e.webkitTransform = t
              }
            }
            if (this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag),
            this.lettersChangedFlag || this.textAnimator.lettersChangedFlag) {
              var i, n, r, s, a, o = 0, l = this.textAnimator.renderedLetters, h = this.textProperty.currentData.l;
              for (n = h.length,
                     i = 0; i < n; i += 1)
                h[i].n ? o += 1 : (s = this.textSpans[i],
                  a = this.textPaths[i],
                  r = l[o],
                  o += 1,
                r._mdf.m && (this.isMasked ? s.setAttribute("transform", r.m) : (s.style.webkitTransform = r.m,
                  s.style.transform = r.m)),
                  s.style.opacity = r.o,
                r.sw && r._mdf.sw && a.setAttribute("stroke-width", r.sw),
                r.sc && r._mdf.sc && a.setAttribute("stroke", r.sc),
                r.fc && r._mdf.fc && (a.setAttribute("fill", r.fc),
                  a.style.color = r.fc));
              if (this.innerElem.getBBox && !this.hidden && (this._isFirstFrame || this._mdf)) {
                var c = this.innerElem.getBBox();
                if (this.currentBBox.w !== c.width && (this.currentBBox.w = c.width,
                  this.svgElement.setAttribute("width", c.width)),
                this.currentBBox.h !== c.height && (this.currentBBox.h = c.height,
                  this.svgElement.setAttribute("height", c.height)),
                this.currentBBox.w !== c.width + 2 || this.currentBBox.h !== c.height + 2 || this.currentBBox.x !== c.x - 1 || this.currentBBox.y !== c.y - 1) {
                  this.currentBBox.w = c.width + 2,
                    this.currentBBox.h = c.height + 2,
                    this.currentBBox.x = c.x - 1,
                    this.currentBBox.y = c.y - 1,
                    this.svgElement.setAttribute("viewBox", this.currentBBox.x + " " + this.currentBBox.y + " " + this.currentBBox.w + " " + this.currentBBox.h),
                    e = this.svgElement.style;
                  var u = "translate(" + this.currentBBox.x + "px," + this.currentBBox.y + "px)";
                  e.transform = u,
                    e.webkitTransform = u
                }
              }
            }
          }
          ,
          extendPrototype([BaseElement, FrameElement, HierarchyElement], HCameraElement),
          HCameraElement.prototype.setup = function() {
            var e, t, i, n, r = this.comp.threeDElements.length;
            for (e = 0; e < r; e += 1)
              if ("3d" === (t = this.comp.threeDElements[e]).type) {
                i = t.perspectiveElem.style,
                  n = t.container.style;
                var s = this.pe.v + "px"
                  , a = "0px 0px 0px"
                  , o = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)";
                i.perspective = s,
                  i.webkitPerspective = s,
                  n.transformOrigin = a,
                  n.mozTransformOrigin = a,
                  n.webkitTransformOrigin = a,
                  i.transform = o,
                  i.webkitTransform = o
              }
          }
          ,
          HCameraElement.prototype.createElements = function() {}
          ,
          HCameraElement.prototype.hide = function() {}
          ,
          HCameraElement.prototype.renderFrame = function() {
            var e, t, i = this._isFirstFrame;
            if (this.hierarchy)
              for (t = this.hierarchy.length,
                     e = 0; e < t; e += 1)
                i = this.hierarchy[e].finalTransform.mProp._mdf || i;
            if (i || this.pe._mdf || this.p && this.p._mdf || this.px && (this.px._mdf || this.py._mdf || this.pz._mdf) || this.rx._mdf || this.ry._mdf || this.rz._mdf || this.or._mdf || this.a && this.a._mdf) {
              if (this.mat.reset(),
                this.hierarchy)
                for (e = t = this.hierarchy.length - 1; e >= 0; e -= 1) {
                  var n = this.hierarchy[e].finalTransform.mProp;
                  this.mat.translate(-n.p.v[0], -n.p.v[1], n.p.v[2]),
                    this.mat.rotateX(-n.or.v[0]).rotateY(-n.or.v[1]).rotateZ(n.or.v[2]),
                    this.mat.rotateX(-n.rx.v).rotateY(-n.ry.v).rotateZ(n.rz.v),
                    this.mat.scale(1 / n.s.v[0], 1 / n.s.v[1], 1 / n.s.v[2]),
                    this.mat.translate(n.a.v[0], n.a.v[1], n.a.v[2])
                }
              if (this.p ? this.mat.translate(-this.p.v[0], -this.p.v[1], this.p.v[2]) : this.mat.translate(-this.px.v, -this.py.v, this.pz.v),
                this.a) {
                var r;
                r = this.p ? [this.p.v[0] - this.a.v[0], this.p.v[1] - this.a.v[1], this.p.v[2] - this.a.v[2]] : [this.px.v - this.a.v[0], this.py.v - this.a.v[1], this.pz.v - this.a.v[2]];
                var s = Math.sqrt(Math.pow(r[0], 2) + Math.pow(r[1], 2) + Math.pow(r[2], 2))
                  , a = [r[0] / s, r[1] / s, r[2] / s]
                  , o = Math.sqrt(a[2] * a[2] + a[0] * a[0])
                  , l = Math.atan2(a[1], o)
                  , h = Math.atan2(a[0], -a[2]);
                this.mat.rotateY(h).rotateX(-l)
              }
              this.mat.rotateX(-this.rx.v).rotateY(-this.ry.v).rotateZ(this.rz.v),
                this.mat.rotateX(-this.or.v[0]).rotateY(-this.or.v[1]).rotateZ(this.or.v[2]),
                this.mat.translate(this.globalData.compSize.w / 2, this.globalData.compSize.h / 2, 0),
                this.mat.translate(0, 0, this.pe.v);
              var c = !this._prevMat.equals(this.mat);
              if ((c || this.pe._mdf) && this.comp.threeDElements) {
                var u, d, p;
                for (t = this.comp.threeDElements.length,
                       e = 0; e < t; e += 1)
                  if ("3d" === (u = this.comp.threeDElements[e]).type) {
                    if (c) {
                      var f = this.mat.toCSS();
                      (p = u.container.style).transform = f,
                        p.webkitTransform = f
                    }
                    this.pe._mdf && ((d = u.perspectiveElem.style).perspective = this.pe.v + "px",
                      d.webkitPerspective = this.pe.v + "px")
                  }
                this.mat.clone(this._prevMat)
              }
            }
            this._isFirstFrame = !1
          }
          ,
          HCameraElement.prototype.prepareFrame = function(e) {
            this.prepareProperties(e, !0)
          }
          ,
          HCameraElement.prototype.destroy = function() {}
          ,
          HCameraElement.prototype.getBaseElement = function() {
            return null
          }
          ,
          extendPrototype([BaseElement, TransformElement, HBaseElement, HSolidElement, HierarchyElement, FrameElement, RenderableElement], HImageElement),
          HImageElement.prototype.createContent = function() {
            var e = this.globalData.getAssetsPath(this.assetData)
              , t = new Image;
            this.data.hasMask ? (this.imageElem = createNS("image"),
              this.imageElem.setAttribute("width", this.assetData.w + "px"),
              this.imageElem.setAttribute("height", this.assetData.h + "px"),
              this.imageElem.setAttributeNS("http://www.w3.org/1999/xlink", "href", e),
              this.layerElement.appendChild(this.imageElem),
              this.baseElement.setAttribute("width", this.assetData.w),
              this.baseElement.setAttribute("height", this.assetData.h)) : this.layerElement.appendChild(t),
              t.crossOrigin = "anonymous",
              t.src = e,
            this.data.ln && this.baseElement.setAttribute("id", this.data.ln)
          }
          ,
          extendPrototype([BaseRenderer], HybridRendererBase),
          HybridRendererBase.prototype.buildItem = SVGRenderer.prototype.buildItem,
          HybridRendererBase.prototype.checkPendingElements = function() {
            for (; this.pendingElements.length; )
              this.pendingElements.pop().checkParenting()
          }
          ,
          HybridRendererBase.prototype.appendElementInPos = function(e, t) {
            var i = e.getBaseElement();
            if (i) {
              var n = this.layers[t];
              if (n.ddd && this.supports3d)
                this.addTo3dContainer(i, t);
              else if (this.threeDElements)
                this.addTo3dContainer(i, t);
              else {
                for (var r, s, a = 0; a < t; )
                  this.elements[a] && !0 !== this.elements[a] && this.elements[a].getBaseElement && (s = this.elements[a],
                    r = (this.layers[a].ddd ? this.getThreeDContainerByPos(a) : s.getBaseElement()) || r),
                    a += 1;
                r ? n.ddd && this.supports3d || this.layerElement.insertBefore(i, r) : n.ddd && this.supports3d || this.layerElement.appendChild(i)
              }
            }
          }
          ,
          HybridRendererBase.prototype.createShape = function(e) {
            return this.supports3d ? new HShapeElement(e,this.globalData,this) : new SVGShapeElement(e,this.globalData,this)
          }
          ,
          HybridRendererBase.prototype.createText = function(e) {
            return this.supports3d ? new HTextElement(e,this.globalData,this) : new SVGTextLottieElement(e,this.globalData,this)
          }
          ,
          HybridRendererBase.prototype.createCamera = function(e) {
            return this.camera = new HCameraElement(e,this.globalData,this),
              this.camera
          }
          ,
          HybridRendererBase.prototype.createImage = function(e) {
            return this.supports3d ? new HImageElement(e,this.globalData,this) : new IImageElement(e,this.globalData,this)
          }
          ,
          HybridRendererBase.prototype.createSolid = function(e) {
            return this.supports3d ? new HSolidElement(e,this.globalData,this) : new ISolidElement(e,this.globalData,this)
          }
          ,
          HybridRendererBase.prototype.createNull = SVGRenderer.prototype.createNull,
          HybridRendererBase.prototype.getThreeDContainerByPos = function(e) {
            for (var t = 0, i = this.threeDElements.length; t < i; ) {
              if (this.threeDElements[t].startPos <= e && this.threeDElements[t].endPos >= e)
                return this.threeDElements[t].perspectiveElem;
              t += 1
            }
            return null
          }
          ,
          HybridRendererBase.prototype.createThreeDContainer = function(e, t) {
            var i, n, r = createTag("div");
            styleDiv(r);
            var s = createTag("div");
            if (styleDiv(s),
            "3d" === t) {
              (i = r.style).width = this.globalData.compSize.w + "px",
                i.height = this.globalData.compSize.h + "px";
              var a = "50% 50%";
              i.webkitTransformOrigin = a,
                i.mozTransformOrigin = a,
                i.transformOrigin = a;
              var o = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)";
              (n = s.style).transform = o,
                n.webkitTransform = o
            }
            r.appendChild(s);
            var l = {
              container: s,
              perspectiveElem: r,
              startPos: e,
              endPos: e,
              type: t
            };
            return this.threeDElements.push(l),
              l
          }
          ,
          HybridRendererBase.prototype.build3dContainers = function() {
            var e, t, i = this.layers.length, n = "";
            for (e = 0; e < i; e += 1)
              this.layers[e].ddd && 3 !== this.layers[e].ty ? ("3d" !== n && (n = "3d",
                t = this.createThreeDContainer(e, "3d")),
                t.endPos = Math.max(t.endPos, e)) : ("2d" !== n && (n = "2d",
                t = this.createThreeDContainer(e, "2d")),
                t.endPos = Math.max(t.endPos, e));
            for (e = (i = this.threeDElements.length) - 1; e >= 0; e -= 1)
              this.resizerElem.appendChild(this.threeDElements[e].perspectiveElem)
          }
          ,
          HybridRendererBase.prototype.addTo3dContainer = function(e, t) {
            for (var i = 0, n = this.threeDElements.length; i < n; ) {
              if (t <= this.threeDElements[i].endPos) {
                for (var r, s = this.threeDElements[i].startPos; s < t; )
                  this.elements[s] && this.elements[s].getBaseElement && (r = this.elements[s].getBaseElement()),
                    s += 1;
                r ? this.threeDElements[i].container.insertBefore(e, r) : this.threeDElements[i].container.appendChild(e);
                break
              }
              i += 1
            }
          }
          ,
          HybridRendererBase.prototype.configAnimation = function(e) {
            var t = createTag("div")
              , i = this.animationItem.wrapper
              , n = t.style;
            n.width = e.w + "px",
              n.height = e.h + "px",
              this.resizerElem = t,
              styleDiv(t),
              n.transformStyle = "flat",
              n.mozTransformStyle = "flat",
              n.webkitTransformStyle = "flat",
            this.renderConfig.className && t.setAttribute("class", this.renderConfig.className),
              i.appendChild(t),
              n.overflow = "hidden";
            var r = createNS("svg");
            r.setAttribute("width", "1"),
              r.setAttribute("height", "1"),
              styleDiv(r),
              this.resizerElem.appendChild(r);
            var s = createNS("defs");
            r.appendChild(s),
              this.data = e,
              this.setupGlobalData(e, r),
              this.globalData.defs = s,
              this.layers = e.layers,
              this.layerElement = this.resizerElem,
              this.build3dContainers(),
              this.updateContainerSize()
          }
          ,
          HybridRendererBase.prototype.destroy = function() {
            var e;
            this.animationItem.wrapper && (this.animationItem.wrapper.innerText = ""),
              this.animationItem.container = null,
              this.globalData.defs = null;
            var t = this.layers ? this.layers.length : 0;
            for (e = 0; e < t; e += 1)
              this.elements[e].destroy();
            this.elements.length = 0,
              this.destroyed = !0,
              this.animationItem = null
          }
          ,
          HybridRendererBase.prototype.updateContainerSize = function() {
            var e, t, i, n, r = this.animationItem.wrapper.offsetWidth, s = this.animationItem.wrapper.offsetHeight, a = r / s;
            this.globalData.compSize.w / this.globalData.compSize.h > a ? (e = r / this.globalData.compSize.w,
              t = r / this.globalData.compSize.w,
              i = 0,
              n = (s - this.globalData.compSize.h * (r / this.globalData.compSize.w)) / 2) : (e = s / this.globalData.compSize.h,
              t = s / this.globalData.compSize.h,
              i = (r - this.globalData.compSize.w * (s / this.globalData.compSize.h)) / 2,
              n = 0);
            var o = this.resizerElem.style;
            o.webkitTransform = "matrix3d(" + e + ",0,0,0,0," + t + ",0,0,0,0,1,0," + i + "," + n + ",0,1)",
              o.transform = o.webkitTransform
          }
          ,
          HybridRendererBase.prototype.renderFrame = SVGRenderer.prototype.renderFrame,
          HybridRendererBase.prototype.hide = function() {
            this.resizerElem.style.display = "none"
          }
          ,
          HybridRendererBase.prototype.show = function() {
            this.resizerElem.style.display = "block"
          }
          ,
          HybridRendererBase.prototype.initItems = function() {
            if (this.buildAllItems(),
              this.camera)
              this.camera.setup();
            else {
              var e, t = this.globalData.compSize.w, i = this.globalData.compSize.h, n = this.threeDElements.length;
              for (e = 0; e < n; e += 1) {
                var r = this.threeDElements[e].perspectiveElem.style;
                r.webkitPerspective = Math.sqrt(Math.pow(t, 2) + Math.pow(i, 2)) + "px",
                  r.perspective = r.webkitPerspective
              }
            }
          }
          ,
          HybridRendererBase.prototype.searchExtraCompositions = function(e) {
            var t, i = e.length, n = createTag("div");
            for (t = 0; t < i; t += 1)
              if (e[t].xt) {
                var r = this.createComp(e[t], n, this.globalData.comp, null);
                r.initExpressions(),
                  this.globalData.projectInterface.registerComposition(r)
              }
          }
          ,
          extendPrototype([HybridRendererBase, ICompElement, HBaseElement], HCompElement),
          HCompElement.prototype._createBaseContainerElements = HCompElement.prototype.createContainerElements,
          HCompElement.prototype.createContainerElements = function() {
            this._createBaseContainerElements(),
              this.data.hasMask ? (this.svgElement.setAttribute("width", this.data.w),
                this.svgElement.setAttribute("height", this.data.h),
                this.transformedElement = this.baseElement) : this.transformedElement = this.layerElement
          }
          ,
          HCompElement.prototype.addTo3dContainer = function(e, t) {
            for (var i, n = 0; n < t; )
              this.elements[n] && this.elements[n].getBaseElement && (i = this.elements[n].getBaseElement()),
                n += 1;
            i ? this.layerElement.insertBefore(e, i) : this.layerElement.appendChild(e)
          }
          ,
          HCompElement.prototype.createComp = function(e) {
            return this.supports3d ? new HCompElement(e,this.globalData,this) : new SVGCompElement(e,this.globalData,this)
          }
          ,
          extendPrototype([HybridRendererBase], HybridRenderer),
          HybridRenderer.prototype.createComp = function(e) {
            return this.supports3d ? new HCompElement(e,this.globalData,this) : new SVGCompElement(e,this.globalData,this)
          }
          ;
          var Expressions = {
            initExpressions: function(e) {
              var t = 0
                , i = [];
              e.renderer.compInterface = CompExpressionInterface(e.renderer),
                e.renderer.globalData.projectInterface.registerComposition(e.renderer),
                e.renderer.globalData.pushExpression = function() {
                  t += 1
                }
                ,
                e.renderer.globalData.popExpression = function() {
                  0 == (t -= 1) && function() {
                    var e, t = i.length;
                    for (e = 0; e < t; e += 1)
                      i[e].release();
                    i.length = 0
                  }()
                }
                ,
                e.renderer.globalData.registerExpressionProperty = function(e) {
                  -1 === i.indexOf(e) && i.push(e)
                }
            }
          };
          function _typeof$1(e) {
            return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                return typeof e
              }
              : function(e) {
                return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
              }
              ,
              _typeof$1(e)
          }
          function seedRandom(e, t) {
            var i = this
              , n = 256
              , r = t.pow(n, 6)
              , s = t.pow(2, 52)
              , a = 2 * s
              , o = 255;
            function l(e) {
              var t, i = e.length, r = this, s = 0, a = r.i = r.j = 0, l = r.S = [];
              for (i || (e = [i++]); s < n; )
                l[s] = s++;
              for (s = 0; s < n; s++)
                l[s] = l[a = o & a + e[s % i] + (t = l[s])],
                  l[a] = t;
              r.g = function(e) {
                for (var t, i = 0, s = r.i, a = r.j, l = r.S; e--; )
                  t = l[s = o & s + 1],
                    i = i * n + l[o & (l[s] = l[a = o & a + t]) + (l[a] = t)];
                return r.i = s,
                  r.j = a,
                  i
              }
            }
            function h(e, t) {
              return t.i = e.i,
                t.j = e.j,
                t.S = e.S.slice(),
                t
            }
            function c(e, t) {
              var i, n = [], r = _typeof$1(e);
              if (t && "object" == r)
                for (i in e)
                  try {
                    n.push(c(e[i], t - 1))
                  } catch (e) {}
              return n.length ? n : "string" == r ? e : e + "\0"
            }
            function u(e, t) {
              for (var i, n = e + "", r = 0; r < n.length; )
                t[o & r] = o & (i ^= 19 * t[o & r]) + n.charCodeAt(r++);
              return d(t)
            }
            function d(e) {
              return String.fromCharCode.apply(0, e)
            }
            t.seedrandom = function(o, p, f) {
              var m = []
                , g = u(c((p = !0 === p ? {
                entropy: !0
              } : p || {}).entropy ? [o, d(e)] : null === o ? function() {
                try {
                  var t = new Uint8Array(n);
                  return (i.crypto || i.msCrypto).getRandomValues(t),
                    d(t)
                } catch (t) {
                  var r = i.navigator
                    , s = r && r.plugins;
                  return [+new Date, i, s, i.screen, d(e)]
                }
              }() : o, 3), m)
                , v = new l(m)
                , y = function() {
                for (var e = v.g(6), t = r, i = 0; e < s; )
                  e = (e + i) * n,
                    t *= n,
                    i = v.g(1);
                for (; e >= a; )
                  e /= 2,
                    t /= 2,
                    i >>>= 1;
                return (e + i) / t
              };
              return y.int32 = function() {
                return 0 | v.g(4)
              }
                ,
                y.quick = function() {
                  return v.g(4) / 4294967296
                }
                ,
                y.double = y,
                u(d(v.S), e),
                (p.pass || f || function(e, i, n, r) {
                    return r && (r.S && h(r, v),
                        e.state = function() {
                          return h(v, {})
                        }
                    ),
                      n ? (t.random = e,
                        i) : e
                  }
                )(y, g, "global"in p ? p.global : this == t, p.state)
            }
              ,
              u(t.random(), e)
          }
          function initialize$2(e) {
            seedRandom([], e)
          }
          var propTypes = {
            SHAPE: "shape"
          };
          function _typeof(e) {
            return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                return typeof e
              }
              : function(e) {
                return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
              }
              ,
              _typeof(e)
          }
          var ExpressionManager = function() {
            var ob = {}
              , Math = BMMath
              , window = null
              , document = null
              , XMLHttpRequest = null
              , fetch = null
              , frames = null;
            function $bm_isInstanceOfArray(e) {
              return e.constructor === Array || e.constructor === Float32Array
            }
            function isNumerable(e, t) {
              return "number" === e || "boolean" === e || "string" === e || t instanceof Number
            }
            function $bm_neg(e) {
              var t = _typeof(e);
              if ("number" === t || "boolean" === t || e instanceof Number)
                return -e;
              if ($bm_isInstanceOfArray(e)) {
                var i, n = e.length, r = [];
                for (i = 0; i < n; i += 1)
                  r[i] = -e[i];
                return r
              }
              return e.propType ? e.v : -e
            }
            initialize$2(BMMath);
            var easeInBez = BezierFactory.getBezierEasing(.333, 0, .833, .833, "easeIn").get
              , easeOutBez = BezierFactory.getBezierEasing(.167, .167, .667, 1, "easeOut").get
              , easeInOutBez = BezierFactory.getBezierEasing(.33, 0, .667, 1, "easeInOut").get;
            function sum(e, t) {
              var i = _typeof(e)
                , n = _typeof(t);
              if ("string" === i || "string" === n)
                return e + t;
              if (isNumerable(i, e) && isNumerable(n, t))
                return e + t;
              if ($bm_isInstanceOfArray(e) && isNumerable(n, t))
                return (e = e.slice(0))[0] += t,
                  e;
              if (isNumerable(i, e) && $bm_isInstanceOfArray(t))
                return (t = t.slice(0))[0] = e + t[0],
                  t;
              if ($bm_isInstanceOfArray(e) && $bm_isInstanceOfArray(t)) {
                for (var r = 0, s = e.length, a = t.length, o = []; r < s || r < a; )
                  ("number" == typeof e[r] || e[r]instanceof Number) && ("number" == typeof t[r] || t[r]instanceof Number) ? o[r] = e[r] + t[r] : o[r] = void 0 === t[r] ? e[r] : e[r] || t[r],
                    r += 1;
                return o
              }
              return 0
            }
            var add = sum;
            function sub(e, t) {
              var i = _typeof(e)
                , n = _typeof(t);
              if (isNumerable(i, e) && isNumerable(n, t))
                return "string" === i && (e = parseInt(e, 10)),
                "string" === n && (t = parseInt(t, 10)),
                e - t;
              if ($bm_isInstanceOfArray(e) && isNumerable(n, t))
                return (e = e.slice(0))[0] -= t,
                  e;
              if (isNumerable(i, e) && $bm_isInstanceOfArray(t))
                return (t = t.slice(0))[0] = e - t[0],
                  t;
              if ($bm_isInstanceOfArray(e) && $bm_isInstanceOfArray(t)) {
                for (var r = 0, s = e.length, a = t.length, o = []; r < s || r < a; )
                  ("number" == typeof e[r] || e[r]instanceof Number) && ("number" == typeof t[r] || t[r]instanceof Number) ? o[r] = e[r] - t[r] : o[r] = void 0 === t[r] ? e[r] : e[r] || t[r],
                    r += 1;
                return o
              }
              return 0
            }
            function mul(e, t) {
              var i, n, r, s = _typeof(e), a = _typeof(t);
              if (isNumerable(s, e) && isNumerable(a, t))
                return e * t;
              if ($bm_isInstanceOfArray(e) && isNumerable(a, t)) {
                for (r = e.length,
                       i = createTypedArray("float32", r),
                       n = 0; n < r; n += 1)
                  i[n] = e[n] * t;
                return i
              }
              if (isNumerable(s, e) && $bm_isInstanceOfArray(t)) {
                for (r = t.length,
                       i = createTypedArray("float32", r),
                       n = 0; n < r; n += 1)
                  i[n] = e * t[n];
                return i
              }
              return 0
            }
            function div(e, t) {
              var i, n, r, s = _typeof(e), a = _typeof(t);
              if (isNumerable(s, e) && isNumerable(a, t))
                return e / t;
              if ($bm_isInstanceOfArray(e) && isNumerable(a, t)) {
                for (r = e.length,
                       i = createTypedArray("float32", r),
                       n = 0; n < r; n += 1)
                  i[n] = e[n] / t;
                return i
              }
              if (isNumerable(s, e) && $bm_isInstanceOfArray(t)) {
                for (r = t.length,
                       i = createTypedArray("float32", r),
                       n = 0; n < r; n += 1)
                  i[n] = e / t[n];
                return i
              }
              return 0
            }
            function mod(e, t) {
              return "string" == typeof e && (e = parseInt(e, 10)),
              "string" == typeof t && (t = parseInt(t, 10)),
              e % t
            }
            var $bm_sum = sum
              , $bm_sub = sub
              , $bm_mul = mul
              , $bm_div = div
              , $bm_mod = mod;
            function clamp(e, t, i) {
              if (t > i) {
                var n = i;
                i = t,
                  t = n
              }
              return Math.min(Math.max(e, t), i)
            }
            function radiansToDegrees(e) {
              return e / degToRads
            }
            var radians_to_degrees = radiansToDegrees;
            function degreesToRadians(e) {
              return e * degToRads
            }
            var degrees_to_radians = radiansToDegrees
              , helperLengthArray = [0, 0, 0, 0, 0, 0];
            function length(e, t) {
              if ("number" == typeof e || e instanceof Number)
                return t = t || 0,
                  Math.abs(e - t);
              var i;
              t || (t = helperLengthArray);
              var n = Math.min(e.length, t.length)
                , r = 0;
              for (i = 0; i < n; i += 1)
                r += Math.pow(t[i] - e[i], 2);
              return Math.sqrt(r)
            }
            function normalize(e) {
              return div(e, length(e))
            }
            function rgbToHsl(e) {
              var t, i, n = e[0], r = e[1], s = e[2], a = Math.max(n, r, s), o = Math.min(n, r, s), l = (a + o) / 2;
              if (a === o)
                t = 0,
                  i = 0;
              else {
                var h = a - o;
                switch (i = l > .5 ? h / (2 - a - o) : h / (a + o),
                  a) {
                  case n:
                    t = (r - s) / h + (r < s ? 6 : 0);
                    break;
                  case r:
                    t = (s - n) / h + 2;
                    break;
                  case s:
                    t = (n - r) / h + 4
                }
                t /= 6
              }
              return [t, i, l, e[3]]
            }
            function hue2rgb(e, t, i) {
              return i < 0 && (i += 1),
              i > 1 && (i -= 1),
                i < 1 / 6 ? e + 6 * (t - e) * i : i < .5 ? t : i < 2 / 3 ? e + (t - e) * (2 / 3 - i) * 6 : e
            }
            function hslToRgb(e) {
              var t, i, n, r = e[0], s = e[1], a = e[2];
              if (0 === s)
                t = a,
                  n = a,
                  i = a;
              else {
                var o = a < .5 ? a * (1 + s) : a + s - a * s
                  , l = 2 * a - o;
                t = hue2rgb(l, o, r + 1 / 3),
                  i = hue2rgb(l, o, r),
                  n = hue2rgb(l, o, r - 1 / 3)
              }
              return [t, i, n, e[3]]
            }
            function linear(e, t, i, n, r) {
              if (void 0 !== n && void 0 !== r || (n = t,
                r = i,
                t = 0,
                i = 1),
              i < t) {
                var s = i;
                i = t,
                  t = s
              }
              if (e <= t)
                return n;
              if (e >= i)
                return r;
              var a, o = i === t ? 0 : (e - t) / (i - t);
              if (!n.length)
                return n + (r - n) * o;
              var l = n.length
                , h = createTypedArray("float32", l);
              for (a = 0; a < l; a += 1)
                h[a] = n[a] + (r[a] - n[a]) * o;
              return h
            }
            function random(e, t) {
              if (void 0 === t && (void 0 === e ? (e = 0,
                t = 1) : (t = e,
                e = void 0)),
                t.length) {
                var i, n = t.length;
                e || (e = createTypedArray("float32", n));
                var r = createTypedArray("float32", n)
                  , s = BMMath.random();
                for (i = 0; i < n; i += 1)
                  r[i] = e[i] + s * (t[i] - e[i]);
                return r
              }
              return void 0 === e && (e = 0),
              e + BMMath.random() * (t - e)
            }
            function createPath(e, t, i, n) {
              var r, s = e.length, a = shapePool.newElement();
              a.setPathData(!!n, s);
              var o, l, h = [0, 0];
              for (r = 0; r < s; r += 1)
                o = t && t[r] ? t[r] : h,
                  l = i && i[r] ? i[r] : h,
                  a.setTripleAt(e[r][0], e[r][1], l[0] + e[r][0], l[1] + e[r][1], o[0] + e[r][0], o[1] + e[r][1], r, !0);
              return a
            }
            function initiateExpression(elem, data, property) {
              var val = data.x, needsVelocity = /velocity(?![\w\d])/.test(val), _needsRandom = -1 !== val.indexOf("random"), elemType = elem.data.ty, transform, $bm_transform, content, effect, thisProperty = property;
              thisProperty.valueAtTime = thisProperty.getValueAtTime,
                Object.defineProperty(thisProperty, "value", {
                  get: function() {
                    return thisProperty.v
                  }
                }),
                elem.comp.frameDuration = 1 / elem.comp.globalData.frameRate,
                elem.comp.displayStartTime = 0;
              var inPoint = elem.data.ip / elem.comp.globalData.frameRate, outPoint = elem.data.op / elem.comp.globalData.frameRate, width = elem.data.sw ? elem.data.sw : 0, height = elem.data.sh ? elem.data.sh : 0, name = elem.data.nm, loopIn, loop_in, loopOut, loop_out, smooth, toWorld, fromWorld, fromComp, toComp, fromCompToSurface, position, rotation, anchorPoint, scale, thisLayer, thisComp, mask, valueAtTime, velocityAtTime, scoped_bm_rt, expression_function = eval("[function _expression_function(){" + val + ";scoped_bm_rt=$bm_rt}]")[0], numKeys = property.kf ? data.k.length : 0, active = !this.data || !0 !== this.data.hd, wiggle = function(e, t) {
                var i, n, r = this.pv.length ? this.pv.length : 1, s = createTypedArray("float32", r), a = Math.floor(5 * time);
                for (i = 0,
                       n = 0; i < a; ) {
                  for (n = 0; n < r; n += 1)
                    s[n] += -t + 2 * t * BMMath.random();
                  i += 1
                }
                var o = 5 * time
                  , l = o - Math.floor(o)
                  , h = createTypedArray("float32", r);
                if (r > 1) {
                  for (n = 0; n < r; n += 1)
                    h[n] = this.pv[n] + s[n] + (-t + 2 * t * BMMath.random()) * l;
                  return h
                }
                return this.pv + s[0] + (-t + 2 * t * BMMath.random()) * l
              }
                .bind(this);
              function loopInDuration(e, t) {
                return loopIn(e, t, !0)
              }
              function loopOutDuration(e, t) {
                return loopOut(e, t, !0)
              }
              thisProperty.loopIn && (loopIn = thisProperty.loopIn.bind(thisProperty),
                loop_in = loopIn),
              thisProperty.loopOut && (loopOut = thisProperty.loopOut.bind(thisProperty),
                loop_out = loopOut),
              thisProperty.smooth && (smooth = thisProperty.smooth.bind(thisProperty)),
              this.getValueAtTime && (valueAtTime = this.getValueAtTime.bind(this)),
              this.getVelocityAtTime && (velocityAtTime = this.getVelocityAtTime.bind(this));
              var comp = elem.comp.globalData.projectInterface.bind(elem.comp.globalData.projectInterface), time, velocity, value, text, textIndex, textTotal, selectorValue;
              function lookAt(e, t) {
                var i = [t[0] - e[0], t[1] - e[1], t[2] - e[2]]
                  , n = Math.atan2(i[0], Math.sqrt(i[1] * i[1] + i[2] * i[2])) / degToRads;
                return [-Math.atan2(i[1], i[2]) / degToRads, n, 0]
              }
              function easeOut(e, t, i, n, r) {
                return applyEase(easeOutBez, e, t, i, n, r)
              }
              function easeIn(e, t, i, n, r) {
                return applyEase(easeInBez, e, t, i, n, r)
              }
              function ease(e, t, i, n, r) {
                return applyEase(easeInOutBez, e, t, i, n, r)
              }
              function applyEase(e, t, i, n, r, s) {
                void 0 === r ? (r = i,
                  s = n) : t = (t - i) / (n - i),
                  t > 1 ? t = 1 : t < 0 && (t = 0);
                var a = e(t);
                if ($bm_isInstanceOfArray(r)) {
                  var o, l = r.length, h = createTypedArray("float32", l);
                  for (o = 0; o < l; o += 1)
                    h[o] = (s[o] - r[o]) * a + r[o];
                  return h
                }
                return (s - r) * a + r
              }
              function nearestKey(e) {
                var t, i, n, r = data.k.length;
                if (data.k.length && "number" != typeof data.k[0])
                  if (i = -1,
                  (e *= elem.comp.globalData.frameRate) < data.k[0].t)
                    i = 1,
                      n = data.k[0].t;
                  else {
                    for (t = 0; t < r - 1; t += 1) {
                      if (e === data.k[t].t) {
                        i = t + 1,
                          n = data.k[t].t;
                        break
                      }
                      if (e > data.k[t].t && e < data.k[t + 1].t) {
                        e - data.k[t].t > data.k[t + 1].t - e ? (i = t + 2,
                          n = data.k[t + 1].t) : (i = t + 1,
                          n = data.k[t].t);
                        break
                      }
                    }
                    -1 === i && (i = t + 1,
                      n = data.k[t].t)
                  }
                else
                  i = 0,
                    n = 0;
                var s = {};
                return s.index = i,
                  s.time = n / elem.comp.globalData.frameRate,
                  s
              }
              function key(e) {
                var t, i, n;
                if (!data.k.length || "number" == typeof data.k[0])
                  throw new Error("The property has no keyframe at index " + e);
                e -= 1,
                  t = {
                    time: data.k[e].t / elem.comp.globalData.frameRate,
                    value: []
                  };
                var r = Object.prototype.hasOwnProperty.call(data.k[e], "s") ? data.k[e].s : data.k[e - 1].e;
                for (n = r.length,
                       i = 0; i < n; i += 1)
                  t[i] = r[i],
                    t.value[i] = r[i];
                return t
              }
              function framesToTime(e, t) {
                return t || (t = elem.comp.globalData.frameRate),
                e / t
              }
              function timeToFrames(e, t) {
                return e || 0 === e || (e = time),
                t || (t = elem.comp.globalData.frameRate),
                e * t
              }
              function seedRandom(e) {
                BMMath.seedrandom(randSeed + e)
              }
              function sourceRectAtTime() {
                return elem.sourceRectAtTime()
              }
              function substring(e, t) {
                return "string" == typeof value ? void 0 === t ? value.substring(e) : value.substring(e, t) : ""
              }
              function substr(e, t) {
                return "string" == typeof value ? void 0 === t ? value.substr(e) : value.substr(e, t) : ""
              }
              function posterizeTime(e) {
                time = 0 === e ? 0 : Math.floor(time * e) / e,
                  value = valueAtTime(time)
              }
              var index = elem.data.ind, hasParent = !(!elem.hierarchy || !elem.hierarchy.length), parent, randSeed = Math.floor(1e6 * Math.random()), globalData = elem.globalData;
              function executeExpression(e) {
                return value = e,
                  this.frameExpressionId === elem.globalData.frameId && "textSelector" !== this.propType ? value : ("textSelector" === this.propType && (textIndex = this.textIndex,
                    textTotal = this.textTotal,
                    selectorValue = this.selectorValue),
                  thisLayer || (text = elem.layerInterface.text,
                    thisLayer = elem.layerInterface,
                    thisComp = elem.comp.compInterface,
                    toWorld = thisLayer.toWorld.bind(thisLayer),
                    fromWorld = thisLayer.fromWorld.bind(thisLayer),
                    fromComp = thisLayer.fromComp.bind(thisLayer),
                    toComp = thisLayer.toComp.bind(thisLayer),
                    mask = thisLayer.mask ? thisLayer.mask.bind(thisLayer) : null,
                    fromCompToSurface = fromComp),
                  transform || (transform = elem.layerInterface("ADBE Transform Group"),
                    $bm_transform = transform,
                  transform && (anchorPoint = transform.anchorPoint)),
                  4 !== elemType || content || (content = thisLayer("ADBE Root Vectors Group")),
                  effect || (effect = thisLayer(4)),
                  (hasParent = !(!elem.hierarchy || !elem.hierarchy.length)) && !parent && (parent = elem.hierarchy[0].layerInterface),
                    time = this.comp.renderedFrame / this.comp.globalData.frameRate,
                  _needsRandom && seedRandom(randSeed + time),
                  needsVelocity && (velocity = velocityAtTime(time)),
                    expression_function(),
                    this.frameExpressionId = elem.globalData.frameId,
                    scoped_bm_rt = scoped_bm_rt.propType === propTypes.SHAPE ? scoped_bm_rt.v : scoped_bm_rt)
              }
              return executeExpression.__preventDeadCodeRemoval = [$bm_transform, anchorPoint, time, velocity, inPoint, outPoint, width, height, name, loop_in, loop_out, smooth, toComp, fromCompToSurface, toWorld, fromWorld, mask, position, rotation, scale, thisComp, numKeys, active, wiggle, loopInDuration, loopOutDuration, comp, lookAt, easeOut, easeIn, ease, nearestKey, key, text, textIndex, textTotal, selectorValue, framesToTime, timeToFrames, sourceRectAtTime, substring, substr, posterizeTime, index, globalData],
                executeExpression
            }
            return ob.initiateExpression = initiateExpression,
              ob.__preventDeadCodeRemoval = [window, document, XMLHttpRequest, fetch, frames, $bm_neg, add, $bm_sum, $bm_sub, $bm_mul, $bm_div, $bm_mod, clamp, radians_to_degrees, degreesToRadians, degrees_to_radians, normalize, rgbToHsl, hslToRgb, linear, random, createPath],
              ob
          }()
            , expressionHelpers = {
            searchExpressions: function(e, t, i) {
              t.x && (i.k = !0,
                i.x = !0,
                i.initiateExpression = ExpressionManager.initiateExpression,
                i.effectsSequence.push(i.initiateExpression(e, t, i).bind(i)))
            },
            getSpeedAtTime: function(e) {
              var t = this.getValueAtTime(e)
                , i = this.getValueAtTime(e + -.01)
                , n = 0;
              if (t.length) {
                var r;
                for (r = 0; r < t.length; r += 1)
                  n += Math.pow(i[r] - t[r], 2);
                n = 100 * Math.sqrt(n)
              } else
                n = 0;
              return n
            },
            getVelocityAtTime: function(e) {
              if (void 0 !== this.vel)
                return this.vel;
              var t, i, n = -.001, r = this.getValueAtTime(e), s = this.getValueAtTime(e + n);
              if (r.length)
                for (t = createTypedArray("float32", r.length),
                       i = 0; i < r.length; i += 1)
                  t[i] = (s[i] - r[i]) / n;
              else
                t = (s - r) / n;
              return t
            },
            getValueAtTime: function(e) {
              return e *= this.elem.globalData.frameRate,
              (e -= this.offsetTime) !== this._cachingAtTime.lastFrame && (this._cachingAtTime.lastIndex = this._cachingAtTime.lastFrame < e ? this._cachingAtTime.lastIndex : 0,
                this._cachingAtTime.value = this.interpolateValue(e, this._cachingAtTime),
                this._cachingAtTime.lastFrame = e),
                this._cachingAtTime.value
            },
            getStaticValueAtTime: function() {
              return this.pv
            },
            setGroupProperty: function(e) {
              this.propertyGroup = e
            }
          };
          function addPropertyDecorator() {
            function e(e, t, i) {
              if (!this.k || !this.keyframes)
                return this.pv;
              e = e ? e.toLowerCase() : "";
              var n, r, s, a, o, l = this.comp.renderedFrame, h = this.keyframes, c = h[h.length - 1].t;
              if (l <= c)
                return this.pv;
              if (i ? r = c - (n = t ? Math.abs(c - this.elem.comp.globalData.frameRate * t) : Math.max(0, c - this.elem.data.ip)) : ((!t || t > h.length - 1) && (t = h.length - 1),
                n = c - (r = h[h.length - 1 - t].t)),
              "pingpong" === e) {
                if (Math.floor((l - r) / n) % 2 != 0)
                  return this.getValueAtTime((n - (l - r) % n + r) / this.comp.globalData.frameRate, 0)
              } else {
                if ("offset" === e) {
                  var u = this.getValueAtTime(r / this.comp.globalData.frameRate, 0)
                    , d = this.getValueAtTime(c / this.comp.globalData.frameRate, 0)
                    , p = this.getValueAtTime(((l - r) % n + r) / this.comp.globalData.frameRate, 0)
                    , f = Math.floor((l - r) / n);
                  if (this.pv.length) {
                    for (a = (o = new Array(u.length)).length,
                           s = 0; s < a; s += 1)
                      o[s] = (d[s] - u[s]) * f + p[s];
                    return o
                  }
                  return (d - u) * f + p
                }
                if ("continue" === e) {
                  var m = this.getValueAtTime(c / this.comp.globalData.frameRate, 0)
                    , g = this.getValueAtTime((c - .001) / this.comp.globalData.frameRate, 0);
                  if (this.pv.length) {
                    for (a = (o = new Array(m.length)).length,
                           s = 0; s < a; s += 1)
                      o[s] = m[s] + (m[s] - g[s]) * ((l - c) / this.comp.globalData.frameRate) / 5e-4;
                    return o
                  }
                  return m + (l - c) / .001 * (m - g)
                }
              }
              return this.getValueAtTime(((l - r) % n + r) / this.comp.globalData.frameRate, 0)
            }
            function t(e, t, i) {
              if (!this.k)
                return this.pv;
              e = e ? e.toLowerCase() : "";
              var n, r, s, a, o, l = this.comp.renderedFrame, h = this.keyframes, c = h[0].t;
              if (l >= c)
                return this.pv;
              if (i ? r = c + (n = t ? Math.abs(this.elem.comp.globalData.frameRate * t) : Math.max(0, this.elem.data.op - c)) : ((!t || t > h.length - 1) && (t = h.length - 1),
                n = (r = h[t].t) - c),
              "pingpong" === e) {
                if (Math.floor((c - l) / n) % 2 == 0)
                  return this.getValueAtTime(((c - l) % n + c) / this.comp.globalData.frameRate, 0)
              } else {
                if ("offset" === e) {
                  var u = this.getValueAtTime(c / this.comp.globalData.frameRate, 0)
                    , d = this.getValueAtTime(r / this.comp.globalData.frameRate, 0)
                    , p = this.getValueAtTime((n - (c - l) % n + c) / this.comp.globalData.frameRate, 0)
                    , f = Math.floor((c - l) / n) + 1;
                  if (this.pv.length) {
                    for (a = (o = new Array(u.length)).length,
                           s = 0; s < a; s += 1)
                      o[s] = p[s] - (d[s] - u[s]) * f;
                    return o
                  }
                  return p - (d - u) * f
                }
                if ("continue" === e) {
                  var m = this.getValueAtTime(c / this.comp.globalData.frameRate, 0)
                    , g = this.getValueAtTime((c + .001) / this.comp.globalData.frameRate, 0);
                  if (this.pv.length) {
                    for (a = (o = new Array(m.length)).length,
                           s = 0; s < a; s += 1)
                      o[s] = m[s] + (m[s] - g[s]) * (c - l) / .001;
                    return o
                  }
                  return m + (m - g) * (c - l) / .001
                }
              }
              return this.getValueAtTime((n - ((c - l) % n + c)) / this.comp.globalData.frameRate, 0)
            }
            function i(e, t) {
              if (!this.k)
                return this.pv;
              if (e = .5 * (e || .4),
              (t = Math.floor(t || 5)) <= 1)
                return this.pv;
              var i, n, r = this.comp.renderedFrame / this.comp.globalData.frameRate, s = r - e, a = t > 1 ? (r + e - s) / (t - 1) : 1, o = 0, l = 0;
              for (i = this.pv.length ? createTypedArray("float32", this.pv.length) : 0; o < t; ) {
                if (n = this.getValueAtTime(s + o * a),
                  this.pv.length)
                  for (l = 0; l < this.pv.length; l += 1)
                    i[l] += n[l];
                else
                  i += n;
                o += 1
              }
              if (this.pv.length)
                for (l = 0; l < this.pv.length; l += 1)
                  i[l] /= t;
              else
                i /= t;
              return i
            }
            function n(e) {
              this._transformCachingAtTime || (this._transformCachingAtTime = {
                v: new Matrix
              });
              var t = this._transformCachingAtTime.v;
              if (t.cloneFromProps(this.pre.props),
              this.appliedTransformations < 1) {
                var i = this.a.getValueAtTime(e);
                t.translate(-i[0] * this.a.mult, -i[1] * this.a.mult, i[2] * this.a.mult)
              }
              if (this.appliedTransformations < 2) {
                var n = this.s.getValueAtTime(e);
                t.scale(n[0] * this.s.mult, n[1] * this.s.mult, n[2] * this.s.mult)
              }
              if (this.sk && this.appliedTransformations < 3) {
                var r = this.sk.getValueAtTime(e)
                  , s = this.sa.getValueAtTime(e);
                t.skewFromAxis(-r * this.sk.mult, s * this.sa.mult)
              }
              if (this.r && this.appliedTransformations < 4) {
                var a = this.r.getValueAtTime(e);
                t.rotate(-a * this.r.mult)
              } else if (!this.r && this.appliedTransformations < 4) {
                var o = this.rz.getValueAtTime(e)
                  , l = this.ry.getValueAtTime(e)
                  , h = this.rx.getValueAtTime(e)
                  , c = this.or.getValueAtTime(e);
                t.rotateZ(-o * this.rz.mult).rotateY(l * this.ry.mult).rotateX(h * this.rx.mult).rotateZ(-c[2] * this.or.mult).rotateY(c[1] * this.or.mult).rotateX(c[0] * this.or.mult)
              }
              if (this.data.p && this.data.p.s) {
                var u = this.px.getValueAtTime(e)
                  , d = this.py.getValueAtTime(e);
                if (this.data.p.z) {
                  var p = this.pz.getValueAtTime(e);
                  t.translate(u * this.px.mult, d * this.py.mult, -p * this.pz.mult)
                } else
                  t.translate(u * this.px.mult, d * this.py.mult, 0)
              } else {
                var f = this.p.getValueAtTime(e);
                t.translate(f[0] * this.p.mult, f[1] * this.p.mult, -f[2] * this.p.mult)
              }
              return t
            }
            function r() {
              return this.v.clone(new Matrix)
            }
            var s = TransformPropertyFactory.getTransformProperty;
            TransformPropertyFactory.getTransformProperty = function(e, t, i) {
              var a = s(e, t, i);
              return a.dynamicProperties.length ? a.getValueAtTime = n.bind(a) : a.getValueAtTime = r.bind(a),
                a.setGroupProperty = expressionHelpers.setGroupProperty,
                a
            }
            ;
            var a = PropertyFactory.getProp;
            PropertyFactory.getProp = function(n, r, s, o, l) {
              var h = a(n, r, s, o, l);
              h.kf ? h.getValueAtTime = expressionHelpers.getValueAtTime.bind(h) : h.getValueAtTime = expressionHelpers.getStaticValueAtTime.bind(h),
                h.setGroupProperty = expressionHelpers.setGroupProperty,
                h.loopOut = e,
                h.loopIn = t,
                h.smooth = i,
                h.getVelocityAtTime = expressionHelpers.getVelocityAtTime.bind(h),
                h.getSpeedAtTime = expressionHelpers.getSpeedAtTime.bind(h),
                h.numKeys = 1 === r.a ? r.k.length : 0,
                h.propertyIndex = r.ix;
              var c = 0;
              return 0 !== s && (c = createTypedArray("float32", 1 === r.a ? r.k[0].s.length : r.k.length)),
                h._cachingAtTime = {
                  lastFrame: initialDefaultFrame,
                  lastIndex: 0,
                  value: c
                },
                expressionHelpers.searchExpressions(n, r, h),
              h.k && l.addDynamicProperty(h),
                h
            }
            ;
            var o = ShapePropertyFactory.getConstructorFunction()
              , l = ShapePropertyFactory.getKeyframedConstructorFunction();
            function h() {}
            h.prototype = {
              vertices: function(e, t) {
                this.k && this.getValue();
                var i, n = this.v;
                void 0 !== t && (n = this.getValueAtTime(t, 0));
                var r = n._length
                  , s = n[e]
                  , a = n.v
                  , o = createSizedArray(r);
                for (i = 0; i < r; i += 1)
                  o[i] = "i" === e || "o" === e ? [s[i][0] - a[i][0], s[i][1] - a[i][1]] : [s[i][0], s[i][1]];
                return o
              },
              points: function(e) {
                return this.vertices("v", e)
              },
              inTangents: function(e) {
                return this.vertices("i", e)
              },
              outTangents: function(e) {
                return this.vertices("o", e)
              },
              isClosed: function() {
                return this.v.c
              },
              pointOnPath: function(e, t) {
                var i = this.v;
                void 0 !== t && (i = this.getValueAtTime(t, 0)),
                this._segmentsLength || (this._segmentsLength = bez.getSegmentsLength(i));
                for (var n, r = this._segmentsLength, s = r.lengths, a = r.totalLength * e, o = 0, l = s.length, h = 0; o < l; ) {
                  if (h + s[o].addedLength > a) {
                    var c = o
                      , u = i.c && o === l - 1 ? 0 : o + 1
                      , d = (a - h) / s[o].addedLength;
                    n = bez.getPointInSegment(i.v[c], i.v[u], i.o[c], i.i[u], d, s[o]);
                    break
                  }
                  h += s[o].addedLength,
                    o += 1
                }
                return n || (n = i.c ? [i.v[0][0], i.v[0][1]] : [i.v[i._length - 1][0], i.v[i._length - 1][1]]),
                  n
              },
              vectorOnPath: function(e, t, i) {
                1 == e ? e = this.v.c : 0 == e && (e = .999);
                var n = this.pointOnPath(e, t)
                  , r = this.pointOnPath(e + .001, t)
                  , s = r[0] - n[0]
                  , a = r[1] - n[1]
                  , o = Math.sqrt(Math.pow(s, 2) + Math.pow(a, 2));
                return 0 === o ? [0, 0] : "tangent" === i ? [s / o, a / o] : [-a / o, s / o]
              },
              tangentOnPath: function(e, t) {
                return this.vectorOnPath(e, t, "tangent")
              },
              normalOnPath: function(e, t) {
                return this.vectorOnPath(e, t, "normal")
              },
              setGroupProperty: expressionHelpers.setGroupProperty,
              getValueAtTime: expressionHelpers.getStaticValueAtTime
            },
              extendPrototype([h], o),
              extendPrototype([h], l),
              l.prototype.getValueAtTime = function(e) {
                return this._cachingAtTime || (this._cachingAtTime = {
                  shapeValue: shapePool.clone(this.pv),
                  lastIndex: 0,
                  lastTime: initialDefaultFrame
                }),
                  e *= this.elem.globalData.frameRate,
                (e -= this.offsetTime) !== this._cachingAtTime.lastTime && (this._cachingAtTime.lastIndex = this._cachingAtTime.lastTime < e ? this._caching.lastIndex : 0,
                  this._cachingAtTime.lastTime = e,
                  this.interpolateShape(e, this._cachingAtTime.shapeValue, this._cachingAtTime)),
                  this._cachingAtTime.shapeValue
              }
              ,
              l.prototype.initiateExpression = ExpressionManager.initiateExpression;
            var c = ShapePropertyFactory.getShapeProp;
            ShapePropertyFactory.getShapeProp = function(e, t, i, n, r) {
              var s = c(e, t, i, n, r);
              return s.propertyIndex = t.ix,
                s.lock = !1,
                3 === i ? expressionHelpers.searchExpressions(e, t.pt, s) : 4 === i && expressionHelpers.searchExpressions(e, t.ks, s),
              s.k && e.addDynamicProperty(s),
                s
            }
          }
          function initialize$1() {
            addPropertyDecorator()
          }
          function addDecorator() {
            TextProperty.prototype.getExpressionValue = function(e, t) {
              var i = this.calculateExpression(t);
              if (e.t !== i) {
                var n = {};
                return this.copyData(n, e),
                  n.t = i.toString(),
                  n.__complete = !1,
                  n
              }
              return e
            }
              ,
              TextProperty.prototype.searchProperty = function() {
                var e = this.searchKeyframes()
                  , t = this.searchExpressions();
                return this.kf = e || t,
                  this.kf
              }
              ,
              TextProperty.prototype.searchExpressions = function() {
                return this.data.d.x ? (this.calculateExpression = ExpressionManager.initiateExpression.bind(this)(this.elem, this.data.d, this),
                  this.addEffect(this.getExpressionValue.bind(this)),
                  !0) : null
              }
          }
          function initialize() {
            addDecorator()
          }
          function SVGComposableEffect() {}
          function SVGTintFilter(e, t, i, n, r) {
            this.filterManager = t;
            var s = createNS("feColorMatrix");
            s.setAttribute("type", "matrix"),
              s.setAttribute("color-interpolation-filters", "linearRGB"),
              s.setAttribute("values", "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0"),
              s.setAttribute("result", n + "_tint_1"),
              e.appendChild(s),
              (s = createNS("feColorMatrix")).setAttribute("type", "matrix"),
              s.setAttribute("color-interpolation-filters", "sRGB"),
              s.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0"),
              s.setAttribute("result", n + "_tint_2"),
              e.appendChild(s),
              this.matrixFilter = s;
            var a = this.createMergeNode(n, [r, n + "_tint_1", n + "_tint_2"]);
            e.appendChild(a)
          }
          function SVGFillFilter(e, t, i, n) {
            this.filterManager = t;
            var r = createNS("feColorMatrix");
            r.setAttribute("type", "matrix"),
              r.setAttribute("color-interpolation-filters", "sRGB"),
              r.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0"),
              r.setAttribute("result", n),
              e.appendChild(r),
              this.matrixFilter = r
          }
          function SVGStrokeEffect(e, t, i) {
            this.initialized = !1,
              this.filterManager = t,
              this.elem = i,
              this.paths = []
          }
          function SVGTritoneFilter(e, t, i, n) {
            this.filterManager = t;
            var r = createNS("feColorMatrix");
            r.setAttribute("type", "matrix"),
              r.setAttribute("color-interpolation-filters", "linearRGB"),
              r.setAttribute("values", "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0"),
              e.appendChild(r);
            var s = createNS("feComponentTransfer");
            s.setAttribute("color-interpolation-filters", "sRGB"),
              s.setAttribute("result", n),
              this.matrixFilter = s;
            var a = createNS("feFuncR");
            a.setAttribute("type", "table"),
              s.appendChild(a),
              this.feFuncR = a;
            var o = createNS("feFuncG");
            o.setAttribute("type", "table"),
              s.appendChild(o),
              this.feFuncG = o;
            var l = createNS("feFuncB");
            l.setAttribute("type", "table"),
              s.appendChild(l),
              this.feFuncB = l,
              e.appendChild(s)
          }
          function SVGProLevelsFilter(e, t, i, n) {
            this.filterManager = t;
            var r = this.filterManager.effectElements
              , s = createNS("feComponentTransfer");
            (r[10].p.k || 0 !== r[10].p.v || r[11].p.k || 1 !== r[11].p.v || r[12].p.k || 1 !== r[12].p.v || r[13].p.k || 0 !== r[13].p.v || r[14].p.k || 1 !== r[14].p.v) && (this.feFuncR = this.createFeFunc("feFuncR", s)),
            (r[17].p.k || 0 !== r[17].p.v || r[18].p.k || 1 !== r[18].p.v || r[19].p.k || 1 !== r[19].p.v || r[20].p.k || 0 !== r[20].p.v || r[21].p.k || 1 !== r[21].p.v) && (this.feFuncG = this.createFeFunc("feFuncG", s)),
            (r[24].p.k || 0 !== r[24].p.v || r[25].p.k || 1 !== r[25].p.v || r[26].p.k || 1 !== r[26].p.v || r[27].p.k || 0 !== r[27].p.v || r[28].p.k || 1 !== r[28].p.v) && (this.feFuncB = this.createFeFunc("feFuncB", s)),
            (r[31].p.k || 0 !== r[31].p.v || r[32].p.k || 1 !== r[32].p.v || r[33].p.k || 1 !== r[33].p.v || r[34].p.k || 0 !== r[34].p.v || r[35].p.k || 1 !== r[35].p.v) && (this.feFuncA = this.createFeFunc("feFuncA", s)),
            (this.feFuncR || this.feFuncG || this.feFuncB || this.feFuncA) && (s.setAttribute("color-interpolation-filters", "sRGB"),
              e.appendChild(s)),
            (r[3].p.k || 0 !== r[3].p.v || r[4].p.k || 1 !== r[4].p.v || r[5].p.k || 1 !== r[5].p.v || r[6].p.k || 0 !== r[6].p.v || r[7].p.k || 1 !== r[7].p.v) && ((s = createNS("feComponentTransfer")).setAttribute("color-interpolation-filters", "sRGB"),
              s.setAttribute("result", n),
              e.appendChild(s),
              this.feFuncRComposed = this.createFeFunc("feFuncR", s),
              this.feFuncGComposed = this.createFeFunc("feFuncG", s),
              this.feFuncBComposed = this.createFeFunc("feFuncB", s))
          }
          function SVGDropShadowEffect(e, t, i, n, r) {
            var s = t.container.globalData.renderConfig.filterSize;
            e.setAttribute("x", s.x),
              e.setAttribute("y", s.y),
              e.setAttribute("width", s.width),
              e.setAttribute("height", s.height),
              this.filterManager = t;
            var a = createNS("feGaussianBlur");
            a.setAttribute("in", "SourceAlpha"),
              a.setAttribute("result", n + "_drop_shadow_1"),
              a.setAttribute("stdDeviation", "0"),
              this.feGaussianBlur = a,
              e.appendChild(a);
            var o = createNS("feOffset");
            o.setAttribute("dx", "25"),
              o.setAttribute("dy", "0"),
              o.setAttribute("in", n + "_drop_shadow_1"),
              o.setAttribute("result", n + "_drop_shadow_2"),
              this.feOffset = o,
              e.appendChild(o);
            var l = createNS("feFlood");
            l.setAttribute("flood-color", "#00ff00"),
              l.setAttribute("flood-opacity", "1"),
              l.setAttribute("result", n + "_drop_shadow_3"),
              this.feFlood = l,
              e.appendChild(l);
            var h = createNS("feComposite");
            h.setAttribute("in", n + "_drop_shadow_3"),
              h.setAttribute("in2", n + "_drop_shadow_2"),
              h.setAttribute("operator", "in"),
              h.setAttribute("result", n + "_drop_shadow_4"),
              e.appendChild(h);
            var c = this.createMergeNode(n, [n + "_drop_shadow_4", r]);
            e.appendChild(c)
          }
          SVGComposableEffect.prototype = {
            createMergeNode: function(e, t) {
              var i, n, r = createNS("feMerge");
              for (r.setAttribute("result", e),
                     n = 0; n < t.length; n += 1)
                (i = createNS("feMergeNode")).setAttribute("in", t[n]),
                  r.appendChild(i),
                  r.appendChild(i);
              return r
            }
          },
            extendPrototype([SVGComposableEffect], SVGTintFilter),
            SVGTintFilter.prototype.renderFrame = function(e) {
              if (e || this.filterManager._mdf) {
                var t = this.filterManager.effectElements[0].p.v
                  , i = this.filterManager.effectElements[1].p.v
                  , n = this.filterManager.effectElements[2].p.v / 100;
                this.matrixFilter.setAttribute("values", i[0] - t[0] + " 0 0 0 " + t[0] + " " + (i[1] - t[1]) + " 0 0 0 " + t[1] + " " + (i[2] - t[2]) + " 0 0 0 " + t[2] + " 0 0 0 " + n + " 0")
              }
            }
            ,
            SVGFillFilter.prototype.renderFrame = function(e) {
              if (e || this.filterManager._mdf) {
                var t = this.filterManager.effectElements[2].p.v
                  , i = this.filterManager.effectElements[6].p.v;
                this.matrixFilter.setAttribute("values", "0 0 0 0 " + t[0] + " 0 0 0 0 " + t[1] + " 0 0 0 0 " + t[2] + " 0 0 0 " + i + " 0")
              }
            }
            ,
            SVGStrokeEffect.prototype.initialize = function() {
              var e, t, i, n, r = this.elem.layerElement.children || this.elem.layerElement.childNodes;
              for (1 === this.filterManager.effectElements[1].p.v ? (n = this.elem.maskManager.masksProperties.length,
                i = 0) : n = 1 + (i = this.filterManager.effectElements[0].p.v - 1),
                     (t = createNS("g")).setAttribute("fill", "none"),
                     t.setAttribute("stroke-linecap", "round"),
                     t.setAttribute("stroke-dashoffset", 1); i < n; i += 1)
                e = createNS("path"),
                  t.appendChild(e),
                  this.paths.push({
                    p: e,
                    m: i
                  });
              if (3 === this.filterManager.effectElements[10].p.v) {
                var s = createNS("mask")
                  , a = createElementID();
                s.setAttribute("id", a),
                  s.setAttribute("mask-type", "alpha"),
                  s.appendChild(t),
                  this.elem.globalData.defs.appendChild(s);
                var o = createNS("g");
                for (o.setAttribute("mask", "url(" + getLocationHref() + "#" + a + ")"); r[0]; )
                  o.appendChild(r[0]);
                this.elem.layerElement.appendChild(o),
                  this.masker = s,
                  t.setAttribute("stroke", "#fff")
              } else if (1 === this.filterManager.effectElements[10].p.v || 2 === this.filterManager.effectElements[10].p.v) {
                if (2 === this.filterManager.effectElements[10].p.v)
                  for (r = this.elem.layerElement.children || this.elem.layerElement.childNodes; r.length; )
                    this.elem.layerElement.removeChild(r[0]);
                this.elem.layerElement.appendChild(t),
                  this.elem.layerElement.removeAttribute("mask"),
                  t.setAttribute("stroke", "#fff")
              }
              this.initialized = !0,
                this.pathMasker = t
            }
            ,
            SVGStrokeEffect.prototype.renderFrame = function(e) {
              var t;
              this.initialized || this.initialize();
              var i, n, r = this.paths.length;
              for (t = 0; t < r; t += 1)
                if (-1 !== this.paths[t].m && (i = this.elem.maskManager.viewData[this.paths[t].m],
                  n = this.paths[t].p,
                (e || this.filterManager._mdf || i.prop._mdf) && n.setAttribute("d", i.lastPath),
                e || this.filterManager.effectElements[9].p._mdf || this.filterManager.effectElements[4].p._mdf || this.filterManager.effectElements[7].p._mdf || this.filterManager.effectElements[8].p._mdf || i.prop._mdf)) {
                  var s;
                  if (0 !== this.filterManager.effectElements[7].p.v || 100 !== this.filterManager.effectElements[8].p.v) {
                    var a = .01 * Math.min(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v)
                      , o = .01 * Math.max(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v)
                      , l = n.getTotalLength();
                    s = "0 0 0 " + l * a + " ";
                    var h, c = l * (o - a), u = 1 + 2 * this.filterManager.effectElements[4].p.v * this.filterManager.effectElements[9].p.v * .01, d = Math.floor(c / u);
                    for (h = 0; h < d; h += 1)
                      s += "1 " + 2 * this.filterManager.effectElements[4].p.v * this.filterManager.effectElements[9].p.v * .01 + " ";
                    s += "0 " + 10 * l + " 0 0"
                  } else
                    s = "1 " + 2 * this.filterManager.effectElements[4].p.v * this.filterManager.effectElements[9].p.v * .01;
                  n.setAttribute("stroke-dasharray", s)
                }
              if ((e || this.filterManager.effectElements[4].p._mdf) && this.pathMasker.setAttribute("stroke-width", 2 * this.filterManager.effectElements[4].p.v),
              (e || this.filterManager.effectElements[6].p._mdf) && this.pathMasker.setAttribute("opacity", this.filterManager.effectElements[6].p.v),
              (1 === this.filterManager.effectElements[10].p.v || 2 === this.filterManager.effectElements[10].p.v) && (e || this.filterManager.effectElements[3].p._mdf)) {
                var p = this.filterManager.effectElements[3].p.v;
                this.pathMasker.setAttribute("stroke", "rgb(" + bmFloor(255 * p[0]) + "," + bmFloor(255 * p[1]) + "," + bmFloor(255 * p[2]) + ")")
              }
            }
            ,
            SVGTritoneFilter.prototype.renderFrame = function(e) {
              if (e || this.filterManager._mdf) {
                var t = this.filterManager.effectElements[0].p.v
                  , i = this.filterManager.effectElements[1].p.v
                  , n = this.filterManager.effectElements[2].p.v
                  , r = n[0] + " " + i[0] + " " + t[0]
                  , s = n[1] + " " + i[1] + " " + t[1]
                  , a = n[2] + " " + i[2] + " " + t[2];
                this.feFuncR.setAttribute("tableValues", r),
                  this.feFuncG.setAttribute("tableValues", s),
                  this.feFuncB.setAttribute("tableValues", a)
              }
            }
            ,
            SVGProLevelsFilter.prototype.createFeFunc = function(e, t) {
              var i = createNS(e);
              return i.setAttribute("type", "table"),
                t.appendChild(i),
                i
            }
            ,
            SVGProLevelsFilter.prototype.getTableValue = function(e, t, i, n, r) {
              for (var s, a, o = 0, l = Math.min(e, t), h = Math.max(e, t), c = Array.call(null, {
                length: 256
              }), u = 0, d = r - n, p = t - e; o <= 256; )
                a = (s = o / 256) <= l ? p < 0 ? r : n : s >= h ? p < 0 ? n : r : n + d * Math.pow((s - e) / p, 1 / i),
                  c[u] = a,
                  u += 1,
                  o += 256 / 255;
              return c.join(" ")
            }
            ,
            SVGProLevelsFilter.prototype.renderFrame = function(e) {
              if (e || this.filterManager._mdf) {
                var t, i = this.filterManager.effectElements;
                this.feFuncRComposed && (e || i[3].p._mdf || i[4].p._mdf || i[5].p._mdf || i[6].p._mdf || i[7].p._mdf) && (t = this.getTableValue(i[3].p.v, i[4].p.v, i[5].p.v, i[6].p.v, i[7].p.v),
                  this.feFuncRComposed.setAttribute("tableValues", t),
                  this.feFuncGComposed.setAttribute("tableValues", t),
                  this.feFuncBComposed.setAttribute("tableValues", t)),
                this.feFuncR && (e || i[10].p._mdf || i[11].p._mdf || i[12].p._mdf || i[13].p._mdf || i[14].p._mdf) && (t = this.getTableValue(i[10].p.v, i[11].p.v, i[12].p.v, i[13].p.v, i[14].p.v),
                  this.feFuncR.setAttribute("tableValues", t)),
                this.feFuncG && (e || i[17].p._mdf || i[18].p._mdf || i[19].p._mdf || i[20].p._mdf || i[21].p._mdf) && (t = this.getTableValue(i[17].p.v, i[18].p.v, i[19].p.v, i[20].p.v, i[21].p.v),
                  this.feFuncG.setAttribute("tableValues", t)),
                this.feFuncB && (e || i[24].p._mdf || i[25].p._mdf || i[26].p._mdf || i[27].p._mdf || i[28].p._mdf) && (t = this.getTableValue(i[24].p.v, i[25].p.v, i[26].p.v, i[27].p.v, i[28].p.v),
                  this.feFuncB.setAttribute("tableValues", t)),
                this.feFuncA && (e || i[31].p._mdf || i[32].p._mdf || i[33].p._mdf || i[34].p._mdf || i[35].p._mdf) && (t = this.getTableValue(i[31].p.v, i[32].p.v, i[33].p.v, i[34].p.v, i[35].p.v),
                  this.feFuncA.setAttribute("tableValues", t))
              }
            }
            ,
            extendPrototype([SVGComposableEffect], SVGDropShadowEffect),
            SVGDropShadowEffect.prototype.renderFrame = function(e) {
              if (e || this.filterManager._mdf) {
                if ((e || this.filterManager.effectElements[4].p._mdf) && this.feGaussianBlur.setAttribute("stdDeviation", this.filterManager.effectElements[4].p.v / 4),
                e || this.filterManager.effectElements[0].p._mdf) {
                  var t = this.filterManager.effectElements[0].p.v;
                  this.feFlood.setAttribute("flood-color", rgbToHex(Math.round(255 * t[0]), Math.round(255 * t[1]), Math.round(255 * t[2])))
                }
                if ((e || this.filterManager.effectElements[1].p._mdf) && this.feFlood.setAttribute("flood-opacity", this.filterManager.effectElements[1].p.v / 255),
                e || this.filterManager.effectElements[2].p._mdf || this.filterManager.effectElements[3].p._mdf) {
                  var i = this.filterManager.effectElements[3].p.v
                    , n = (this.filterManager.effectElements[2].p.v - 90) * degToRads
                    , r = i * Math.cos(n)
                    , s = i * Math.sin(n);
                  this.feOffset.setAttribute("dx", r),
                    this.feOffset.setAttribute("dy", s)
                }
              }
            }
          ;
          var _svgMatteSymbols = [];
          function SVGMatte3Effect(e, t, i) {
            this.initialized = !1,
              this.filterManager = t,
              this.filterElem = e,
              this.elem = i,
              i.matteElement = createNS("g"),
              i.matteElement.appendChild(i.layerElement),
              i.matteElement.appendChild(i.transformedElement),
              i.baseElement = i.matteElement
          }
          function SVGGaussianBlurEffect(e, t, i, n) {
            e.setAttribute("x", "-100%"),
              e.setAttribute("y", "-100%"),
              e.setAttribute("width", "300%"),
              e.setAttribute("height", "300%"),
              this.filterManager = t;
            var r = createNS("feGaussianBlur");
            r.setAttribute("result", n),
              e.appendChild(r),
              this.feGaussianBlur = r
          }
          return SVGMatte3Effect.prototype.findSymbol = function(e) {
            for (var t = 0, i = _svgMatteSymbols.length; t < i; ) {
              if (_svgMatteSymbols[t] === e)
                return _svgMatteSymbols[t];
              t += 1
            }
            return null
          }
            ,
            SVGMatte3Effect.prototype.replaceInParent = function(e, t) {
              var i = e.layerElement.parentNode;
              if (i) {
                for (var n, r = i.children, s = 0, a = r.length; s < a && r[s] !== e.layerElement; )
                  s += 1;
                s <= a - 2 && (n = r[s + 1]);
                var o = createNS("use");
                o.setAttribute("href", "#" + t),
                  n ? i.insertBefore(o, n) : i.appendChild(o)
              }
            }
            ,
            SVGMatte3Effect.prototype.setElementAsMask = function(e, t) {
              if (!this.findSymbol(t)) {
                var i = createElementID()
                  , n = createNS("mask");
                n.setAttribute("id", t.layerId),
                  n.setAttribute("mask-type", "alpha"),
                  _svgMatteSymbols.push(t);
                var r = e.globalData.defs;
                r.appendChild(n);
                var s = createNS("symbol");
                s.setAttribute("id", i),
                  this.replaceInParent(t, i),
                  s.appendChild(t.layerElement),
                  r.appendChild(s);
                var a = createNS("use");
                a.setAttribute("href", "#" + i),
                  n.appendChild(a),
                  t.data.hd = !1,
                  t.show()
              }
              e.setMatte(t.layerId)
            }
            ,
            SVGMatte3Effect.prototype.initialize = function() {
              for (var e = this.filterManager.effectElements[0].p.v, t = this.elem.comp.elements, i = 0, n = t.length; i < n; )
                t[i] && t[i].data.ind === e && this.setElementAsMask(this.elem, t[i]),
                  i += 1;
              this.initialized = !0
            }
            ,
            SVGMatte3Effect.prototype.renderFrame = function() {
              this.initialized || this.initialize()
            }
            ,
            SVGGaussianBlurEffect.prototype.renderFrame = function(e) {
              if (e || this.filterManager._mdf) {
                var t = .3 * this.filterManager.effectElements[0].p.v
                  , i = this.filterManager.effectElements[1].p.v
                  , n = 3 == i ? 0 : t
                  , r = 2 == i ? 0 : t;
                this.feGaussianBlur.setAttribute("stdDeviation", n + " " + r);
                var s = 1 == this.filterManager.effectElements[2].p.v ? "wrap" : "duplicate";
                this.feGaussianBlur.setAttribute("edgeMode", s)
              }
            }
            ,
            registerRenderer("canvas", CanvasRenderer),
            registerRenderer("html", HybridRenderer),
            registerRenderer("svg", SVGRenderer),
            ShapeModifiers.registerModifier("tm", TrimModifier),
            ShapeModifiers.registerModifier("pb", PuckerAndBloatModifier),
            ShapeModifiers.registerModifier("rp", RepeaterModifier),
            ShapeModifiers.registerModifier("rd", RoundCornersModifier),
            setExpressionsPlugin(Expressions),
            initialize$1(),
            initialize(),
            registerEffect(20, SVGTintFilter, !0),
            registerEffect(21, SVGFillFilter, !0),
            registerEffect(22, SVGStrokeEffect, !1),
            registerEffect(23, SVGTritoneFilter, !0),
            registerEffect(24, SVGProLevelsFilter, !0),
            registerEffect(25, SVGDropShadowEffect, !0),
            registerEffect(28, SVGMatte3Effect, !1),
            registerEffect(29, SVGGaussianBlurEffect, !0),
            lottie
        }
          ,
          module.exports = factory())
      },
      796: (e,t,i)=>{
        e.exports = i(643)
      }
      ,
      264: e=>{
        "use strict";
        var t = !("undefined" == typeof window || !window.document || !window.document.createElement)
          , i = {
          canUseDOM: t,
          canUseWorkers: "undefined" != typeof Worker,
          canUseEventListeners: t && !(!window.addEventListener && !window.attachEvent),
          canUseViewport: t && !!window.screen,
          isInWorker: !t
        };
        e.exports = i
      }
      ,
      518: e=>{
        var t, i, n, r, s, a, o, l, h, c, u, d, p, f, m, g = !1;
        function v() {
          if (!g) {
            g = !0;
            var e = navigator.userAgent
              , v = /(?:MSIE.(\d+\.\d+))|(?:(?:Firefox|GranParadiso|Iceweasel).(\d+\.\d+))|(?:Opera(?:.+Version.|.)(\d+\.\d+))|(?:AppleWebKit.(\d+(?:\.\d+)?))|(?:Trident\/\d+\.\d+.*rv:(\d+\.\d+))/.exec(e)
              , y = /(Mac OS X)|(Windows)|(Linux)/.exec(e);
            if (d = /\b(iPhone|iP[ao]d)/.exec(e),
              p = /\b(iP[ao]d)/.exec(e),
              c = /Android/i.exec(e),
              f = /FBAN\/\w+;/i.exec(e),
              m = /Mobile/i.exec(e),
              u = !!/Win64/.exec(e),
              v) {
              (t = v[1] ? parseFloat(v[1]) : v[5] ? parseFloat(v[5]) : NaN) && document && document.documentMode && (t = document.documentMode);
              var x = /(?:Trident\/(\d+.\d+))/.exec(e);
              a = x ? parseFloat(x[1]) + 4 : t,
                i = v[2] ? parseFloat(v[2]) : NaN,
                n = v[3] ? parseFloat(v[3]) : NaN,
                (r = v[4] ? parseFloat(v[4]) : NaN) ? (v = /(?:Chrome\/(\d+\.\d+))/.exec(e),
                  s = v && v[1] ? parseFloat(v[1]) : NaN) : s = NaN
            } else
              t = i = n = s = r = NaN;
            if (y) {
              if (y[1]) {
                var _ = /(?:Mac OS X (\d+(?:[._]\d+)?))/.exec(e);
                o = !_ || parseFloat(_[1].replace("_", "."))
              } else
                o = !1;
              l = !!y[2],
                h = !!y[3]
            } else
              o = l = h = !1
          }
        }
        var y = {
          ie: function() {
            return v() || t
          },
          ieCompatibilityMode: function() {
            return v() || a > t
          },
          ie64: function() {
            return y.ie() && u
          },
          firefox: function() {
            return v() || i
          },
          opera: function() {
            return v() || n
          },
          webkit: function() {
            return v() || r
          },
          safari: function() {
            return y.webkit()
          },
          chrome: function() {
            return v() || s
          },
          windows: function() {
            return v() || l
          },
          osx: function() {
            return v() || o
          },
          linux: function() {
            return v() || h
          },
          iphone: function() {
            return v() || d
          },
          mobile: function() {
            return v() || d || p || c || m
          },
          nativeApp: function() {
            return v() || f
          },
          android: function() {
            return v() || c
          },
          ipad: function() {
            return v() || p
          }
        };
        e.exports = y
      }
      ,
      534: (e,t,i)=>{
        "use strict";
        var n, r = i(264);
        r.canUseDOM && (n = document.implementation && document.implementation.hasFeature && !0 !== document.implementation.hasFeature("", "")),
          e.exports = function(e, t) {
            if (!r.canUseDOM || t && !("addEventListener"in document))
              return !1;
            var i = "on" + e
              , s = i in document;
            if (!s) {
              var a = document.createElement("div");
              a.setAttribute(i, "return;"),
                s = "function" == typeof a[i]
            }
            return !s && n && "wheel" === e && (s = document.implementation.hasFeature("Events.wheel", "3.0")),
              s
          }
      }
      ,
      643: (e,t,i)=>{
        "use strict";
        var n = i(518)
          , r = i(534);
        function s(e) {
          var t = 0
            , i = 0
            , n = 0
            , r = 0;
          return "detail"in e && (i = e.detail),
          "wheelDelta"in e && (i = -e.wheelDelta / 120),
          "wheelDeltaY"in e && (i = -e.wheelDeltaY / 120),
          "wheelDeltaX"in e && (t = -e.wheelDeltaX / 120),
          "axis"in e && e.axis === e.HORIZONTAL_AXIS && (t = i,
            i = 0),
            n = 10 * t,
            r = 10 * i,
          "deltaY"in e && (r = e.deltaY),
          "deltaX"in e && (n = e.deltaX),
          (n || r) && e.deltaMode && (1 == e.deltaMode ? (n *= 40,
            r *= 40) : (n *= 800,
            r *= 800)),
          n && !t && (t = n < 1 ? -1 : 1),
          r && !i && (i = r < 1 ? -1 : 1),
            {
              spinX: t,
              spinY: i,
              pixelX: n,
              pixelY: r
            }
        }
        s.getEventType = function() {
          return n.firefox() ? "DOMMouseScroll" : r("wheel") ? "wheel" : "mousewheel"
        }
          ,
          e.exports = s
      }
      ,
      690: (e,t,i)=>{
        "use strict";
        // e.exports = i.p + "8069ffca34f7abec8f31.mp3"
      }
      ,
      689: (e,t,i)=>{
        "use strict";
        // e.exports = i.p + "6ca15b60fc13e83999ca.mp3"
      }
      ,
      783: (e,t,i)=>{
        "use strict";
        // e.exports = i.p + "152989251ccdc1b521b7.mp3"
      }
      ,
      966: (e,t,i)=>{
        "use strict";
        // e.exports = i.p + "e123bb992ebe4c317c10.mp3"
      }
      ,
      314: (e,t,i)=>{
        "use strict";
        // e.exports = i.p + "4ee96395e07a04577aab.ttf"
      }
      ,
      145: (e,t,i)=>{
        "use strict";
        // e.exports = i.p + "86e747d8b10ce7e39527.otf"
      }
      ,
      73: (e,t,i)=>{
        "use strict";
        e.exports = i.p + "446c446a8a06cd725832.svg"
      }
      ,
      531: (e,t,i)=>{
        "use strict";
        e.exports = i.p + "d7ca8e53d93f0c4d5484.json"
      }
      ,
      701: (e,t,i)=>{
        "use strict";
        e.exports = i.p + "ff1931f754696ae28e15.json"
      }
    }
      , __webpack_module_cache__ = {};
    function __webpack_require__(e) {
      var t = __webpack_module_cache__[e];
      if (void 0 !== t)
        return t.exports;
      var i = __webpack_module_cache__[e] = {
        exports: {}
      };
      return __webpack_modules__[e].call(i.exports, i, i.exports, __webpack_require__),
        i.exports
    }
    __webpack_require__.amdO = {},
      __webpack_require__.n = e=>{
        var t = e && e.__esModule ? ()=>e.default : ()=>e;
        return __webpack_require__.d(t, {
          a: t
        }),
          t
      }
      ,
      __webpack_require__.d = (e,t)=>{
        for (var i in t)
          __webpack_require__.o(t, i) && !__webpack_require__.o(e, i) && Object.defineProperty(e, i, {
            enumerable: !0,
            get: t[i]
          })
      }
      ,
      __webpack_require__.g = function() {
        if ("object" == typeof globalThis)
          return globalThis;
        try {
          return this || new Function("return this")()
        } catch (e) {
          if ("object" == typeof window)
            return window
        }
      }(),
      __webpack_require__.o = (e,t)=>Object.prototype.hasOwnProperty.call(e, t),
      __webpack_require__.r = e=>{
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
          value: "Module"
        }),
          Object.defineProperty(e, "__esModule", {
            value: !0
          })
      }
      ,
      (()=>{
          var e;
          __webpack_require__.g.importScripts && (e = __webpack_require__.g.location + "");
          var t = __webpack_require__.g.document;
          if (!e && t && (t.currentScript && (e = t.currentScript.src),
            !e)) {
            var i = t.getElementsByTagName("script");
            i.length && (e = i[i.length - 1].src)
          }
          if (!e)
            throw new Error("Automatic publicPath is not supported in this browser");
          e = e.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/"),
            __webpack_require__.p = e
        }
      )();
    var __webpack_exports__ = {};
    (()=>{
        "use strict";
        var e = {};
        __webpack_require__.r(e),
          __webpack_require__.d(e, {
            clip: ()=>Qp,
            crossswap: ()=>Yp,
            depth: ()=>Kp,
            fade: ()=>Hp,
            gradient: ()=>jp,
            linearblur: ()=>Zp,
            morph: ()=>Xp,
            waveclip: ()=>Wp,
            windowslice: ()=>Jp,
            zoomincircles: ()=>qp
          });
        var t = {};
        __webpack_require__.r(t),
          __webpack_require__.d(t, {
            beforeLeave: ()=>sf,
            enter: ()=>hf,
            leave: ()=>of,
            onBeforeLeave: ()=>rf,
            onEnter: ()=>lf,
            onLeave: ()=>af
          });
        var i = function() {
          var e = 0
            , t = document.createElement("div");
          function n(e) {
            return t.appendChild(e.dom),
              e
          }
          function r(i) {
            for (var n = 0; n < t.children.length; n++)
              t.children[n].style.display = n === i ? "block" : "none";
            e = i
          }
          t.style.cssText = "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000",
            t.addEventListener("click", (function(i) {
                i.preventDefault(),
                  r(++e % t.children.length)
              }
            ), !1);
          var s = (performance || Date).now()
            , a = s
            , o = 0
            , l = n(new i.Panel("FPS","#0ff","#002"))
            , h = n(new i.Panel("MS","#0f0","#020"));
          if (self.performance && self.performance.memory)
            var c = n(new i.Panel("MB","#f08","#201"));
          return r(0),
            {
              REVISION: 16,
              dom: t,
              addPanel: n,
              showPanel: r,
              begin: function() {
                s = (performance || Date).now()
              },
              end: function() {
                o++;
                var e = (performance || Date).now();
                if (h.update(e - s, 200),
                e >= a + 1e3 && (l.update(1e3 * o / (e - a), 100),
                  a = e,
                  o = 0,
                  c)) {
                  var t = performance.memory;
                  c.update(t.usedJSHeapSize / 1048576, t.jsHeapSizeLimit / 1048576)
                }
                return e
              },
              update: function() {
                s = this.end()
              },
              domElement: t,
              setMode: r
            }
        };
        function n(e) {
          if (void 0 === e)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return e
        }
        function r(e, t) {
          e.prototype = Object.create(t.prototype),
            e.prototype.constructor = e,
            e.__proto__ = t
        }
        i.Panel = function(e, t, i) {
          var n = 1 / 0
            , r = 0
            , s = Math.round
            , a = s(window.devicePixelRatio || 1)
            , o = 80 * a
            , l = 48 * a
            , h = 3 * a
            , c = 2 * a
            , u = 3 * a
            , d = 15 * a
            , p = 74 * a
            , f = 30 * a
            , m = document.createElement("canvas");
          m.width = o,
            m.height = l,
            m.style.cssText = "width:80px;height:48px";
          var g = m.getContext("2d");
          return g.font = "bold " + 9 * a + "px Helvetica,Arial,sans-serif",
            g.textBaseline = "top",
            g.fillStyle = i,
            g.fillRect(0, 0, o, l),
            g.fillStyle = t,
            g.fillText(e, h, c),
            g.fillRect(u, d, p, f),
            g.fillStyle = i,
            g.globalAlpha = .9,
            g.fillRect(u, d, p, f),
            {
              dom: m,
              update: function(l, v) {
                n = Math.min(n, l),
                  r = Math.max(r, l),
                  g.fillStyle = i,
                  g.globalAlpha = 1,
                  g.fillRect(0, 0, o, d),
                  g.fillStyle = t,
                  g.fillText(s(l) + " " + e + " (" + s(n) + "-" + s(r) + ")", h, c),
                  g.drawImage(m, u + a, d, p - a, f, u, d, p - a, f),
                  g.fillRect(u + p - a, d, a, f),
                  g.fillStyle = i,
                  g.globalAlpha = .9,
                  g.fillRect(u + p - a, d, a, s((1 - l / v) * f))
              }
            }
        }
        ;
        var s, a, o, l, h, c, u, d, p, f = {
          autoSleep: 120,
          force3D: "auto",
          nullTargetWarn: 1,
          units: {
            lineHeight: ""
          }
        }, m = {
          duration: .5,
          overwrite: !1,
          delay: 0
        }, g = 1e8, v = 1e-8, y = 2 * Math.PI, x = y / 4, _ = 0, b = Math.sqrt, w = Math.cos, A = Math.sin, S = function(e) {
          return "string" == typeof e
        }, M = function(e) {
          return "function" == typeof e
        }, T = function(e) {
          return "number" == typeof e
        }, E = function(e) {
          return void 0 === e
        }, C = function(e) {
          return "object" == typeof e
        }, P = function(e) {
          return !1 !== e
        }, D = function() {
          return "undefined" != typeof window
        }, I = function(e) {
          return M(e) || S(e)
        }, R = "function" == typeof ArrayBuffer && ArrayBuffer.isView || function() {}
          , L = Array.isArray, k = /(?:-?\.?\d|\.)+/gi, F = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g, B = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, O = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, N = /[+-]=-?[.\d]+/, z = /[^,'"\[\]\s]+/gi, U = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i, G = {}, V = {}, H = function(e) {
          return (V = me(e, G)) && ri
        }, W = function(e, t) {
          return console.warn("Invalid property", e, "set to", t, "Missing plugin? gsap.registerPlugin()")
        }, j = function(e, t) {
          return !t && console.warn(e)
        }, X = function(e, t) {
          return e && (G[e] = t) && V && (V[e] = t) || G
        }, Y = function() {
          return 0
        }, q = {}, Q = [], K = {}, J = {}, Z = {}, $ = 30, ee = [], te = "", ie = function(e) {
          var t, i, n = e[0];
          if (C(n) || M(n) || (e = [e]),
            !(t = (n._gsap || {}).harness)) {
            for (i = ee.length; i-- && !ee[i].targetTest(n); )
              ;
            t = ee[i]
          }
          for (i = e.length; i--; )
            e[i] && (e[i]._gsap || (e[i]._gsap = new Et(e[i],t))) || e.splice(i, 1);
          return e
        }, ne = function(e) {
          return e._gsap || ie(Xe(e))[0]._gsap
        }, re = function(e, t, i) {
          return (i = e[t]) && M(i) ? e[t]() : E(i) && e.getAttribute && e.getAttribute(t) || i
        }, se = function(e, t) {
          return (e = e.split(",")).forEach(t) || e
        }, ae = function(e) {
          return Math.round(1e5 * e) / 1e5 || 0
        }, oe = function(e) {
          return Math.round(1e7 * e) / 1e7 || 0
        }, le = function(e, t) {
          var i = t.charAt(0)
            , n = parseFloat(t.substr(2));
          return e = parseFloat(e),
            "+" === i ? e + n : "-" === i ? e - n : "*" === i ? e * n : e / n
        }, he = function(e, t) {
          for (var i = t.length, n = 0; e.indexOf(t[n]) < 0 && ++n < i; )
            ;
          return n < i
        }, ce = function() {
          var e, t, i = Q.length, n = Q.slice(0);
          for (K = {},
                 Q.length = 0,
                 e = 0; e < i; e++)
            (t = n[e]) && t._lazy && (t.render(t._lazy[0], t._lazy[1], !0)._lazy = 0)
        }, ue = function(e, t, i, n) {
          Q.length && ce(),
            e.render(t, i, n),
          Q.length && ce()
        }, de = function(e) {
          var t = parseFloat(e);
          return (t || 0 === t) && (e + "").match(z).length < 2 ? t : S(e) ? e.trim() : e
        }, pe = function(e) {
          return e
        }, fe = function(e, t) {
          for (var i in t)
            i in e || (e[i] = t[i]);
          return e
        }, me = function(e, t) {
          for (var i in t)
            e[i] = t[i];
          return e
        }, ge = function e(t, i) {
          for (var n in i)
            "__proto__" !== n && "constructor" !== n && "prototype" !== n && (t[n] = C(i[n]) ? e(t[n] || (t[n] = {}), i[n]) : i[n]);
          return t
        }, ve = function(e, t) {
          var i, n = {};
          for (i in e)
            i in t || (n[i] = e[i]);
          return n
        }, ye = function(e) {
          var t, i = e.parent || a, n = e.keyframes ? (t = L(e.keyframes),
              function(e, i) {
                for (var n in i)
                  n in e || "duration" === n && t || "ease" === n || (e[n] = i[n])
              }
          ) : fe;
          if (P(e.inherit))
            for (; i; )
              n(e, i.vars.defaults),
                i = i.parent || i._dp;
          return e
        }, xe = function(e, t, i, n, r) {
          void 0 === i && (i = "_first"),
          void 0 === n && (n = "_last");
          var s, a = e[n];
          if (r)
            for (s = t[r]; a && a[r] > s; )
              a = a._prev;
          return a ? (t._next = a._next,
            a._next = t) : (t._next = e[i],
            e[i] = t),
            t._next ? t._next._prev = t : e[n] = t,
            t._prev = a,
            t.parent = t._dp = e,
            t
        }, _e = function(e, t, i, n) {
          void 0 === i && (i = "_first"),
          void 0 === n && (n = "_last");
          var r = t._prev
            , s = t._next;
          r ? r._next = s : e[i] === t && (e[i] = s),
            s ? s._prev = r : e[n] === t && (e[n] = r),
            t._next = t._prev = t.parent = null
        }, be = function(e, t) {
          e.parent && (!t || e.parent.autoRemoveChildren) && e.parent.remove(e),
            e._act = 0
        }, we = function(e, t) {
          if (e && (!t || t._end > e._dur || t._start < 0))
            for (var i = e; i; )
              i._dirty = 1,
                i = i.parent;
          return e
        }, Ae = function(e) {
          for (var t = e.parent; t && t.parent; )
            t._dirty = 1,
              t.totalDuration(),
              t = t.parent;
          return e
        }, Se = function e(t) {
          return !t || t._ts && e(t.parent)
        }, Me = function(e) {
          return e._repeat ? Te(e._tTime, e = e.duration() + e._rDelay) * e : 0
        }, Te = function(e, t) {
          var i = Math.floor(e /= t);
          return e && i === e ? i - 1 : i
        }, Ee = function(e, t) {
          return (e - t._start) * t._ts + (t._ts >= 0 ? 0 : t._dirty ? t.totalDuration() : t._tDur)
        }, Ce = function(e) {
          return e._end = oe(e._start + (e._tDur / Math.abs(e._ts || e._rts || v) || 0))
        }, Pe = function(e, t) {
          var i = e._dp;
          return i && i.smoothChildTiming && e._ts && (e._start = oe(i._time - (e._ts > 0 ? t / e._ts : ((e._dirty ? e.totalDuration() : e._tDur) - t) / -e._ts)),
            Ce(e),
          i._dirty || we(i, e)),
            e
        }, De = function(e, t) {
          var i;
          if ((t._time || t._initted && !t._dur) && (i = Ee(e.rawTime(), t),
          (!t._dur || Ve(0, t.totalDuration(), i) - t._tTime > v) && t.render(i, !0)),
          we(e, t)._dp && e._initted && e._time >= e._dur && e._ts) {
            if (e._dur < e.duration())
              for (i = e; i._dp; )
                i.rawTime() >= 0 && i.totalTime(i._tTime),
                  i = i._dp;
            e._zTime = -1e-8
          }
        }, Ie = function(e, t, i, n) {
          return t.parent && be(t),
            t._start = oe((T(i) ? i : i || e !== a ? ze(e, i, t) : e._time) + t._delay),
            t._end = oe(t._start + (t.totalDuration() / Math.abs(t.timeScale()) || 0)),
            xe(e, t, "_first", "_last", e._sort ? "_start" : 0),
          Fe(t) || (e._recent = t),
          n || De(e, t),
            e
        }, Re = function(e, t) {
          return (G.ScrollTrigger || W("scrollTrigger", t)) && G.ScrollTrigger.create(t, e)
        }, Le = function(e, t, i, n) {
          return Ft(e, t),
            e._initted ? !i && e._pt && (e._dur && !1 !== e.vars.lazy || !e._dur && e.vars.lazy) && u !== ft.frame ? (Q.push(e),
              e._lazy = [t, n],
              1) : void 0 : 1
        }, ke = function e(t) {
          var i = t.parent;
          return i && i._ts && i._initted && !i._lock && (i.rawTime() < 0 || e(i))
        }, Fe = function(e) {
          var t = e.data;
          return "isFromStart" === t || "isStart" === t
        }, Be = function(e, t, i, n) {
          var r = e._repeat
            , s = oe(t) || 0
            , a = e._tTime / e._tDur;
          return a && !n && (e._time *= s / e._dur),
            e._dur = s,
            e._tDur = r ? r < 0 ? 1e10 : oe(s * (r + 1) + e._rDelay * r) : s,
            a > 0 && !n ? Pe(e, e._tTime = e._tDur * a) : e.parent && Ce(e),
          i || we(e.parent, e),
            e
        }, Oe = function(e) {
          return e instanceof Pt ? we(e) : Be(e, e._dur)
        }, Ne = {
          _start: 0,
          endTime: Y,
          totalDuration: Y
        }, ze = function e(t, i, n) {
          var r, s, a, o = t.labels, l = t._recent || Ne, h = t.duration() >= g ? l.endTime(!1) : t._dur;
          return S(i) && (isNaN(i) || i in o) ? (s = i.charAt(0),
            a = "%" === i.substr(-1),
            r = i.indexOf("="),
            "<" === s || ">" === s ? (r >= 0 && (i = i.replace(/=/, "")),
            ("<" === s ? l._start : l.endTime(l._repeat >= 0)) + (parseFloat(i.substr(1)) || 0) * (a ? (r < 0 ? l : n).totalDuration() / 100 : 1)) : r < 0 ? (i in o || (o[i] = h),
              o[i]) : (s = parseFloat(i.charAt(r - 1) + i.substr(r + 1)),
            a && n && (s = s / 100 * (L(n) ? n[0] : n).totalDuration()),
              r > 1 ? e(t, i.substr(0, r - 1), n) + s : h + s)) : null == i ? h : +i
        }, Ue = function(e, t, i) {
          var n, r, s = T(t[1]), a = (s ? 2 : 1) + (e < 2 ? 0 : 1), o = t[a];
          if (s && (o.duration = t[1]),
            o.parent = i,
            e) {
            for (n = o,
                   r = i; r && !("immediateRender"in n); )
              n = r.vars.defaults || {},
                r = P(r.vars.inherit) && r.parent;
            o.immediateRender = P(n.immediateRender),
              e < 2 ? o.runBackwards = 1 : o.startAt = t[a - 1]
          }
          return new Ut(t[0],o,t[a + 1])
        }, Ge = function(e, t) {
          return e || 0 === e ? t(e) : t
        }, Ve = function(e, t, i) {
          return i < e ? e : i > t ? t : i
        }, He = function(e, t) {
          return S(e) && (t = U.exec(e)) ? t[1] : ""
        }, We = [].slice, je = function(e, t) {
          return e && C(e) && "length"in e && (!t && !e.length || e.length - 1 in e && C(e[0])) && !e.nodeType && e !== o
        }, Xe = function(e, t, i) {
          return !S(e) || i || !l && mt() ? L(e) ? function(e, t, i) {
            return void 0 === i && (i = []),
            e.forEach((function(e) {
                var n;
                return S(e) && !t || je(e, 1) ? (n = i).push.apply(n, Xe(e)) : i.push(e)
              }
            )) || i
          }(e, i) : je(e) ? We.call(e, 0) : e ? [e] : [] : We.call((t || h).querySelectorAll(e), 0)
        }, Ye = function(e) {
          return e.sort((function() {
              return .5 - Math.random()
            }
          ))
        }, qe = function(e) {
          if (M(e))
            return e;
          var t = C(e) ? e : {
            each: e
          }
            , i = wt(t.ease)
            , n = t.from || 0
            , r = parseFloat(t.base) || 0
            , s = {}
            , a = n > 0 && n < 1
            , o = isNaN(n) || a
            , l = t.axis
            , h = n
            , c = n;
          return S(n) ? h = c = {
            center: .5,
            edges: .5,
            end: 1
          }[n] || 0 : !a && o && (h = n[0],
            c = n[1]),
            function(e, a, u) {
              var d, p, f, m, v, y, x, _, w, A = (u || t).length, S = s[A];
              if (!S) {
                if (!(w = "auto" === t.grid ? 0 : (t.grid || [1, g])[1])) {
                  for (x = -g; x < (x = u[w++].getBoundingClientRect().left) && w < A; )
                    ;
                  w--
                }
                for (S = s[A] = [],
                       d = o ? Math.min(w, A) * h - .5 : n % w,
                       p = w === g ? 0 : o ? A * c / w - .5 : n / w | 0,
                       x = 0,
                       _ = g,
                       y = 0; y < A; y++)
                  f = y % w - d,
                    m = p - (y / w | 0),
                    S[y] = v = l ? Math.abs("y" === l ? m : f) : b(f * f + m * m),
                  v > x && (x = v),
                  v < _ && (_ = v);
                "random" === n && Ye(S),
                  S.max = x - _,
                  S.min = _,
                  S.v = A = (parseFloat(t.amount) || parseFloat(t.each) * (w > A ? A - 1 : l ? "y" === l ? A / w : w : Math.max(w, A / w)) || 0) * ("edges" === n ? -1 : 1),
                  S.b = A < 0 ? r - A : r,
                  S.u = He(t.amount || t.each) || 0,
                  i = i && A < 0 ? _t(i) : i
              }
              return A = (S[e] - S.min) / S.max || 0,
              oe(S.b + (i ? i(A) : A) * S.v) + S.u
            }
        }, Qe = function(e) {
          var t = Math.pow(10, ((e + "").split(".")[1] || "").length);
          return function(i) {
            var n = Math.round(parseFloat(i) / e) * e * t;
            return (n - n % 1) / t + (T(i) ? 0 : He(i))
          }
        }, Ke = function(e, t) {
          var i, n, r = L(e);
          return !r && C(e) && (i = r = e.radius || g,
            e.values ? (e = Xe(e.values),
            (n = !T(e[0])) && (i *= i)) : e = Qe(e.increment)),
            Ge(t, r ? M(e) ? function(t) {
                return n = e(t),
                  Math.abs(n - t) <= i ? n : t
              }
              : function(t) {
                for (var r, s, a = parseFloat(n ? t.x : t), o = parseFloat(n ? t.y : 0), l = g, h = 0, c = e.length; c--; )
                  (r = n ? (r = e[c].x - a) * r + (s = e[c].y - o) * s : Math.abs(e[c] - a)) < l && (l = r,
                    h = c);
                return h = !i || l <= i ? e[h] : t,
                  n || h === t || T(t) ? h : h + He(t)
              }
              : Qe(e))
        }, Je = function(e, t, i, n) {
          return Ge(L(e) ? !t : !0 === i ? !!(i = 0) : !n, (function() {
              return L(e) ? e[~~(Math.random() * e.length)] : (i = i || 1e-5) && (n = i < 1 ? Math.pow(10, (i + "").length - 2) : 1) && Math.floor(Math.round((e - i / 2 + Math.random() * (t - e + .99 * i)) / i) * i * n) / n
            }
          ))
        }, Ze = function(e, t, i) {
          return Ge(i, (function(i) {
              return e[~~t(i)]
            }
          ))
        }, $e = function(e) {
          for (var t, i, n, r, s = 0, a = ""; ~(t = e.indexOf("random(", s)); )
            n = e.indexOf(")", t),
              r = "[" === e.charAt(t + 7),
              i = e.substr(t + 7, n - t - 7).match(r ? z : k),
              a += e.substr(s, t - s) + Je(r ? i : +i[0], r ? 0 : +i[1], +i[2] || 1e-5),
              s = n + 1;
          return a + e.substr(s, e.length - s)
        }, et = function(e, t, i, n, r) {
          var s = t - e
            , a = n - i;
          return Ge(r, (function(t) {
              return i + ((t - e) / s * a || 0)
            }
          ))
        }, tt = function(e, t, i) {
          var n, r, s, a = e.labels, o = g;
          for (n in a)
            (r = a[n] - t) < 0 == !!i && r && o > (r = Math.abs(r)) && (s = n,
              o = r);
          return s
        }, it = function(e, t, i) {
          var n, r, s = e.vars, a = s[t];
          if (a)
            return n = s[t + "Params"],
              r = s.callbackScope || e,
            i && Q.length && ce(),
              n ? a.apply(r, n) : a.call(r)
        }, nt = function(e) {
          return be(e),
          e.scrollTrigger && e.scrollTrigger.kill(!1),
          e.progress() < 1 && it(e, "onInterrupt"),
            e
        }, rt = function(e) {
          var t = (e = !e.name && e.default || e).name
            , i = M(e)
            , n = t && !i && e.init ? function() {
              this._props = []
            }
            : e
            , r = {
            init: Y,
            render: Qt,
            add: Lt,
            kill: Jt,
            modifier: Kt,
            rawVars: 0
          }
            , s = {
            targetTest: 0,
            get: 0,
            getSetter: jt,
            aliases: {},
            register: 0
          };
          if (mt(),
          e !== n) {
            if (J[t])
              return;
            fe(n, fe(ve(e, r), s)),
              me(n.prototype, me(r, ve(e, s))),
              J[n.prop = t] = n,
            e.targetTest && (ee.push(n),
              q[t] = 1),
              t = ("css" === t ? "CSS" : t.charAt(0).toUpperCase() + t.substr(1)) + "Plugin"
          }
          X(t, n),
          e.register && e.register(ri, n, ei)
        }, st = 255, at = {
          aqua: [0, st, st],
          lime: [0, st, 0],
          silver: [192, 192, 192],
          black: [0, 0, 0],
          maroon: [128, 0, 0],
          teal: [0, 128, 128],
          blue: [0, 0, st],
          navy: [0, 0, 128],
          white: [st, st, st],
          olive: [128, 128, 0],
          yellow: [st, st, 0],
          orange: [st, 165, 0],
          gray: [128, 128, 128],
          purple: [128, 0, 128],
          green: [0, 128, 0],
          red: [st, 0, 0],
          pink: [st, 192, 203],
          cyan: [0, st, st],
          transparent: [st, st, st, 0]
        }, ot = function(e, t, i) {
          return (6 * (e += e < 0 ? 1 : e > 1 ? -1 : 0) < 1 ? t + (i - t) * e * 6 : e < .5 ? i : 3 * e < 2 ? t + (i - t) * (2 / 3 - e) * 6 : t) * st + .5 | 0
        }, lt = function(e, t, i) {
          var n, r, s, a, o, l, h, c, u, d, p = e ? T(e) ? [e >> 16, e >> 8 & st, e & st] : 0 : at.black;
          if (!p) {
            if ("," === e.substr(-1) && (e = e.substr(0, e.length - 1)),
              at[e])
              p = at[e];
            else if ("#" === e.charAt(0)) {
              if (e.length < 6 && (n = e.charAt(1),
                r = e.charAt(2),
                s = e.charAt(3),
                e = "#" + n + n + r + r + s + s + (5 === e.length ? e.charAt(4) + e.charAt(4) : "")),
              9 === e.length)
                return [(p = parseInt(e.substr(1, 6), 16)) >> 16, p >> 8 & st, p & st, parseInt(e.substr(7), 16) / 255];
              p = [(e = parseInt(e.substr(1), 16)) >> 16, e >> 8 & st, e & st]
            } else if ("hsl" === e.substr(0, 3))
              if (p = d = e.match(k),
                t) {
                if (~e.indexOf("="))
                  return p = e.match(F),
                  i && p.length < 4 && (p[3] = 1),
                    p
              } else
                a = +p[0] % 360 / 360,
                  o = +p[1] / 100,
                  n = 2 * (l = +p[2] / 100) - (r = l <= .5 ? l * (o + 1) : l + o - l * o),
                p.length > 3 && (p[3] *= 1),
                  p[0] = ot(a + 1 / 3, n, r),
                  p[1] = ot(a, n, r),
                  p[2] = ot(a - 1 / 3, n, r);
            else
              p = e.match(k) || at.transparent;
            p = p.map(Number)
          }
          return t && !d && (n = p[0] / st,
            r = p[1] / st,
            s = p[2] / st,
            l = ((h = Math.max(n, r, s)) + (c = Math.min(n, r, s))) / 2,
            h === c ? a = o = 0 : (u = h - c,
              o = l > .5 ? u / (2 - h - c) : u / (h + c),
              a = h === n ? (r - s) / u + (r < s ? 6 : 0) : h === r ? (s - n) / u + 2 : (n - r) / u + 4,
              a *= 60),
            p[0] = ~~(a + .5),
            p[1] = ~~(100 * o + .5),
            p[2] = ~~(100 * l + .5)),
          i && p.length < 4 && (p[3] = 1),
            p
        }, ht = function(e) {
          var t = []
            , i = []
            , n = -1;
          return e.split(ut).forEach((function(e) {
              var r = e.match(B) || [];
              t.push.apply(t, r),
                i.push(n += r.length + 1)
            }
          )),
            t.c = i,
            t
        }, ct = function(e, t, i) {
          var n, r, s, a, o = "", l = (e + o).match(ut), h = t ? "hsla(" : "rgba(", c = 0;
          if (!l)
            return e;
          if (l = l.map((function(e) {
              return (e = lt(e, t, 1)) && h + (t ? e[0] + "," + e[1] + "%," + e[2] + "%," + e[3] : e.join(",")) + ")"
            }
          )),
          i && (s = ht(e),
          (n = i.c).join(o) !== s.c.join(o)))
            for (a = (r = e.replace(ut, "1").split(B)).length - 1; c < a; c++)
              o += r[c] + (~n.indexOf(c) ? l.shift() || h + "0,0,0,0)" : (s.length ? s : l.length ? l : i).shift());
          if (!r)
            for (a = (r = e.split(ut)).length - 1; c < a; c++)
              o += r[c] + l[c];
          return o + r[a]
        }, ut = function() {
          var e, t = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b";
          for (e in at)
            t += "|" + e + "\\b";
          return new RegExp(t + ")","gi")
        }(), dt = /hsl[a]?\(/, pt = function(e) {
          var t, i = e.join(" ");
          if (ut.lastIndex = 0,
            ut.test(i))
            return t = dt.test(i),
              e[1] = ct(e[1], t),
              e[0] = ct(e[0], t, ht(e[1])),
              !0
        }, ft = function() {
          var e, t, i, n, r, s, a = Date.now, u = 500, d = 33, f = a(), m = f, g = 1e3 / 240, v = g, y = [], x = function i(o) {
            var l, h, c, p, x = a() - m, _ = !0 === o;
            if (x > u && (f += x - d),
            ((l = (c = (m += x) - f) - v) > 0 || _) && (p = ++n.frame,
              r = c - 1e3 * n.time,
              n.time = c /= 1e3,
              v += l + (l >= g ? 4 : g - l),
              h = 1),
            _ || (e = t(i)),
              h)
              for (s = 0; s < y.length; s++)
                y[s](c, r, p, o)
          };
          return n = {
            time: 0,
            frame: 0,
            tick: function() {
              x(!0)
            },
            deltaRatio: function(e) {
              return r / (1e3 / (e || 60))
            },
            wake: function() {
              c && (!l && D() && (o = l = window,
                h = o.document || {},
                G.gsap = ri,
                (o.gsapVersions || (o.gsapVersions = [])).push(ri.version),
                H(V || o.GreenSockGlobals || !o.gsap && o || {}),
                i = o.requestAnimationFrame),
              e && n.sleep(),
                t = i || function(e) {
                  return setTimeout(e, v - 1e3 * n.time + 1 | 0)
                }
                ,
                p = 1,
                x(2))
            },
            sleep: function() {
              (i ? o.cancelAnimationFrame : clearTimeout)(e),
                p = 0,
                t = Y
            },
            lagSmoothing: function(e, t) {
              u = e || 1e8,
                d = Math.min(t, u, 0)
            },
            fps: function(e) {
              g = 1e3 / (e || 240),
                v = 1e3 * n.time + g
            },
            add: function(e, t, i) {
              var r = t ? function(t, i, s, a) {
                  e(t, i, s, a),
                    n.remove(r)
                }
                : e;
              return n.remove(e),
                y[i ? "unshift" : "push"](r),
                mt(),
                r
            },
            remove: function(e, t) {
              ~(t = y.indexOf(e)) && y.splice(t, 1) && s >= t && s--
            },
            _listeners: y
          },
            n
        }(), mt = function() {
          return !p && ft.wake()
        }, gt = {}, vt = /^[\d.\-M][\d.\-,\s]/, yt = /["']/g, xt = function(e) {
          for (var t, i, n, r = {}, s = e.substr(1, e.length - 3).split(":"), a = s[0], o = 1, l = s.length; o < l; o++)
            i = s[o],
              t = o !== l - 1 ? i.lastIndexOf(",") : i.length,
              n = i.substr(0, t),
              r[a] = isNaN(n) ? n.replace(yt, "").trim() : +n,
              a = i.substr(t + 1).trim();
          return r
        }, _t = function(e) {
          return function(t) {
            return 1 - e(1 - t)
          }
        }, bt = function e(t, i) {
          for (var n, r = t._first; r; )
            r instanceof Pt ? e(r, i) : !r.vars.yoyoEase || r._yoyo && r._repeat || r._yoyo === i || (r.timeline ? e(r.timeline, i) : (n = r._ease,
              r._ease = r._yEase,
              r._yEase = n,
              r._yoyo = i)),
              r = r._next
        }, wt = function(e, t) {
          return e && (M(e) ? e : gt[e] || function(e) {
            var t, i, n, r, s = (e + "").split("("), a = gt[s[0]];
            return a && s.length > 1 && a.config ? a.config.apply(null, ~e.indexOf("{") ? [xt(s[1])] : (t = e,
              i = t.indexOf("(") + 1,
              n = t.indexOf(")"),
              r = t.indexOf("(", i),
              t.substring(i, ~r && r < n ? t.indexOf(")", n + 1) : n)).split(",").map(de)) : gt._CE && vt.test(e) ? gt._CE("", e) : a
          }(e)) || t
        }, At = function(e, t, i, n) {
          void 0 === i && (i = function(e) {
              return 1 - t(1 - e)
            }
          ),
          void 0 === n && (n = function(e) {
              return e < .5 ? t(2 * e) / 2 : 1 - t(2 * (1 - e)) / 2
            }
          );
          var r, s = {
            easeIn: t,
            easeOut: i,
            easeInOut: n
          };
          return se(e, (function(e) {
              for (var t in gt[e] = G[e] = s,
                gt[r = e.toLowerCase()] = i,
                s)
                gt[r + ("easeIn" === t ? ".in" : "easeOut" === t ? ".out" : ".inOut")] = gt[e + "." + t] = s[t]
            }
          )),
            s
        }, St = function(e) {
          return function(t) {
            return t < .5 ? (1 - e(1 - 2 * t)) / 2 : .5 + e(2 * (t - .5)) / 2
          }
        }, Mt = function e(t, i, n) {
          var r = i >= 1 ? i : 1
            , s = (n || (t ? .3 : .45)) / (i < 1 ? i : 1)
            , a = s / y * (Math.asin(1 / r) || 0)
            , o = function(e) {
            return 1 === e ? 1 : r * Math.pow(2, -10 * e) * A((e - a) * s) + 1
          }
            , l = "out" === t ? o : "in" === t ? function(e) {
              return 1 - o(1 - e)
            }
            : St(o);
          return s = y / s,
            l.config = function(i, n) {
              return e(t, i, n)
            }
            ,
            l
        }, Tt = function e(t, i) {
          void 0 === i && (i = 1.70158);
          var n = function(e) {
            return e ? --e * e * ((i + 1) * e + i) + 1 : 0
          }
            , r = "out" === t ? n : "in" === t ? function(e) {
              return 1 - n(1 - e)
            }
            : St(n);
          return r.config = function(i) {
            return e(t, i)
          }
            ,
            r
        };
        se("Linear,Quad,Cubic,Quart,Quint,Strong", (function(e, t) {
            var i = t < 5 ? t + 1 : t;
            At(e + ",Power" + (i - 1), t ? function(e) {
                return Math.pow(e, i)
              }
              : function(e) {
                return e
              }
              , (function(e) {
                  return 1 - Math.pow(1 - e, i)
                }
              ), (function(e) {
                  return e < .5 ? Math.pow(2 * e, i) / 2 : 1 - Math.pow(2 * (1 - e), i) / 2
                }
              ))
          }
        )),
          gt.Linear.easeNone = gt.none = gt.Linear.easeIn,
          At("Elastic", Mt("in"), Mt("out"), Mt()),
          function(e, t) {
            var i = function(i) {
              return i < .36363636363636365 ? e * i * i : i < .7272727272727273 ? e * Math.pow(i - 1.5 / t, 2) + .75 : i < .9090909090909092 ? e * (i -= 2.25 / t) * i + .9375 : e * Math.pow(i - 2.625 / t, 2) + .984375
            };
            At("Bounce", (function(e) {
                return 1 - i(1 - e)
              }
            ), i)
          }(7.5625, 2.75),
          At("Expo", (function(e) {
              return e ? Math.pow(2, 10 * (e - 1)) : 0
            }
          )),
          At("Circ", (function(e) {
              return -(b(1 - e * e) - 1)
            }
          )),
          At("Sine", (function(e) {
              return 1 === e ? 1 : 1 - w(e * x)
            }
          )),
          At("Back", Tt("in"), Tt("out"), Tt()),
          gt.SteppedEase = gt.steps = G.SteppedEase = {
            config: function(e, t) {
              void 0 === e && (e = 1);
              var i = 1 / e
                , n = e + (t ? 0 : 1)
                , r = t ? 1 : 0;
              return function(e) {
                return ((n * Ve(0, .99999999, e) | 0) + r) * i
              }
            }
          },
          m.ease = gt["quad.out"],
          se("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", (function(e) {
              return te += e + "," + e + "Params,"
            }
          ));
        var Et = function(e, t) {
          this.id = _++,
            e._gsap = this,
            this.target = e,
            this.harness = t,
            this.get = t ? t.get : re,
            this.set = t ? t.getSetter : jt
        }
          , Ct = function() {
          function e(e) {
            this.vars = e,
              this._delay = +e.delay || 0,
            (this._repeat = e.repeat === 1 / 0 ? -2 : e.repeat || 0) && (this._rDelay = e.repeatDelay || 0,
              this._yoyo = !!e.yoyo || !!e.yoyoEase),
              this._ts = 1,
              Be(this, +e.duration, 1, 1),
              this.data = e.data,
            p || ft.wake()
          }
          var t = e.prototype;
          return t.delay = function(e) {
            return e || 0 === e ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + e - this._delay),
              this._delay = e,
              this) : this._delay
          }
            ,
            t.duration = function(e) {
              return arguments.length ? this.totalDuration(this._repeat > 0 ? e + (e + this._rDelay) * this._repeat : e) : this.totalDuration() && this._dur
            }
            ,
            t.totalDuration = function(e) {
              return arguments.length ? (this._dirty = 0,
                Be(this, this._repeat < 0 ? e : (e - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
            }
            ,
            t.totalTime = function(e, t) {
              if (mt(),
                !arguments.length)
                return this._tTime;
              var i = this._dp;
              if (i && i.smoothChildTiming && this._ts) {
                for (Pe(this, e),
                     !i._dp || i.parent || De(i, this); i && i.parent; )
                  i.parent._time !== i._start + (i._ts >= 0 ? i._tTime / i._ts : (i.totalDuration() - i._tTime) / -i._ts) && i.totalTime(i._tTime, !0),
                    i = i.parent;
                !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && e < this._tDur || this._ts < 0 && e > 0 || !this._tDur && !e) && Ie(this._dp, this, this._start - this._delay)
              }
              return (this._tTime !== e || !this._dur && !t || this._initted && Math.abs(this._zTime) === v || !e && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = e),
                ue(this, e, t)),
                this
            }
            ,
            t.time = function(e, t) {
              return arguments.length ? this.totalTime(Math.min(this.totalDuration(), e + Me(this)) % (this._dur + this._rDelay) || (e ? this._dur : 0), t) : this._time
            }
            ,
            t.totalProgress = function(e, t) {
              return arguments.length ? this.totalTime(this.totalDuration() * e, t) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio
            }
            ,
            t.progress = function(e, t) {
              return arguments.length ? this.totalTime(this.duration() * (!this._yoyo || 1 & this.iteration() ? e : 1 - e) + Me(this), t) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio
            }
            ,
            t.iteration = function(e, t) {
              var i = this.duration() + this._rDelay;
              return arguments.length ? this.totalTime(this._time + (e - 1) * i, t) : this._repeat ? Te(this._tTime, i) + 1 : 1
            }
            ,
            t.timeScale = function(e) {
              if (!arguments.length)
                return -1e-8 === this._rts ? 0 : this._rts;
              if (this._rts === e)
                return this;
              var t = this.parent && this._ts ? Ee(this.parent._time, this) : this._tTime;
              return this._rts = +e || 0,
                this._ts = this._ps || -1e-8 === e ? 0 : this._rts,
                this.totalTime(Ve(-this._delay, this._tDur, t), !0),
                Ce(this),
                Ae(this)
            }
            ,
            t.paused = function(e) {
              return arguments.length ? (this._ps !== e && (this._ps = e,
                e ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()),
                  this._ts = this._act = 0) : (mt(),
                  this._ts = this._rts,
                  this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, 1 === this.progress() && Math.abs(this._zTime) !== v && (this._tTime -= v)))),
                this) : this._ps
            }
            ,
            t.startTime = function(e) {
              if (arguments.length) {
                this._start = e;
                var t = this.parent || this._dp;
                return t && (t._sort || !this.parent) && Ie(t, this, e - this._delay),
                  this
              }
              return this._start
            }
            ,
            t.endTime = function(e) {
              return this._start + (P(e) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1)
            }
            ,
            t.rawTime = function(e) {
              var t = this.parent || this._dp;
              return t ? e && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? Ee(t.rawTime(e), this) : this._tTime : this._tTime
            }
            ,
            t.globalTime = function(e) {
              for (var t = this, i = arguments.length ? e : t.rawTime(); t; )
                i = t._start + i / (t._ts || 1),
                  t = t._dp;
              return i
            }
            ,
            t.repeat = function(e) {
              return arguments.length ? (this._repeat = e === 1 / 0 ? -2 : e,
                Oe(this)) : -2 === this._repeat ? 1 / 0 : this._repeat
            }
            ,
            t.repeatDelay = function(e) {
              if (arguments.length) {
                var t = this._time;
                return this._rDelay = e,
                  Oe(this),
                  t ? this.time(t) : this
              }
              return this._rDelay
            }
            ,
            t.yoyo = function(e) {
              return arguments.length ? (this._yoyo = e,
                this) : this._yoyo
            }
            ,
            t.seek = function(e, t) {
              return this.totalTime(ze(this, e), P(t))
            }
            ,
            t.restart = function(e, t) {
              return this.play().totalTime(e ? -this._delay : 0, P(t))
            }
            ,
            t.play = function(e, t) {
              return null != e && this.seek(e, t),
                this.reversed(!1).paused(!1)
            }
            ,
            t.reverse = function(e, t) {
              return null != e && this.seek(e || this.totalDuration(), t),
                this.reversed(!0).paused(!1)
            }
            ,
            t.pause = function(e, t) {
              return null != e && this.seek(e, t),
                this.paused(!0)
            }
            ,
            t.resume = function() {
              return this.paused(!1)
            }
            ,
            t.reversed = function(e) {
              return arguments.length ? (!!e !== this.reversed() && this.timeScale(-this._rts || (e ? -1e-8 : 0)),
                this) : this._rts < 0
            }
            ,
            t.invalidate = function() {
              return this._initted = this._act = 0,
                this._zTime = -1e-8,
                this
            }
            ,
            t.isActive = function() {
              var e, t = this.parent || this._dp, i = this._start;
              return !(t && !(this._ts && this._initted && t.isActive() && (e = t.rawTime(!0)) >= i && e < this.endTime(!0) - v))
            }
            ,
            t.eventCallback = function(e, t, i) {
              var n = this.vars;
              return arguments.length > 1 ? (t ? (n[e] = t,
              i && (n[e + "Params"] = i),
              "onUpdate" === e && (this._onUpdate = t)) : delete n[e],
                this) : n[e]
            }
            ,
            t.then = function(e) {
              var t = this;
              return new Promise((function(i) {
                  var n = M(e) ? e : pe
                    , r = function() {
                    var e = t.then;
                    t.then = null,
                    M(n) && (n = n(t)) && (n.then || n === t) && (t.then = e),
                      i(n),
                      t.then = e
                  };
                  t._initted && 1 === t.totalProgress() && t._ts >= 0 || !t._tTime && t._ts < 0 ? r() : t._prom = r
                }
              ))
            }
            ,
            t.kill = function() {
              nt(this)
            }
            ,
            e
        }();
        fe(Ct.prototype, {
          _time: 0,
          _start: 0,
          _end: 0,
          _tTime: 0,
          _tDur: 0,
          _dirty: 0,
          _repeat: 0,
          _yoyo: !1,
          parent: null,
          _initted: !1,
          _rDelay: 0,
          _ts: 1,
          _dp: 0,
          ratio: 0,
          _zTime: -1e-8,
          _prom: 0,
          _ps: !1,
          _rts: 1
        });
        var Pt = function(e) {
          function t(t, i) {
            var r;
            return void 0 === t && (t = {}),
              (r = e.call(this, t) || this).labels = {},
              r.smoothChildTiming = !!t.smoothChildTiming,
              r.autoRemoveChildren = !!t.autoRemoveChildren,
              r._sort = P(t.sortChildren),
            a && Ie(t.parent || a, n(r), i),
            t.reversed && r.reverse(),
            t.paused && r.paused(!0),
            t.scrollTrigger && Re(n(r), t.scrollTrigger),
              r
          }
          r(t, e);
          var i = t.prototype;
          return i.to = function(e, t, i) {
            return Ue(0, arguments, this),
              this
          }
            ,
            i.from = function(e, t, i) {
              return Ue(1, arguments, this),
                this
            }
            ,
            i.fromTo = function(e, t, i, n) {
              return Ue(2, arguments, this),
                this
            }
            ,
            i.set = function(e, t, i) {
              return t.duration = 0,
                t.parent = this,
              ye(t).repeatDelay || (t.repeat = 0),
                t.immediateRender = !!t.immediateRender,
                new Ut(e,t,ze(this, i),1),
                this
            }
            ,
            i.call = function(e, t, i) {
              return Ie(this, Ut.delayedCall(0, e, t), i)
            }
            ,
            i.staggerTo = function(e, t, i, n, r, s, a) {
              return i.duration = t,
                i.stagger = i.stagger || n,
                i.onComplete = s,
                i.onCompleteParams = a,
                i.parent = this,
                new Ut(e,i,ze(this, r)),
                this
            }
            ,
            i.staggerFrom = function(e, t, i, n, r, s, a) {
              return i.runBackwards = 1,
                ye(i).immediateRender = P(i.immediateRender),
                this.staggerTo(e, t, i, n, r, s, a)
            }
            ,
            i.staggerFromTo = function(e, t, i, n, r, s, a, o) {
              return n.startAt = i,
                ye(n).immediateRender = P(n.immediateRender),
                this.staggerTo(e, t, n, r, s, a, o)
            }
            ,
            i.render = function(e, t, i) {
              var n, r, s, o, l, h, c, u, d, p, f, m, g = this._time, y = this._dirty ? this.totalDuration() : this._tDur, x = this._dur, _ = e <= 0 ? 0 : oe(e), b = this._zTime < 0 != e < 0 && (this._initted || !x);
              if (this !== a && _ > y && e >= 0 && (_ = y),
              _ !== this._tTime || i || b) {
                if (g !== this._time && x && (_ += this._time - g,
                  e += this._time - g),
                  n = _,
                  d = this._start,
                  h = !(u = this._ts),
                b && (x || (g = this._zTime),
                (e || !t) && (this._zTime = e)),
                  this._repeat) {
                  if (f = this._yoyo,
                    l = x + this._rDelay,
                  this._repeat < -1 && e < 0)
                    return this.totalTime(100 * l + e, t, i);
                  if (n = oe(_ % l),
                    _ === y ? (o = this._repeat,
                      n = x) : ((o = ~~(_ / l)) && o === _ / l && (n = x,
                      o--),
                    n > x && (n = x)),
                    p = Te(this._tTime, l),
                  !g && this._tTime && p !== o && (p = o),
                  f && 1 & o && (n = x - n,
                    m = 1),
                  o !== p && !this._lock) {
                    var w = f && 1 & p
                      , A = w === (f && 1 & o);
                    if (o < p && (w = !w),
                      g = w ? 0 : x,
                      this._lock = 1,
                      this.render(g || (m ? 0 : oe(o * l)), t, !x)._lock = 0,
                      this._tTime = _,
                    !t && this.parent && it(this, "onRepeat"),
                    this.vars.repeatRefresh && !m && (this.invalidate()._lock = 1),
                    g && g !== this._time || h !== !this._ts || this.vars.onRepeat && !this.parent && !this._act)
                      return this;
                    if (x = this._dur,
                      y = this._tDur,
                    A && (this._lock = 2,
                      g = w ? x : -1e-4,
                      this.render(g, !0),
                    this.vars.repeatRefresh && !m && this.invalidate()),
                      this._lock = 0,
                    !this._ts && !h)
                      return this;
                    bt(this, m)
                  }
                }
                if (this._hasPause && !this._forcing && this._lock < 2 && (c = function(e, t, i) {
                  var n;
                  if (i > t)
                    for (n = e._first; n && n._start <= i; ) {
                      if ("isPause" === n.data && n._start > t)
                        return n;
                      n = n._next
                    }
                  else
                    for (n = e._last; n && n._start >= i; ) {
                      if ("isPause" === n.data && n._start < t)
                        return n;
                      n = n._prev
                    }
                }(this, oe(g), oe(n)),
                c && (_ -= n - (n = c._start))),
                  this._tTime = _,
                  this._time = n,
                  this._act = !u,
                this._initted || (this._onUpdate = this.vars.onUpdate,
                  this._initted = 1,
                  this._zTime = e,
                  g = 0),
                !g && n && !t && (it(this, "onStart"),
                this._tTime !== _))
                  return this;
                if (n >= g && e >= 0)
                  for (r = this._first; r; ) {
                    if (s = r._next,
                    (r._act || n >= r._start) && r._ts && c !== r) {
                      if (r.parent !== this)
                        return this.render(e, t, i);
                      if (r.render(r._ts > 0 ? (n - r._start) * r._ts : (r._dirty ? r.totalDuration() : r._tDur) + (n - r._start) * r._ts, t, i),
                      n !== this._time || !this._ts && !h) {
                        c = 0,
                        s && (_ += this._zTime = -1e-8);
                        break
                      }
                    }
                    r = s
                  }
                else {
                  r = this._last;
                  for (var S = e < 0 ? e : n; r; ) {
                    if (s = r._prev,
                    (r._act || S <= r._end) && r._ts && c !== r) {
                      if (r.parent !== this)
                        return this.render(e, t, i);
                      if (r.render(r._ts > 0 ? (S - r._start) * r._ts : (r._dirty ? r.totalDuration() : r._tDur) + (S - r._start) * r._ts, t, i),
                      n !== this._time || !this._ts && !h) {
                        c = 0,
                        s && (_ += this._zTime = S ? -1e-8 : v);
                        break
                      }
                    }
                    r = s
                  }
                }
                if (c && !t && (this.pause(),
                  c.render(n >= g ? 0 : -1e-8)._zTime = n >= g ? 1 : -1,
                  this._ts))
                  return this._start = d,
                    Ce(this),
                    this.render(e, t, i);
                this._onUpdate && !t && it(this, "onUpdate", !0),
                (_ === y && this._tTime >= this.totalDuration() || !_ && g) && (d !== this._start && Math.abs(u) === Math.abs(this._ts) || this._lock || ((e || !x) && (_ === y && this._ts > 0 || !_ && this._ts < 0) && be(this, 1),
                t || e < 0 && !g || !_ && !g && y || (it(this, _ === y && e >= 0 ? "onComplete" : "onReverseComplete", !0),
                this._prom && !(_ < y && this.timeScale() > 0) && this._prom())))
              }
              return this
            }
            ,
            i.add = function(e, t) {
              var i = this;
              if (T(t) || (t = ze(this, t, e)),
                !(e instanceof Ct)) {
                if (L(e))
                  return e.forEach((function(e) {
                      return i.add(e, t)
                    }
                  )),
                    this;
                if (S(e))
                  return this.addLabel(e, t);
                if (!M(e))
                  return this;
                e = Ut.delayedCall(0, e)
              }
              return this !== e ? Ie(this, e, t) : this
            }
            ,
            i.getChildren = function(e, t, i, n) {
              void 0 === e && (e = !0),
              void 0 === t && (t = !0),
              void 0 === i && (i = !0),
              void 0 === n && (n = -g);
              for (var r = [], s = this._first; s; )
                s._start >= n && (s instanceof Ut ? t && r.push(s) : (i && r.push(s),
                e && r.push.apply(r, s.getChildren(!0, t, i)))),
                  s = s._next;
              return r
            }
            ,
            i.getById = function(e) {
              for (var t = this.getChildren(1, 1, 1), i = t.length; i--; )
                if (t[i].vars.id === e)
                  return t[i]
            }
            ,
            i.remove = function(e) {
              return S(e) ? this.removeLabel(e) : M(e) ? this.killTweensOf(e) : (_e(this, e),
              e === this._recent && (this._recent = this._last),
                we(this))
            }
            ,
            i.totalTime = function(t, i) {
              return arguments.length ? (this._forcing = 1,
              !this._dp && this._ts && (this._start = oe(ft.time - (this._ts > 0 ? t / this._ts : (this.totalDuration() - t) / -this._ts))),
                e.prototype.totalTime.call(this, t, i),
                this._forcing = 0,
                this) : this._tTime
            }
            ,
            i.addLabel = function(e, t) {
              return this.labels[e] = ze(this, t),
                this
            }
            ,
            i.removeLabel = function(e) {
              return delete this.labels[e],
                this
            }
            ,
            i.addPause = function(e, t, i) {
              var n = Ut.delayedCall(0, t || Y, i);
              return n.data = "isPause",
                this._hasPause = 1,
                Ie(this, n, ze(this, e))
            }
            ,
            i.removePause = function(e) {
              var t = this._first;
              for (e = ze(this, e); t; )
                t._start === e && "isPause" === t.data && be(t),
                  t = t._next
            }
            ,
            i.killTweensOf = function(e, t, i) {
              for (var n = this.getTweensOf(e, i), r = n.length; r--; )
                Dt !== n[r] && n[r].kill(e, t);
              return this
            }
            ,
            i.getTweensOf = function(e, t) {
              for (var i, n = [], r = Xe(e), s = this._first, a = T(t); s; )
                s instanceof Ut ? he(s._targets, r) && (a ? (!Dt || s._initted && s._ts) && s.globalTime(0) <= t && s.globalTime(s.totalDuration()) > t : !t || s.isActive()) && n.push(s) : (i = s.getTweensOf(r, t)).length && n.push.apply(n, i),
                  s = s._next;
              return n
            }
            ,
            i.tweenTo = function(e, t) {
              t = t || {};
              var i, n = this, r = ze(n, e), s = t, a = s.startAt, o = s.onStart, l = s.onStartParams, h = s.immediateRender, c = Ut.to(n, fe({
                ease: t.ease || "none",
                lazy: !1,
                immediateRender: !1,
                time: r,
                overwrite: "auto",
                duration: t.duration || Math.abs((r - (a && "time"in a ? a.time : n._time)) / n.timeScale()) || v,
                onStart: function() {
                  if (n.pause(),
                    !i) {
                    var e = t.duration || Math.abs((r - (a && "time"in a ? a.time : n._time)) / n.timeScale());
                    c._dur !== e && Be(c, e, 0, 1).render(c._time, !0, !0),
                      i = 1
                  }
                  o && o.apply(c, l || [])
                }
              }, t));
              return h ? c.render(0) : c
            }
            ,
            i.tweenFromTo = function(e, t, i) {
              return this.tweenTo(t, fe({
                startAt: {
                  time: ze(this, e)
                }
              }, i))
            }
            ,
            i.recent = function() {
              return this._recent
            }
            ,
            i.nextLabel = function(e) {
              return void 0 === e && (e = this._time),
                tt(this, ze(this, e))
            }
            ,
            i.previousLabel = function(e) {
              return void 0 === e && (e = this._time),
                tt(this, ze(this, e), 1)
            }
            ,
            i.currentLabel = function(e) {
              return arguments.length ? this.seek(e, !0) : this.previousLabel(this._time + v)
            }
            ,
            i.shiftChildren = function(e, t, i) {
              void 0 === i && (i = 0);
              for (var n, r = this._first, s = this.labels; r; )
                r._start >= i && (r._start += e,
                  r._end += e),
                  r = r._next;
              if (t)
                for (n in s)
                  s[n] >= i && (s[n] += e);
              return we(this)
            }
            ,
            i.invalidate = function() {
              var t = this._first;
              for (this._lock = 0; t; )
                t.invalidate(),
                  t = t._next;
              return e.prototype.invalidate.call(this)
            }
            ,
            i.clear = function(e) {
              void 0 === e && (e = !0);
              for (var t, i = this._first; i; )
                t = i._next,
                  this.remove(i),
                  i = t;
              return this._dp && (this._time = this._tTime = this._pTime = 0),
              e && (this.labels = {}),
                we(this)
            }
            ,
            i.totalDuration = function(e) {
              var t, i, n, r = 0, s = this, o = s._last, l = g;
              if (arguments.length)
                return s.timeScale((s._repeat < 0 ? s.duration() : s.totalDuration()) / (s.reversed() ? -e : e));
              if (s._dirty) {
                for (n = s.parent; o; )
                  t = o._prev,
                  o._dirty && o.totalDuration(),
                    (i = o._start) > l && s._sort && o._ts && !s._lock ? (s._lock = 1,
                      Ie(s, o, i - o._delay, 1)._lock = 0) : l = i,
                  i < 0 && o._ts && (r -= i,
                  (!n && !s._dp || n && n.smoothChildTiming) && (s._start += i / s._ts,
                    s._time -= i,
                    s._tTime -= i),
                    s.shiftChildren(-i, !1, -Infinity),
                    l = 0),
                  o._end > r && o._ts && (r = o._end),
                    o = t;
                Be(s, s === a && s._time > r ? s._time : r, 1, 1),
                  s._dirty = 0
              }
              return s._tDur
            }
            ,
            t.updateRoot = function(e) {
              if (a._ts && (ue(a, Ee(e, a)),
                u = ft.frame),
              ft.frame >= $) {
                $ += f.autoSleep || 120;
                var t = a._first;
                if ((!t || !t._ts) && f.autoSleep && ft._listeners.length < 2) {
                  for (; t && !t._ts; )
                    t = t._next;
                  t || ft.sleep()
                }
              }
            }
            ,
            t
        }(Ct);
        fe(Pt.prototype, {
          _lock: 0,
          _hasPause: 0,
          _forcing: 0
        });
        var Dt, It, Rt = function(e, t, i, n, r, s, a) {
          var o, l, h, c, u, d, p, f, m = new ei(this._pt,e,t,0,1,qt,null,r), g = 0, v = 0;
          for (m.b = i,
                 m.e = n,
                 i += "",
               (p = ~(n += "").indexOf("random(")) && (n = $e(n)),
               s && (s(f = [i, n], e, t),
                 i = f[0],
                 n = f[1]),
                 l = i.match(O) || []; o = O.exec(n); )
            c = o[0],
              u = n.substring(g, o.index),
              h ? h = (h + 1) % 5 : "rgba(" === u.substr(-5) && (h = 1),
            c !== l[v++] && (d = parseFloat(l[v - 1]) || 0,
              m._pt = {
                _next: m._pt,
                p: u || 1 === v ? u : ",",
                s: d,
                c: "=" === c.charAt(1) ? le(d, c) - d : parseFloat(c) - d,
                m: h && h < 4 ? Math.round : 0
              },
              g = O.lastIndex);
          return m.c = g < n.length ? n.substring(g, n.length) : "",
            m.fp = a,
          (N.test(n) || p) && (m.e = 0),
            this._pt = m,
            m
        }, Lt = function(e, t, i, n, r, s, a, o, l) {
          M(n) && (n = n(r || 0, e, s));
          var h, c = e[t], u = "get" !== i ? i : M(c) ? l ? e[t.indexOf("set") || !M(e["get" + t.substr(3)]) ? t : "get" + t.substr(3)](l) : e[t]() : c, d = M(c) ? l ? Ht : Vt : Gt;
          if (S(n) && (~n.indexOf("random(") && (n = $e(n)),
          "=" === n.charAt(1) && ((h = le(u, n) + (He(u) || 0)) || 0 === h) && (n = h)),
          u !== n || It)
            return isNaN(u * n) || "" === n ? (!c && !(t in e) && W(t, n),
              Rt.call(this, e, t, u, n, d, o || f.stringFilter, l)) : (h = new ei(this._pt,e,t,+u || 0,n - (u || 0),"boolean" == typeof c ? Yt : Xt,0,d),
            l && (h.fp = l),
            a && h.modifier(a, this, e),
              this._pt = h)
        }, kt = function(e, t, i, n, r, s) {
          var a, o, l, h;
          if (J[e] && !1 !== (a = new J[e]).init(r, a.rawVars ? t[e] : function(e, t, i, n, r) {
            if (M(e) && (e = Ot(e, r, t, i, n)),
            !C(e) || e.style && e.nodeType || L(e) || R(e))
              return S(e) ? Ot(e, r, t, i, n) : e;
            var s, a = {};
            for (s in e)
              a[s] = Ot(e[s], r, t, i, n);
            return a
          }(t[e], n, r, s, i), i, n, s) && (i._pt = o = new ei(i._pt,r,e,0,1,a.render,a,0,a.priority),
          i !== d))
            for (l = i._ptLookup[i._targets.indexOf(r)],
                   h = a._props.length; h--; )
              l[a._props[h]] = o;
          return a
        }, Ft = function e(t, i) {
          var n, r, o, l, h, c, u, d, p, f, y, x, _, b = t.vars, w = b.ease, A = b.startAt, S = b.immediateRender, M = b.lazy, T = b.onUpdate, E = b.onUpdateParams, C = b.callbackScope, D = b.runBackwards, I = b.yoyoEase, R = b.keyframes, L = b.autoRevert, k = t._dur, F = t._startAt, B = t._targets, O = t.parent, N = O && "nested" === O.data ? O.parent._targets : B, z = "auto" === t._overwrite && !s, U = t.timeline;
          if (U && (!R || !w) && (w = "none"),
            t._ease = wt(w, m.ease),
            t._yEase = I ? _t(wt(!0 === I ? w : I, m.ease)) : 0,
          I && t._yoyo && !t._repeat && (I = t._yEase,
            t._yEase = t._ease,
            t._ease = I),
            t._from = !U && !!b.runBackwards,
          !U || R && !b.stagger) {
            if (x = (d = B[0] ? ne(B[0]).harness : 0) && b[d.prop],
              n = ve(b, q),
            F && (be(F.render(-1, !0)),
              F._lazy = 0),
              A)
              if (be(t._startAt = Ut.set(B, fe({
                data: "isStart",
                overwrite: !1,
                parent: O,
                immediateRender: !0,
                lazy: P(M),
                startAt: null,
                delay: 0,
                onUpdate: T,
                onUpdateParams: E,
                callbackScope: C,
                stagger: 0
              }, A))),
              i < 0 && !S && !L && t._startAt.render(-1, !0),
                S) {
                if (i > 0 && !L && (t._startAt = 0),
                k && i <= 0)
                  return void (i && (t._zTime = i))
              } else
                !1 === L && (t._startAt = 0);
            else if (D && k)
              if (F)
                !L && (t._startAt = 0);
              else if (i && (S = !1),
                o = fe({
                  overwrite: !1,
                  data: "isFromStart",
                  lazy: S && P(M),
                  immediateRender: S,
                  stagger: 0,
                  parent: O
                }, n),
              x && (o[d.prop] = x),
                be(t._startAt = Ut.set(B, o)),
              i < 0 && t._startAt.render(-1, !0),
                t._zTime = i,
                S) {
                if (!i)
                  return
              } else
                e(t._startAt, v);
            for (t._pt = t._ptCache = 0,
                   M = k && P(M) || M && !k,
                   r = 0; r < B.length; r++) {
              if (u = (h = B[r])._gsap || ie(B)[r]._gsap,
                t._ptLookup[r] = f = {},
              K[u.id] && Q.length && ce(),
                y = N === B ? r : N.indexOf(h),
              d && !1 !== (p = new d).init(h, x || n, t, y, N) && (t._pt = l = new ei(t._pt,h,p.name,0,1,p.render,p,0,p.priority),
                p._props.forEach((function(e) {
                    f[e] = l
                  }
                )),
              p.priority && (c = 1)),
              !d || x)
                for (o in n)
                  J[o] && (p = kt(o, n, t, y, h, N)) ? p.priority && (c = 1) : f[o] = l = Lt.call(t, h, o, "get", n[o], y, N, 0, b.stringFilter);
              t._op && t._op[r] && t.kill(h, t._op[r]),
              z && t._pt && (Dt = t,
                a.killTweensOf(h, f, t.globalTime(i)),
                _ = !t.parent,
                Dt = 0),
              t._pt && M && (K[u.id] = 1)
            }
            c && $t(t),
            t._onInit && t._onInit(t)
          }
          t._onUpdate = T,
            t._initted = (!t._op || t._pt) && !_,
          R && i <= 0 && U.render(g, !0, !0)
        }, Bt = function(e, t, i, n) {
          var r, s, a = t.ease || n || "power1.inOut";
          if (L(t))
            s = i[e] || (i[e] = []),
              t.forEach((function(e, i) {
                  return s.push({
                    t: i / (t.length - 1) * 100,
                    v: e,
                    e: a
                  })
                }
              ));
          else
            for (r in t)
              s = i[r] || (i[r] = []),
              "ease" === r || s.push({
                t: parseFloat(e),
                v: t[r],
                e: a
              })
        }, Ot = function(e, t, i, n, r) {
          return M(e) ? e.call(t, i, n, r) : S(e) && ~e.indexOf("random(") ? $e(e) : e
        }, Nt = te + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert", zt = {};
        se(Nt + ",id,stagger,delay,duration,paused,scrollTrigger", (function(e) {
            return zt[e] = 1
          }
        ));
        var Ut = function(e) {
          function t(t, i, r, o) {
            var l;
            "number" == typeof i && (r.duration = i,
              i = r,
              r = null);
            var h, c, u, d, p, m, g, v, y = (l = e.call(this, o ? i : ye(i)) || this).vars, x = y.duration, _ = y.delay, b = y.immediateRender, w = y.stagger, A = y.overwrite, S = y.keyframes, M = y.defaults, E = y.scrollTrigger, D = y.yoyoEase, k = i.parent || a, F = (L(t) || R(t) ? T(t[0]) : "length"in i) ? [t] : Xe(t);
            if (l._targets = F.length ? ie(F) : j("GSAP target " + t + " not found. https://greensock.com", !f.nullTargetWarn) || [],
              l._ptLookup = [],
              l._overwrite = A,
            S || w || I(x) || I(_)) {
              if (i = l.vars,
                (h = l.timeline = new Pt({
                  data: "nested",
                  defaults: M || {}
                })).kill(),
                h.parent = h._dp = n(l),
                h._start = 0,
              w || I(x) || I(_)) {
                if (d = F.length,
                  g = w && qe(w),
                  C(w))
                  for (p in w)
                    ~Nt.indexOf(p) && (v || (v = {}),
                      v[p] = w[p]);
                for (c = 0; c < d; c++)
                  (u = ve(i, zt)).stagger = 0,
                  D && (u.yoyoEase = D),
                  v && me(u, v),
                    m = F[c],
                    u.duration = +Ot(x, n(l), c, m, F),
                    u.delay = (+Ot(_, n(l), c, m, F) || 0) - l._delay,
                  !w && 1 === d && u.delay && (l._delay = _ = u.delay,
                    l._start += _,
                    u.delay = 0),
                    h.to(m, u, g ? g(c, m, F) : 0),
                    h._ease = gt.none;
                h.duration() ? x = _ = 0 : l.timeline = 0
              } else if (S) {
                ye(fe(h.vars.defaults, {
                  ease: "none"
                })),
                  h._ease = wt(S.ease || i.ease || "none");
                var B, O, N, z = 0;
                if (L(S))
                  S.forEach((function(e) {
                      return h.to(F, e, ">")
                    }
                  ));
                else {
                  for (p in u = {},
                    S)
                    "ease" === p || "easeEach" === p || Bt(p, S[p], u, S.easeEach);
                  for (p in u)
                    for (B = u[p].sort((function(e, t) {
                        return e.t - t.t
                      }
                    )),
                           z = 0,
                           c = 0; c < B.length; c++)
                      (N = {
                        ease: (O = B[c]).e,
                        duration: (O.t - (c ? B[c - 1].t : 0)) / 100 * x
                      })[p] = O.v,
                        h.to(F, N, z),
                        z += N.duration;
                  h.duration() < x && h.to({}, {
                    duration: x - h.duration()
                  })
                }
              }
              x || l.duration(x = h.duration())
            } else
              l.timeline = 0;
            return !0 !== A || s || (Dt = n(l),
              a.killTweensOf(F),
              Dt = 0),
              Ie(k, n(l), r),
            i.reversed && l.reverse(),
            i.paused && l.paused(!0),
            (b || !x && !S && l._start === oe(k._time) && P(b) && Se(n(l)) && "nested" !== k.data) && (l._tTime = -1e-8,
              l.render(Math.max(0, -_))),
            E && Re(n(l), E),
              l
          }
          r(t, e);
          var i = t.prototype;
          return i.render = function(e, t, i) {
            var n, r, s, a, o, l, h, c, u, d = this._time, p = this._tDur, f = this._dur, m = e > p - v && e >= 0 ? p : e < v ? 0 : e;
            if (f) {
              if (m !== this._tTime || !e || i || !this._initted && this._tTime || this._startAt && this._zTime < 0 != e < 0) {
                if (n = m,
                  c = this.timeline,
                  this._repeat) {
                  if (a = f + this._rDelay,
                  this._repeat < -1 && e < 0)
                    return this.totalTime(100 * a + e, t, i);
                  if (n = oe(m % a),
                    m === p ? (s = this._repeat,
                      n = f) : ((s = ~~(m / a)) && s === m / a && (n = f,
                      s--),
                    n > f && (n = f)),
                  (l = this._yoyo && 1 & s) && (u = this._yEase,
                    n = f - n),
                    o = Te(this._tTime, a),
                  n === d && !i && this._initted)
                    return this._tTime = m,
                      this;
                  s !== o && (c && this._yEase && bt(c, l),
                  !this.vars.repeatRefresh || l || this._lock || (this._lock = i = 1,
                    this.render(oe(a * s), !0).invalidate()._lock = 0))
                }
                if (!this._initted) {
                  if (Le(this, e < 0 ? e : n, i, t))
                    return this._tTime = 0,
                      this;
                  if (d !== this._time)
                    return this;
                  if (f !== this._dur)
                    return this.render(e, t, i)
                }
                if (this._tTime = m,
                  this._time = n,
                !this._act && this._ts && (this._act = 1,
                  this._lazy = 0),
                  this.ratio = h = (u || this._ease)(n / f),
                this._from && (this.ratio = h = 1 - h),
                n && !d && !t && (it(this, "onStart"),
                this._tTime !== m))
                  return this;
                for (r = this._pt; r; )
                  r.r(h, r.d),
                    r = r._next;
                c && c.render(e < 0 ? e : !n && l ? -1e-8 : c._dur * c._ease(n / this._dur), t, i) || this._startAt && (this._zTime = e),
                this._onUpdate && !t && (e < 0 && this._startAt && this._startAt.render(e, !0, i),
                  it(this, "onUpdate")),
                this._repeat && s !== o && this.vars.onRepeat && !t && this.parent && it(this, "onRepeat"),
                m !== this._tDur && m || this._tTime !== m || (e < 0 && this._startAt && !this._onUpdate && this._startAt.render(e, !0, !0),
                (e || !f) && (m === this._tDur && this._ts > 0 || !m && this._ts < 0) && be(this, 1),
                t || e < 0 && !d || !m && !d || (it(this, m === p ? "onComplete" : "onReverseComplete", !0),
                this._prom && !(m < p && this.timeScale() > 0) && this._prom()))
              }
            } else
              !function(e, t, i, n) {
                var r, s, a, o = e.ratio, l = t < 0 || !t && (!e._start && ke(e) && (e._initted || !Fe(e)) || (e._ts < 0 || e._dp._ts < 0) && !Fe(e)) ? 0 : 1, h = e._rDelay, c = 0;
                if (h && e._repeat && (c = Ve(0, e._tDur, t),
                  s = Te(c, h),
                e._yoyo && 1 & s && (l = 1 - l),
                s !== Te(e._tTime, h) && (o = 1 - l,
                e.vars.repeatRefresh && e._initted && e.invalidate())),
                l !== o || n || e._zTime === v || !t && e._zTime) {
                  if (!e._initted && Le(e, t, n, i))
                    return;
                  for (a = e._zTime,
                         e._zTime = t || (i ? v : 0),
                       i || (i = t && !a),
                         e.ratio = l,
                       e._from && (l = 1 - l),
                         e._time = 0,
                         e._tTime = c,
                         r = e._pt; r; )
                    r.r(l, r.d),
                      r = r._next;
                  e._startAt && t < 0 && e._startAt.render(t, !0, !0),
                  e._onUpdate && !i && it(e, "onUpdate"),
                  c && e._repeat && !i && e.parent && it(e, "onRepeat"),
                  (t >= e._tDur || t < 0) && e.ratio === l && (l && be(e, 1),
                  i || (it(e, l ? "onComplete" : "onReverseComplete", !0),
                  e._prom && e._prom()))
                } else
                  e._zTime || (e._zTime = t)
              }(this, e, t, i);
            return this
          }
            ,
            i.targets = function() {
              return this._targets
            }
            ,
            i.invalidate = function() {
              return this._pt = this._op = this._startAt = this._onUpdate = this._lazy = this.ratio = 0,
                this._ptLookup = [],
              this.timeline && this.timeline.invalidate(),
                e.prototype.invalidate.call(this)
            }
            ,
            i.resetTo = function(e, t, i, n) {
              p || ft.wake(),
              this._ts || this.play();
              var r = Math.min(this._dur, (this._dp._time - this._start) * this._ts);
              return this._initted || Ft(this, r),
                function(e, t, i, n, r, s, a) {
                  var o, l, h, c = (e._pt && e._ptCache || (e._ptCache = {}))[t];
                  if (!c)
                    for (c = e._ptCache[t] = [],
                           l = e._ptLookup,
                           h = e._targets.length; h--; ) {
                      if ((o = l[h][t]) && o.d && o.d._pt)
                        for (o = o.d._pt; o && o.p !== t; )
                          o = o._next;
                      if (!o)
                        return It = 1,
                          e.vars[t] = "+=0",
                          Ft(e, a),
                          It = 0,
                          1;
                      c.push(o)
                    }
                  for (h = c.length; h--; )
                    (o = c[h]).s = !n && 0 !== n || r ? o.s + (n || 0) + s * o.c : n,
                      o.c = i - o.s,
                    o.e && (o.e = ae(i) + He(o.e)),
                    o.b && (o.b = o.s + He(o.b))
                }(this, e, t, i, n, this._ease(r / this._dur), r) ? this.resetTo(e, t, i, n) : (Pe(this, 0),
                this.parent || xe(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0),
                  this.render(0))
            }
            ,
            i.kill = function(e, t) {
              if (void 0 === t && (t = "all"),
                !(e || t && "all" !== t))
                return this._lazy = this._pt = 0,
                  this.parent ? nt(this) : this;
              if (this.timeline) {
                var i = this.timeline.totalDuration();
                return this.timeline.killTweensOf(e, t, Dt && !0 !== Dt.vars.overwrite)._first || nt(this),
                this.parent && i !== this.timeline.totalDuration() && Be(this, this._dur * this.timeline._tDur / i, 0, 1),
                  this
              }
              var n, r, s, a, o, l, h, c = this._targets, u = e ? Xe(e) : c, d = this._ptLookup, p = this._pt;
              if ((!t || "all" === t) && function(e, t) {
                for (var i = e.length, n = i === t.length; n && i-- && e[i] === t[i]; )
                  ;
                return i < 0
              }(c, u))
                return "all" === t && (this._pt = 0),
                  nt(this);
              for (n = this._op = this._op || [],
                   "all" !== t && (S(t) && (o = {},
                     se(t, (function(e) {
                         return o[e] = 1
                       }
                     )),
                     t = o),
                     t = function(e, t) {
                       var i, n, r, s, a = e[0] ? ne(e[0]).harness : 0, o = a && a.aliases;
                       if (!o)
                         return t;
                       for (n in i = me({}, t),
                         o)
                         if (n in i)
                           for (r = (s = o[n].split(",")).length; r--; )
                             i[s[r]] = i[n];
                       return i
                     }(c, t)),
                     h = c.length; h--; )
                if (~u.indexOf(c[h]))
                  for (o in r = d[h],
                    "all" === t ? (n[h] = t,
                      a = r,
                      s = {}) : (s = n[h] = n[h] || {},
                      a = t),
                    a)
                    (l = r && r[o]) && ("kill"in l.d && !0 !== l.d.kill(o) || _e(this, l, "_pt"),
                      delete r[o]),
                    "all" !== s && (s[o] = 1);
              return this._initted && !this._pt && p && nt(this),
                this
            }
            ,
            t.to = function(e, i) {
              return new t(e,i,arguments[2])
            }
            ,
            t.from = function(e, t) {
              return Ue(1, arguments)
            }
            ,
            t.delayedCall = function(e, i, n, r) {
              return new t(i,0,{
                immediateRender: !1,
                lazy: !1,
                overwrite: !1,
                delay: e,
                onComplete: i,
                onReverseComplete: i,
                onCompleteParams: n,
                onReverseCompleteParams: n,
                callbackScope: r
              })
            }
            ,
            t.fromTo = function(e, t, i) {
              return Ue(2, arguments)
            }
            ,
            t.set = function(e, i) {
              return i.duration = 0,
              i.repeatDelay || (i.repeat = 0),
                new t(e,i)
            }
            ,
            t.killTweensOf = function(e, t, i) {
              return a.killTweensOf(e, t, i)
            }
            ,
            t
        }(Ct);
        fe(Ut.prototype, {
          _targets: [],
          _lazy: 0,
          _startAt: 0,
          _op: 0,
          _onInit: 0
        }),
          se("staggerTo,staggerFrom,staggerFromTo", (function(e) {
              Ut[e] = function() {
                var t = new Pt
                  , i = We.call(arguments, 0);
                return i.splice("staggerFromTo" === e ? 5 : 4, 0, 0),
                  t[e].apply(t, i)
              }
            }
          ));
        var Gt = function(e, t, i) {
          return e[t] = i
        }
          , Vt = function(e, t, i) {
          return e[t](i)
        }
          , Ht = function(e, t, i, n) {
          return e[t](n.fp, i)
        }
          , Wt = function(e, t, i) {
          return e.setAttribute(t, i)
        }
          , jt = function(e, t) {
          return M(e[t]) ? Vt : E(e[t]) && e.setAttribute ? Wt : Gt
        }
          , Xt = function(e, t) {
          return t.set(t.t, t.p, Math.round(1e6 * (t.s + t.c * e)) / 1e6, t)
        }
          , Yt = function(e, t) {
          return t.set(t.t, t.p, !!(t.s + t.c * e), t)
        }
          , qt = function(e, t) {
          var i = t._pt
            , n = "";
          if (!e && t.b)
            n = t.b;
          else if (1 === e && t.e)
            n = t.e;
          else {
            for (; i; )
              n = i.p + (i.m ? i.m(i.s + i.c * e) : Math.round(1e4 * (i.s + i.c * e)) / 1e4) + n,
                i = i._next;
            n += t.c
          }
          t.set(t.t, t.p, n, t)
        }
          , Qt = function(e, t) {
          for (var i = t._pt; i; )
            i.r(e, i.d),
              i = i._next
        }
          , Kt = function(e, t, i, n) {
          for (var r, s = this._pt; s; )
            r = s._next,
            s.p === n && s.modifier(e, t, i),
              s = r
        }
          , Jt = function(e) {
          for (var t, i, n = this._pt; n; )
            i = n._next,
              n.p === e && !n.op || n.op === e ? _e(this, n, "_pt") : n.dep || (t = 1),
              n = i;
          return !t
        }
          , Zt = function(e, t, i, n) {
          n.mSet(e, t, n.m.call(n.tween, i, n.mt), n)
        }
          , $t = function(e) {
          for (var t, i, n, r, s = e._pt; s; ) {
            for (t = s._next,
                   i = n; i && i.pr > s.pr; )
              i = i._next;
            (s._prev = i ? i._prev : r) ? s._prev._next = s : n = s,
              (s._next = i) ? i._prev = s : r = s,
              s = t
          }
          e._pt = n
        }
          , ei = function() {
          function e(e, t, i, n, r, s, a, o, l) {
            this.t = t,
              this.s = n,
              this.c = r,
              this.p = i,
              this.r = s || Xt,
              this.d = a || this,
              this.set = o || Gt,
              this.pr = l || 0,
              this._next = e,
            e && (e._prev = this)
          }
          return e.prototype.modifier = function(e, t, i) {
            this.mSet = this.mSet || this.set,
              this.set = Zt,
              this.m = e,
              this.mt = i,
              this.tween = t
          }
            ,
            e
        }();
        se(te + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", (function(e) {
            return q[e] = 1
          }
        )),
          G.TweenMax = G.TweenLite = Ut,
          G.TimelineLite = G.TimelineMax = Pt,
          a = new Pt({
            sortChildren: !1,
            defaults: m,
            autoRemoveChildren: !0,
            id: "root",
            smoothChildTiming: !0
          }),
          f.stringFilter = pt;
        var ti = {
          registerPlugin: function() {
            for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
              t[i] = arguments[i];
            t.forEach((function(e) {
                return rt(e)
              }
            ))
          },
          timeline: function(e) {
            return new Pt(e)
          },
          getTweensOf: function(e, t) {
            return a.getTweensOf(e, t)
          },
          getProperty: function(e, t, i, n) {
            S(e) && (e = Xe(e)[0]);
            var r = ne(e || {}).get
              , s = i ? pe : de;
            return "native" === i && (i = ""),
              e ? t ? s((J[t] && J[t].get || r)(e, t, i, n)) : function(t, i, n) {
                  return s((J[t] && J[t].get || r)(e, t, i, n))
                }
                : e
          },
          quickSetter: function(e, t, i) {
            if ((e = Xe(e)).length > 1) {
              var n = e.map((function(e) {
                  return ri.quickSetter(e, t, i)
                }
              ))
                , r = n.length;
              return function(e) {
                for (var t = r; t--; )
                  n[t](e)
              }
            }
            e = e[0] || {};
            var s = J[t]
              , a = ne(e)
              , o = a.harness && (a.harness.aliases || {})[t] || t
              , l = s ? function(t) {
                var n = new s;
                d._pt = 0,
                  n.init(e, i ? t + i : t, d, 0, [e]),
                  n.render(1, n),
                d._pt && Qt(1, d)
              }
              : a.set(e, o);
            return s ? l : function(t) {
              return l(e, o, i ? t + i : t, a, 1)
            }
          },
          quickTo: function(e, t, i) {
            var n, r = ri.to(e, me(((n = {})[t] = "+=0.1",
              n.paused = !0,
              n), i || {})), s = function(e, i, n) {
              return r.resetTo(t, e, i, n)
            };
            return s.tween = r,
              s
          },
          isTweening: function(e) {
            return a.getTweensOf(e, !0).length > 0
          },
          defaults: function(e) {
            return e && e.ease && (e.ease = wt(e.ease, m.ease)),
              ge(m, e || {})
          },
          config: function(e) {
            return ge(f, e || {})
          },
          registerEffect: function(e) {
            var t = e.name
              , i = e.effect
              , n = e.plugins
              , r = e.defaults
              , s = e.extendTimeline;
            (n || "").split(",").forEach((function(e) {
                return e && !J[e] && !G[e] && j(t + " effect requires " + e + " plugin.")
              }
            )),
              Z[t] = function(e, t, n) {
                return i(Xe(e), fe(t || {}, r), n)
              }
              ,
            s && (Pt.prototype[t] = function(e, i, n) {
                return this.add(Z[t](e, C(i) ? i : (n = i) && {}, this), n)
              }
            )
          },
          registerEase: function(e, t) {
            gt[e] = wt(t)
          },
          parseEase: function(e, t) {
            return arguments.length ? wt(e, t) : gt
          },
          getById: function(e) {
            return a.getById(e)
          },
          exportRoot: function(e, t) {
            void 0 === e && (e = {});
            var i, n, r = new Pt(e);
            for (r.smoothChildTiming = P(e.smoothChildTiming),
                   a.remove(r),
                   r._dp = 0,
                   r._time = r._tTime = a._time,
                   i = a._first; i; )
              n = i._next,
              !t && !i._dur && i instanceof Ut && i.vars.onComplete === i._targets[0] || Ie(r, i, i._start - i._delay),
                i = n;
            return Ie(a, r, 0),
              r
          },
          utils: {
            wrap: function e(t, i, n) {
              var r = i - t;
              return L(t) ? Ze(t, e(0, t.length), i) : Ge(n, (function(e) {
                  return (r + (e - t) % r) % r + t
                }
              ))
            },
            wrapYoyo: function e(t, i, n) {
              var r = i - t
                , s = 2 * r;
              return L(t) ? Ze(t, e(0, t.length - 1), i) : Ge(n, (function(e) {
                  return t + ((e = (s + (e - t) % s) % s || 0) > r ? s - e : e)
                }
              ))
            },
            distribute: qe,
            random: Je,
            snap: Ke,
            normalize: function(e, t, i) {
              return et(e, t, 0, 1, i)
            },
            getUnit: He,
            clamp: function(e, t, i) {
              return Ge(i, (function(i) {
                  return Ve(e, t, i)
                }
              ))
            },
            splitColor: lt,
            toArray: Xe,
            selector: function(e) {
              return e = Xe(e)[0] || j("Invalid scope") || {},
                function(t) {
                  var i = e.current || e.nativeElement || e;
                  return Xe(t, i.querySelectorAll ? i : i === e ? j("Invalid scope") || h.createElement("div") : e)
                }
            },
            mapRange: et,
            pipe: function() {
              for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
                t[i] = arguments[i];
              return function(e) {
                return t.reduce((function(e, t) {
                    return t(e)
                  }
                ), e)
              }
            },
            unitize: function(e, t) {
              return function(i) {
                return e(parseFloat(i)) + (t || He(i))
              }
            },
            interpolate: function e(t, i, n, r) {
              var s = isNaN(t + i) ? 0 : function(e) {
                  return (1 - e) * t + e * i
                }
              ;
              if (!s) {
                var a, o, l, h, c, u = S(t), d = {};
                if (!0 === n && (r = 1) && (n = null),
                  u)
                  t = {
                    p: t
                  },
                    i = {
                      p: i
                    };
                else if (L(t) && !L(i)) {
                  for (l = [],
                         h = t.length,
                         c = h - 2,
                         o = 1; o < h; o++)
                    l.push(e(t[o - 1], t[o]));
                  h--,
                    s = function(e) {
                      e *= h;
                      var t = Math.min(c, ~~e);
                      return l[t](e - t)
                    }
                    ,
                    n = i
                } else
                  r || (t = me(L(t) ? [] : {}, t));
                if (!l) {
                  for (a in i)
                    Lt.call(d, t, a, "get", i[a]);
                  s = function(e) {
                    return Qt(e, d) || (u ? t.p : t)
                  }
                }
              }
              return Ge(n, s)
            },
            shuffle: Ye
          },
          install: H,
          effects: Z,
          ticker: ft,
          updateRoot: Pt.updateRoot,
          plugins: J,
          globalTimeline: a,
          core: {
            PropTween: ei,
            globals: X,
            Tween: Ut,
            Timeline: Pt,
            Animation: Ct,
            getCache: ne,
            _removeLinkedListItem: _e,
            suppressOverwrites: function(e) {
              return s = e
            }
          }
        };
        se("to,from,fromTo,delayedCall,set,killTweensOf", (function(e) {
            return ti[e] = Ut[e]
          }
        )),
          ft.add(Pt.updateRoot),
          d = ti.to({}, {
            duration: 0
          });
        var ii = function(e, t) {
          for (var i = e._pt; i && i.p !== t && i.op !== t && i.fp !== t; )
            i = i._next;
          return i
        }
          , ni = function(e, t) {
          return {
            name: e,
            rawVars: 1,
            init: function(e, i, n) {
              n._onInit = function(e) {
                var n, r;
                if (S(i) && (n = {},
                  se(i, (function(e) {
                      return n[e] = 1
                    }
                  )),
                  i = n),
                  t) {
                  for (r in n = {},
                    i)
                    n[r] = t(i[r]);
                  i = n
                }
                !function(e, t) {
                  var i, n, r, s = e._targets;
                  for (i in t)
                    for (n = s.length; n--; )
                      (r = e._ptLookup[n][i]) && (r = r.d) && (r._pt && (r = ii(r, i)),
                      r && r.modifier && r.modifier(t[i], e, s[n], i))
                }(e, i)
              }
            }
          }
        }
          , ri = ti.registerPlugin({
          name: "attr",
          init: function(e, t, i, n, r) {
            var s, a;
            for (s in t)
              (a = this.add(e, "setAttribute", (e.getAttribute(s) || 0) + "", t[s], n, r, 0, 0, s)) && (a.op = s),
                this._props.push(s)
          }
        }, {
          name: "endArray",
          init: function(e, t) {
            for (var i = t.length; i--; )
              this.add(e, i, e[i] || 0, t[i])
          }
        }, ni("roundProps", Qe), ni("modifiers"), ni("snap", Ke)) || ti;
        Ut.version = Pt.version = ri.version = "3.10.4",
          c = 1,
        D() && mt(),
          gt.Power0,
          gt.Power1,
          gt.Power2,
          gt.Power3,
          gt.Power4,
          gt.Linear,
          gt.Quad,
          gt.Cubic,
          gt.Quart,
          gt.Quint,
          gt.Strong,
          gt.Elastic,
          gt.Back,
          gt.SteppedEase,
          gt.Bounce,
          gt.Sine,
          gt.Expo,
          gt.Circ;
        var si, ai, oi, li, hi, ci, ui, di = {}, pi = 180 / Math.PI, fi = Math.PI / 180, mi = Math.atan2, gi = /([A-Z])/g, vi = /(left|right|width|margin|padding|x)/i, yi = /[\s,\(]\S/, xi = {
          autoAlpha: "opacity,visibility",
          scale: "scaleX,scaleY",
          alpha: "opacity"
        }, _i = function(e, t) {
          return t.set(t.t, t.p, Math.round(1e4 * (t.s + t.c * e)) / 1e4 + t.u, t)
        }, bi = function(e, t) {
          return t.set(t.t, t.p, 1 === e ? t.e : Math.round(1e4 * (t.s + t.c * e)) / 1e4 + t.u, t)
        }, wi = function(e, t) {
          return t.set(t.t, t.p, e ? Math.round(1e4 * (t.s + t.c * e)) / 1e4 + t.u : t.b, t)
        }, Ai = function(e, t) {
          var i = t.s + t.c * e;
          t.set(t.t, t.p, ~~(i + (i < 0 ? -.5 : .5)) + t.u, t)
        }, Si = function(e, t) {
          return t.set(t.t, t.p, e ? t.e : t.b, t)
        }, Mi = function(e, t) {
          return t.set(t.t, t.p, 1 !== e ? t.b : t.e, t)
        }, Ti = function(e, t, i) {
          return e.style[t] = i
        }, Ei = function(e, t, i) {
          return e.style.setProperty(t, i)
        }, Ci = function(e, t, i) {
          return e._gsap[t] = i
        }, Pi = function(e, t, i) {
          return e._gsap.scaleX = e._gsap.scaleY = i
        }, Di = function(e, t, i, n, r) {
          var s = e._gsap;
          s.scaleX = s.scaleY = i,
            s.renderTransform(r, s)
        }, Ii = function(e, t, i, n, r) {
          var s = e._gsap;
          s[t] = i,
            s.renderTransform(r, s)
        }, Ri = "transform", Li = Ri + "Origin", ki = function(e, t) {
          var i = ai.createElementNS ? ai.createElementNS((t || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), e) : ai.createElement(e);
          return i.style ? i : ai.createElement(e)
        }, Fi = function e(t, i, n) {
          var r = getComputedStyle(t);
          return r[i] || r.getPropertyValue(i.replace(gi, "-$1").toLowerCase()) || r.getPropertyValue(i) || !n && e(t, Oi(i) || i, 1) || ""
        }, Bi = "O,Moz,ms,Ms,Webkit".split(","), Oi = function(e, t, i) {
          var n = (t || hi).style
            , r = 5;
          if (e in n && !i)
            return e;
          for (e = e.charAt(0).toUpperCase() + e.substr(1); r-- && !(Bi[r] + e in n); )
            ;
          return r < 0 ? null : (3 === r ? "ms" : r >= 0 ? Bi[r] : "") + e
        }, Ni = function() {
          "undefined" != typeof window && window.document && (si = window,
            ai = si.document,
            oi = ai.documentElement,
            hi = ki("div") || {
              style: {}
            },
            ki("div"),
            Ri = Oi(Ri),
            Li = Ri + "Origin",
            hi.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0",
            ui = !!Oi("perspective"),
            li = 1)
        }, zi = function e(t) {
          var i, n = ki("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), r = this.parentNode, s = this.nextSibling, a = this.style.cssText;
          if (oi.appendChild(n),
            n.appendChild(this),
            this.style.display = "block",
            t)
            try {
              i = this.getBBox(),
                this._gsapBBox = this.getBBox,
                this.getBBox = e
            } catch (e) {}
          else
            this._gsapBBox && (i = this._gsapBBox());
          return r && (s ? r.insertBefore(this, s) : r.appendChild(this)),
            oi.removeChild(n),
            this.style.cssText = a,
            i
        }, Ui = function(e, t) {
          for (var i = t.length; i--; )
            if (e.hasAttribute(t[i]))
              return e.getAttribute(t[i])
        }, Gi = function(e) {
          var t;
          try {
            t = e.getBBox()
          } catch (i) {
            t = zi.call(e, !0)
          }
          return t && (t.width || t.height) || e.getBBox === zi || (t = zi.call(e, !0)),
            !t || t.width || t.x || t.y ? t : {
              x: +Ui(e, ["x", "cx", "x1"]) || 0,
              y: +Ui(e, ["y", "cy", "y1"]) || 0,
              width: 0,
              height: 0
            }
        }, Vi = function(e) {
          return !(!e.getCTM || e.parentNode && !e.ownerSVGElement || !Gi(e))
        }, Hi = function(e, t) {
          if (t) {
            var i = e.style;
            t in di && t !== Li && (t = Ri),
              i.removeProperty ? ("ms" !== t.substr(0, 2) && "webkit" !== t.substr(0, 6) || (t = "-" + t),
                i.removeProperty(t.replace(gi, "-$1").toLowerCase())) : i.removeAttribute(t)
          }
        }, Wi = function(e, t, i, n, r, s) {
          var a = new ei(e._pt,t,i,0,1,s ? Mi : Si);
          return e._pt = a,
            a.b = n,
            a.e = r,
            e._props.push(i),
            a
        }, ji = {
          deg: 1,
          rad: 1,
          turn: 1
        }, Xi = function e(t, i, n, r) {
          var s, a, o, l, h = parseFloat(n) || 0, c = (n + "").trim().substr((h + "").length) || "px", u = hi.style, d = vi.test(i), p = "svg" === t.tagName.toLowerCase(), f = (p ? "client" : "offset") + (d ? "Width" : "Height"), m = 100, g = "px" === r, v = "%" === r;
          return r === c || !h || ji[r] || ji[c] ? h : ("px" !== c && !g && (h = e(t, i, n, "px")),
            l = t.getCTM && Vi(t),
            !v && "%" !== c || !di[i] && !~i.indexOf("adius") ? (u[d ? "width" : "height"] = m + (g ? c : r),
              a = ~i.indexOf("adius") || "em" === r && t.appendChild && !p ? t : t.parentNode,
            l && (a = (t.ownerSVGElement || {}).parentNode),
            a && a !== ai && a.appendChild || (a = ai.body),
              (o = a._gsap) && v && o.width && d && o.time === ft.time ? ae(h / o.width * m) : ((v || "%" === c) && (u.position = Fi(t, "position")),
              a === t && (u.position = "static"),
                a.appendChild(hi),
                s = hi[f],
                a.removeChild(hi),
                u.position = "absolute",
              d && v && ((o = ne(a)).time = ft.time,
                o.width = a[f]),
                ae(g ? s * h / m : s && h ? m / s * h : 0))) : (s = l ? t.getBBox()[d ? "width" : "height"] : t[f],
              ae(v ? h / s * m : h / 100 * s)))
        }, Yi = function(e, t, i, n) {
          var r;
          return li || Ni(),
          t in xi && "transform" !== t && ~(t = xi[t]).indexOf(",") && (t = t.split(",")[0]),
            di[t] && "transform" !== t ? (r = sn(e, n),
              r = "transformOrigin" !== t ? r[t] : r.svg ? r.origin : an(Fi(e, Li)) + " " + r.zOrigin + "px") : (!(r = e.style[t]) || "auto" === r || n || ~(r + "").indexOf("calc(")) && (r = Ji[t] && Ji[t](e, t, i) || Fi(e, t) || re(e, t) || ("opacity" === t ? 1 : 0)),
            i && !~(r + "").trim().indexOf(" ") ? Xi(e, t, r, i) + i : r
        }, qi = function(e, t, i, n) {
          if (!i || "none" === i) {
            var r = Oi(t, e, 1)
              , s = r && Fi(e, r, 1);
            s && s !== i ? (t = r,
              i = s) : "borderColor" === t && (i = Fi(e, "borderTopColor"))
          }
          var a, o, l, h, c, u, d, p, m, g, v, y = new ei(this._pt,e.style,t,0,1,qt), x = 0, _ = 0;
          if (y.b = i,
            y.e = n,
            i += "",
          "auto" == (n += "") && (e.style[t] = n,
            n = Fi(e, t) || n,
            e.style[t] = i),
            pt(a = [i, n]),
            n = a[1],
            l = (i = a[0]).match(B) || [],
            (n.match(B) || []).length) {
            for (; o = B.exec(n); )
              d = o[0],
                m = n.substring(x, o.index),
                c ? c = (c + 1) % 5 : "rgba(" !== m.substr(-5) && "hsla(" !== m.substr(-5) || (c = 1),
              d !== (u = l[_++] || "") && (h = parseFloat(u) || 0,
                v = u.substr((h + "").length),
              "=" === d.charAt(1) && (d = le(h, d) + v),
                p = parseFloat(d),
                g = d.substr((p + "").length),
                x = B.lastIndex - g.length,
              g || (g = g || f.units[t] || v,
              x === n.length && (n += g,
                y.e += g)),
              v !== g && (h = Xi(e, t, u, g) || 0),
                y._pt = {
                  _next: y._pt,
                  p: m || 1 === _ ? m : ",",
                  s: h,
                  c: p - h,
                  m: c && c < 4 || "zIndex" === t ? Math.round : 0
                });
            y.c = x < n.length ? n.substring(x, n.length) : ""
          } else
            y.r = "display" === t && "none" === n ? Mi : Si;
          return N.test(n) && (y.e = 0),
            this._pt = y,
            y
        }, Qi = {
          top: "0%",
          bottom: "100%",
          left: "0%",
          right: "100%",
          center: "50%"
        }, Ki = function(e, t) {
          if (t.tween && t.tween._time === t.tween._dur) {
            var i, n, r, s = t.t, a = s.style, o = t.u, l = s._gsap;
            if ("all" === o || !0 === o)
              a.cssText = "",
                n = 1;
            else
              for (r = (o = o.split(",")).length; --r > -1; )
                i = o[r],
                di[i] && (n = 1,
                  i = "transformOrigin" === i ? Li : Ri),
                  Hi(s, i);
            n && (Hi(s, Ri),
            l && (l.svg && s.removeAttribute("transform"),
              sn(s, 1),
              l.uncache = 1))
          }
        }, Ji = {
          clearProps: function(e, t, i, n, r) {
            if ("isFromStart" !== r.data) {
              var s = e._pt = new ei(e._pt,t,i,0,0,Ki);
              return s.u = n,
                s.pr = -10,
                s.tween = r,
                e._props.push(i),
                1
            }
          }
        }, Zi = [1, 0, 0, 1, 0, 0], $i = {}, en = function(e) {
          return "matrix(1, 0, 0, 1, 0, 0)" === e || "none" === e || !e
        }, tn = function(e) {
          var t = Fi(e, Ri);
          return en(t) ? Zi : t.substr(7).match(F).map(ae)
        }, nn = function(e, t) {
          var i, n, r, s, a = e._gsap || ne(e), o = e.style, l = tn(e);
          return a.svg && e.getAttribute("transform") ? "1,0,0,1,0,0" === (l = [(r = e.transform.baseVal.consolidate().matrix).a, r.b, r.c, r.d, r.e, r.f]).join(",") ? Zi : l : (l !== Zi || e.offsetParent || e === oi || a.svg || (r = o.display,
            o.display = "block",
          (i = e.parentNode) && e.offsetParent || (s = 1,
            n = e.nextSibling,
            oi.appendChild(e)),
            l = tn(e),
            r ? o.display = r : Hi(e, "display"),
          s && (n ? i.insertBefore(e, n) : i ? i.appendChild(e) : oi.removeChild(e))),
            t && l.length > 6 ? [l[0], l[1], l[4], l[5], l[12], l[13]] : l)
        }, rn = function(e, t, i, n, r, s) {
          var a, o, l, h = e._gsap, c = r || nn(e, !0), u = h.xOrigin || 0, d = h.yOrigin || 0, p = h.xOffset || 0, f = h.yOffset || 0, m = c[0], g = c[1], v = c[2], y = c[3], x = c[4], _ = c[5], b = t.split(" "), w = parseFloat(b[0]) || 0, A = parseFloat(b[1]) || 0;
          i ? c !== Zi && (o = m * y - g * v) && (l = w * (-g / o) + A * (m / o) - (m * _ - g * x) / o,
            w = w * (y / o) + A * (-v / o) + (v * _ - y * x) / o,
            A = l) : (w = (a = Gi(e)).x + (~b[0].indexOf("%") ? w / 100 * a.width : w),
            A = a.y + (~(b[1] || b[0]).indexOf("%") ? A / 100 * a.height : A)),
            n || !1 !== n && h.smooth ? (x = w - u,
              _ = A - d,
              h.xOffset = p + (x * m + _ * v) - x,
              h.yOffset = f + (x * g + _ * y) - _) : h.xOffset = h.yOffset = 0,
            h.xOrigin = w,
            h.yOrigin = A,
            h.smooth = !!n,
            h.origin = t,
            h.originIsAbsolute = !!i,
            e.style[Li] = "0px 0px",
          s && (Wi(s, h, "xOrigin", u, w),
            Wi(s, h, "yOrigin", d, A),
            Wi(s, h, "xOffset", p, h.xOffset),
            Wi(s, h, "yOffset", f, h.yOffset)),
            e.setAttribute("data-svg-origin", w + " " + A)
        }, sn = function(e, t) {
          var i = e._gsap || new Et(e);
          if ("x"in i && !t && !i.uncache)
            return i;
          var n, r, s, a, o, l, h, c, u, d, p, m, g, v, y, x, _, b, w, A, S, M, T, E, C, P, D, I, R, L, k, F, B = e.style, O = i.scaleX < 0, N = "px", z = "deg", U = Fi(e, Li) || "0";
          return n = r = s = l = h = c = u = d = p = 0,
            a = o = 1,
            i.svg = !(!e.getCTM || !Vi(e)),
            v = nn(e, i.svg),
          i.svg && (E = (!i.uncache || "0px 0px" === U) && !t && e.getAttribute("data-svg-origin"),
            rn(e, E || U, !!E || i.originIsAbsolute, !1 !== i.smooth, v)),
            m = i.xOrigin || 0,
            g = i.yOrigin || 0,
          v !== Zi && (b = v[0],
            w = v[1],
            A = v[2],
            S = v[3],
            n = M = v[4],
            r = T = v[5],
            6 === v.length ? (a = Math.sqrt(b * b + w * w),
              o = Math.sqrt(S * S + A * A),
              l = b || w ? mi(w, b) * pi : 0,
            (u = A || S ? mi(A, S) * pi + l : 0) && (o *= Math.abs(Math.cos(u * fi))),
            i.svg && (n -= m - (m * b + g * A),
              r -= g - (m * w + g * S))) : (F = v[6],
              L = v[7],
              D = v[8],
              I = v[9],
              R = v[10],
              k = v[11],
              n = v[12],
              r = v[13],
              s = v[14],
              h = (y = mi(F, R)) * pi,
            y && (E = M * (x = Math.cos(-y)) + D * (_ = Math.sin(-y)),
              C = T * x + I * _,
              P = F * x + R * _,
              D = M * -_ + D * x,
              I = T * -_ + I * x,
              R = F * -_ + R * x,
              k = L * -_ + k * x,
              M = E,
              T = C,
              F = P),
              c = (y = mi(-A, R)) * pi,
            y && (x = Math.cos(-y),
              k = S * (_ = Math.sin(-y)) + k * x,
              b = E = b * x - D * _,
              w = C = w * x - I * _,
              A = P = A * x - R * _),
              l = (y = mi(w, b)) * pi,
            y && (E = b * (x = Math.cos(y)) + w * (_ = Math.sin(y)),
              C = M * x + T * _,
              w = w * x - b * _,
              T = T * x - M * _,
              b = E,
              M = C),
            h && Math.abs(h) + Math.abs(l) > 359.9 && (h = l = 0,
              c = 180 - c),
              a = ae(Math.sqrt(b * b + w * w + A * A)),
              o = ae(Math.sqrt(T * T + F * F)),
              y = mi(M, T),
              u = Math.abs(y) > 2e-4 ? y * pi : 0,
              p = k ? 1 / (k < 0 ? -k : k) : 0),
          i.svg && (E = e.getAttribute("transform"),
            i.forceCSS = e.setAttribute("transform", "") || !en(Fi(e, Ri)),
          E && e.setAttribute("transform", E))),
          Math.abs(u) > 90 && Math.abs(u) < 270 && (O ? (a *= -1,
            u += l <= 0 ? 180 : -180,
            l += l <= 0 ? 180 : -180) : (o *= -1,
            u += u <= 0 ? 180 : -180)),
            t = t || i.uncache,
            i.x = n - ((i.xPercent = n && (!t && i.xPercent || (Math.round(e.offsetWidth / 2) === Math.round(-n) ? -50 : 0))) ? e.offsetWidth * i.xPercent / 100 : 0) + N,
            i.y = r - ((i.yPercent = r && (!t && i.yPercent || (Math.round(e.offsetHeight / 2) === Math.round(-r) ? -50 : 0))) ? e.offsetHeight * i.yPercent / 100 : 0) + N,
            i.z = s + N,
            i.scaleX = ae(a),
            i.scaleY = ae(o),
            i.rotation = ae(l) + z,
            i.rotationX = ae(h) + z,
            i.rotationY = ae(c) + z,
            i.skewX = u + z,
            i.skewY = d + z,
            i.transformPerspective = p + N,
          (i.zOrigin = parseFloat(U.split(" ")[2]) || 0) && (B[Li] = an(U)),
            i.xOffset = i.yOffset = 0,
            i.force3D = f.force3D,
            i.renderTransform = i.svg ? pn : ui ? dn : ln,
            i.uncache = 0,
            i
        }, an = function(e) {
          return (e = e.split(" "))[0] + " " + e[1]
        }, on = function(e, t, i) {
          var n = He(t);
          return ae(parseFloat(t) + parseFloat(Xi(e, "x", i + "px", n))) + n
        }, ln = function(e, t) {
          t.z = "0px",
            t.rotationY = t.rotationX = "0deg",
            t.force3D = 0,
            dn(e, t)
        }, hn = "0deg", cn = "0px", un = ") ", dn = function(e, t) {
          var i = t || this
            , n = i.xPercent
            , r = i.yPercent
            , s = i.x
            , a = i.y
            , o = i.z
            , l = i.rotation
            , h = i.rotationY
            , c = i.rotationX
            , u = i.skewX
            , d = i.skewY
            , p = i.scaleX
            , f = i.scaleY
            , m = i.transformPerspective
            , g = i.force3D
            , v = i.target
            , y = i.zOrigin
            , x = ""
            , _ = "auto" === g && e && 1 !== e || !0 === g;
          if (y && (c !== hn || h !== hn)) {
            var b, w = parseFloat(h) * fi, A = Math.sin(w), S = Math.cos(w);
            w = parseFloat(c) * fi,
              b = Math.cos(w),
              s = on(v, s, A * b * -y),
              a = on(v, a, -Math.sin(w) * -y),
              o = on(v, o, S * b * -y + y)
          }
          m !== cn && (x += "perspective(" + m + un),
          (n || r) && (x += "translate(" + n + "%, " + r + "%) "),
          (_ || s !== cn || a !== cn || o !== cn) && (x += o !== cn || _ ? "translate3d(" + s + ", " + a + ", " + o + ") " : "translate(" + s + ", " + a + un),
          l !== hn && (x += "rotate(" + l + un),
          h !== hn && (x += "rotateY(" + h + un),
          c !== hn && (x += "rotateX(" + c + un),
          u === hn && d === hn || (x += "skew(" + u + ", " + d + un),
          1 === p && 1 === f || (x += "scale(" + p + ", " + f + un),
            v.style[Ri] = x || "translate(0, 0)"
        }, pn = function(e, t) {
          var i, n, r, s, a, o = t || this, l = o.xPercent, h = o.yPercent, c = o.x, u = o.y, d = o.rotation, p = o.skewX, f = o.skewY, m = o.scaleX, g = o.scaleY, v = o.target, y = o.xOrigin, x = o.yOrigin, _ = o.xOffset, b = o.yOffset, w = o.forceCSS, A = parseFloat(c), S = parseFloat(u);
          d = parseFloat(d),
            p = parseFloat(p),
          (f = parseFloat(f)) && (p += f = parseFloat(f),
            d += f),
            d || p ? (d *= fi,
              p *= fi,
              i = Math.cos(d) * m,
              n = Math.sin(d) * m,
              r = Math.sin(d - p) * -g,
              s = Math.cos(d - p) * g,
            p && (f *= fi,
              a = Math.tan(p - f),
              r *= a = Math.sqrt(1 + a * a),
              s *= a,
            f && (a = Math.tan(f),
              i *= a = Math.sqrt(1 + a * a),
              n *= a)),
              i = ae(i),
              n = ae(n),
              r = ae(r),
              s = ae(s)) : (i = m,
              s = g,
              n = r = 0),
          (A && !~(c + "").indexOf("px") || S && !~(u + "").indexOf("px")) && (A = Xi(v, "x", c, "px"),
            S = Xi(v, "y", u, "px")),
          (y || x || _ || b) && (A = ae(A + y - (y * i + x * r) + _),
            S = ae(S + x - (y * n + x * s) + b)),
          (l || h) && (a = v.getBBox(),
            A = ae(A + l / 100 * a.width),
            S = ae(S + h / 100 * a.height)),
            a = "matrix(" + i + "," + n + "," + r + "," + s + "," + A + "," + S + ")",
            v.setAttribute("transform", a),
          w && (v.style[Ri] = a)
        }, fn = function(e, t, i, n, r) {
          var s, a, o = 360, l = S(r), h = parseFloat(r) * (l && ~r.indexOf("rad") ? pi : 1) - n, c = n + h + "deg";
          return l && ("short" === (s = r.split("_")[1]) && (h %= o) != h % 180 && (h += h < 0 ? o : -360),
            "cw" === s && h < 0 ? h = (h + 36e9) % o - ~~(h / o) * o : "ccw" === s && h > 0 && (h = (h - 36e9) % o - ~~(h / o) * o)),
            e._pt = a = new ei(e._pt,t,i,n,h,bi),
            a.e = c,
            a.u = "deg",
            e._props.push(i),
            a
        }, mn = function(e, t) {
          for (var i in t)
            e[i] = t[i];
          return e
        }, gn = function(e, t, i) {
          var n, r, s, a, o, l, h, c = mn({}, i._gsap), u = i.style;
          for (r in c.svg ? (s = i.getAttribute("transform"),
            i.setAttribute("transform", ""),
            u[Ri] = t,
            n = sn(i, 1),
            Hi(i, Ri),
            i.setAttribute("transform", s)) : (s = getComputedStyle(i)[Ri],
            u[Ri] = t,
            n = sn(i, 1),
            u[Ri] = s),
            di)
            (s = c[r]) !== (a = n[r]) && "perspective,force3D,transformOrigin,svgOrigin".indexOf(r) < 0 && (o = He(s) !== (h = He(a)) ? Xi(i, r, s, h) : parseFloat(s),
              l = parseFloat(a),
              e._pt = new ei(e._pt,n,r,o,l - o,_i),
              e._pt.u = h || 0,
              e._props.push(r));
          mn(n, c)
        };
        se("padding,margin,Width,Radius", (function(e, t) {
            var i = "Top"
              , n = "Right"
              , r = "Bottom"
              , s = "Left"
              , a = (t < 3 ? [i, n, r, s] : [i + s, i + n, r + n, r + s]).map((function(i) {
                return t < 2 ? e + i : "border" + i + e
              }
            ));
            Ji[t > 1 ? "border" + e : e] = function(e, t, i, n, r) {
              var s, o;
              if (arguments.length < 4)
                return s = a.map((function(t) {
                    return Yi(e, t, i)
                  }
                )),
                  5 === (o = s.join(" ")).split(s[0]).length ? s[0] : o;
              s = (n + "").split(" "),
                o = {},
                a.forEach((function(e, t) {
                    return o[e] = s[t] = s[t] || s[(t - 1) / 2 | 0]
                  }
                )),
                e.init(t, o, r)
            }
          }
        ));
        var vn, yn, xn = {
          name: "css",
          register: Ni,
          targetTest: function(e) {
            return e.style && e.nodeType
          },
          init: function(e, t, i, n, r) {
            var s, a, o, l, h, c, u, d, p, m, g, v, y, x, _, b, w, A, M, T = this._props, E = e.style, C = i.vars.startAt;
            for (u in li || Ni(),
              t)
              if ("autoRound" !== u && (a = t[u],
              !J[u] || !kt(u, t, i, n, e, r)))
                if (h = typeof a,
                  c = Ji[u],
                "function" === h && (h = typeof (a = a.call(i, n, e, r))),
                "string" === h && ~a.indexOf("random(") && (a = $e(a)),
                  c)
                  c(this, e, u, a, i) && (_ = 1);
                else if ("--" === u.substr(0, 2))
                  s = (getComputedStyle(e).getPropertyValue(u) + "").trim(),
                    a += "",
                    ut.lastIndex = 0,
                  ut.test(s) || (d = He(s),
                    p = He(a)),
                    p ? d !== p && (s = Xi(e, u, s, p) + p) : d && (a += d),
                    this.add(E, "setProperty", s, a, n, r, 0, 0, u),
                    T.push(u);
                else if ("undefined" !== h) {
                  if (C && u in C ? (s = "function" == typeof C[u] ? C[u].call(i, n, e, r) : C[u],
                  S(s) && ~s.indexOf("random(") && (s = $e(s)),
                  He(s + "") || (s += f.units[u] || He(Yi(e, u)) || ""),
                  "=" === (s + "").charAt(1) && (s = Yi(e, u))) : s = Yi(e, u),
                    l = parseFloat(s),
                  (m = "string" === h && "=" === a.charAt(1) && a.substr(0, 2)) && (a = a.substr(2)),
                    o = parseFloat(a),
                  u in xi && ("autoAlpha" === u && (1 === l && "hidden" === Yi(e, "visibility") && o && (l = 0),
                    Wi(this, E, "visibility", l ? "inherit" : "hidden", o ? "inherit" : "hidden", !o)),
                  "scale" !== u && "transform" !== u && ~(u = xi[u]).indexOf(",") && (u = u.split(",")[0])),
                    g = u in di)
                    if (v || ((y = e._gsap).renderTransform && !t.parseTransform || sn(e, t.parseTransform),
                      x = !1 !== t.smoothOrigin && y.smooth,
                      (v = this._pt = new ei(this._pt,E,Ri,0,1,y.renderTransform,y,0,-1)).dep = 1),
                    "scale" === u)
                      this._pt = new ei(this._pt,y,"scaleY",y.scaleY,(m ? le(y.scaleY, m + o) : o) - y.scaleY || 0),
                        T.push("scaleY", u),
                        u += "X";
                    else {
                      if ("transformOrigin" === u) {
                        w = void 0,
                          A = void 0,
                          M = void 0,
                          A = (w = (b = a).split(" "))[0],
                          M = w[1] || "50%",
                        "top" !== A && "bottom" !== A && "left" !== M && "right" !== M || (b = A,
                          A = M,
                          M = b),
                          w[0] = Qi[A] || A,
                          w[1] = Qi[M] || M,
                          a = w.join(" "),
                          y.svg ? rn(e, a, 0, x, 0, this) : ((p = parseFloat(a.split(" ")[2]) || 0) !== y.zOrigin && Wi(this, y, "zOrigin", y.zOrigin, p),
                            Wi(this, E, u, an(s), an(a)));
                        continue
                      }
                      if ("svgOrigin" === u) {
                        rn(e, a, 1, x, 0, this);
                        continue
                      }
                      if (u in $i) {
                        fn(this, y, u, l, m ? le(l, m + a) : a);
                        continue
                      }
                      if ("smoothOrigin" === u) {
                        Wi(this, y, "smooth", y.smooth, a);
                        continue
                      }
                      if ("force3D" === u) {
                        y[u] = a;
                        continue
                      }
                      if ("transform" === u) {
                        gn(this, a, e);
                        continue
                      }
                    }
                  else
                    u in E || (u = Oi(u) || u);
                  if (g || (o || 0 === o) && (l || 0 === l) && !yi.test(a) && u in E)
                    o || (o = 0),
                    (d = (s + "").substr((l + "").length)) !== (p = He(a) || (u in f.units ? f.units[u] : d)) && (l = Xi(e, u, s, p)),
                      this._pt = new ei(this._pt,g ? y : E,u,l,(m ? le(l, m + o) : o) - l,g || "px" !== p && "zIndex" !== u || !1 === t.autoRound ? _i : Ai),
                      this._pt.u = p || 0,
                    d !== p && "%" !== p && (this._pt.b = s,
                      this._pt.r = wi);
                  else if (u in E)
                    qi.call(this, e, u, s, m ? m + a : a);
                  else {
                    if (!(u in e)) {
                      W(u, a);
                      continue
                    }
                    this.add(e, u, s || e[u], m ? m + a : a, n, r)
                  }
                  T.push(u)
                }
            _ && $t(this)
          },
          get: Yi,
          aliases: xi,
          getSetter: function(e, t, i) {
            var n = xi[t];
            return n && n.indexOf(",") < 0 && (t = n),
              t in di && t !== Li && (e._gsap.x || Yi(e, "x")) ? i && ci === i ? "scale" === t ? Pi : Ci : (ci = i || {}) && ("scale" === t ? Di : Ii) : e.style && !E(e.style[t]) ? Ti : ~t.indexOf("-") ? Ei : jt(e, t)
          },
          core: {
            _removeProperty: Hi,
            _getMatrix: nn
          }
        };
        ri.utils.checkPrefix = Oi,
          yn = se("x,y,z,scale,scaleX,scaleY,xPercent,yPercent" + "," + (vn = "rotation,rotationX,rotationY,skewX,skewY") + ",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", (function(e) {
              di[e] = 1
            }
          )),
          se(vn, (function(e) {
              f.units[e] = "deg",
                $i[e] = 1
            }
          )),
          xi[yn[13]] = "x,y,z,scale,scaleX,scaleY,xPercent,yPercent," + vn,
          se("0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY", (function(e) {
              var t = e.split(":");
              xi[t[1]] = yn[t[0]]
            }
          )),
          se("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", (function(e) {
              f.units[e] = "px"
            }
          )),
          ri.registerPlugin(xn);
        var _n = ri.registerPlugin(xn) || ri;
        _n.core.Tween;
        const bn = {
          canvas: null,
          gpuTier: null,
          devStats: !1,
          devMode: !1,
          camera_offset: !0
        };
        function wn(e, t, i, n) {
          return new (i || (i = Promise))((function(r, s) {
              function a(e) {
                try {
                  l(n.next(e))
                } catch (e) {
                  s(e)
                }
              }
              function o(e) {
                try {
                  l(n.throw(e))
                } catch (e) {
                  s(e)
                }
              }
              function l(e) {
                var t;
                e.done ? r(e.value) : (t = e.value,
                  t instanceof i ? t : new i((function(e) {
                      e(t)
                    }
                  ))).then(a, o)
              }
              l((n = n.apply(e, t || [])).next())
            }
          ))
        }
        _n.ticker.fps(60);
        const An = ["geforce 320m", "geforce 8600", "geforce 8600m gt", "geforce 8800 gs", "geforce 8800 gt", "geforce 9400", "geforce 9400m g", "geforce 9400m", "geforce 9600m gt", "geforce 9600m", "geforce fx go5200", "geforce gt 120", "geforce gt 130", "geforce gt 330m", "geforce gtx 285", "google swiftshader", "intel g41", "intel g45", "intel gma 4500mhd", "intel gma x3100", "intel hd 3000", "intel q45", "legacy", "mali-2", "mali-3", "mali-4", "quadro fx 1500", "quadro fx 4", "quadro fx 5", "radeon hd 2400", "radeon hd 2600", "radeon hd 4670", "radeon hd 4850", "radeon hd 4870", "radeon hd 5670", "radeon hd 5750", "radeon hd 6290", "radeon hd 6300", "radeon hd 6310", "radeon hd 6320", "radeon hd 6490m", "radeon hd 6630m", "radeon hd 6750m", "radeon hd 6770m", "radeon hd 6970m", "sgx 543", "sgx543"];
        function Sn(e) {
          return e.toLowerCase().replace(/^angle ?\((.+)\)*$/, "$1").replace(/\s(\d{1,2}gb|direct3d.+$)|\(r\)| \([^)]+\)$/g, "")
        }
        const Mn = "undefined" == typeof window
          , Tn = (()=>{
            if (Mn)
              return;
            const {userAgent: e, platform: t, maxTouchPoints: i} = window.navigator
              , n = /(iphone|ipod|ipad)/i.test(e)
              , r = "iPad" === t || "MacIntel" === t && i > 0 && !window.MSStream;
            return {
              isIpad: r,
              isMobile: /android/i.test(e) || n || r,
              isSafari12: /Version\/12.+Safari/.test(e)
            }
          }
        )()
          , En = []
          , Cn = [];
        function Pn(e, t) {
          if (e === t)
            return 0;
          const i = e;
          e.length > t.length && (e = t,
            t = i);
          let n = e.length
            , r = t.length;
          for (; n > 0 && e.charCodeAt(~-n) === t.charCodeAt(~-r); )
            n--,
              r--;
          let s, a = 0;
          for (; a < n && e.charCodeAt(a) === t.charCodeAt(a); )
            a++;
          if (n -= a,
            r -= a,
          0 === n)
            return r;
          let o, l, h = 0, c = 0, u = 0;
          for (; c < n; )
            Cn[c] = e.charCodeAt(a + c),
              En[c] = ++c;
          for (; u < r; )
            for (s = t.charCodeAt(a + u),
                   o = u++,
                   h = u,
                   c = 0; c < n; c++)
              l = s === Cn[c] ? o : o + 1,
                o = En[c],
                h = En[c] = o > h ? l > h ? h + 1 : l : l > o ? o + 1 : l;
          return h
        }
        function Dn(e) {
          return null != e
        }
        class In extends Error {
          constructor(e) {
            super(e),
              Object.setPrototypeOf(this, new.target.prototype)
          }
        }
        const Rn = "141"
          , Ln = 100
          , kn = 301
          , Fn = 302
          , Bn = 306
          , On = 1e3
          , Nn = 1001
          , zn = 1002
          , Un = 1003
          , Gn = 1004
          , Vn = 1005
          , Hn = 1006
          , Wn = 1008
          , jn = 1009
          , Xn = 1014
          , Yn = 1015
          , qn = 1016
          , Qn = 1020
          , Kn = 1023
          , Jn = 1026
          , Zn = 1027
          , $n = 33776
          , er = 33777
          , tr = 33778
          , ir = 33779
          , nr = 2300
          , rr = 2301
          , sr = 2302
          , ar = 2400
          , or = 2401
          , lr = 2402
          , hr = 3e3
          , cr = 3001
          , ur = "srgb"
          , dr = "srgb-linear"
          , pr = 7680
          , fr = 35044
          , mr = "300 es"
          , gr = 1035;
        class vr {
          addEventListener(e, t) {
            void 0 === this._listeners && (this._listeners = {});
            const i = this._listeners;
            void 0 === i[e] && (i[e] = []),
            -1 === i[e].indexOf(t) && i[e].push(t)
          }
          hasEventListener(e, t) {
            if (void 0 === this._listeners)
              return !1;
            const i = this._listeners;
            return void 0 !== i[e] && -1 !== i[e].indexOf(t)
          }
          removeEventListener(e, t) {
            if (void 0 === this._listeners)
              return;
            const i = this._listeners[e];
            if (void 0 !== i) {
              const e = i.indexOf(t);
              -1 !== e && i.splice(e, 1)
            }
          }
          dispatchEvent(e) {
            if (void 0 === this._listeners)
              return;
            const t = this._listeners[e.type];
            if (void 0 !== t) {
              e.target = this;
              const i = t.slice(0);
              for (let t = 0, n = i.length; t < n; t++)
                i[t].call(this, e);
              e.target = null
            }
          }
        }
        const yr = [];
        for (let e = 0; e < 256; e++)
          yr[e] = (e < 16 ? "0" : "") + e.toString(16);
        let xr = 1234567;
        const _r = Math.PI / 180
          , br = 180 / Math.PI;
        function wr() {
          const e = 4294967295 * Math.random() | 0
            , t = 4294967295 * Math.random() | 0
            , i = 4294967295 * Math.random() | 0
            , n = 4294967295 * Math.random() | 0;
          return (yr[255 & e] + yr[e >> 8 & 255] + yr[e >> 16 & 255] + yr[e >> 24 & 255] + "-" + yr[255 & t] + yr[t >> 8 & 255] + "-" + yr[t >> 16 & 15 | 64] + yr[t >> 24 & 255] + "-" + yr[63 & i | 128] + yr[i >> 8 & 255] + "-" + yr[i >> 16 & 255] + yr[i >> 24 & 255] + yr[255 & n] + yr[n >> 8 & 255] + yr[n >> 16 & 255] + yr[n >> 24 & 255]).toLowerCase()
        }
        function Ar(e, t, i) {
          return Math.max(t, Math.min(i, e))
        }
        function Sr(e, t) {
          return (e % t + t) % t
        }
        function Mr(e, t, i) {
          return (1 - i) * e + i * t
        }
        function Tr(e) {
          return 0 == (e & e - 1) && 0 !== e
        }
        function Er(e) {
          return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2))
        }
        function Cr(e) {
          return Math.pow(2, Math.floor(Math.log(e) / Math.LN2))
        }
        var Pr = Object.freeze({
          __proto__: null,
          DEG2RAD: _r,
          RAD2DEG: br,
          generateUUID: wr,
          clamp: Ar,
          euclideanModulo: Sr,
          mapLinear: function(e, t, i, n, r) {
            return n + (e - t) * (r - n) / (i - t)
          },
          inverseLerp: function(e, t, i) {
            return e !== t ? (i - e) / (t - e) : 0
          },
          lerp: Mr,
          damp: function(e, t, i, n) {
            return Mr(e, t, 1 - Math.exp(-i * n))
          },
          pingpong: function(e, t=1) {
            return t - Math.abs(Sr(e, 2 * t) - t)
          },
          smoothstep: function(e, t, i) {
            return e <= t ? 0 : e >= i ? 1 : (e = (e - t) / (i - t)) * e * (3 - 2 * e)
          },
          smootherstep: function(e, t, i) {
            return e <= t ? 0 : e >= i ? 1 : (e = (e - t) / (i - t)) * e * e * (e * (6 * e - 15) + 10)
          },
          randInt: function(e, t) {
            return e + Math.floor(Math.random() * (t - e + 1))
          },
          randFloat: function(e, t) {
            return e + Math.random() * (t - e)
          },
          randFloatSpread: function(e) {
            return e * (.5 - Math.random())
          },
          seededRandom: function(e) {
            void 0 !== e && (xr = e);
            let t = xr += 1831565813;
            return t = Math.imul(t ^ t >>> 15, 1 | t),
              t ^= t + Math.imul(t ^ t >>> 7, 61 | t),
            ((t ^ t >>> 14) >>> 0) / 4294967296
          },
          degToRad: function(e) {
            return e * _r
          },
          radToDeg: function(e) {
            return e * br
          },
          isPowerOfTwo: Tr,
          ceilPowerOfTwo: Er,
          floorPowerOfTwo: Cr,
          setQuaternionFromProperEuler: function(e, t, i, n, r) {
            const s = Math.cos
              , a = Math.sin
              , o = s(i / 2)
              , l = a(i / 2)
              , h = s((t + n) / 2)
              , c = a((t + n) / 2)
              , u = s((t - n) / 2)
              , d = a((t - n) / 2)
              , p = s((n - t) / 2)
              , f = a((n - t) / 2);
            switch (r) {
              case "XYX":
                e.set(o * c, l * u, l * d, o * h);
                break;
              case "YZY":
                e.set(l * d, o * c, l * u, o * h);
                break;
              case "ZXZ":
                e.set(l * u, l * d, o * c, o * h);
                break;
              case "XZX":
                e.set(o * c, l * f, l * p, o * h);
                break;
              case "YXY":
                e.set(l * p, o * c, l * f, o * h);
                break;
              case "ZYZ":
                e.set(l * f, l * p, o * c, o * h);
                break;
              default:
                console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r)
            }
          },
          normalize: function(e, t) {
            switch (t.constructor) {
              case Float32Array:
                return e;
              case Uint16Array:
                return Math.round(65535 * e);
              case Uint8Array:
                return Math.round(255 * e);
              case Int16Array:
                return Math.round(32767 * e);
              case Int8Array:
                return Math.round(127 * e);
              default:
                throw new Error("Invalid component type.")
            }
          },
          denormalize: function(e, t) {
            switch (t.constructor) {
              case Float32Array:
                return e;
              case Uint16Array:
                return e / 65535;
              case Uint8Array:
                return e / 255;
              case Int16Array:
                return Math.max(e / 32767, -1);
              case Int8Array:
                return Math.max(e / 127, -1);
              default:
                throw new Error("Invalid component type.")
            }
          }
        });
        class Dr {
          constructor(e=0, t=0) {
            this.isVector2 = !0,
              this.x = e,
              this.y = t
          }
          get width() {
            return this.x
          }
          set width(e) {
            this.x = e
          }
          get height() {
            return this.y
          }
          set height(e) {
            this.y = e
          }
          set(e, t) {
            return this.x = e,
              this.y = t,
              this
          }
          setScalar(e) {
            return this.x = e,
              this.y = e,
              this
          }
          setX(e) {
            return this.x = e,
              this
          }
          setY(e) {
            return this.y = e,
              this
          }
          setComponent(e, t) {
            switch (e) {
              case 0:
                this.x = t;
                break;
              case 1:
                this.y = t;
                break;
              default:
                throw new Error("index is out of range: " + e)
            }
            return this
          }
          getComponent(e) {
            switch (e) {
              case 0:
                return this.x;
              case 1:
                return this.y;
              default:
                throw new Error("index is out of range: " + e)
            }
          }
          clone() {
            return new this.constructor(this.x,this.y)
          }
          copy(e) {
            return this.x = e.x,
              this.y = e.y,
              this
          }
          add(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
              this.addVectors(e, t)) : (this.x += e.x,
              this.y += e.y,
              this)
          }
          addScalar(e) {
            return this.x += e,
              this.y += e,
              this
          }
          addVectors(e, t) {
            return this.x = e.x + t.x,
              this.y = e.y + t.y,
              this
          }
          addScaledVector(e, t) {
            return this.x += e.x * t,
              this.y += e.y * t,
              this
          }
          sub(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
              this.subVectors(e, t)) : (this.x -= e.x,
              this.y -= e.y,
              this)
          }
          subScalar(e) {
            return this.x -= e,
              this.y -= e,
              this
          }
          subVectors(e, t) {
            return this.x = e.x - t.x,
              this.y = e.y - t.y,
              this
          }
          multiply(e) {
            return this.x *= e.x,
              this.y *= e.y,
              this
          }
          multiplyScalar(e) {
            return this.x *= e,
              this.y *= e,
              this
          }
          divide(e) {
            return this.x /= e.x,
              this.y /= e.y,
              this
          }
          divideScalar(e) {
            return this.multiplyScalar(1 / e)
          }
          applyMatrix3(e) {
            const t = this.x
              , i = this.y
              , n = e.elements;
            return this.x = n[0] * t + n[3] * i + n[6],
              this.y = n[1] * t + n[4] * i + n[7],
              this
          }
          min(e) {
            return this.x = Math.min(this.x, e.x),
              this.y = Math.min(this.y, e.y),
              this
          }
          max(e) {
            return this.x = Math.max(this.x, e.x),
              this.y = Math.max(this.y, e.y),
              this
          }
          clamp(e, t) {
            return this.x = Math.max(e.x, Math.min(t.x, this.x)),
              this.y = Math.max(e.y, Math.min(t.y, this.y)),
              this
          }
          clampScalar(e, t) {
            return this.x = Math.max(e, Math.min(t, this.x)),
              this.y = Math.max(e, Math.min(t, this.y)),
              this
          }
          clampLength(e, t) {
            const i = this.length();
            return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
          }
          floor() {
            return this.x = Math.floor(this.x),
              this.y = Math.floor(this.y),
              this
          }
          ceil() {
            return this.x = Math.ceil(this.x),
              this.y = Math.ceil(this.y),
              this
          }
          round() {
            return this.x = Math.round(this.x),
              this.y = Math.round(this.y),
              this
          }
          roundToZero() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
              this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
              this
          }
          negate() {
            return this.x = -this.x,
              this.y = -this.y,
              this
          }
          dot(e) {
            return this.x * e.x + this.y * e.y
          }
          cross(e) {
            return this.x * e.y - this.y * e.x
          }
          lengthSq() {
            return this.x * this.x + this.y * this.y
          }
          length() {
            return Math.sqrt(this.x * this.x + this.y * this.y)
          }
          manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y)
          }
          normalize() {
            return this.divideScalar(this.length() || 1)
          }
          angle() {
            return Math.atan2(-this.y, -this.x) + Math.PI
          }
          distanceTo(e) {
            return Math.sqrt(this.distanceToSquared(e))
          }
          distanceToSquared(e) {
            const t = this.x - e.x
              , i = this.y - e.y;
            return t * t + i * i
          }
          manhattanDistanceTo(e) {
            return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
          }
          setLength(e) {
            return this.normalize().multiplyScalar(e)
          }
          lerp(e, t) {
            return this.x += (e.x - this.x) * t,
              this.y += (e.y - this.y) * t,
              this
          }
          lerpVectors(e, t, i) {
            return this.x = e.x + (t.x - e.x) * i,
              this.y = e.y + (t.y - e.y) * i,
              this
          }
          equals(e) {
            return e.x === this.x && e.y === this.y
          }
          fromArray(e, t=0) {
            return this.x = e[t],
              this.y = e[t + 1],
              this
          }
          toArray(e=[], t=0) {
            return e[t] = this.x,
              e[t + 1] = this.y,
              e
          }
          fromBufferAttribute(e, t, i) {
            return void 0 !== i && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),
              this.x = e.getX(t),
              this.y = e.getY(t),
              this
          }
          rotateAround(e, t) {
            const i = Math.cos(t)
              , n = Math.sin(t)
              , r = this.x - e.x
              , s = this.y - e.y;
            return this.x = r * i - s * n + e.x,
              this.y = r * n + s * i + e.y,
              this
          }
          random() {
            return this.x = Math.random(),
              this.y = Math.random(),
              this
          }
          *[Symbol.iterator]() {
            yield this.x,
              yield this.y
          }
        }
        class Ir {
          constructor() {
            this.isMatrix3 = !0,
              this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1],
            arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
          }
          set(e, t, i, n, r, s, a, o, l) {
            const h = this.elements;
            return h[0] = e,
              h[1] = n,
              h[2] = a,
              h[3] = t,
              h[4] = r,
              h[5] = o,
              h[6] = i,
              h[7] = s,
              h[8] = l,
              this
          }
          identity() {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
              this
          }
          copy(e) {
            const t = this.elements
              , i = e.elements;
            return t[0] = i[0],
              t[1] = i[1],
              t[2] = i[2],
              t[3] = i[3],
              t[4] = i[4],
              t[5] = i[5],
              t[6] = i[6],
              t[7] = i[7],
              t[8] = i[8],
              this
          }
          extractBasis(e, t, i) {
            return e.setFromMatrix3Column(this, 0),
              t.setFromMatrix3Column(this, 1),
              i.setFromMatrix3Column(this, 2),
              this
          }
          setFromMatrix4(e) {
            const t = e.elements;
            return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]),
              this
          }
          multiply(e) {
            return this.multiplyMatrices(this, e)
          }
          premultiply(e) {
            return this.multiplyMatrices(e, this)
          }
          multiplyMatrices(e, t) {
            const i = e.elements
              , n = t.elements
              , r = this.elements
              , s = i[0]
              , a = i[3]
              , o = i[6]
              , l = i[1]
              , h = i[4]
              , c = i[7]
              , u = i[2]
              , d = i[5]
              , p = i[8]
              , f = n[0]
              , m = n[3]
              , g = n[6]
              , v = n[1]
              , y = n[4]
              , x = n[7]
              , _ = n[2]
              , b = n[5]
              , w = n[8];
            return r[0] = s * f + a * v + o * _,
              r[3] = s * m + a * y + o * b,
              r[6] = s * g + a * x + o * w,
              r[1] = l * f + h * v + c * _,
              r[4] = l * m + h * y + c * b,
              r[7] = l * g + h * x + c * w,
              r[2] = u * f + d * v + p * _,
              r[5] = u * m + d * y + p * b,
              r[8] = u * g + d * x + p * w,
              this
          }
          multiplyScalar(e) {
            const t = this.elements;
            return t[0] *= e,
              t[3] *= e,
              t[6] *= e,
              t[1] *= e,
              t[4] *= e,
              t[7] *= e,
              t[2] *= e,
              t[5] *= e,
              t[8] *= e,
              this
          }
          determinant() {
            const e = this.elements
              , t = e[0]
              , i = e[1]
              , n = e[2]
              , r = e[3]
              , s = e[4]
              , a = e[5]
              , o = e[6]
              , l = e[7]
              , h = e[8];
            return t * s * h - t * a * l - i * r * h + i * a * o + n * r * l - n * s * o
          }
          invert() {
            const e = this.elements
              , t = e[0]
              , i = e[1]
              , n = e[2]
              , r = e[3]
              , s = e[4]
              , a = e[5]
              , o = e[6]
              , l = e[7]
              , h = e[8]
              , c = h * s - a * l
              , u = a * o - h * r
              , d = l * r - s * o
              , p = t * c + i * u + n * d;
            if (0 === p)
              return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
            const f = 1 / p;
            return e[0] = c * f,
              e[1] = (n * l - h * i) * f,
              e[2] = (a * i - n * s) * f,
              e[3] = u * f,
              e[4] = (h * t - n * o) * f,
              e[5] = (n * r - a * t) * f,
              e[6] = d * f,
              e[7] = (i * o - l * t) * f,
              e[8] = (s * t - i * r) * f,
              this
          }
          transpose() {
            let e;
            const t = this.elements;
            return e = t[1],
              t[1] = t[3],
              t[3] = e,
              e = t[2],
              t[2] = t[6],
              t[6] = e,
              e = t[5],
              t[5] = t[7],
              t[7] = e,
              this
          }
          getNormalMatrix(e) {
            return this.setFromMatrix4(e).invert().transpose()
          }
          transposeIntoArray(e) {
            const t = this.elements;
            return e[0] = t[0],
              e[1] = t[3],
              e[2] = t[6],
              e[3] = t[1],
              e[4] = t[4],
              e[5] = t[7],
              e[6] = t[2],
              e[7] = t[5],
              e[8] = t[8],
              this
          }
          setUvTransform(e, t, i, n, r, s, a) {
            const o = Math.cos(r)
              , l = Math.sin(r);
            return this.set(i * o, i * l, -i * (o * s + l * a) + s + e, -n * l, n * o, -n * (-l * s + o * a) + a + t, 0, 0, 1),
              this
          }
          scale(e, t) {
            const i = this.elements;
            return i[0] *= e,
              i[3] *= e,
              i[6] *= e,
              i[1] *= t,
              i[4] *= t,
              i[7] *= t,
              this
          }
          rotate(e) {
            const t = Math.cos(e)
              , i = Math.sin(e)
              , n = this.elements
              , r = n[0]
              , s = n[3]
              , a = n[6]
              , o = n[1]
              , l = n[4]
              , h = n[7];
            return n[0] = t * r + i * o,
              n[3] = t * s + i * l,
              n[6] = t * a + i * h,
              n[1] = -i * r + t * o,
              n[4] = -i * s + t * l,
              n[7] = -i * a + t * h,
              this
          }
          translate(e, t) {
            const i = this.elements;
            return i[0] += e * i[2],
              i[3] += e * i[5],
              i[6] += e * i[8],
              i[1] += t * i[2],
              i[4] += t * i[5],
              i[7] += t * i[8],
              this
          }
          equals(e) {
            const t = this.elements
              , i = e.elements;
            for (let e = 0; e < 9; e++)
              if (t[e] !== i[e])
                return !1;
            return !0
          }
          fromArray(e, t=0) {
            for (let i = 0; i < 9; i++)
              this.elements[i] = e[i + t];
            return this
          }
          toArray(e=[], t=0) {
            const i = this.elements;
            return e[t] = i[0],
              e[t + 1] = i[1],
              e[t + 2] = i[2],
              e[t + 3] = i[3],
              e[t + 4] = i[4],
              e[t + 5] = i[5],
              e[t + 6] = i[6],
              e[t + 7] = i[7],
              e[t + 8] = i[8],
              e
          }
          clone() {
            return (new this.constructor).fromArray(this.elements)
          }
        }
        function Rr(e) {
          for (let t = e.length - 1; t >= 0; --t)
            if (e[t] > 65535)
              return !0;
          return !1
        }
        function Lr(e) {
          return document.createElementNS("http://www.w3.org/1999/xhtml", e)
        }
        function kr(e) {
          return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4)
        }
        function Fr(e) {
          return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055
        }
        Int8Array,
          Uint8Array,
          Uint8ClampedArray,
          Int16Array,
          Uint16Array,
          Int32Array,
          Uint32Array,
          Float32Array,
          Float64Array;
        const Br = {
          [ur]: {
            [dr]: kr
          },
          [dr]: {
            [ur]: Fr
          }
        }
          , Or = {
          legacyMode: !0,
          get workingColorSpace() {
            return dr
          },
          set workingColorSpace(e) {
            console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")
          },
          convert: function(e, t, i) {
            if (this.legacyMode || t === i || !t || !i)
              return e;
            if (Br[t] && void 0 !== Br[t][i]) {
              const n = Br[t][i];
              return e.r = n(e.r),
                e.g = n(e.g),
                e.b = n(e.b),
                e
            }
            throw new Error("Unsupported color space conversion.")
          },
          fromWorkingColorSpace: function(e, t) {
            return this.convert(e, this.workingColorSpace, t)
          },
          toWorkingColorSpace: function(e, t) {
            return this.convert(e, t, this.workingColorSpace)
          }
        }
          , Nr = {
          aliceblue: 15792383,
          antiquewhite: 16444375,
          aqua: 65535,
          aquamarine: 8388564,
          azure: 15794175,
          beige: 16119260,
          bisque: 16770244,
          black: 0,
          blanchedalmond: 16772045,
          blue: 255,
          blueviolet: 9055202,
          brown: 10824234,
          burlywood: 14596231,
          cadetblue: 6266528,
          chartreuse: 8388352,
          chocolate: 13789470,
          coral: 16744272,
          cornflowerblue: 6591981,
          cornsilk: 16775388,
          crimson: 14423100,
          cyan: 65535,
          darkblue: 139,
          darkcyan: 35723,
          darkgoldenrod: 12092939,
          darkgray: 11119017,
          darkgreen: 25600,
          darkgrey: 11119017,
          darkkhaki: 12433259,
          darkmagenta: 9109643,
          darkolivegreen: 5597999,
          darkorange: 16747520,
          darkorchid: 10040012,
          darkred: 9109504,
          darksalmon: 15308410,
          darkseagreen: 9419919,
          darkslateblue: 4734347,
          darkslategray: 3100495,
          darkslategrey: 3100495,
          darkturquoise: 52945,
          darkviolet: 9699539,
          deeppink: 16716947,
          deepskyblue: 49151,
          dimgray: 6908265,
          dimgrey: 6908265,
          dodgerblue: 2003199,
          firebrick: 11674146,
          floralwhite: 16775920,
          forestgreen: 2263842,
          fuchsia: 16711935,
          gainsboro: 14474460,
          ghostwhite: 16316671,
          gold: 16766720,
          goldenrod: 14329120,
          gray: 8421504,
          green: 32768,
          greenyellow: 11403055,
          grey: 8421504,
          honeydew: 15794160,
          hotpink: 16738740,
          indianred: 13458524,
          indigo: 4915330,
          ivory: 16777200,
          khaki: 15787660,
          lavender: 15132410,
          lavenderblush: 16773365,
          lawngreen: 8190976,
          lemonchiffon: 16775885,
          lightblue: 11393254,
          lightcoral: 15761536,
          lightcyan: 14745599,
          lightgoldenrodyellow: 16448210,
          lightgray: 13882323,
          lightgreen: 9498256,
          lightgrey: 13882323,
          lightpink: 16758465,
          lightsalmon: 16752762,
          lightseagreen: 2142890,
          lightskyblue: 8900346,
          lightslategray: 7833753,
          lightslategrey: 7833753,
          lightsteelblue: 11584734,
          lightyellow: 16777184,
          lime: 65280,
          limegreen: 3329330,
          linen: 16445670,
          magenta: 16711935,
          maroon: 8388608,
          mediumaquamarine: 6737322,
          mediumblue: 205,
          mediumorchid: 12211667,
          mediumpurple: 9662683,
          mediumseagreen: 3978097,
          mediumslateblue: 8087790,
          mediumspringgreen: 64154,
          mediumturquoise: 4772300,
          mediumvioletred: 13047173,
          midnightblue: 1644912,
          mintcream: 16121850,
          mistyrose: 16770273,
          moccasin: 16770229,
          navajowhite: 16768685,
          navy: 128,
          oldlace: 16643558,
          olive: 8421376,
          olivedrab: 7048739,
          orange: 16753920,
          orangered: 16729344,
          orchid: 14315734,
          palegoldenrod: 15657130,
          palegreen: 10025880,
          paleturquoise: 11529966,
          palevioletred: 14381203,
          papayawhip: 16773077,
          peachpuff: 16767673,
          peru: 13468991,
          pink: 16761035,
          plum: 14524637,
          powderblue: 11591910,
          purple: 8388736,
          rebeccapurple: 6697881,
          red: 16711680,
          rosybrown: 12357519,
          royalblue: 4286945,
          saddlebrown: 9127187,
          salmon: 16416882,
          sandybrown: 16032864,
          seagreen: 3050327,
          seashell: 16774638,
          sienna: 10506797,
          silver: 12632256,
          skyblue: 8900331,
          slateblue: 6970061,
          slategray: 7372944,
          slategrey: 7372944,
          snow: 16775930,
          springgreen: 65407,
          steelblue: 4620980,
          tan: 13808780,
          teal: 32896,
          thistle: 14204888,
          tomato: 16737095,
          turquoise: 4251856,
          violet: 15631086,
          wheat: 16113331,
          white: 16777215,
          whitesmoke: 16119285,
          yellow: 16776960,
          yellowgreen: 10145074
        }
          , zr = {
          r: 0,
          g: 0,
          b: 0
        }
          , Ur = {
          h: 0,
          s: 0,
          l: 0
        }
          , Gr = {
          h: 0,
          s: 0,
          l: 0
        };
        function Vr(e, t, i) {
          return i < 0 && (i += 1),
          i > 1 && (i -= 1),
            i < 1 / 6 ? e + 6 * (t - e) * i : i < .5 ? t : i < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - i) : e
        }
        function Hr(e, t) {
          return t.r = e.r,
            t.g = e.g,
            t.b = e.b,
            t
        }
        class Wr {
          constructor(e, t, i) {
            return this.isColor = !0,
              this.r = 1,
              this.g = 1,
              this.b = 1,
              void 0 === t && void 0 === i ? this.set(e) : this.setRGB(e, t, i)
          }
          set(e) {
            return e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e),
              this
          }
          setScalar(e) {
            return this.r = e,
              this.g = e,
              this.b = e,
              this
          }
          setHex(e, t="srgb") {
            return e = Math.floor(e),
              this.r = (e >> 16 & 255) / 255,
              this.g = (e >> 8 & 255) / 255,
              this.b = (255 & e) / 255,
              Or.toWorkingColorSpace(this, t),
              this
          }
          setRGB(e, t, i, n="srgb-linear") {
            return this.r = e,
              this.g = t,
              this.b = i,
              Or.toWorkingColorSpace(this, n),
              this
          }
          setHSL(e, t, i, n="srgb-linear") {
            if (e = Sr(e, 1),
              t = Ar(t, 0, 1),
              i = Ar(i, 0, 1),
            0 === t)
              this.r = this.g = this.b = i;
            else {
              const n = i <= .5 ? i * (1 + t) : i + t - i * t
                , r = 2 * i - n;
              this.r = Vr(r, n, e + 1 / 3),
                this.g = Vr(r, n, e),
                this.b = Vr(r, n, e - 1 / 3)
            }
            return Or.toWorkingColorSpace(this, n),
              this
          }
          setStyle(e, t="srgb") {
            function i(t) {
              void 0 !== t && parseFloat(t) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
            }
            let n;
            if (n = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)) {
              let e;
              const r = n[1]
                , s = n[2];
              switch (r) {
                case "rgb":
                case "rgba":
                  if (e = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))
                    return this.r = Math.min(255, parseInt(e[1], 10)) / 255,
                      this.g = Math.min(255, parseInt(e[2], 10)) / 255,
                      this.b = Math.min(255, parseInt(e[3], 10)) / 255,
                      Or.toWorkingColorSpace(this, t),
                      i(e[4]),
                      this;
                  if (e = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))
                    return this.r = Math.min(100, parseInt(e[1], 10)) / 100,
                      this.g = Math.min(100, parseInt(e[2], 10)) / 100,
                      this.b = Math.min(100, parseInt(e[3], 10)) / 100,
                      Or.toWorkingColorSpace(this, t),
                      i(e[4]),
                      this;
                  break;
                case "hsl":
                case "hsla":
                  if (e = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)) {
                    const n = parseFloat(e[1]) / 360
                      , r = parseInt(e[2], 10) / 100
                      , s = parseInt(e[3], 10) / 100;
                    return i(e[4]),
                      this.setHSL(n, r, s, t)
                  }
              }
            } else if (n = /^\#([A-Fa-f\d]+)$/.exec(e)) {
              const e = n[1]
                , i = e.length;
              if (3 === i)
                return this.r = parseInt(e.charAt(0) + e.charAt(0), 16) / 255,
                  this.g = parseInt(e.charAt(1) + e.charAt(1), 16) / 255,
                  this.b = parseInt(e.charAt(2) + e.charAt(2), 16) / 255,
                  Or.toWorkingColorSpace(this, t),
                  this;
              if (6 === i)
                return this.r = parseInt(e.charAt(0) + e.charAt(1), 16) / 255,
                  this.g = parseInt(e.charAt(2) + e.charAt(3), 16) / 255,
                  this.b = parseInt(e.charAt(4) + e.charAt(5), 16) / 255,
                  Or.toWorkingColorSpace(this, t),
                  this
            }
            return e && e.length > 0 ? this.setColorName(e, t) : this
          }
          setColorName(e, t="srgb") {
            const i = Nr[e.toLowerCase()];
            return void 0 !== i ? this.setHex(i, t) : console.warn("THREE.Color: Unknown color " + e),
              this
          }
          clone() {
            return new this.constructor(this.r,this.g,this.b)
          }
          copy(e) {
            return this.r = e.r,
              this.g = e.g,
              this.b = e.b,
              this
          }
          copySRGBToLinear(e) {
            return this.r = kr(e.r),
              this.g = kr(e.g),
              this.b = kr(e.b),
              this
          }
          copyLinearToSRGB(e) {
            return this.r = Fr(e.r),
              this.g = Fr(e.g),
              this.b = Fr(e.b),
              this
          }
          convertSRGBToLinear() {
            return this.copySRGBToLinear(this),
              this
          }
          convertLinearToSRGB() {
            return this.copyLinearToSRGB(this),
              this
          }
          getHex(e="srgb") {
            return Or.fromWorkingColorSpace(Hr(this, zr), e),
            Ar(255 * zr.r, 0, 255) << 16 ^ Ar(255 * zr.g, 0, 255) << 8 ^ Ar(255 * zr.b, 0, 255) << 0
          }
          getHexString(e="srgb") {
            return ("000000" + this.getHex(e).toString(16)).slice(-6)
          }
          getHSL(e, t="srgb-linear") {
            Or.fromWorkingColorSpace(Hr(this, zr), t);
            const i = zr.r
              , n = zr.g
              , r = zr.b
              , s = Math.max(i, n, r)
              , a = Math.min(i, n, r);
            let o, l;
            const h = (a + s) / 2;
            if (a === s)
              o = 0,
                l = 0;
            else {
              const e = s - a;
              switch (l = h <= .5 ? e / (s + a) : e / (2 - s - a),
                s) {
                case i:
                  o = (n - r) / e + (n < r ? 6 : 0);
                  break;
                case n:
                  o = (r - i) / e + 2;
                  break;
                case r:
                  o = (i - n) / e + 4
              }
              o /= 6
            }
            return e.h = o,
              e.s = l,
              e.l = h,
              e
          }
          getRGB(e, t="srgb-linear") {
            return Or.fromWorkingColorSpace(Hr(this, zr), t),
              e.r = zr.r,
              e.g = zr.g,
              e.b = zr.b,
              e
          }
          getStyle(e="srgb") {
            return Or.fromWorkingColorSpace(Hr(this, zr), e),
              e !== ur ? `color(${e} ${zr.r} ${zr.g} ${zr.b})` : `rgb(${255 * zr.r | 0},${255 * zr.g | 0},${255 * zr.b | 0})`
          }
          offsetHSL(e, t, i) {
            return this.getHSL(Ur),
              Ur.h += e,
              Ur.s += t,
              Ur.l += i,
              this.setHSL(Ur.h, Ur.s, Ur.l),
              this
          }
          add(e) {
            return this.r += e.r,
              this.g += e.g,
              this.b += e.b,
              this
          }
          addColors(e, t) {
            return this.r = e.r + t.r,
              this.g = e.g + t.g,
              this.b = e.b + t.b,
              this
          }
          addScalar(e) {
            return this.r += e,
              this.g += e,
              this.b += e,
              this
          }
          sub(e) {
            return this.r = Math.max(0, this.r - e.r),
              this.g = Math.max(0, this.g - e.g),
              this.b = Math.max(0, this.b - e.b),
              this
          }
          multiply(e) {
            return this.r *= e.r,
              this.g *= e.g,
              this.b *= e.b,
              this
          }
          multiplyScalar(e) {
            return this.r *= e,
              this.g *= e,
              this.b *= e,
              this
          }
          lerp(e, t) {
            return this.r += (e.r - this.r) * t,
              this.g += (e.g - this.g) * t,
              this.b += (e.b - this.b) * t,
              this
          }
          lerpColors(e, t, i) {
            return this.r = e.r + (t.r - e.r) * i,
              this.g = e.g + (t.g - e.g) * i,
              this.b = e.b + (t.b - e.b) * i,
              this
          }
          lerpHSL(e, t) {
            this.getHSL(Ur),
              e.getHSL(Gr);
            const i = Mr(Ur.h, Gr.h, t)
              , n = Mr(Ur.s, Gr.s, t)
              , r = Mr(Ur.l, Gr.l, t);
            return this.setHSL(i, n, r),
              this
          }
          equals(e) {
            return e.r === this.r && e.g === this.g && e.b === this.b
          }
          fromArray(e, t=0) {
            return this.r = e[t],
              this.g = e[t + 1],
              this.b = e[t + 2],
              this
          }
          toArray(e=[], t=0) {
            return e[t] = this.r,
              e[t + 1] = this.g,
              e[t + 2] = this.b,
              e
          }
          fromBufferAttribute(e, t) {
            return this.r = e.getX(t),
              this.g = e.getY(t),
              this.b = e.getZ(t),
            !0 === e.normalized && (this.r /= 255,
              this.g /= 255,
              this.b /= 255),
              this
          }
          toJSON() {
            return this.getHex()
          }
          *[Symbol.iterator]() {
            yield this.r,
              yield this.g,
              yield this.b
          }
        }
        let jr;
        Wr.NAMES = Nr;
        class Xr {
          static getDataURL(e) {
            if (/^data:/i.test(e.src))
              return e.src;
            if ("undefined" == typeof HTMLCanvasElement)
              return e.src;
            let t;
            if (e instanceof HTMLCanvasElement)
              t = e;
            else {
              void 0 === jr && (jr = Lr("canvas")),
                jr.width = e.width,
                jr.height = e.height;
              const i = jr.getContext("2d");
              e instanceof ImageData ? i.putImageData(e, 0, 0) : i.drawImage(e, 0, 0, e.width, e.height),
                t = jr
            }
            return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e),
              t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png")
          }
          static sRGBToLinear(e) {
            if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) {
              const t = Lr("canvas");
              t.width = e.width,
                t.height = e.height;
              const i = t.getContext("2d");
              i.drawImage(e, 0, 0, e.width, e.height);
              const n = i.getImageData(0, 0, e.width, e.height)
                , r = n.data;
              for (let e = 0; e < r.length; e++)
                r[e] = 255 * kr(r[e] / 255);
              return i.putImageData(n, 0, 0),
                t
            }
            if (e.data) {
              const t = e.data.slice(0);
              for (let e = 0; e < t.length; e++)
                t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[e] = Math.floor(255 * kr(t[e] / 255)) : t[e] = kr(t[e]);
              return {
                data: t,
                width: e.width,
                height: e.height
              }
            }
            return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),
              e
          }
        }
        class Yr {
          constructor(e=null) {
            this.isSource = !0,
              this.uuid = wr(),
              this.data = e,
              this.version = 0
          }
          set needsUpdate(e) {
            !0 === e && this.version++
          }
          toJSON(e) {
            const t = void 0 === e || "string" == typeof e;
            if (!t && void 0 !== e.images[this.uuid])
              return e.images[this.uuid];
            const i = {
              uuid: this.uuid,
              url: ""
            }
              , n = this.data;
            if (null !== n) {
              let e;
              if (Array.isArray(n)) {
                e = [];
                for (let t = 0, i = n.length; t < i; t++)
                  n[t].isDataTexture ? e.push(qr(n[t].image)) : e.push(qr(n[t]))
              } else
                e = qr(n);
              i.url = e
            }
            return t || (e.images[this.uuid] = i),
              i
          }
        }
        function qr(e) {
          return "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap ? Xr.getDataURL(e) : e.data ? {
            data: Array.prototype.slice.call(e.data),
            width: e.width,
            height: e.height,
            type: e.data.constructor.name
          } : (console.warn("THREE.Texture: Unable to serialize Texture."),
            {})
        }
        let Qr = 0;
        class Kr extends vr {
          constructor(e=Kr.DEFAULT_IMAGE, t=Kr.DEFAULT_MAPPING, i=1001, n=1001, r=1006, s=1008, a=1023, o=1009, l=1, h=3e3) {
            super(),
              this.isTexture = !0,
              Object.defineProperty(this, "id", {
                value: Qr++
              }),
              this.uuid = wr(),
              this.name = "",
              this.source = new Yr(e),
              this.mipmaps = [],
              this.mapping = t,
              this.wrapS = i,
              this.wrapT = n,
              this.magFilter = r,
              this.minFilter = s,
              this.anisotropy = l,
              this.format = a,
              this.internalFormat = null,
              this.type = o,
              this.offset = new Dr(0,0),
              this.repeat = new Dr(1,1),
              this.center = new Dr(0,0),
              this.rotation = 0,
              this.matrixAutoUpdate = !0,
              this.matrix = new Ir,
              this.generateMipmaps = !0,
              this.premultiplyAlpha = !1,
              this.flipY = !0,
              this.unpackAlignment = 4,
              this.encoding = h,
              this.userData = {},
              this.version = 0,
              this.onUpdate = null,
              this.isRenderTargetTexture = !1,
              this.needsPMREMUpdate = !1
          }
          get image() {
            return this.source.data
          }
          set image(e) {
            this.source.data = e
          }
          updateMatrix() {
            this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
          }
          clone() {
            return (new this.constructor).copy(this)
          }
          copy(e) {
            return this.name = e.name,
              this.source = e.source,
              this.mipmaps = e.mipmaps.slice(0),
              this.mapping = e.mapping,
              this.wrapS = e.wrapS,
              this.wrapT = e.wrapT,
              this.magFilter = e.magFilter,
              this.minFilter = e.minFilter,
              this.anisotropy = e.anisotropy,
              this.format = e.format,
              this.internalFormat = e.internalFormat,
              this.type = e.type,
              this.offset.copy(e.offset),
              this.repeat.copy(e.repeat),
              this.center.copy(e.center),
              this.rotation = e.rotation,
              this.matrixAutoUpdate = e.matrixAutoUpdate,
              this.matrix.copy(e.matrix),
              this.generateMipmaps = e.generateMipmaps,
              this.premultiplyAlpha = e.premultiplyAlpha,
              this.flipY = e.flipY,
              this.unpackAlignment = e.unpackAlignment,
              this.encoding = e.encoding,
              this.userData = JSON.parse(JSON.stringify(e.userData)),
              this.needsUpdate = !0,
              this
          }
          toJSON(e) {
            const t = void 0 === e || "string" == typeof e;
            if (!t && void 0 !== e.textures[this.uuid])
              return e.textures[this.uuid];
            const i = {
              metadata: {
                version: 4.5,
                type: "Texture",
                generator: "Texture.toJSON"
              },
              uuid: this.uuid,
              name: this.name,
              image: this.source.toJSON(e).uuid,
              mapping: this.mapping,
              repeat: [this.repeat.x, this.repeat.y],
              offset: [this.offset.x, this.offset.y],
              center: [this.center.x, this.center.y],
              rotation: this.rotation,
              wrap: [this.wrapS, this.wrapT],
              format: this.format,
              type: this.type,
              encoding: this.encoding,
              minFilter: this.minFilter,
              magFilter: this.magFilter,
              anisotropy: this.anisotropy,
              flipY: this.flipY,
              premultiplyAlpha: this.premultiplyAlpha,
              unpackAlignment: this.unpackAlignment
            };
            return "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData),
            t || (e.textures[this.uuid] = i),
              i
          }
          dispose() {
            this.dispatchEvent({
              type: "dispose"
            })
          }
          transformUv(e) {
            if (300 !== this.mapping)
              return e;
            if (e.applyMatrix3(this.matrix),
            e.x < 0 || e.x > 1)
              switch (this.wrapS) {
                case On:
                  e.x = e.x - Math.floor(e.x);
                  break;
                case Nn:
                  e.x = e.x < 0 ? 0 : 1;
                  break;
                case zn:
                  1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x)
              }
            if (e.y < 0 || e.y > 1)
              switch (this.wrapT) {
                case On:
                  e.y = e.y - Math.floor(e.y);
                  break;
                case Nn:
                  e.y = e.y < 0 ? 0 : 1;
                  break;
                case zn:
                  1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y)
              }
            return this.flipY && (e.y = 1 - e.y),
              e
          }
          set needsUpdate(e) {
            !0 === e && (this.version++,
              this.source.needsUpdate = !0)
          }
        }
        Kr.DEFAULT_IMAGE = null,
          Kr.DEFAULT_MAPPING = 300;
        class Jr {
          constructor(e=0, t=0, i=0, n=1) {
            this.isVector4 = !0,
              this.x = e,
              this.y = t,
              this.z = i,
              this.w = n
          }
          get width() {
            return this.z
          }
          set width(e) {
            this.z = e
          }
          get height() {
            return this.w
          }
          set height(e) {
            this.w = e
          }
          set(e, t, i, n) {
            return this.x = e,
              this.y = t,
              this.z = i,
              this.w = n,
              this
          }
          setScalar(e) {
            return this.x = e,
              this.y = e,
              this.z = e,
              this.w = e,
              this
          }
          setX(e) {
            return this.x = e,
              this
          }
          setY(e) {
            return this.y = e,
              this
          }
          setZ(e) {
            return this.z = e,
              this
          }
          setW(e) {
            return this.w = e,
              this
          }
          setComponent(e, t) {
            switch (e) {
              case 0:
                this.x = t;
                break;
              case 1:
                this.y = t;
                break;
              case 2:
                this.z = t;
                break;
              case 3:
                this.w = t;
                break;
              default:
                throw new Error("index is out of range: " + e)
            }
            return this
          }
          getComponent(e) {
            switch (e) {
              case 0:
                return this.x;
              case 1:
                return this.y;
              case 2:
                return this.z;
              case 3:
                return this.w;
              default:
                throw new Error("index is out of range: " + e)
            }
          }
          clone() {
            return new this.constructor(this.x,this.y,this.z,this.w)
          }
          copy(e) {
            return this.x = e.x,
              this.y = e.y,
              this.z = e.z,
              this.w = void 0 !== e.w ? e.w : 1,
              this
          }
          add(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
              this.addVectors(e, t)) : (this.x += e.x,
              this.y += e.y,
              this.z += e.z,
              this.w += e.w,
              this)
          }
          addScalar(e) {
            return this.x += e,
              this.y += e,
              this.z += e,
              this.w += e,
              this
          }
          addVectors(e, t) {
            return this.x = e.x + t.x,
              this.y = e.y + t.y,
              this.z = e.z + t.z,
              this.w = e.w + t.w,
              this
          }
          addScaledVector(e, t) {
            return this.x += e.x * t,
              this.y += e.y * t,
              this.z += e.z * t,
              this.w += e.w * t,
              this
          }
          sub(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
              this.subVectors(e, t)) : (this.x -= e.x,
              this.y -= e.y,
              this.z -= e.z,
              this.w -= e.w,
              this)
          }
          subScalar(e) {
            return this.x -= e,
              this.y -= e,
              this.z -= e,
              this.w -= e,
              this
          }
          subVectors(e, t) {
            return this.x = e.x - t.x,
              this.y = e.y - t.y,
              this.z = e.z - t.z,
              this.w = e.w - t.w,
              this
          }
          multiply(e) {
            return this.x *= e.x,
              this.y *= e.y,
              this.z *= e.z,
              this.w *= e.w,
              this
          }
          multiplyScalar(e) {
            return this.x *= e,
              this.y *= e,
              this.z *= e,
              this.w *= e,
              this
          }
          applyMatrix4(e) {
            const t = this.x
              , i = this.y
              , n = this.z
              , r = this.w
              , s = e.elements;
            return this.x = s[0] * t + s[4] * i + s[8] * n + s[12] * r,
              this.y = s[1] * t + s[5] * i + s[9] * n + s[13] * r,
              this.z = s[2] * t + s[6] * i + s[10] * n + s[14] * r,
              this.w = s[3] * t + s[7] * i + s[11] * n + s[15] * r,
              this
          }
          divideScalar(e) {
            return this.multiplyScalar(1 / e)
          }
          setAxisAngleFromQuaternion(e) {
            this.w = 2 * Math.acos(e.w);
            const t = Math.sqrt(1 - e.w * e.w);
            return t < 1e-4 ? (this.x = 1,
              this.y = 0,
              this.z = 0) : (this.x = e.x / t,
              this.y = e.y / t,
              this.z = e.z / t),
              this
          }
          setAxisAngleFromRotationMatrix(e) {
            let t, i, n, r;
            const s = .01
              , a = .1
              , o = e.elements
              , l = o[0]
              , h = o[4]
              , c = o[8]
              , u = o[1]
              , d = o[5]
              , p = o[9]
              , f = o[2]
              , m = o[6]
              , g = o[10];
            if (Math.abs(h - u) < s && Math.abs(c - f) < s && Math.abs(p - m) < s) {
              if (Math.abs(h + u) < a && Math.abs(c + f) < a && Math.abs(p + m) < a && Math.abs(l + d + g - 3) < a)
                return this.set(1, 0, 0, 0),
                  this;
              t = Math.PI;
              const e = (l + 1) / 2
                , o = (d + 1) / 2
                , v = (g + 1) / 2
                , y = (h + u) / 4
                , x = (c + f) / 4
                , _ = (p + m) / 4;
              return e > o && e > v ? e < s ? (i = 0,
                n = .707106781,
                r = .707106781) : (i = Math.sqrt(e),
                n = y / i,
                r = x / i) : o > v ? o < s ? (i = .707106781,
                n = 0,
                r = .707106781) : (n = Math.sqrt(o),
                i = y / n,
                r = _ / n) : v < s ? (i = .707106781,
                n = .707106781,
                r = 0) : (r = Math.sqrt(v),
                i = x / r,
                n = _ / r),
                this.set(i, n, r, t),
                this
            }
            let v = Math.sqrt((m - p) * (m - p) + (c - f) * (c - f) + (u - h) * (u - h));
            return Math.abs(v) < .001 && (v = 1),
              this.x = (m - p) / v,
              this.y = (c - f) / v,
              this.z = (u - h) / v,
              this.w = Math.acos((l + d + g - 1) / 2),
              this
          }
          min(e) {
            return this.x = Math.min(this.x, e.x),
              this.y = Math.min(this.y, e.y),
              this.z = Math.min(this.z, e.z),
              this.w = Math.min(this.w, e.w),
              this
          }
          max(e) {
            return this.x = Math.max(this.x, e.x),
              this.y = Math.max(this.y, e.y),
              this.z = Math.max(this.z, e.z),
              this.w = Math.max(this.w, e.w),
              this
          }
          clamp(e, t) {
            return this.x = Math.max(e.x, Math.min(t.x, this.x)),
              this.y = Math.max(e.y, Math.min(t.y, this.y)),
              this.z = Math.max(e.z, Math.min(t.z, this.z)),
              this.w = Math.max(e.w, Math.min(t.w, this.w)),
              this
          }
          clampScalar(e, t) {
            return this.x = Math.max(e, Math.min(t, this.x)),
              this.y = Math.max(e, Math.min(t, this.y)),
              this.z = Math.max(e, Math.min(t, this.z)),
              this.w = Math.max(e, Math.min(t, this.w)),
              this
          }
          clampLength(e, t) {
            const i = this.length();
            return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
          }
          floor() {
            return this.x = Math.floor(this.x),
              this.y = Math.floor(this.y),
              this.z = Math.floor(this.z),
              this.w = Math.floor(this.w),
              this
          }
          ceil() {
            return this.x = Math.ceil(this.x),
              this.y = Math.ceil(this.y),
              this.z = Math.ceil(this.z),
              this.w = Math.ceil(this.w),
              this
          }
          round() {
            return this.x = Math.round(this.x),
              this.y = Math.round(this.y),
              this.z = Math.round(this.z),
              this.w = Math.round(this.w),
              this
          }
          roundToZero() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
              this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
              this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
              this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w),
              this
          }
          negate() {
            return this.x = -this.x,
              this.y = -this.y,
              this.z = -this.z,
              this.w = -this.w,
              this
          }
          dot(e) {
            return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
          }
          lengthSq() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
          }
          length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
          }
          manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
          }
          normalize() {
            return this.divideScalar(this.length() || 1)
          }
          setLength(e) {
            return this.normalize().multiplyScalar(e)
          }
          lerp(e, t) {
            return this.x += (e.x - this.x) * t,
              this.y += (e.y - this.y) * t,
              this.z += (e.z - this.z) * t,
              this.w += (e.w - this.w) * t,
              this
          }
          lerpVectors(e, t, i) {
            return this.x = e.x + (t.x - e.x) * i,
              this.y = e.y + (t.y - e.y) * i,
              this.z = e.z + (t.z - e.z) * i,
              this.w = e.w + (t.w - e.w) * i,
              this
          }
          equals(e) {
            return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
          }
          fromArray(e, t=0) {
            return this.x = e[t],
              this.y = e[t + 1],
              this.z = e[t + 2],
              this.w = e[t + 3],
              this
          }
          toArray(e=[], t=0) {
            return e[t] = this.x,
              e[t + 1] = this.y,
              e[t + 2] = this.z,
              e[t + 3] = this.w,
              e
          }
          fromBufferAttribute(e, t, i) {
            return void 0 !== i && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),
              this.x = e.getX(t),
              this.y = e.getY(t),
              this.z = e.getZ(t),
              this.w = e.getW(t),
              this
          }
          random() {
            return this.x = Math.random(),
              this.y = Math.random(),
              this.z = Math.random(),
              this.w = Math.random(),
              this
          }
          *[Symbol.iterator]() {
            yield this.x,
              yield this.y,
              yield this.z,
              yield this.w
          }
        }
        class Zr extends vr {
          constructor(e, t, i={}) {
            super(),
              this.isWebGLRenderTarget = !0,
              this.width = e,
              this.height = t,
              this.depth = 1,
              this.scissor = new Jr(0,0,e,t),
              this.scissorTest = !1,
              this.viewport = new Jr(0,0,e,t);
            const n = {
              width: e,
              height: t,
              depth: 1
            };
            this.texture = new Kr(n,i.mapping,i.wrapS,i.wrapT,i.magFilter,i.minFilter,i.format,i.type,i.anisotropy,i.encoding),
              this.texture.isRenderTargetTexture = !0,
              this.texture.flipY = !1,
              this.texture.generateMipmaps = void 0 !== i.generateMipmaps && i.generateMipmaps,
              this.texture.internalFormat = void 0 !== i.internalFormat ? i.internalFormat : null,
              this.texture.minFilter = void 0 !== i.minFilter ? i.minFilter : Hn,
              this.depthBuffer = void 0 === i.depthBuffer || i.depthBuffer,
              this.stencilBuffer = void 0 !== i.stencilBuffer && i.stencilBuffer,
              this.depthTexture = void 0 !== i.depthTexture ? i.depthTexture : null,
              this.samples = void 0 !== i.samples ? i.samples : 0
          }
          setSize(e, t, i=1) {
            this.width === e && this.height === t && this.depth === i || (this.width = e,
              this.height = t,
              this.depth = i,
              this.texture.image.width = e,
              this.texture.image.height = t,
              this.texture.image.depth = i,
              this.dispose()),
              this.viewport.set(0, 0, e, t),
              this.scissor.set(0, 0, e, t)
          }
          clone() {
            return (new this.constructor).copy(this)
          }
          copy(e) {
            this.width = e.width,
              this.height = e.height,
              this.depth = e.depth,
              this.viewport.copy(e.viewport),
              this.texture = e.texture.clone(),
              this.texture.isRenderTargetTexture = !0;
            const t = Object.assign({}, e.texture.image);
            return this.texture.source = new Yr(t),
              this.depthBuffer = e.depthBuffer,
              this.stencilBuffer = e.stencilBuffer,
            null !== e.depthTexture && (this.depthTexture = e.depthTexture.clone()),
              this.samples = e.samples,
              this
          }
          dispose() {
            this.dispatchEvent({
              type: "dispose"
            })
          }
        }
        class $r extends Kr {
          constructor(e=null, t=1, i=1, n=1) {
            super(null),
              this.isDataArrayTexture = !0,
              this.image = {
                data: e,
                width: t,
                height: i,
                depth: n
              },
              this.magFilter = Un,
              this.minFilter = Un,
              this.wrapR = Nn,
              this.generateMipmaps = !1,
              this.flipY = !1,
              this.unpackAlignment = 1
          }
        }
        class es {
          constructor(e=0, t=0, i=0, n=1) {
            this.isQuaternion = !0,
              this._x = e,
              this._y = t,
              this._z = i,
              this._w = n
          }
          static slerp(e, t, i, n) {
            return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."),
              i.slerpQuaternions(e, t, n)
          }
          static slerpFlat(e, t, i, n, r, s, a) {
            let o = i[n + 0]
              , l = i[n + 1]
              , h = i[n + 2]
              , c = i[n + 3];
            const u = r[s + 0]
              , d = r[s + 1]
              , p = r[s + 2]
              , f = r[s + 3];
            if (0 === a)
              return e[t + 0] = o,
                e[t + 1] = l,
                e[t + 2] = h,
                void (e[t + 3] = c);
            if (1 === a)
              return e[t + 0] = u,
                e[t + 1] = d,
                e[t + 2] = p,
                void (e[t + 3] = f);
            if (c !== f || o !== u || l !== d || h !== p) {
              let e = 1 - a;
              const t = o * u + l * d + h * p + c * f
                , i = t >= 0 ? 1 : -1
                , n = 1 - t * t;
              if (n > Number.EPSILON) {
                const r = Math.sqrt(n)
                  , s = Math.atan2(r, t * i);
                e = Math.sin(e * s) / r,
                  a = Math.sin(a * s) / r
              }
              const r = a * i;
              if (o = o * e + u * r,
                l = l * e + d * r,
                h = h * e + p * r,
                c = c * e + f * r,
              e === 1 - a) {
                const e = 1 / Math.sqrt(o * o + l * l + h * h + c * c);
                o *= e,
                  l *= e,
                  h *= e,
                  c *= e
              }
            }
            e[t] = o,
              e[t + 1] = l,
              e[t + 2] = h,
              e[t + 3] = c
          }
          static multiplyQuaternionsFlat(e, t, i, n, r, s) {
            const a = i[n]
              , o = i[n + 1]
              , l = i[n + 2]
              , h = i[n + 3]
              , c = r[s]
              , u = r[s + 1]
              , d = r[s + 2]
              , p = r[s + 3];
            return e[t] = a * p + h * c + o * d - l * u,
              e[t + 1] = o * p + h * u + l * c - a * d,
              e[t + 2] = l * p + h * d + a * u - o * c,
              e[t + 3] = h * p - a * c - o * u - l * d,
              e
          }
          get x() {
            return this._x
          }
          set x(e) {
            this._x = e,
              this._onChangeCallback()
          }
          get y() {
            return this._y
          }
          set y(e) {
            this._y = e,
              this._onChangeCallback()
          }
          get z() {
            return this._z
          }
          set z(e) {
            this._z = e,
              this._onChangeCallback()
          }
          get w() {
            return this._w
          }
          set w(e) {
            this._w = e,
              this._onChangeCallback()
          }
          set(e, t, i, n) {
            return this._x = e,
              this._y = t,
              this._z = i,
              this._w = n,
              this._onChangeCallback(),
              this
          }
          clone() {
            return new this.constructor(this._x,this._y,this._z,this._w)
          }
          copy(e) {
            return this._x = e.x,
              this._y = e.y,
              this._z = e.z,
              this._w = e.w,
              this._onChangeCallback(),
              this
          }
          setFromEuler(e, t) {
            if (!e || !e.isEuler)
              throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
            const i = e._x
              , n = e._y
              , r = e._z
              , s = e._order
              , a = Math.cos
              , o = Math.sin
              , l = a(i / 2)
              , h = a(n / 2)
              , c = a(r / 2)
              , u = o(i / 2)
              , d = o(n / 2)
              , p = o(r / 2);
            switch (s) {
              case "XYZ":
                this._x = u * h * c + l * d * p,
                  this._y = l * d * c - u * h * p,
                  this._z = l * h * p + u * d * c,
                  this._w = l * h * c - u * d * p;
                break;
              case "YXZ":
                this._x = u * h * c + l * d * p,
                  this._y = l * d * c - u * h * p,
                  this._z = l * h * p - u * d * c,
                  this._w = l * h * c + u * d * p;
                break;
              case "ZXY":
                this._x = u * h * c - l * d * p,
                  this._y = l * d * c + u * h * p,
                  this._z = l * h * p + u * d * c,
                  this._w = l * h * c - u * d * p;
                break;
              case "ZYX":
                this._x = u * h * c - l * d * p,
                  this._y = l * d * c + u * h * p,
                  this._z = l * h * p - u * d * c,
                  this._w = l * h * c + u * d * p;
                break;
              case "YZX":
                this._x = u * h * c + l * d * p,
                  this._y = l * d * c + u * h * p,
                  this._z = l * h * p - u * d * c,
                  this._w = l * h * c - u * d * p;
                break;
              case "XZY":
                this._x = u * h * c - l * d * p,
                  this._y = l * d * c - u * h * p,
                  this._z = l * h * p + u * d * c,
                  this._w = l * h * c + u * d * p;
                break;
              default:
                console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + s)
            }
            return !1 !== t && this._onChangeCallback(),
              this
          }
          setFromAxisAngle(e, t) {
            const i = t / 2
              , n = Math.sin(i);
            return this._x = e.x * n,
              this._y = e.y * n,
              this._z = e.z * n,
              this._w = Math.cos(i),
              this._onChangeCallback(),
              this
          }
          setFromRotationMatrix(e) {
            const t = e.elements
              , i = t[0]
              , n = t[4]
              , r = t[8]
              , s = t[1]
              , a = t[5]
              , o = t[9]
              , l = t[2]
              , h = t[6]
              , c = t[10]
              , u = i + a + c;
            if (u > 0) {
              const e = .5 / Math.sqrt(u + 1);
              this._w = .25 / e,
                this._x = (h - o) * e,
                this._y = (r - l) * e,
                this._z = (s - n) * e
            } else if (i > a && i > c) {
              const e = 2 * Math.sqrt(1 + i - a - c);
              this._w = (h - o) / e,
                this._x = .25 * e,
                this._y = (n + s) / e,
                this._z = (r + l) / e
            } else if (a > c) {
              const e = 2 * Math.sqrt(1 + a - i - c);
              this._w = (r - l) / e,
                this._x = (n + s) / e,
                this._y = .25 * e,
                this._z = (o + h) / e
            } else {
              const e = 2 * Math.sqrt(1 + c - i - a);
              this._w = (s - n) / e,
                this._x = (r + l) / e,
                this._y = (o + h) / e,
                this._z = .25 * e
            }
            return this._onChangeCallback(),
              this
          }
          setFromUnitVectors(e, t) {
            let i = e.dot(t) + 1;
            return i < Number.EPSILON ? (i = 0,
              Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y,
                this._y = e.x,
                this._z = 0,
                this._w = i) : (this._x = 0,
                this._y = -e.z,
                this._z = e.y,
                this._w = i)) : (this._x = e.y * t.z - e.z * t.y,
              this._y = e.z * t.x - e.x * t.z,
              this._z = e.x * t.y - e.y * t.x,
              this._w = i),
              this.normalize()
          }
          angleTo(e) {
            return 2 * Math.acos(Math.abs(Ar(this.dot(e), -1, 1)))
          }
          rotateTowards(e, t) {
            const i = this.angleTo(e);
            if (0 === i)
              return this;
            const n = Math.min(1, t / i);
            return this.slerp(e, n),
              this
          }
          identity() {
            return this.set(0, 0, 0, 1)
          }
          invert() {
            return this.conjugate()
          }
          conjugate() {
            return this._x *= -1,
              this._y *= -1,
              this._z *= -1,
              this._onChangeCallback(),
              this
          }
          dot(e) {
            return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
          }
          lengthSq() {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
          }
          length() {
            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
          }
          normalize() {
            let e = this.length();
            return 0 === e ? (this._x = 0,
              this._y = 0,
              this._z = 0,
              this._w = 1) : (e = 1 / e,
              this._x = this._x * e,
              this._y = this._y * e,
              this._z = this._z * e,
              this._w = this._w * e),
              this._onChangeCallback(),
              this
          }
          multiply(e, t) {
            return void 0 !== t ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),
              this.multiplyQuaternions(e, t)) : this.multiplyQuaternions(this, e)
          }
          premultiply(e) {
            return this.multiplyQuaternions(e, this)
          }
          multiplyQuaternions(e, t) {
            const i = e._x
              , n = e._y
              , r = e._z
              , s = e._w
              , a = t._x
              , o = t._y
              , l = t._z
              , h = t._w;
            return this._x = i * h + s * a + n * l - r * o,
              this._y = n * h + s * o + r * a - i * l,
              this._z = r * h + s * l + i * o - n * a,
              this._w = s * h - i * a - n * o - r * l,
              this._onChangeCallback(),
              this
          }
          slerp(e, t) {
            if (0 === t)
              return this;
            if (1 === t)
              return this.copy(e);
            const i = this._x
              , n = this._y
              , r = this._z
              , s = this._w;
            let a = s * e._w + i * e._x + n * e._y + r * e._z;
            if (a < 0 ? (this._w = -e._w,
              this._x = -e._x,
              this._y = -e._y,
              this._z = -e._z,
              a = -a) : this.copy(e),
            a >= 1)
              return this._w = s,
                this._x = i,
                this._y = n,
                this._z = r,
                this;
            const o = 1 - a * a;
            if (o <= Number.EPSILON) {
              const e = 1 - t;
              return this._w = e * s + t * this._w,
                this._x = e * i + t * this._x,
                this._y = e * n + t * this._y,
                this._z = e * r + t * this._z,
                this.normalize(),
                this._onChangeCallback(),
                this
            }
            const l = Math.sqrt(o)
              , h = Math.atan2(l, a)
              , c = Math.sin((1 - t) * h) / l
              , u = Math.sin(t * h) / l;
            return this._w = s * c + this._w * u,
              this._x = i * c + this._x * u,
              this._y = n * c + this._y * u,
              this._z = r * c + this._z * u,
              this._onChangeCallback(),
              this
          }
          slerpQuaternions(e, t, i) {
            return this.copy(e).slerp(t, i)
          }
          random() {
            const e = Math.random()
              , t = Math.sqrt(1 - e)
              , i = Math.sqrt(e)
              , n = 2 * Math.PI * Math.random()
              , r = 2 * Math.PI * Math.random();
            return this.set(t * Math.cos(n), i * Math.sin(r), i * Math.cos(r), t * Math.sin(n))
          }
          equals(e) {
            return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
          }
          fromArray(e, t=0) {
            return this._x = e[t],
              this._y = e[t + 1],
              this._z = e[t + 2],
              this._w = e[t + 3],
              this._onChangeCallback(),
              this
          }
          toArray(e=[], t=0) {
            return e[t] = this._x,
              e[t + 1] = this._y,
              e[t + 2] = this._z,
              e[t + 3] = this._w,
              e
          }
          fromBufferAttribute(e, t) {
            return this._x = e.getX(t),
              this._y = e.getY(t),
              this._z = e.getZ(t),
              this._w = e.getW(t),
              this
          }
          _onChange(e) {
            return this._onChangeCallback = e,
              this
          }
          _onChangeCallback() {}
          *[Symbol.iterator]() {
            yield this._x,
              yield this._y,
              yield this._z,
              yield this._w
          }
        }
        class ts {
          constructor(e=0, t=0, i=0) {
            this.isVector3 = !0,
              this.x = e,
              this.y = t,
              this.z = i
          }
          set(e, t, i) {
            return void 0 === i && (i = this.z),
              this.x = e,
              this.y = t,
              this.z = i,
              this
          }
          setScalar(e) {
            return this.x = e,
              this.y = e,
              this.z = e,
              this
          }
          setX(e) {
            return this.x = e,
              this
          }
          setY(e) {
            return this.y = e,
              this
          }
          setZ(e) {
            return this.z = e,
              this
          }
          setComponent(e, t) {
            switch (e) {
              case 0:
                this.x = t;
                break;
              case 1:
                this.y = t;
                break;
              case 2:
                this.z = t;
                break;
              default:
                throw new Error("index is out of range: " + e)
            }
            return this
          }
          getComponent(e) {
            switch (e) {
              case 0:
                return this.x;
              case 1:
                return this.y;
              case 2:
                return this.z;
              default:
                throw new Error("index is out of range: " + e)
            }
          }
          clone() {
            return new this.constructor(this.x,this.y,this.z)
          }
          copy(e) {
            return this.x = e.x,
              this.y = e.y,
              this.z = e.z,
              this
          }
          add(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
              this.addVectors(e, t)) : (this.x += e.x,
              this.y += e.y,
              this.z += e.z,
              this)
          }
          addScalar(e) {
            return this.x += e,
              this.y += e,
              this.z += e,
              this
          }
          addVectors(e, t) {
            return this.x = e.x + t.x,
              this.y = e.y + t.y,
              this.z = e.z + t.z,
              this
          }
          addScaledVector(e, t) {
            return this.x += e.x * t,
              this.y += e.y * t,
              this.z += e.z * t,
              this
          }
          sub(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
              this.subVectors(e, t)) : (this.x -= e.x,
              this.y -= e.y,
              this.z -= e.z,
              this)
          }
          subScalar(e) {
            return this.x -= e,
              this.y -= e,
              this.z -= e,
              this
          }
          subVectors(e, t) {
            return this.x = e.x - t.x,
              this.y = e.y - t.y,
              this.z = e.z - t.z,
              this
          }
          multiply(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),
              this.multiplyVectors(e, t)) : (this.x *= e.x,
              this.y *= e.y,
              this.z *= e.z,
              this)
          }
          multiplyScalar(e) {
            return this.x *= e,
              this.y *= e,
              this.z *= e,
              this
          }
          multiplyVectors(e, t) {
            return this.x = e.x * t.x,
              this.y = e.y * t.y,
              this.z = e.z * t.z,
              this
          }
          applyEuler(e) {
            return e && e.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),
              this.applyQuaternion(ns.setFromEuler(e))
          }
          applyAxisAngle(e, t) {
            return this.applyQuaternion(ns.setFromAxisAngle(e, t))
          }
          applyMatrix3(e) {
            const t = this.x
              , i = this.y
              , n = this.z
              , r = e.elements;
            return this.x = r[0] * t + r[3] * i + r[6] * n,
              this.y = r[1] * t + r[4] * i + r[7] * n,
              this.z = r[2] * t + r[5] * i + r[8] * n,
              this
          }
          applyNormalMatrix(e) {
            return this.applyMatrix3(e).normalize()
          }
          applyMatrix4(e) {
            const t = this.x
              , i = this.y
              , n = this.z
              , r = e.elements
              , s = 1 / (r[3] * t + r[7] * i + r[11] * n + r[15]);
            return this.x = (r[0] * t + r[4] * i + r[8] * n + r[12]) * s,
              this.y = (r[1] * t + r[5] * i + r[9] * n + r[13]) * s,
              this.z = (r[2] * t + r[6] * i + r[10] * n + r[14]) * s,
              this
          }
          applyQuaternion(e) {
            const t = this.x
              , i = this.y
              , n = this.z
              , r = e.x
              , s = e.y
              , a = e.z
              , o = e.w
              , l = o * t + s * n - a * i
              , h = o * i + a * t - r * n
              , c = o * n + r * i - s * t
              , u = -r * t - s * i - a * n;
            return this.x = l * o + u * -r + h * -a - c * -s,
              this.y = h * o + u * -s + c * -r - l * -a,
              this.z = c * o + u * -a + l * -s - h * -r,
              this
          }
          project(e) {
            return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
          }
          unproject(e) {
            return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
          }
          transformDirection(e) {
            const t = this.x
              , i = this.y
              , n = this.z
              , r = e.elements;
            return this.x = r[0] * t + r[4] * i + r[8] * n,
              this.y = r[1] * t + r[5] * i + r[9] * n,
              this.z = r[2] * t + r[6] * i + r[10] * n,
              this.normalize()
          }
          divide(e) {
            return this.x /= e.x,
              this.y /= e.y,
              this.z /= e.z,
              this
          }
          divideScalar(e) {
            return this.multiplyScalar(1 / e)
          }
          min(e) {
            return this.x = Math.min(this.x, e.x),
              this.y = Math.min(this.y, e.y),
              this.z = Math.min(this.z, e.z),
              this
          }
          max(e) {
            return this.x = Math.max(this.x, e.x),
              this.y = Math.max(this.y, e.y),
              this.z = Math.max(this.z, e.z),
              this
          }
          clamp(e, t) {
            return this.x = Math.max(e.x, Math.min(t.x, this.x)),
              this.y = Math.max(e.y, Math.min(t.y, this.y)),
              this.z = Math.max(e.z, Math.min(t.z, this.z)),
              this
          }
          clampScalar(e, t) {
            return this.x = Math.max(e, Math.min(t, this.x)),
              this.y = Math.max(e, Math.min(t, this.y)),
              this.z = Math.max(e, Math.min(t, this.z)),
              this
          }
          clampLength(e, t) {
            const i = this.length();
            return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
          }
          floor() {
            return this.x = Math.floor(this.x),
              this.y = Math.floor(this.y),
              this.z = Math.floor(this.z),
              this
          }
          ceil() {
            return this.x = Math.ceil(this.x),
              this.y = Math.ceil(this.y),
              this.z = Math.ceil(this.z),
              this
          }
          round() {
            return this.x = Math.round(this.x),
              this.y = Math.round(this.y),
              this.z = Math.round(this.z),
              this
          }
          roundToZero() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
              this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
              this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
              this
          }
          negate() {
            return this.x = -this.x,
              this.y = -this.y,
              this.z = -this.z,
              this
          }
          dot(e) {
            return this.x * e.x + this.y * e.y + this.z * e.z
          }
          lengthSq() {
            return this.x * this.x + this.y * this.y + this.z * this.z
          }
          length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
          }
          manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
          }
          normalize() {
            return this.divideScalar(this.length() || 1)
          }
          setLength(e) {
            return this.normalize().multiplyScalar(e)
          }
          lerp(e, t) {
            return this.x += (e.x - this.x) * t,
              this.y += (e.y - this.y) * t,
              this.z += (e.z - this.z) * t,
              this
          }
          lerpVectors(e, t, i) {
            return this.x = e.x + (t.x - e.x) * i,
              this.y = e.y + (t.y - e.y) * i,
              this.z = e.z + (t.z - e.z) * i,
              this
          }
          cross(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),
              this.crossVectors(e, t)) : this.crossVectors(this, e)
          }
          crossVectors(e, t) {
            const i = e.x
              , n = e.y
              , r = e.z
              , s = t.x
              , a = t.y
              , o = t.z;
            return this.x = n * o - r * a,
              this.y = r * s - i * o,
              this.z = i * a - n * s,
              this
          }
          projectOnVector(e) {
            const t = e.lengthSq();
            if (0 === t)
              return this.set(0, 0, 0);
            const i = e.dot(this) / t;
            return this.copy(e).multiplyScalar(i)
          }
          projectOnPlane(e) {
            return is.copy(this).projectOnVector(e),
              this.sub(is)
          }
          reflect(e) {
            return this.sub(is.copy(e).multiplyScalar(2 * this.dot(e)))
          }
          angleTo(e) {
            const t = Math.sqrt(this.lengthSq() * e.lengthSq());
            if (0 === t)
              return Math.PI / 2;
            const i = this.dot(e) / t;
            return Math.acos(Ar(i, -1, 1))
          }
          distanceTo(e) {
            return Math.sqrt(this.distanceToSquared(e))
          }
          distanceToSquared(e) {
            const t = this.x - e.x
              , i = this.y - e.y
              , n = this.z - e.z;
            return t * t + i * i + n * n
          }
          manhattanDistanceTo(e) {
            return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
          }
          setFromSpherical(e) {
            return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
          }
          setFromSphericalCoords(e, t, i) {
            const n = Math.sin(t) * e;
            return this.x = n * Math.sin(i),
              this.y = Math.cos(t) * e,
              this.z = n * Math.cos(i),
              this
          }
          setFromCylindrical(e) {
            return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
          }
          setFromCylindricalCoords(e, t, i) {
            return this.x = e * Math.sin(t),
              this.y = i,
              this.z = e * Math.cos(t),
              this
          }
          setFromMatrixPosition(e) {
            const t = e.elements;
            return this.x = t[12],
              this.y = t[13],
              this.z = t[14],
              this
          }
          setFromMatrixScale(e) {
            const t = this.setFromMatrixColumn(e, 0).length()
              , i = this.setFromMatrixColumn(e, 1).length()
              , n = this.setFromMatrixColumn(e, 2).length();
            return this.x = t,
              this.y = i,
              this.z = n,
              this
          }
          setFromMatrixColumn(e, t) {
            return this.fromArray(e.elements, 4 * t)
          }
          setFromMatrix3Column(e, t) {
            return this.fromArray(e.elements, 3 * t)
          }
          setFromEuler(e) {
            return this.x = e._x,
              this.y = e._y,
              this.z = e._z,
              this
          }
          equals(e) {
            return e.x === this.x && e.y === this.y && e.z === this.z
          }
          fromArray(e, t=0) {
            return this.x = e[t],
              this.y = e[t + 1],
              this.z = e[t + 2],
              this
          }
          toArray(e=[], t=0) {
            return e[t] = this.x,
              e[t + 1] = this.y,
              e[t + 2] = this.z,
              e
          }
          fromBufferAttribute(e, t, i) {
            return void 0 !== i && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),
              this.x = e.getX(t),
              this.y = e.getY(t),
              this.z = e.getZ(t),
              this
          }
          random() {
            return this.x = Math.random(),
              this.y = Math.random(),
              this.z = Math.random(),
              this
          }
          randomDirection() {
            const e = 2 * (Math.random() - .5)
              , t = Math.random() * Math.PI * 2
              , i = Math.sqrt(1 - e ** 2);
            return this.x = i * Math.cos(t),
              this.y = i * Math.sin(t),
              this.z = e,
              this
          }
          *[Symbol.iterator]() {
            yield this.x,
              yield this.y,
              yield this.z
          }
        }
        const is = new ts
          , ns = new es;
        class rs {
          constructor(e=new ts(1 / 0,1 / 0,1 / 0), t=new ts(-1 / 0,-1 / 0,-1 / 0)) {
            this.isBox3 = !0,
              this.min = e,
              this.max = t
          }
          set(e, t) {
            return this.min.copy(e),
              this.max.copy(t),
              this
          }
          setFromArray(e) {
            let t = 1 / 0
              , i = 1 / 0
              , n = 1 / 0
              , r = -1 / 0
              , s = -1 / 0
              , a = -1 / 0;
            for (let o = 0, l = e.length; o < l; o += 3) {
              const l = e[o]
                , h = e[o + 1]
                , c = e[o + 2];
              l < t && (t = l),
              h < i && (i = h),
              c < n && (n = c),
              l > r && (r = l),
              h > s && (s = h),
              c > a && (a = c)
            }
            return this.min.set(t, i, n),
              this.max.set(r, s, a),
              this
          }
          setFromBufferAttribute(e) {
            let t = 1 / 0
              , i = 1 / 0
              , n = 1 / 0
              , r = -1 / 0
              , s = -1 / 0
              , a = -1 / 0;
            for (let o = 0, l = e.count; o < l; o++) {
              const l = e.getX(o)
                , h = e.getY(o)
                , c = e.getZ(o);
              l < t && (t = l),
              h < i && (i = h),
              c < n && (n = c),
              l > r && (r = l),
              h > s && (s = h),
              c > a && (a = c)
            }
            return this.min.set(t, i, n),
              this.max.set(r, s, a),
              this
          }
          setFromPoints(e) {
            this.makeEmpty();
            for (let t = 0, i = e.length; t < i; t++)
              this.expandByPoint(e[t]);
            return this
          }
          setFromCenterAndSize(e, t) {
            const i = as.copy(t).multiplyScalar(.5);
            return this.min.copy(e).sub(i),
              this.max.copy(e).add(i),
              this
          }
          setFromObject(e, t=!1) {
            return this.makeEmpty(),
              this.expandByObject(e, t)
          }
          clone() {
            return (new this.constructor).copy(this)
          }
          copy(e) {
            return this.min.copy(e.min),
              this.max.copy(e.max),
              this
          }
          makeEmpty() {
            return this.min.x = this.min.y = this.min.z = 1 / 0,
              this.max.x = this.max.y = this.max.z = -1 / 0,
              this
          }
          isEmpty() {
            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
          }
          getCenter(e) {
            return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
          }
          getSize(e) {
            return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
          }
          expandByPoint(e) {
            return this.min.min(e),
              this.max.max(e),
              this
          }
          expandByVector(e) {
            return this.min.sub(e),
              this.max.add(e),
              this
          }
          expandByScalar(e) {
            return this.min.addScalar(-e),
              this.max.addScalar(e),
              this
          }
          expandByObject(e, t=!1) {
            e.updateWorldMatrix(!1, !1);
            const i = e.geometry;
            if (void 0 !== i)
              if (t && null != i.attributes && void 0 !== i.attributes.position) {
                const t = i.attributes.position;
                for (let i = 0, n = t.count; i < n; i++)
                  as.fromBufferAttribute(t, i).applyMatrix4(e.matrixWorld),
                    this.expandByPoint(as)
              } else
                null === i.boundingBox && i.computeBoundingBox(),
                  os.copy(i.boundingBox),
                  os.applyMatrix4(e.matrixWorld),
                  this.union(os);
            const n = e.children;
            for (let e = 0, i = n.length; e < i; e++)
              this.expandByObject(n[e], t);
            return this
          }
          containsPoint(e) {
            return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
          }
          containsBox(e) {
            return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
          }
          getParameter(e, t) {
            return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
          }
          intersectsBox(e) {
            return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
          }
          intersectsSphere(e) {
            return this.clampPoint(e.center, as),
            as.distanceToSquared(e.center) <= e.radius * e.radius
          }
          intersectsPlane(e) {
            let t, i;
            return e.normal.x > 0 ? (t = e.normal.x * this.min.x,
              i = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x,
              i = e.normal.x * this.min.x),
              e.normal.y > 0 ? (t += e.normal.y * this.min.y,
                i += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y,
                i += e.normal.y * this.min.y),
              e.normal.z > 0 ? (t += e.normal.z * this.min.z,
                i += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z,
                i += e.normal.z * this.min.z),
            t <= -e.constant && i >= -e.constant
          }
          intersectsTriangle(e) {
            if (this.isEmpty())
              return !1;
            this.getCenter(fs),
              ms.subVectors(this.max, fs),
              ls.subVectors(e.a, fs),
              hs.subVectors(e.b, fs),
              cs.subVectors(e.c, fs),
              us.subVectors(hs, ls),
              ds.subVectors(cs, hs),
              ps.subVectors(ls, cs);
            let t = [0, -us.z, us.y, 0, -ds.z, ds.y, 0, -ps.z, ps.y, us.z, 0, -us.x, ds.z, 0, -ds.x, ps.z, 0, -ps.x, -us.y, us.x, 0, -ds.y, ds.x, 0, -ps.y, ps.x, 0];
            return !!ys(t, ls, hs, cs, ms) && (t = [1, 0, 0, 0, 1, 0, 0, 0, 1],
            !!ys(t, ls, hs, cs, ms) && (gs.crossVectors(us, ds),
              t = [gs.x, gs.y, gs.z],
              ys(t, ls, hs, cs, ms)))
          }
          clampPoint(e, t) {
            return t.copy(e).clamp(this.min, this.max)
          }
          distanceToPoint(e) {
            return as.copy(e).clamp(this.min, this.max).sub(e).length()
          }
          getBoundingSphere(e) {
            return this.getCenter(e.center),
              e.radius = .5 * this.getSize(as).length(),
              e
          }
          intersect(e) {
            return this.min.max(e.min),
              this.max.min(e.max),
            this.isEmpty() && this.makeEmpty(),
              this
          }
          union(e) {
            return this.min.min(e.min),
              this.max.max(e.max),
              this
          }
          applyMatrix4(e) {
            return this.isEmpty() || (ss[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
              ss[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
              ss[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
              ss[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
              ss[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
              ss[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
              ss[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
              ss[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
              this.setFromPoints(ss)),
              this
          }
          translate(e) {
            return this.min.add(e),
              this.max.add(e),
              this
          }
          equals(e) {
            return e.min.equals(this.min) && e.max.equals(this.max)
          }
        }
        const ss = [new ts, new ts, new ts, new ts, new ts, new ts, new ts, new ts]
          , as = new ts
          , os = new rs
          , ls = new ts
          , hs = new ts
          , cs = new ts
          , us = new ts
          , ds = new ts
          , ps = new ts
          , fs = new ts
          , ms = new ts
          , gs = new ts
          , vs = new ts;
        function ys(e, t, i, n, r) {
          for (let s = 0, a = e.length - 3; s <= a; s += 3) {
            vs.fromArray(e, s);
            const a = r.x * Math.abs(vs.x) + r.y * Math.abs(vs.y) + r.z * Math.abs(vs.z)
              , o = t.dot(vs)
              , l = i.dot(vs)
              , h = n.dot(vs);
            if (Math.max(-Math.max(o, l, h), Math.min(o, l, h)) > a)
              return !1
          }
          return !0
        }
        const xs = new rs
          , _s = new ts
          , bs = new ts
          , ws = new ts;
        class As {
          constructor(e=new ts, t=-1) {
            this.center = e,
              this.radius = t
          }
          set(e, t) {
            return this.center.copy(e),
              this.radius = t,
              this
          }
          setFromPoints(e, t) {
            const i = this.center;
            void 0 !== t ? i.copy(t) : xs.setFromPoints(e).getCenter(i);
            let n = 0;
            for (let t = 0, r = e.length; t < r; t++)
              n = Math.max(n, i.distanceToSquared(e[t]));
            return this.radius = Math.sqrt(n),
              this
          }
          copy(e) {
            return this.center.copy(e.center),
              this.radius = e.radius,
              this
          }
          isEmpty() {
            return this.radius < 0
          }
          makeEmpty() {
            return this.center.set(0, 0, 0),
              this.radius = -1,
              this
          }
          containsPoint(e) {
            return e.distanceToSquared(this.center) <= this.radius * this.radius
          }
          distanceToPoint(e) {
            return e.distanceTo(this.center) - this.radius
          }
          intersectsSphere(e) {
            const t = this.radius + e.radius;
            return e.center.distanceToSquared(this.center) <= t * t
          }
          intersectsBox(e) {
            return e.intersectsSphere(this)
          }
          intersectsPlane(e) {
            return Math.abs(e.distanceToPoint(this.center)) <= this.radius
          }
          clampPoint(e, t) {
            const i = this.center.distanceToSquared(e);
            return t.copy(e),
            i > this.radius * this.radius && (t.sub(this.center).normalize(),
              t.multiplyScalar(this.radius).add(this.center)),
              t
          }
          getBoundingBox(e) {
            return this.isEmpty() ? (e.makeEmpty(),
              e) : (e.set(this.center, this.center),
              e.expandByScalar(this.radius),
              e)
          }
          applyMatrix4(e) {
            return this.center.applyMatrix4(e),
              this.radius = this.radius * e.getMaxScaleOnAxis(),
              this
          }
          translate(e) {
            return this.center.add(e),
              this
          }
          expandByPoint(e) {
            ws.subVectors(e, this.center);
            const t = ws.lengthSq();
            if (t > this.radius * this.radius) {
              const e = Math.sqrt(t)
                , i = .5 * (e - this.radius);
              this.center.add(ws.multiplyScalar(i / e)),
                this.radius += i
            }
            return this
          }
          union(e) {
            return !0 === this.center.equals(e.center) ? bs.set(0, 0, 1).multiplyScalar(e.radius) : bs.subVectors(e.center, this.center).normalize().multiplyScalar(e.radius),
              this.expandByPoint(_s.copy(e.center).add(bs)),
              this.expandByPoint(_s.copy(e.center).sub(bs)),
              this
          }
          equals(e) {
            return e.center.equals(this.center) && e.radius === this.radius
          }
          clone() {
            return (new this.constructor).copy(this)
          }
        }
        const Ss = new ts
          , Ms = new ts
          , Ts = new ts
          , Es = new ts
          , Cs = new ts
          , Ps = new ts
          , Ds = new ts;
        class Is {
          constructor(e=new ts, t=new ts(0,0,-1)) {
            this.origin = e,
              this.direction = t
          }
          set(e, t) {
            return this.origin.copy(e),
              this.direction.copy(t),
              this
          }
          copy(e) {
            return this.origin.copy(e.origin),
              this.direction.copy(e.direction),
              this
          }
          at(e, t) {
            return t.copy(this.direction).multiplyScalar(e).add(this.origin)
          }
          lookAt(e) {
            return this.direction.copy(e).sub(this.origin).normalize(),
              this
          }
          recast(e) {
            return this.origin.copy(this.at(e, Ss)),
              this
          }
          closestPointToPoint(e, t) {
            t.subVectors(e, this.origin);
            const i = t.dot(this.direction);
            return i < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(i).add(this.origin)
          }
          distanceToPoint(e) {
            return Math.sqrt(this.distanceSqToPoint(e))
          }
          distanceSqToPoint(e) {
            const t = Ss.subVectors(e, this.origin).dot(this.direction);
            return t < 0 ? this.origin.distanceToSquared(e) : (Ss.copy(this.direction).multiplyScalar(t).add(this.origin),
              Ss.distanceToSquared(e))
          }
          distanceSqToSegment(e, t, i, n) {
            Ms.copy(e).add(t).multiplyScalar(.5),
              Ts.copy(t).sub(e).normalize(),
              Es.copy(this.origin).sub(Ms);
            const r = .5 * e.distanceTo(t)
              , s = -this.direction.dot(Ts)
              , a = Es.dot(this.direction)
              , o = -Es.dot(Ts)
              , l = Es.lengthSq()
              , h = Math.abs(1 - s * s);
            let c, u, d, p;
            if (h > 0)
              if (c = s * o - a,
                u = s * a - o,
                p = r * h,
              c >= 0)
                if (u >= -p)
                  if (u <= p) {
                    const e = 1 / h;
                    c *= e,
                      u *= e,
                      d = c * (c + s * u + 2 * a) + u * (s * c + u + 2 * o) + l
                  } else
                    u = r,
                      c = Math.max(0, -(s * u + a)),
                      d = -c * c + u * (u + 2 * o) + l;
                else
                  u = -r,
                    c = Math.max(0, -(s * u + a)),
                    d = -c * c + u * (u + 2 * o) + l;
              else
                u <= -p ? (c = Math.max(0, -(-s * r + a)),
                  u = c > 0 ? -r : Math.min(Math.max(-r, -o), r),
                  d = -c * c + u * (u + 2 * o) + l) : u <= p ? (c = 0,
                  u = Math.min(Math.max(-r, -o), r),
                  d = u * (u + 2 * o) + l) : (c = Math.max(0, -(s * r + a)),
                  u = c > 0 ? r : Math.min(Math.max(-r, -o), r),
                  d = -c * c + u * (u + 2 * o) + l);
            else
              u = s > 0 ? -r : r,
                c = Math.max(0, -(s * u + a)),
                d = -c * c + u * (u + 2 * o) + l;
            return i && i.copy(this.direction).multiplyScalar(c).add(this.origin),
            n && n.copy(Ts).multiplyScalar(u).add(Ms),
              d
          }
          intersectSphere(e, t) {
            Ss.subVectors(e.center, this.origin);
            const i = Ss.dot(this.direction)
              , n = Ss.dot(Ss) - i * i
              , r = e.radius * e.radius;
            if (n > r)
              return null;
            const s = Math.sqrt(r - n)
              , a = i - s
              , o = i + s;
            return a < 0 && o < 0 ? null : a < 0 ? this.at(o, t) : this.at(a, t)
          }
          intersectsSphere(e) {
            return this.distanceSqToPoint(e.center) <= e.radius * e.radius
          }
          distanceToPlane(e) {
            const t = e.normal.dot(this.direction);
            if (0 === t)
              return 0 === e.distanceToPoint(this.origin) ? 0 : null;
            const i = -(this.origin.dot(e.normal) + e.constant) / t;
            return i >= 0 ? i : null
          }
          intersectPlane(e, t) {
            const i = this.distanceToPlane(e);
            return null === i ? null : this.at(i, t)
          }
          intersectsPlane(e) {
            const t = e.distanceToPoint(this.origin);
            return 0 === t || e.normal.dot(this.direction) * t < 0
          }
          intersectBox(e, t) {
            let i, n, r, s, a, o;
            const l = 1 / this.direction.x
              , h = 1 / this.direction.y
              , c = 1 / this.direction.z
              , u = this.origin;
            return l >= 0 ? (i = (e.min.x - u.x) * l,
              n = (e.max.x - u.x) * l) : (i = (e.max.x - u.x) * l,
              n = (e.min.x - u.x) * l),
              h >= 0 ? (r = (e.min.y - u.y) * h,
                s = (e.max.y - u.y) * h) : (r = (e.max.y - u.y) * h,
                s = (e.min.y - u.y) * h),
              i > s || r > n ? null : ((r > i || i != i) && (i = r),
              (s < n || n != n) && (n = s),
                c >= 0 ? (a = (e.min.z - u.z) * c,
                  o = (e.max.z - u.z) * c) : (a = (e.max.z - u.z) * c,
                  o = (e.min.z - u.z) * c),
                i > o || a > n ? null : ((a > i || i != i) && (i = a),
                (o < n || n != n) && (n = o),
                  n < 0 ? null : this.at(i >= 0 ? i : n, t)))
          }
          intersectsBox(e) {
            return null !== this.intersectBox(e, Ss)
          }
          intersectTriangle(e, t, i, n, r) {
            Cs.subVectors(t, e),
              Ps.subVectors(i, e),
              Ds.crossVectors(Cs, Ps);
            let s, a = this.direction.dot(Ds);
            if (a > 0) {
              if (n)
                return null;
              s = 1
            } else {
              if (!(a < 0))
                return null;
              s = -1,
                a = -a
            }
            Es.subVectors(this.origin, e);
            const o = s * this.direction.dot(Ps.crossVectors(Es, Ps));
            if (o < 0)
              return null;
            const l = s * this.direction.dot(Cs.cross(Es));
            if (l < 0)
              return null;
            if (o + l > a)
              return null;
            const h = -s * Es.dot(Ds);
            return h < 0 ? null : this.at(h / a, r)
          }
          applyMatrix4(e) {
            return this.origin.applyMatrix4(e),
              this.direction.transformDirection(e),
              this
          }
          equals(e) {
            return e.origin.equals(this.origin) && e.direction.equals(this.direction)
          }
          clone() {
            return (new this.constructor).copy(this)
          }
        }
        class Rs {
          constructor() {
            this.isMatrix4 = !0,
              this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
            arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
          }
          set(e, t, i, n, r, s, a, o, l, h, c, u, d, p, f, m) {
            const g = this.elements;
            return g[0] = e,
              g[4] = t,
              g[8] = i,
              g[12] = n,
              g[1] = r,
              g[5] = s,
              g[9] = a,
              g[13] = o,
              g[2] = l,
              g[6] = h,
              g[10] = c,
              g[14] = u,
              g[3] = d,
              g[7] = p,
              g[11] = f,
              g[15] = m,
              this
          }
          identity() {
            return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
              this
          }
          clone() {
            return (new Rs).fromArray(this.elements)
          }
          copy(e) {
            const t = this.elements
              , i = e.elements;
            return t[0] = i[0],
              t[1] = i[1],
              t[2] = i[2],
              t[3] = i[3],
              t[4] = i[4],
              t[5] = i[5],
              t[6] = i[6],
              t[7] = i[7],
              t[8] = i[8],
              t[9] = i[9],
              t[10] = i[10],
              t[11] = i[11],
              t[12] = i[12],
              t[13] = i[13],
              t[14] = i[14],
              t[15] = i[15],
              this
          }
          copyPosition(e) {
            const t = this.elements
              , i = e.elements;
            return t[12] = i[12],
              t[13] = i[13],
              t[14] = i[14],
              this
          }
          setFromMatrix3(e) {
            const t = e.elements;
            return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1),
              this
          }
          extractBasis(e, t, i) {
            return e.setFromMatrixColumn(this, 0),
              t.setFromMatrixColumn(this, 1),
              i.setFromMatrixColumn(this, 2),
              this
          }
          makeBasis(e, t, i) {
            return this.set(e.x, t.x, i.x, 0, e.y, t.y, i.y, 0, e.z, t.z, i.z, 0, 0, 0, 0, 1),
              this
          }
          extractRotation(e) {
            const t = this.elements
              , i = e.elements
              , n = 1 / Ls.setFromMatrixColumn(e, 0).length()
              , r = 1 / Ls.setFromMatrixColumn(e, 1).length()
              , s = 1 / Ls.setFromMatrixColumn(e, 2).length();
            return t[0] = i[0] * n,
              t[1] = i[1] * n,
              t[2] = i[2] * n,
              t[3] = 0,
              t[4] = i[4] * r,
              t[5] = i[5] * r,
              t[6] = i[6] * r,
              t[7] = 0,
              t[8] = i[8] * s,
              t[9] = i[9] * s,
              t[10] = i[10] * s,
              t[11] = 0,
              t[12] = 0,
              t[13] = 0,
              t[14] = 0,
              t[15] = 1,
              this
          }
          makeRotationFromEuler(e) {
            e && e.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
            const t = this.elements
              , i = e.x
              , n = e.y
              , r = e.z
              , s = Math.cos(i)
              , a = Math.sin(i)
              , o = Math.cos(n)
              , l = Math.sin(n)
              , h = Math.cos(r)
              , c = Math.sin(r);
            if ("XYZ" === e.order) {
              const e = s * h
                , i = s * c
                , n = a * h
                , r = a * c;
              t[0] = o * h,
                t[4] = -o * c,
                t[8] = l,
                t[1] = i + n * l,
                t[5] = e - r * l,
                t[9] = -a * o,
                t[2] = r - e * l,
                t[6] = n + i * l,
                t[10] = s * o
            } else if ("YXZ" === e.order) {
              const e = o * h
                , i = o * c
                , n = l * h
                , r = l * c;
              t[0] = e + r * a,
                t[4] = n * a - i,
                t[8] = s * l,
                t[1] = s * c,
                t[5] = s * h,
                t[9] = -a,
                t[2] = i * a - n,
                t[6] = r + e * a,
                t[10] = s * o
            } else if ("ZXY" === e.order) {
              const e = o * h
                , i = o * c
                , n = l * h
                , r = l * c;
              t[0] = e - r * a,
                t[4] = -s * c,
                t[8] = n + i * a,
                t[1] = i + n * a,
                t[5] = s * h,
                t[9] = r - e * a,
                t[2] = -s * l,
                t[6] = a,
                t[10] = s * o
            } else if ("ZYX" === e.order) {
              const e = s * h
                , i = s * c
                , n = a * h
                , r = a * c;
              t[0] = o * h,
                t[4] = n * l - i,
                t[8] = e * l + r,
                t[1] = o * c,
                t[5] = r * l + e,
                t[9] = i * l - n,
                t[2] = -l,
                t[6] = a * o,
                t[10] = s * o
            } else if ("YZX" === e.order) {
              const e = s * o
                , i = s * l
                , n = a * o
                , r = a * l;
              t[0] = o * h,
                t[4] = r - e * c,
                t[8] = n * c + i,
                t[1] = c,
                t[5] = s * h,
                t[9] = -a * h,
                t[2] = -l * h,
                t[6] = i * c + n,
                t[10] = e - r * c
            } else if ("XZY" === e.order) {
              const e = s * o
                , i = s * l
                , n = a * o
                , r = a * l;
              t[0] = o * h,
                t[4] = -c,
                t[8] = l * h,
                t[1] = e * c + r,
                t[5] = s * h,
                t[9] = i * c - n,
                t[2] = n * c - i,
                t[6] = a * h,
                t[10] = r * c + e
            }
            return t[3] = 0,
              t[7] = 0,
              t[11] = 0,
              t[12] = 0,
              t[13] = 0,
              t[14] = 0,
              t[15] = 1,
              this
          }
          makeRotationFromQuaternion(e) {
            return this.compose(Fs, e, Bs)
          }
          lookAt(e, t, i) {
            const n = this.elements;
            return zs.subVectors(e, t),
            0 === zs.lengthSq() && (zs.z = 1),
              zs.normalize(),
              Os.crossVectors(i, zs),
            0 === Os.lengthSq() && (1 === Math.abs(i.z) ? zs.x += 1e-4 : zs.z += 1e-4,
              zs.normalize(),
              Os.crossVectors(i, zs)),
              Os.normalize(),
              Ns.crossVectors(zs, Os),
              n[0] = Os.x,
              n[4] = Ns.x,
              n[8] = zs.x,
              n[1] = Os.y,
              n[5] = Ns.y,
              n[9] = zs.y,
              n[2] = Os.z,
              n[6] = Ns.z,
              n[10] = zs.z,
              this
          }
          multiply(e, t) {
            return void 0 !== t ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),
              this.multiplyMatrices(e, t)) : this.multiplyMatrices(this, e)
          }
          premultiply(e) {
            return this.multiplyMatrices(e, this)
          }
          multiplyMatrices(e, t) {
            const i = e.elements
              , n = t.elements
              , r = this.elements
              , s = i[0]
              , a = i[4]
              , o = i[8]
              , l = i[12]
              , h = i[1]
              , c = i[5]
              , u = i[9]
              , d = i[13]
              , p = i[2]
              , f = i[6]
              , m = i[10]
              , g = i[14]
              , v = i[3]
              , y = i[7]
              , x = i[11]
              , _ = i[15]
              , b = n[0]
              , w = n[4]
              , A = n[8]
              , S = n[12]
              , M = n[1]
              , T = n[5]
              , E = n[9]
              , C = n[13]
              , P = n[2]
              , D = n[6]
              , I = n[10]
              , R = n[14]
              , L = n[3]
              , k = n[7]
              , F = n[11]
              , B = n[15];
            return r[0] = s * b + a * M + o * P + l * L,
              r[4] = s * w + a * T + o * D + l * k,
              r[8] = s * A + a * E + o * I + l * F,
              r[12] = s * S + a * C + o * R + l * B,
              r[1] = h * b + c * M + u * P + d * L,
              r[5] = h * w + c * T + u * D + d * k,
              r[9] = h * A + c * E + u * I + d * F,
              r[13] = h * S + c * C + u * R + d * B,
              r[2] = p * b + f * M + m * P + g * L,
              r[6] = p * w + f * T + m * D + g * k,
              r[10] = p * A + f * E + m * I + g * F,
              r[14] = p * S + f * C + m * R + g * B,
              r[3] = v * b + y * M + x * P + _ * L,
              r[7] = v * w + y * T + x * D + _ * k,
              r[11] = v * A + y * E + x * I + _ * F,
              r[15] = v * S + y * C + x * R + _ * B,
              this
          }
          multiplyScalar(e) {
            const t = this.elements;
            return t[0] *= e,
              t[4] *= e,
              t[8] *= e,
              t[12] *= e,
              t[1] *= e,
              t[5] *= e,
              t[9] *= e,
              t[13] *= e,
              t[2] *= e,
              t[6] *= e,
              t[10] *= e,
              t[14] *= e,
              t[3] *= e,
              t[7] *= e,
              t[11] *= e,
              t[15] *= e,
              this
          }
          determinant() {
            const e = this.elements
              , t = e[0]
              , i = e[4]
              , n = e[8]
              , r = e[12]
              , s = e[1]
              , a = e[5]
              , o = e[9]
              , l = e[13]
              , h = e[2]
              , c = e[6]
              , u = e[10]
              , d = e[14];
            return e[3] * (+r * o * c - n * l * c - r * a * u + i * l * u + n * a * d - i * o * d) + e[7] * (+t * o * d - t * l * u + r * s * u - n * s * d + n * l * h - r * o * h) + e[11] * (+t * l * c - t * a * d - r * s * c + i * s * d + r * a * h - i * l * h) + e[15] * (-n * a * h - t * o * c + t * a * u + n * s * c - i * s * u + i * o * h)
          }
          transpose() {
            const e = this.elements;
            let t;
            return t = e[1],
              e[1] = e[4],
              e[4] = t,
              t = e[2],
              e[2] = e[8],
              e[8] = t,
              t = e[6],
              e[6] = e[9],
              e[9] = t,
              t = e[3],
              e[3] = e[12],
              e[12] = t,
              t = e[7],
              e[7] = e[13],
              e[13] = t,
              t = e[11],
              e[11] = e[14],
              e[14] = t,
              this
          }
          setPosition(e, t, i) {
            const n = this.elements;
            return e.isVector3 ? (n[12] = e.x,
              n[13] = e.y,
              n[14] = e.z) : (n[12] = e,
              n[13] = t,
              n[14] = i),
              this
          }
          invert() {
            const e = this.elements
              , t = e[0]
              , i = e[1]
              , n = e[2]
              , r = e[3]
              , s = e[4]
              , a = e[5]
              , o = e[6]
              , l = e[7]
              , h = e[8]
              , c = e[9]
              , u = e[10]
              , d = e[11]
              , p = e[12]
              , f = e[13]
              , m = e[14]
              , g = e[15]
              , v = c * m * l - f * u * l + f * o * d - a * m * d - c * o * g + a * u * g
              , y = p * u * l - h * m * l - p * o * d + s * m * d + h * o * g - s * u * g
              , x = h * f * l - p * c * l + p * a * d - s * f * d - h * a * g + s * c * g
              , _ = p * c * o - h * f * o - p * a * u + s * f * u + h * a * m - s * c * m
              , b = t * v + i * y + n * x + r * _;
            if (0 === b)
              return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
            const w = 1 / b;
            return e[0] = v * w,
              e[1] = (f * u * r - c * m * r - f * n * d + i * m * d + c * n * g - i * u * g) * w,
              e[2] = (a * m * r - f * o * r + f * n * l - i * m * l - a * n * g + i * o * g) * w,
              e[3] = (c * o * r - a * u * r - c * n * l + i * u * l + a * n * d - i * o * d) * w,
              e[4] = y * w,
              e[5] = (h * m * r - p * u * r + p * n * d - t * m * d - h * n * g + t * u * g) * w,
              e[6] = (p * o * r - s * m * r - p * n * l + t * m * l + s * n * g - t * o * g) * w,
              e[7] = (s * u * r - h * o * r + h * n * l - t * u * l - s * n * d + t * o * d) * w,
              e[8] = x * w,
              e[9] = (p * c * r - h * f * r - p * i * d + t * f * d + h * i * g - t * c * g) * w,
              e[10] = (s * f * r - p * a * r + p * i * l - t * f * l - s * i * g + t * a * g) * w,
              e[11] = (h * a * r - s * c * r - h * i * l + t * c * l + s * i * d - t * a * d) * w,
              e[12] = _ * w,
              e[13] = (h * f * n - p * c * n + p * i * u - t * f * u - h * i * m + t * c * m) * w,
              e[14] = (p * a * n - s * f * n - p * i * o + t * f * o + s * i * m - t * a * m) * w,
              e[15] = (s * c * n - h * a * n + h * i * o - t * c * o - s * i * u + t * a * u) * w,
              this
          }
          scale(e) {
            const t = this.elements
              , i = e.x
              , n = e.y
              , r = e.z;
            return t[0] *= i,
              t[4] *= n,
              t[8] *= r,
              t[1] *= i,
              t[5] *= n,
              t[9] *= r,
              t[2] *= i,
              t[6] *= n,
              t[10] *= r,
              t[3] *= i,
              t[7] *= n,
              t[11] *= r,
              this
          }
          getMaxScaleOnAxis() {
            const e = this.elements
              , t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2]
              , i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6]
              , n = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
            return Math.sqrt(Math.max(t, i, n))
          }
          makeTranslation(e, t, i) {
            return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1),
              this
          }
          makeRotationX(e) {
            const t = Math.cos(e)
              , i = Math.sin(e);
            return this.set(1, 0, 0, 0, 0, t, -i, 0, 0, i, t, 0, 0, 0, 0, 1),
              this
          }
          makeRotationY(e) {
            const t = Math.cos(e)
              , i = Math.sin(e);
            return this.set(t, 0, i, 0, 0, 1, 0, 0, -i, 0, t, 0, 0, 0, 0, 1),
              this
          }
          makeRotationZ(e) {
            const t = Math.cos(e)
              , i = Math.sin(e);
            return this.set(t, -i, 0, 0, i, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
              this
          }
          makeRotationAxis(e, t) {
            const i = Math.cos(t)
              , n = Math.sin(t)
              , r = 1 - i
              , s = e.x
              , a = e.y
              , o = e.z
              , l = r * s
              , h = r * a;
            return this.set(l * s + i, l * a - n * o, l * o + n * a, 0, l * a + n * o, h * a + i, h * o - n * s, 0, l * o - n * a, h * o + n * s, r * o * o + i, 0, 0, 0, 0, 1),
              this
          }
          makeScale(e, t, i) {
            return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1),
              this
          }
          makeShear(e, t, i, n, r, s) {
            return this.set(1, i, r, 0, e, 1, s, 0, t, n, 1, 0, 0, 0, 0, 1),
              this
          }
          compose(e, t, i) {
            const n = this.elements
              , r = t._x
              , s = t._y
              , a = t._z
              , o = t._w
              , l = r + r
              , h = s + s
              , c = a + a
              , u = r * l
              , d = r * h
              , p = r * c
              , f = s * h
              , m = s * c
              , g = a * c
              , v = o * l
              , y = o * h
              , x = o * c
              , _ = i.x
              , b = i.y
              , w = i.z;
            return n[0] = (1 - (f + g)) * _,
              n[1] = (d + x) * _,
              n[2] = (p - y) * _,
              n[3] = 0,
              n[4] = (d - x) * b,
              n[5] = (1 - (u + g)) * b,
              n[6] = (m + v) * b,
              n[7] = 0,
              n[8] = (p + y) * w,
              n[9] = (m - v) * w,
              n[10] = (1 - (u + f)) * w,
              n[11] = 0,
              n[12] = e.x,
              n[13] = e.y,
              n[14] = e.z,
              n[15] = 1,
              this
          }
          decompose(e, t, i) {
            const n = this.elements;
            let r = Ls.set(n[0], n[1], n[2]).length();
            const s = Ls.set(n[4], n[5], n[6]).length()
              , a = Ls.set(n[8], n[9], n[10]).length();
            this.determinant() < 0 && (r = -r),
              e.x = n[12],
              e.y = n[13],
              e.z = n[14],
              ks.copy(this);
            const o = 1 / r
              , l = 1 / s
              , h = 1 / a;
            return ks.elements[0] *= o,
              ks.elements[1] *= o,
              ks.elements[2] *= o,
              ks.elements[4] *= l,
              ks.elements[5] *= l,
              ks.elements[6] *= l,
              ks.elements[8] *= h,
              ks.elements[9] *= h,
              ks.elements[10] *= h,
              t.setFromRotationMatrix(ks),
              i.x = r,
              i.y = s,
              i.z = a,
              this
          }
          makePerspective(e, t, i, n, r, s) {
            void 0 === s && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
            const a = this.elements
              , o = 2 * r / (t - e)
              , l = 2 * r / (i - n)
              , h = (t + e) / (t - e)
              , c = (i + n) / (i - n)
              , u = -(s + r) / (s - r)
              , d = -2 * s * r / (s - r);
            return a[0] = o,
              a[4] = 0,
              a[8] = h,
              a[12] = 0,
              a[1] = 0,
              a[5] = l,
              a[9] = c,
              a[13] = 0,
              a[2] = 0,
              a[6] = 0,
              a[10] = u,
              a[14] = d,
              a[3] = 0,
              a[7] = 0,
              a[11] = -1,
              a[15] = 0,
              this
          }
          makeOrthographic(e, t, i, n, r, s) {
            const a = this.elements
              , o = 1 / (t - e)
              , l = 1 / (i - n)
              , h = 1 / (s - r)
              , c = (t + e) * o
              , u = (i + n) * l
              , d = (s + r) * h;
            return a[0] = 2 * o,
              a[4] = 0,
              a[8] = 0,
              a[12] = -c,
              a[1] = 0,
              a[5] = 2 * l,
              a[9] = 0,
              a[13] = -u,
              a[2] = 0,
              a[6] = 0,
              a[10] = -2 * h,
              a[14] = -d,
              a[3] = 0,
              a[7] = 0,
              a[11] = 0,
              a[15] = 1,
              this
          }
          equals(e) {
            const t = this.elements
              , i = e.elements;
            for (let e = 0; e < 16; e++)
              if (t[e] !== i[e])
                return !1;
            return !0
          }
          fromArray(e, t=0) {
            for (let i = 0; i < 16; i++)
              this.elements[i] = e[i + t];
            return this
          }
          toArray(e=[], t=0) {
            const i = this.elements;
            return e[t] = i[0],
              e[t + 1] = i[1],
              e[t + 2] = i[2],
              e[t + 3] = i[3],
              e[t + 4] = i[4],
              e[t + 5] = i[5],
              e[t + 6] = i[6],
              e[t + 7] = i[7],
              e[t + 8] = i[8],
              e[t + 9] = i[9],
              e[t + 10] = i[10],
              e[t + 11] = i[11],
              e[t + 12] = i[12],
              e[t + 13] = i[13],
              e[t + 14] = i[14],
              e[t + 15] = i[15],
              e
          }
        }
        const Ls = new ts
          , ks = new Rs
          , Fs = new ts(0,0,0)
          , Bs = new ts(1,1,1)
          , Os = new ts
          , Ns = new ts
          , zs = new ts
          , Us = new Rs
          , Gs = new es;
        class Vs {
          constructor(e=0, t=0, i=0, n=Vs.DefaultOrder) {
            this.isEuler = !0,
              this._x = e,
              this._y = t,
              this._z = i,
              this._order = n
          }
          get x() {
            return this._x
          }
          set x(e) {
            this._x = e,
              this._onChangeCallback()
          }
          get y() {
            return this._y
          }
          set y(e) {
            this._y = e,
              this._onChangeCallback()
          }
          get z() {
            return this._z
          }
          set z(e) {
            this._z = e,
              this._onChangeCallback()
          }
          get order() {
            return this._order
          }
          set order(e) {
            this._order = e,
              this._onChangeCallback()
          }
          set(e, t, i, n=this._order) {
            return this._x = e,
              this._y = t,
              this._z = i,
              this._order = n,
              this._onChangeCallback(),
              this
          }
          clone() {
            return new this.constructor(this._x,this._y,this._z,this._order)
          }
          copy(e) {
            return this._x = e._x,
              this._y = e._y,
              this._z = e._z,
              this._order = e._order,
              this._onChangeCallback(),
              this
          }
          setFromRotationMatrix(e, t=this._order, i=!0) {
            const n = e.elements
              , r = n[0]
              , s = n[4]
              , a = n[8]
              , o = n[1]
              , l = n[5]
              , h = n[9]
              , c = n[2]
              , u = n[6]
              , d = n[10];
            switch (t) {
              case "XYZ":
                this._y = Math.asin(Ar(a, -1, 1)),
                  Math.abs(a) < .9999999 ? (this._x = Math.atan2(-h, d),
                    this._z = Math.atan2(-s, r)) : (this._x = Math.atan2(u, l),
                    this._z = 0);
                break;
              case "YXZ":
                this._x = Math.asin(-Ar(h, -1, 1)),
                  Math.abs(h) < .9999999 ? (this._y = Math.atan2(a, d),
                    this._z = Math.atan2(o, l)) : (this._y = Math.atan2(-c, r),
                    this._z = 0);
                break;
              case "ZXY":
                this._x = Math.asin(Ar(u, -1, 1)),
                  Math.abs(u) < .9999999 ? (this._y = Math.atan2(-c, d),
                    this._z = Math.atan2(-s, l)) : (this._y = 0,
                    this._z = Math.atan2(o, r));
                break;
              case "ZYX":
                this._y = Math.asin(-Ar(c, -1, 1)),
                  Math.abs(c) < .9999999 ? (this._x = Math.atan2(u, d),
                    this._z = Math.atan2(o, r)) : (this._x = 0,
                    this._z = Math.atan2(-s, l));
                break;
              case "YZX":
                this._z = Math.asin(Ar(o, -1, 1)),
                  Math.abs(o) < .9999999 ? (this._x = Math.atan2(-h, l),
                    this._y = Math.atan2(-c, r)) : (this._x = 0,
                    this._y = Math.atan2(a, d));
                break;
              case "XZY":
                this._z = Math.asin(-Ar(s, -1, 1)),
                  Math.abs(s) < .9999999 ? (this._x = Math.atan2(u, l),
                    this._y = Math.atan2(a, r)) : (this._x = Math.atan2(-h, d),
                    this._y = 0);
                break;
              default:
                console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t)
            }
            return this._order = t,
            !0 === i && this._onChangeCallback(),
              this
          }
          setFromQuaternion(e, t, i) {
            return Us.makeRotationFromQuaternion(e),
              this.setFromRotationMatrix(Us, t, i)
          }
          setFromVector3(e, t=this._order) {
            return this.set(e.x, e.y, e.z, t)
          }
          reorder(e) {
            return Gs.setFromEuler(this),
              this.setFromQuaternion(Gs, e)
          }
          equals(e) {
            return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
          }
          fromArray(e) {
            return this._x = e[0],
              this._y = e[1],
              this._z = e[2],
            void 0 !== e[3] && (this._order = e[3]),
              this._onChangeCallback(),
              this
          }
          toArray(e=[], t=0) {
            return e[t] = this._x,
              e[t + 1] = this._y,
              e[t + 2] = this._z,
              e[t + 3] = this._order,
              e
          }
          _onChange(e) {
            return this._onChangeCallback = e,
              this
          }
          _onChangeCallback() {}
          *[Symbol.iterator]() {
            yield this._x,
              yield this._y,
              yield this._z,
              yield this._order
          }
          toVector3() {
            console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead")
          }
        }
        Vs.DefaultOrder = "XYZ",
          Vs.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
        class Hs {
          constructor() {
            this.mask = 1
          }
          set(e) {
            this.mask = (1 << e | 0) >>> 0
          }
          enable(e) {
            this.mask |= 1 << e | 0
          }
          enableAll() {
            this.mask = -1
          }
          toggle(e) {
            this.mask ^= 1 << e | 0
          }
          disable(e) {
            this.mask &= ~(1 << e | 0)
          }
          disableAll() {
            this.mask = 0
          }
          test(e) {
            return 0 != (this.mask & e.mask)
          }
          isEnabled(e) {
            return 0 != (this.mask & (1 << e | 0))
          }
        }
        let Ws = 0;
        const js = new ts
          , Xs = new es
          , Ys = new Rs
          , qs = new ts
          , Qs = new ts
          , Ks = new ts
          , Js = new es
          , Zs = new ts(1,0,0)
          , $s = new ts(0,1,0)
          , ea = new ts(0,0,1)
          , ta = {
          type: "added"
        }
          , ia = {
          type: "removed"
        };
        class na extends vr {
          constructor() {
            super(),
              this.isObject3D = !0,
              Object.defineProperty(this, "id", {
                value: Ws++
              }),
              this.uuid = wr(),
              this.name = "",
              this.type = "Object3D",
              this.parent = null,
              this.children = [],
              this.up = na.DefaultUp.clone();
            const e = new ts
              , t = new Vs
              , i = new es
              , n = new ts(1,1,1);
            t._onChange((function() {
                i.setFromEuler(t, !1)
              }
            )),
              i._onChange((function() {
                  t.setFromQuaternion(i, void 0, !1)
                }
              )),
              Object.defineProperties(this, {
                position: {
                  configurable: !0,
                  enumerable: !0,
                  value: e
                },
                rotation: {
                  configurable: !0,
                  enumerable: !0,
                  value: t
                },
                quaternion: {
                  configurable: !0,
                  enumerable: !0,
                  value: i
                },
                scale: {
                  configurable: !0,
                  enumerable: !0,
                  value: n
                },
                modelViewMatrix: {
                  value: new Rs
                },
                normalMatrix: {
                  value: new Ir
                }
              }),
              this.matrix = new Rs,
              this.matrixWorld = new Rs,
              this.matrixAutoUpdate = na.DefaultMatrixAutoUpdate,
              this.matrixWorldNeedsUpdate = !1,
              this.layers = new Hs,
              this.visible = !0,
              this.castShadow = !1,
              this.receiveShadow = !1,
              this.frustumCulled = !0,
              this.renderOrder = 0,
              this.animations = [],
              this.userData = {}
          }
          onBeforeRender() {}
          onAfterRender() {}
          applyMatrix4(e) {
            this.matrixAutoUpdate && this.updateMatrix(),
              this.matrix.premultiply(e),
              this.matrix.decompose(this.position, this.quaternion, this.scale)
          }
          applyQuaternion(e) {
            return this.quaternion.premultiply(e),
              this
          }
          setRotationFromAxisAngle(e, t) {
            this.quaternion.setFromAxisAngle(e, t)
          }
          setRotationFromEuler(e) {
            this.quaternion.setFromEuler(e, !0)
          }
          setRotationFromMatrix(e) {
            this.quaternion.setFromRotationMatrix(e)
          }
          setRotationFromQuaternion(e) {
            this.quaternion.copy(e)
          }
          rotateOnAxis(e, t) {
            return Xs.setFromAxisAngle(e, t),
              this.quaternion.multiply(Xs),
              this
          }
          rotateOnWorldAxis(e, t) {
            return Xs.setFromAxisAngle(e, t),
              this.quaternion.premultiply(Xs),
              this
          }
          rotateX(e) {
            return this.rotateOnAxis(Zs, e)
          }
          rotateY(e) {
            return this.rotateOnAxis($s, e)
          }
          rotateZ(e) {
            return this.rotateOnAxis(ea, e)
          }
          translateOnAxis(e, t) {
            return js.copy(e).applyQuaternion(this.quaternion),
              this.position.add(js.multiplyScalar(t)),
              this
          }
          translateX(e) {
            return this.translateOnAxis(Zs, e)
          }
          translateY(e) {
            return this.translateOnAxis($s, e)
          }
          translateZ(e) {
            return this.translateOnAxis(ea, e)
          }
          localToWorld(e) {
            return e.applyMatrix4(this.matrixWorld)
          }
          worldToLocal(e) {
            return e.applyMatrix4(Ys.copy(this.matrixWorld).invert())
          }
          lookAt(e, t, i) {
            e.isVector3 ? qs.copy(e) : qs.set(e, t, i);
            const n = this.parent;
            this.updateWorldMatrix(!0, !1),
              Qs.setFromMatrixPosition(this.matrixWorld),
              this.isCamera || this.isLight ? Ys.lookAt(Qs, qs, this.up) : Ys.lookAt(qs, Qs, this.up),
              this.quaternion.setFromRotationMatrix(Ys),
            n && (Ys.extractRotation(n.matrixWorld),
              Xs.setFromRotationMatrix(Ys),
              this.quaternion.premultiply(Xs.invert()))
          }
          add(e) {
            if (arguments.length > 1) {
              for (let e = 0; e < arguments.length; e++)
                this.add(arguments[e]);
              return this
            }
            return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e),
              this) : (e && e.isObject3D ? (null !== e.parent && e.parent.remove(e),
              e.parent = this,
              this.children.push(e),
              e.dispatchEvent(ta)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e),
              this)
          }
          remove(e) {
            if (arguments.length > 1) {
              for (let e = 0; e < arguments.length; e++)
                this.remove(arguments[e]);
              return this
            }
            const t = this.children.indexOf(e);
            return -1 !== t && (e.parent = null,
              this.children.splice(t, 1),
              e.dispatchEvent(ia)),
              this
          }
          removeFromParent() {
            const e = this.parent;
            return null !== e && e.remove(this),
              this
          }
          clear() {
            for (let e = 0; e < this.children.length; e++) {
              const t = this.children[e];
              t.parent = null,
                t.dispatchEvent(ia)
            }
            return this.children.length = 0,
              this
          }
          attach(e) {
            return this.updateWorldMatrix(!0, !1),
              Ys.copy(this.matrixWorld).invert(),
            null !== e.parent && (e.parent.updateWorldMatrix(!0, !1),
              Ys.multiply(e.parent.matrixWorld)),
              e.applyMatrix4(Ys),
              this.add(e),
              e.updateWorldMatrix(!1, !0),
              this
          }
          getObjectById(e) {
            return this.getObjectByProperty("id", e)
          }
          getObjectByName(e) {
            return this.getObjectByProperty("name", e)
          }
          getObjectByProperty(e, t) {
            if (this[e] === t)
              return this;
            for (let i = 0, n = this.children.length; i < n; i++) {
              const n = this.children[i].getObjectByProperty(e, t);
              if (void 0 !== n)
                return n
            }
          }
          getWorldPosition(e) {
            return this.updateWorldMatrix(!0, !1),
              e.setFromMatrixPosition(this.matrixWorld)
          }
          getWorldQuaternion(e) {
            return this.updateWorldMatrix(!0, !1),
              this.matrixWorld.decompose(Qs, e, Ks),
              e
          }
          getWorldScale(e) {
            return this.updateWorldMatrix(!0, !1),
              this.matrixWorld.decompose(Qs, Js, e),
              e
          }
          getWorldDirection(e) {
            this.updateWorldMatrix(!0, !1);
            const t = this.matrixWorld.elements;
            return e.set(t[8], t[9], t[10]).normalize()
          }
          raycast() {}
          traverse(e) {
            e(this);
            const t = this.children;
            for (let i = 0, n = t.length; i < n; i++)
              t[i].traverse(e)
          }
          traverseVisible(e) {
            if (!1 === this.visible)
              return;
            e(this);
            const t = this.children;
            for (let i = 0, n = t.length; i < n; i++)
              t[i].traverseVisible(e)
          }
          traverseAncestors(e) {
            const t = this.parent;
            null !== t && (e(t),
              t.traverseAncestors(e))
          }
          updateMatrix() {
            this.matrix.compose(this.position, this.quaternion, this.scale),
              this.matrixWorldNeedsUpdate = !0
          }
          updateMatrixWorld(e) {
            this.matrixAutoUpdate && this.updateMatrix(),
            (this.matrixWorldNeedsUpdate || e) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
              this.matrixWorldNeedsUpdate = !1,
              e = !0);
            const t = this.children;
            for (let i = 0, n = t.length; i < n; i++)
              t[i].updateMatrixWorld(e)
          }
          updateWorldMatrix(e, t) {
            const i = this.parent;
            if (!0 === e && null !== i && i.updateWorldMatrix(!0, !1),
            this.matrixAutoUpdate && this.updateMatrix(),
              null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
            !0 === t) {
              const e = this.children;
              for (let t = 0, i = e.length; t < i; t++)
                e[t].updateWorldMatrix(!1, !0)
            }
          }
          toJSON(e) {
            const t = void 0 === e || "string" == typeof e
              , i = {};
            t && (e = {
              geometries: {},
              materials: {},
              textures: {},
              images: {},
              shapes: {},
              skeletons: {},
              animations: {},
              nodes: {}
            },
              i.metadata = {
                version: 4.5,
                type: "Object",
                generator: "Object3D.toJSON"
              });
            const n = {};
            function r(t, i) {
              return void 0 === t[i.uuid] && (t[i.uuid] = i.toJSON(e)),
                i.uuid
            }
            if (n.uuid = this.uuid,
              n.type = this.type,
            "" !== this.name && (n.name = this.name),
            !0 === this.castShadow && (n.castShadow = !0),
            !0 === this.receiveShadow && (n.receiveShadow = !0),
            !1 === this.visible && (n.visible = !1),
            !1 === this.frustumCulled && (n.frustumCulled = !1),
            0 !== this.renderOrder && (n.renderOrder = this.renderOrder),
            "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData),
              n.layers = this.layers.mask,
              n.matrix = this.matrix.toArray(),
            !1 === this.matrixAutoUpdate && (n.matrixAutoUpdate = !1),
            this.isInstancedMesh && (n.type = "InstancedMesh",
              n.count = this.count,
              n.instanceMatrix = this.instanceMatrix.toJSON(),
            null !== this.instanceColor && (n.instanceColor = this.instanceColor.toJSON())),
              this.isScene)
              this.background && (this.background.isColor ? n.background = this.background.toJSON() : this.background.isTexture && (n.background = this.background.toJSON(e).uuid)),
              this.environment && this.environment.isTexture && (n.environment = this.environment.toJSON(e).uuid);
            else if (this.isMesh || this.isLine || this.isPoints) {
              n.geometry = r(e.geometries, this.geometry);
              const t = this.geometry.parameters;
              if (void 0 !== t && void 0 !== t.shapes) {
                const i = t.shapes;
                if (Array.isArray(i))
                  for (let t = 0, n = i.length; t < n; t++) {
                    const n = i[t];
                    r(e.shapes, n)
                  }
                else
                  r(e.shapes, i)
              }
            }
            if (this.isSkinnedMesh && (n.bindMode = this.bindMode,
              n.bindMatrix = this.bindMatrix.toArray(),
            void 0 !== this.skeleton && (r(e.skeletons, this.skeleton),
              n.skeleton = this.skeleton.uuid)),
            void 0 !== this.material)
              if (Array.isArray(this.material)) {
                const t = [];
                for (let i = 0, n = this.material.length; i < n; i++)
                  t.push(r(e.materials, this.material[i]));
                n.material = t
              } else
                n.material = r(e.materials, this.material);
            if (this.children.length > 0) {
              n.children = [];
              for (let t = 0; t < this.children.length; t++)
                n.children.push(this.children[t].toJSON(e).object)
            }
            if (this.animations.length > 0) {
              n.animations = [];
              for (let t = 0; t < this.animations.length; t++) {
                const i = this.animations[t];
                n.animations.push(r(e.animations, i))
              }
            }
            if (t) {
              const t = s(e.geometries)
                , n = s(e.materials)
                , r = s(e.textures)
                , a = s(e.images)
                , o = s(e.shapes)
                , l = s(e.skeletons)
                , h = s(e.animations)
                , c = s(e.nodes);
              t.length > 0 && (i.geometries = t),
              n.length > 0 && (i.materials = n),
              r.length > 0 && (i.textures = r),
              a.length > 0 && (i.images = a),
              o.length > 0 && (i.shapes = o),
              l.length > 0 && (i.skeletons = l),
              h.length > 0 && (i.animations = h),
              c.length > 0 && (i.nodes = c)
            }
            return i.object = n,
              i;
            function s(e) {
              const t = [];
              for (const i in e) {
                const n = e[i];
                delete n.metadata,
                  t.push(n)
              }
              return t
            }
          }
          clone(e) {
            return (new this.constructor).copy(this, e)
          }
          copy(e, t=!0) {
            if (this.name = e.name,
              this.up.copy(e.up),
              this.position.copy(e.position),
              this.rotation.order = e.rotation.order,
              this.quaternion.copy(e.quaternion),
              this.scale.copy(e.scale),
              this.matrix.copy(e.matrix),
              this.matrixWorld.copy(e.matrixWorld),
              this.matrixAutoUpdate = e.matrixAutoUpdate,
              this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate,
              this.layers.mask = e.layers.mask,
              this.visible = e.visible,
              this.castShadow = e.castShadow,
              this.receiveShadow = e.receiveShadow,
              this.frustumCulled = e.frustumCulled,
              this.renderOrder = e.renderOrder,
              this.userData = JSON.parse(JSON.stringify(e.userData)),
            !0 === t)
              for (let t = 0; t < e.children.length; t++) {
                const i = e.children[t];
                this.add(i.clone())
              }
            return this
          }
        }
        na.DefaultUp = new ts(0,1,0),
          na.DefaultMatrixAutoUpdate = !0;
        const ra = new ts
          , sa = new ts
          , aa = new ts
          , oa = new ts
          , la = new ts
          , ha = new ts
          , ca = new ts
          , ua = new ts
          , da = new ts
          , pa = new ts;
        class fa {
          constructor(e=new ts, t=new ts, i=new ts) {
            this.a = e,
              this.b = t,
              this.c = i
          }
          static getNormal(e, t, i, n) {
            n.subVectors(i, t),
              ra.subVectors(e, t),
              n.cross(ra);
            const r = n.lengthSq();
            return r > 0 ? n.multiplyScalar(1 / Math.sqrt(r)) : n.set(0, 0, 0)
          }
          static getBarycoord(e, t, i, n, r) {
            ra.subVectors(n, t),
              sa.subVectors(i, t),
              aa.subVectors(e, t);
            const s = ra.dot(ra)
              , a = ra.dot(sa)
              , o = ra.dot(aa)
              , l = sa.dot(sa)
              , h = sa.dot(aa)
              , c = s * l - a * a;
            if (0 === c)
              return r.set(-2, -1, -1);
            const u = 1 / c
              , d = (l * o - a * h) * u
              , p = (s * h - a * o) * u;
            return r.set(1 - d - p, p, d)
          }
          static containsPoint(e, t, i, n) {
            return this.getBarycoord(e, t, i, n, oa),
            oa.x >= 0 && oa.y >= 0 && oa.x + oa.y <= 1
          }
          static getUV(e, t, i, n, r, s, a, o) {
            return this.getBarycoord(e, t, i, n, oa),
              o.set(0, 0),
              o.addScaledVector(r, oa.x),
              o.addScaledVector(s, oa.y),
              o.addScaledVector(a, oa.z),
              o
          }
          static isFrontFacing(e, t, i, n) {
            return ra.subVectors(i, t),
              sa.subVectors(e, t),
            ra.cross(sa).dot(n) < 0
          }
          set(e, t, i) {
            return this.a.copy(e),
              this.b.copy(t),
              this.c.copy(i),
              this
          }
          setFromPointsAndIndices(e, t, i, n) {
            return this.a.copy(e[t]),
              this.b.copy(e[i]),
              this.c.copy(e[n]),
              this
          }
          setFromAttributeAndIndices(e, t, i, n) {
            return this.a.fromBufferAttribute(e, t),
              this.b.fromBufferAttribute(e, i),
              this.c.fromBufferAttribute(e, n),
              this
          }
          clone() {
            return (new this.constructor).copy(this)
          }
          copy(e) {
            return this.a.copy(e.a),
              this.b.copy(e.b),
              this.c.copy(e.c),
              this
          }
          getArea() {
            return ra.subVectors(this.c, this.b),
              sa.subVectors(this.a, this.b),
            .5 * ra.cross(sa).length()
          }
          getMidpoint(e) {
            return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
          }
          getNormal(e) {
            return fa.getNormal(this.a, this.b, this.c, e)
          }
          getPlane(e) {
            return e.setFromCoplanarPoints(this.a, this.b, this.c)
          }
          getBarycoord(e, t) {
            return fa.getBarycoord(e, this.a, this.b, this.c, t)
          }
          getUV(e, t, i, n, r) {
            return fa.getUV(e, this.a, this.b, this.c, t, i, n, r)
          }
          containsPoint(e) {
            return fa.containsPoint(e, this.a, this.b, this.c)
          }
          isFrontFacing(e) {
            return fa.isFrontFacing(this.a, this.b, this.c, e)
          }
          intersectsBox(e) {
            return e.intersectsTriangle(this)
          }
          closestPointToPoint(e, t) {
            const i = this.a
              , n = this.b
              , r = this.c;
            let s, a;
            la.subVectors(n, i),
              ha.subVectors(r, i),
              ua.subVectors(e, i);
            const o = la.dot(ua)
              , l = ha.dot(ua);
            if (o <= 0 && l <= 0)
              return t.copy(i);
            da.subVectors(e, n);
            const h = la.dot(da)
              , c = ha.dot(da);
            if (h >= 0 && c <= h)
              return t.copy(n);
            const u = o * c - h * l;
            if (u <= 0 && o >= 0 && h <= 0)
              return s = o / (o - h),
                t.copy(i).addScaledVector(la, s);
            pa.subVectors(e, r);
            const d = la.dot(pa)
              , p = ha.dot(pa);
            if (p >= 0 && d <= p)
              return t.copy(r);
            const f = d * l - o * p;
            if (f <= 0 && l >= 0 && p <= 0)
              return a = l / (l - p),
                t.copy(i).addScaledVector(ha, a);
            const m = h * p - d * c;
            if (m <= 0 && c - h >= 0 && d - p >= 0)
              return ca.subVectors(r, n),
                a = (c - h) / (c - h + (d - p)),
                t.copy(n).addScaledVector(ca, a);
            const g = 1 / (m + f + u);
            return s = f * g,
              a = u * g,
              t.copy(i).addScaledVector(la, s).addScaledVector(ha, a)
          }
          equals(e) {
            return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
          }
        }
        let ma = 0;
        class ga extends vr {
          constructor() {
            super(),
              this.isMaterial = !0,
              Object.defineProperty(this, "id", {
                value: ma++
              }),
              this.uuid = wr(),
              this.name = "",
              this.type = "Material",
              this.blending = 1,
              this.side = 0,
              this.vertexColors = !1,
              this.opacity = 1,
              this.transparent = !1,
              this.blendSrc = 204,
              this.blendDst = 205,
              this.blendEquation = Ln,
              this.blendSrcAlpha = null,
              this.blendDstAlpha = null,
              this.blendEquationAlpha = null,
              this.depthFunc = 3,
              this.depthTest = !0,
              this.depthWrite = !0,
              this.stencilWriteMask = 255,
              this.stencilFunc = 519,
              this.stencilRef = 0,
              this.stencilFuncMask = 255,
              this.stencilFail = pr,
              this.stencilZFail = pr,
              this.stencilZPass = pr,
              this.stencilWrite = !1,
              this.clippingPlanes = null,
              this.clipIntersection = !1,
              this.clipShadows = !1,
              this.shadowSide = null,
              this.colorWrite = !0,
              this.precision = null,
              this.polygonOffset = !1,
              this.polygonOffsetFactor = 0,
              this.polygonOffsetUnits = 0,
              this.dithering = !1,
              this.alphaToCoverage = !1,
              this.premultipliedAlpha = !1,
              this.visible = !0,
              this.toneMapped = !0,
              this.userData = {},
              this.version = 0,
              this._alphaTest = 0
          }
          get alphaTest() {
            return this._alphaTest
          }
          set alphaTest(e) {
            this._alphaTest > 0 != e > 0 && this.version++,
              this._alphaTest = e
          }
          onBuild() {}
          onBeforeRender() {}
          onBeforeCompile() {}
          customProgramCacheKey() {
            return this.onBeforeCompile.toString()
          }
          setValues(e) {
            if (void 0 !== e)
              for (const t in e) {
                const i = e[t];
                if (void 0 === i) {
                  console.warn("THREE.Material: '" + t + "' parameter is undefined.");
                  continue
                }
                if ("shading" === t) {
                  console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."),
                    this.flatShading = 1 === i;
                  continue
                }
                const n = this[t];
                void 0 !== n ? n && n.isColor ? n.set(i) : n && n.isVector3 && i && i.isVector3 ? n.copy(i) : this[t] = i : console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material.")
              }
          }
          toJSON(e) {
            const t = void 0 === e || "string" == typeof e;
            t && (e = {
              textures: {},
              images: {}
            });
            const i = {
              metadata: {
                version: 4.5,
                type: "Material",
                generator: "Material.toJSON"
              }
            };
            function n(e) {
              const t = [];
              for (const i in e) {
                const n = e[i];
                delete n.metadata,
                  t.push(n)
              }
              return t
            }
            if (i.uuid = this.uuid,
              i.type = this.type,
            "" !== this.name && (i.name = this.name),
            this.color && this.color.isColor && (i.color = this.color.getHex()),
            void 0 !== this.roughness && (i.roughness = this.roughness),
            void 0 !== this.metalness && (i.metalness = this.metalness),
            void 0 !== this.sheen && (i.sheen = this.sheen),
            this.sheenColor && this.sheenColor.isColor && (i.sheenColor = this.sheenColor.getHex()),
            void 0 !== this.sheenRoughness && (i.sheenRoughness = this.sheenRoughness),
            this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()),
            this.emissiveIntensity && 1 !== this.emissiveIntensity && (i.emissiveIntensity = this.emissiveIntensity),
            this.specular && this.specular.isColor && (i.specular = this.specular.getHex()),
            void 0 !== this.specularIntensity && (i.specularIntensity = this.specularIntensity),
            this.specularColor && this.specularColor.isColor && (i.specularColor = this.specularColor.getHex()),
            void 0 !== this.shininess && (i.shininess = this.shininess),
            void 0 !== this.clearcoat && (i.clearcoat = this.clearcoat),
            void 0 !== this.clearcoatRoughness && (i.clearcoatRoughness = this.clearcoatRoughness),
            this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
            this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
            this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid,
              i.clearcoatNormalScale = this.clearcoatNormalScale.toArray()),
            void 0 !== this.iridescence && (i.iridescence = this.iridescence),
            void 0 !== this.iridescenceIOR && (i.iridescenceIOR = this.iridescenceIOR),
            void 0 !== this.iridescenceThicknessRange && (i.iridescenceThicknessRange = this.iridescenceThicknessRange),
            this.iridescenceMap && this.iridescenceMap.isTexture && (i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
            this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (i.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid),
            this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid),
            this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(e).uuid),
            this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(e).uuid),
            this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(e).uuid,
              i.lightMapIntensity = this.lightMapIntensity),
            this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(e).uuid,
              i.aoMapIntensity = this.aoMapIntensity),
            this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(e).uuid,
              i.bumpScale = this.bumpScale),
            this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(e).uuid,
              i.normalMapType = this.normalMapType,
              i.normalScale = this.normalScale.toArray()),
            this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(e).uuid,
              i.displacementScale = this.displacementScale,
              i.displacementBias = this.displacementBias),
            this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(e).uuid),
            this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(e).uuid),
            this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(e).uuid),
            this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(e).uuid),
            this.specularIntensityMap && this.specularIntensityMap.isTexture && (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
            this.specularColorMap && this.specularColorMap.isTexture && (i.specularColorMap = this.specularColorMap.toJSON(e).uuid),
            this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(e).uuid,
            void 0 !== this.combine && (i.combine = this.combine)),
            void 0 !== this.envMapIntensity && (i.envMapIntensity = this.envMapIntensity),
            void 0 !== this.reflectivity && (i.reflectivity = this.reflectivity),
            void 0 !== this.refractionRatio && (i.refractionRatio = this.refractionRatio),
            this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(e).uuid),
            void 0 !== this.transmission && (i.transmission = this.transmission),
            this.transmissionMap && this.transmissionMap.isTexture && (i.transmissionMap = this.transmissionMap.toJSON(e).uuid),
            void 0 !== this.thickness && (i.thickness = this.thickness),
            this.thicknessMap && this.thicknessMap.isTexture && (i.thicknessMap = this.thicknessMap.toJSON(e).uuid),
            void 0 !== this.attenuationDistance && (i.attenuationDistance = this.attenuationDistance),
            void 0 !== this.attenuationColor && (i.attenuationColor = this.attenuationColor.getHex()),
            void 0 !== this.size && (i.size = this.size),
            null !== this.shadowSide && (i.shadowSide = this.shadowSide),
            void 0 !== this.sizeAttenuation && (i.sizeAttenuation = this.sizeAttenuation),
            1 !== this.blending && (i.blending = this.blending),
            0 !== this.side && (i.side = this.side),
            this.vertexColors && (i.vertexColors = !0),
            this.opacity < 1 && (i.opacity = this.opacity),
            !0 === this.transparent && (i.transparent = this.transparent),
              i.depthFunc = this.depthFunc,
              i.depthTest = this.depthTest,
              i.depthWrite = this.depthWrite,
              i.colorWrite = this.colorWrite,
              i.stencilWrite = this.stencilWrite,
              i.stencilWriteMask = this.stencilWriteMask,
              i.stencilFunc = this.stencilFunc,
              i.stencilRef = this.stencilRef,
              i.stencilFuncMask = this.stencilFuncMask,
              i.stencilFail = this.stencilFail,
              i.stencilZFail = this.stencilZFail,
              i.stencilZPass = this.stencilZPass,
            void 0 !== this.rotation && 0 !== this.rotation && (i.rotation = this.rotation),
            !0 === this.polygonOffset && (i.polygonOffset = !0),
            0 !== this.polygonOffsetFactor && (i.polygonOffsetFactor = this.polygonOffsetFactor),
            0 !== this.polygonOffsetUnits && (i.polygonOffsetUnits = this.polygonOffsetUnits),
            void 0 !== this.linewidth && 1 !== this.linewidth && (i.linewidth = this.linewidth),
            void 0 !== this.dashSize && (i.dashSize = this.dashSize),
            void 0 !== this.gapSize && (i.gapSize = this.gapSize),
            void 0 !== this.scale && (i.scale = this.scale),
            !0 === this.dithering && (i.dithering = !0),
            this.alphaTest > 0 && (i.alphaTest = this.alphaTest),
            !0 === this.alphaToCoverage && (i.alphaToCoverage = this.alphaToCoverage),
            !0 === this.premultipliedAlpha && (i.premultipliedAlpha = this.premultipliedAlpha),
            !0 === this.wireframe && (i.wireframe = this.wireframe),
            this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth),
            "round" !== this.wireframeLinecap && (i.wireframeLinecap = this.wireframeLinecap),
            "round" !== this.wireframeLinejoin && (i.wireframeLinejoin = this.wireframeLinejoin),
            !0 === this.flatShading && (i.flatShading = this.flatShading),
            !1 === this.visible && (i.visible = !1),
            !1 === this.toneMapped && (i.toneMapped = !1),
            !1 === this.fog && (i.fog = !1),
            "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData),
              t) {
              const t = n(e.textures)
                , r = n(e.images);
              t.length > 0 && (i.textures = t),
              r.length > 0 && (i.images = r)
            }
            return i
          }
          clone() {
            return (new this.constructor).copy(this)
          }
          copy(e) {
            this.name = e.name,
              this.blending = e.blending,
              this.side = e.side,
              this.vertexColors = e.vertexColors,
              this.opacity = e.opacity,
              this.transparent = e.transparent,
              this.blendSrc = e.blendSrc,
              this.blendDst = e.blendDst,
              this.blendEquation = e.blendEquation,
              this.blendSrcAlpha = e.blendSrcAlpha,
              this.blendDstAlpha = e.blendDstAlpha,
              this.blendEquationAlpha = e.blendEquationAlpha,
              this.depthFunc = e.depthFunc,
              this.depthTest = e.depthTest,
              this.depthWrite = e.depthWrite,
              this.stencilWriteMask = e.stencilWriteMask,
              this.stencilFunc = e.stencilFunc,
              this.stencilRef = e.stencilRef,
              this.stencilFuncMask = e.stencilFuncMask,
              this.stencilFail = e.stencilFail,
              this.stencilZFail = e.stencilZFail,
              this.stencilZPass = e.stencilZPass,
              this.stencilWrite = e.stencilWrite;
            const t = e.clippingPlanes;
            let i = null;
            if (null !== t) {
              const e = t.length;
              i = new Array(e);
              for (let n = 0; n !== e; ++n)
                i[n] = t[n].clone()
            }
            return this.clippingPlanes = i,
              this.clipIntersection = e.clipIntersection,
              this.clipShadows = e.clipShadows,
              this.shadowSide = e.shadowSide,
              this.colorWrite = e.colorWrite,
              this.precision = e.precision,
              this.polygonOffset = e.polygonOffset,
              this.polygonOffsetFactor = e.polygonOffsetFactor,
              this.polygonOffsetUnits = e.polygonOffsetUnits,
              this.dithering = e.dithering,
              this.alphaTest = e.alphaTest,
              this.alphaToCoverage = e.alphaToCoverage,
              this.premultipliedAlpha = e.premultipliedAlpha,
              this.visible = e.visible,
              this.toneMapped = e.toneMapped,
              this.userData = JSON.parse(JSON.stringify(e.userData)),
              this
          }
          dispose() {
            this.dispatchEvent({
              type: "dispose"
            })
          }
          set needsUpdate(e) {
            !0 === e && this.version++
          }
          get vertexTangents() {
            return console.warn("THREE." + this.type + ": .vertexTangents has been removed."),
              !1
          }
          set vertexTangents(e) {
            console.warn("THREE." + this.type + ": .vertexTangents has been removed.")
          }
        }
        ga.fromType = function() {
          return null
        }
        ;
        class va extends ga {
          constructor(e) {
            super(),
              this.isMeshBasicMaterial = !0,
              this.type = "MeshBasicMaterial",
              this.color = new Wr(16777215),
              this.map = null,
              this.lightMap = null,
              this.lightMapIntensity = 1,
              this.aoMap = null,
              this.aoMapIntensity = 1,
              this.specularMap = null,
              this.alphaMap = null,
              this.envMap = null,
              this.combine = 0,
              this.reflectivity = 1,
              this.refractionRatio = .98,
              this.wireframe = !1,
              this.wireframeLinewidth = 1,
              this.wireframeLinecap = "round",
              this.wireframeLinejoin = "round",
              this.fog = !0,
              this.setValues(e)
          }
          copy(e) {
            return super.copy(e),
              this.color.copy(e.color),
              this.map = e.map,
              this.lightMap = e.lightMap,
              this.lightMapIntensity = e.lightMapIntensity,
              this.aoMap = e.aoMap,
              this.aoMapIntensity = e.aoMapIntensity,
              this.specularMap = e.specularMap,
              this.alphaMap = e.alphaMap,
              this.envMap = e.envMap,
              this.combine = e.combine,
              this.reflectivity = e.reflectivity,
              this.refractionRatio = e.refractionRatio,
              this.wireframe = e.wireframe,
              this.wireframeLinewidth = e.wireframeLinewidth,
              this.wireframeLinecap = e.wireframeLinecap,
              this.wireframeLinejoin = e.wireframeLinejoin,
              this.fog = e.fog,
              this
          }
        }
        const ya = new ts
          , xa = new Dr;
        class _a {
          constructor(e, t, i) {
            if (Array.isArray(e))
              throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            this.isBufferAttribute = !0,
              this.name = "",
              this.array = e,
              this.itemSize = t,
              this.count = void 0 !== e ? e.length / t : 0,
              this.normalized = !0 === i,
              this.usage = fr,
              this.updateRange = {
                offset: 0,
                count: -1
              },
              this.version = 0
          }
          onUploadCallback() {}
          set needsUpdate(e) {
            !0 === e && this.version++
          }
          setUsage(e) {
            return this.usage = e,
              this
          }
          copy(e) {
            return this.name = e.name,
              this.array = new e.array.constructor(e.array),
              this.itemSize = e.itemSize,
              this.count = e.count,
              this.normalized = e.normalized,
              this.usage = e.usage,
              this
          }
          copyAt(e, t, i) {
            e *= this.itemSize,
              i *= t.itemSize;
            for (let n = 0, r = this.itemSize; n < r; n++)
              this.array[e + n] = t.array[i + n];
            return this
          }
          copyArray(e) {
            return this.array.set(e),
              this
          }
          copyColorsArray(e) {
            const t = this.array;
            let i = 0;
            for (let n = 0, r = e.length; n < r; n++) {
              let r = e[n];
              void 0 === r && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", n),
                r = new Wr),
                t[i++] = r.r,
                t[i++] = r.g,
                t[i++] = r.b
            }
            return this
          }
          copyVector2sArray(e) {
            const t = this.array;
            let i = 0;
            for (let n = 0, r = e.length; n < r; n++) {
              let r = e[n];
              void 0 === r && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", n),
                r = new Dr),
                t[i++] = r.x,
                t[i++] = r.y
            }
            return this
          }
          copyVector3sArray(e) {
            const t = this.array;
            let i = 0;
            for (let n = 0, r = e.length; n < r; n++) {
              let r = e[n];
              void 0 === r && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", n),
                r = new ts),
                t[i++] = r.x,
                t[i++] = r.y,
                t[i++] = r.z
            }
            return this
          }
          copyVector4sArray(e) {
            const t = this.array;
            let i = 0;
            for (let n = 0, r = e.length; n < r; n++) {
              let r = e[n];
              void 0 === r && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", n),
                r = new Jr),
                t[i++] = r.x,
                t[i++] = r.y,
                t[i++] = r.z,
                t[i++] = r.w
            }
            return this
          }
          applyMatrix3(e) {
            if (2 === this.itemSize)
              for (let t = 0, i = this.count; t < i; t++)
                xa.fromBufferAttribute(this, t),
                  xa.applyMatrix3(e),
                  this.setXY(t, xa.x, xa.y);
            else if (3 === this.itemSize)
              for (let t = 0, i = this.count; t < i; t++)
                ya.fromBufferAttribute(this, t),
                  ya.applyMatrix3(e),
                  this.setXYZ(t, ya.x, ya.y, ya.z);
            return this
          }
          applyMatrix4(e) {
            for (let t = 0, i = this.count; t < i; t++)
              ya.fromBufferAttribute(this, t),
                ya.applyMatrix4(e),
                this.setXYZ(t, ya.x, ya.y, ya.z);
            return this
          }
          applyNormalMatrix(e) {
            for (let t = 0, i = this.count; t < i; t++)
              ya.fromBufferAttribute(this, t),
                ya.applyNormalMatrix(e),
                this.setXYZ(t, ya.x, ya.y, ya.z);
            return this
          }
          transformDirection(e) {
            for (let t = 0, i = this.count; t < i; t++)
              ya.fromBufferAttribute(this, t),
                ya.transformDirection(e),
                this.setXYZ(t, ya.x, ya.y, ya.z);
            return this
          }
          set(e, t=0) {
            return this.array.set(e, t),
              this
          }
          getX(e) {
            return this.array[e * this.itemSize]
          }
          setX(e, t) {
            return this.array[e * this.itemSize] = t,
              this
          }
          getY(e) {
            return this.array[e * this.itemSize + 1]
          }
          setY(e, t) {
            return this.array[e * this.itemSize + 1] = t,
              this
          }
          getZ(e) {
            return this.array[e * this.itemSize + 2]
          }
          setZ(e, t) {
            return this.array[e * this.itemSize + 2] = t,
              this
          }
          getW(e) {
            return this.array[e * this.itemSize + 3]
          }
          setW(e, t) {
            return this.array[e * this.itemSize + 3] = t,
              this
          }
          setXY(e, t, i) {
            return e *= this.itemSize,
              this.array[e + 0] = t,
              this.array[e + 1] = i,
              this
          }
          setXYZ(e, t, i, n) {
            return e *= this.itemSize,
              this.array[e + 0] = t,
              this.array[e + 1] = i,
              this.array[e + 2] = n,
              this
          }
          setXYZW(e, t, i, n, r) {
            return e *= this.itemSize,
              this.array[e + 0] = t,
              this.array[e + 1] = i,
              this.array[e + 2] = n,
              this.array[e + 3] = r,
              this
          }
          onUpload(e) {
            return this.onUploadCallback = e,
              this
          }
          clone() {
            return new this.constructor(this.array,this.itemSize).copy(this)
          }
          toJSON() {
            const e = {
              itemSize: this.itemSize,
              type: this.array.constructor.name,
              array: Array.prototype.slice.call(this.array),
              normalized: this.normalized
            };
            return "" !== this.name && (e.name = this.name),
            this.usage !== fr && (e.usage = this.usage),
            0 === this.updateRange.offset && -1 === this.updateRange.count || (e.updateRange = this.updateRange),
              e
          }
        }
        class ba extends _a {
          constructor(e, t, i) {
            super(new Uint16Array(e), t, i)
          }
        }
        class wa extends _a {
          constructor(e, t, i) {
            super(new Uint32Array(e), t, i)
          }
        }
        class Aa extends _a {
          constructor(e, t, i) {
            super(new Float32Array(e), t, i)
          }
        }
        let Sa = 0;
        const Ma = new Rs
          , Ta = new na
          , Ea = new ts
          , Ca = new rs
          , Pa = new rs
          , Da = new ts;
        class Ia extends vr {
          constructor() {
            super(),
              this.isBufferGeometry = !0,
              Object.defineProperty(this, "id", {
                value: Sa++
              }),
              this.uuid = wr(),
              this.name = "",
              this.type = "BufferGeometry",
              this.index = null,
              this.attributes = {},
              this.morphAttributes = {},
              this.morphTargetsRelative = !1,
              this.groups = [],
              this.boundingBox = null,
              this.boundingSphere = null,
              this.drawRange = {
                start: 0,
                count: 1 / 0
              },
              this.userData = {}
          }
          getIndex() {
            return this.index
          }
          setIndex(e) {
            return Array.isArray(e) ? this.index = new (Rr(e) ? wa : ba)(e,1) : this.index = e,
              this
          }
          getAttribute(e) {
            return this.attributes[e]
          }
          setAttribute(e, t) {
            return this.attributes[e] = t,
              this
          }
          deleteAttribute(e) {
            return delete this.attributes[e],
              this
          }
          hasAttribute(e) {
            return void 0 !== this.attributes[e]
          }
          addGroup(e, t, i=0) {
            this.groups.push({
              start: e,
              count: t,
              materialIndex: i
            })
          }
          clearGroups() {
            this.groups = []
          }
          setDrawRange(e, t) {
            this.drawRange.start = e,
              this.drawRange.count = t
          }
          applyMatrix4(e) {
            const t = this.attributes.position;
            void 0 !== t && (t.applyMatrix4(e),
              t.needsUpdate = !0);
            const i = this.attributes.normal;
            if (void 0 !== i) {
              const t = (new Ir).getNormalMatrix(e);
              i.applyNormalMatrix(t),
                i.needsUpdate = !0
            }
            const n = this.attributes.tangent;
            return void 0 !== n && (n.transformDirection(e),
              n.needsUpdate = !0),
            null !== this.boundingBox && this.computeBoundingBox(),
            null !== this.boundingSphere && this.computeBoundingSphere(),
              this
          }
          applyQuaternion(e) {
            return Ma.makeRotationFromQuaternion(e),
              this.applyMatrix4(Ma),
              this
          }
          rotateX(e) {
            return Ma.makeRotationX(e),
              this.applyMatrix4(Ma),
              this
          }
          rotateY(e) {
            return Ma.makeRotationY(e),
              this.applyMatrix4(Ma),
              this
          }
          rotateZ(e) {
            return Ma.makeRotationZ(e),
              this.applyMatrix4(Ma),
              this
          }
          translate(e, t, i) {
            return Ma.makeTranslation(e, t, i),
              this.applyMatrix4(Ma),
              this
          }
          scale(e, t, i) {
            return Ma.makeScale(e, t, i),
              this.applyMatrix4(Ma),
              this
          }
          lookAt(e) {
            return Ta.lookAt(e),
              Ta.updateMatrix(),
              this.applyMatrix4(Ta.matrix),
              this
          }
          center() {
            return this.computeBoundingBox(),
              this.boundingBox.getCenter(Ea).negate(),
              this.translate(Ea.x, Ea.y, Ea.z),
              this
          }
          setFromPoints(e) {
            const t = [];
            for (let i = 0, n = e.length; i < n; i++) {
              const n = e[i];
              t.push(n.x, n.y, n.z || 0)
            }
            return this.setAttribute("position", new Aa(t,3)),
              this
          }
          computeBoundingBox() {
            null === this.boundingBox && (this.boundingBox = new rs);
            const e = this.attributes.position
              , t = this.morphAttributes.position;
            if (e && e.isGLBufferAttribute)
              return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this),
                void this.boundingBox.set(new ts(-1 / 0,-1 / 0,-1 / 0), new ts(1 / 0,1 / 0,1 / 0));
            if (void 0 !== e) {
              if (this.boundingBox.setFromBufferAttribute(e),
                t)
                for (let e = 0, i = t.length; e < i; e++) {
                  const i = t[e];
                  Ca.setFromBufferAttribute(i),
                    this.morphTargetsRelative ? (Da.addVectors(this.boundingBox.min, Ca.min),
                      this.boundingBox.expandByPoint(Da),
                      Da.addVectors(this.boundingBox.max, Ca.max),
                      this.boundingBox.expandByPoint(Da)) : (this.boundingBox.expandByPoint(Ca.min),
                      this.boundingBox.expandByPoint(Ca.max))
                }
            } else
              this.boundingBox.makeEmpty();
            (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
          }
          computeBoundingSphere() {
            null === this.boundingSphere && (this.boundingSphere = new As);
            const e = this.attributes.position
              , t = this.morphAttributes.position;
            if (e && e.isGLBufferAttribute)
              return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this),
                void this.boundingSphere.set(new ts, 1 / 0);
            if (e) {
              const i = this.boundingSphere.center;
              if (Ca.setFromBufferAttribute(e),
                t)
                for (let e = 0, i = t.length; e < i; e++) {
                  const i = t[e];
                  Pa.setFromBufferAttribute(i),
                    this.morphTargetsRelative ? (Da.addVectors(Ca.min, Pa.min),
                      Ca.expandByPoint(Da),
                      Da.addVectors(Ca.max, Pa.max),
                      Ca.expandByPoint(Da)) : (Ca.expandByPoint(Pa.min),
                      Ca.expandByPoint(Pa.max))
                }
              Ca.getCenter(i);
              let n = 0;
              for (let t = 0, r = e.count; t < r; t++)
                Da.fromBufferAttribute(e, t),
                  n = Math.max(n, i.distanceToSquared(Da));
              if (t)
                for (let r = 0, s = t.length; r < s; r++) {
                  const s = t[r]
                    , a = this.morphTargetsRelative;
                  for (let t = 0, r = s.count; t < r; t++)
                    Da.fromBufferAttribute(s, t),
                    a && (Ea.fromBufferAttribute(e, t),
                      Da.add(Ea)),
                      n = Math.max(n, i.distanceToSquared(Da))
                }
              this.boundingSphere.radius = Math.sqrt(n),
              isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
            }
          }
          computeTangents() {
            const e = this.index
              , t = this.attributes;
            if (null === e || void 0 === t.position || void 0 === t.normal || void 0 === t.uv)
              return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
            const i = e.array
              , n = t.position.array
              , r = t.normal.array
              , s = t.uv.array
              , a = n.length / 3;
            !1 === this.hasAttribute("tangent") && this.setAttribute("tangent", new _a(new Float32Array(4 * a),4));
            const o = this.getAttribute("tangent").array
              , l = []
              , h = [];
            for (let e = 0; e < a; e++)
              l[e] = new ts,
                h[e] = new ts;
            const c = new ts
              , u = new ts
              , d = new ts
              , p = new Dr
              , f = new Dr
              , m = new Dr
              , g = new ts
              , v = new ts;
            function y(e, t, i) {
              c.fromArray(n, 3 * e),
                u.fromArray(n, 3 * t),
                d.fromArray(n, 3 * i),
                p.fromArray(s, 2 * e),
                f.fromArray(s, 2 * t),
                m.fromArray(s, 2 * i),
                u.sub(c),
                d.sub(c),
                f.sub(p),
                m.sub(p);
              const r = 1 / (f.x * m.y - m.x * f.y);
              isFinite(r) && (g.copy(u).multiplyScalar(m.y).addScaledVector(d, -f.y).multiplyScalar(r),
                v.copy(d).multiplyScalar(f.x).addScaledVector(u, -m.x).multiplyScalar(r),
                l[e].add(g),
                l[t].add(g),
                l[i].add(g),
                h[e].add(v),
                h[t].add(v),
                h[i].add(v))
            }
            let x = this.groups;
            0 === x.length && (x = [{
              start: 0,
              count: i.length
            }]);
            for (let e = 0, t = x.length; e < t; ++e) {
              const t = x[e]
                , n = t.start;
              for (let e = n, r = n + t.count; e < r; e += 3)
                y(i[e + 0], i[e + 1], i[e + 2])
            }
            const _ = new ts
              , b = new ts
              , w = new ts
              , A = new ts;
            function S(e) {
              w.fromArray(r, 3 * e),
                A.copy(w);
              const t = l[e];
              _.copy(t),
                _.sub(w.multiplyScalar(w.dot(t))).normalize(),
                b.crossVectors(A, t);
              const i = b.dot(h[e]) < 0 ? -1 : 1;
              o[4 * e] = _.x,
                o[4 * e + 1] = _.y,
                o[4 * e + 2] = _.z,
                o[4 * e + 3] = i
            }
            for (let e = 0, t = x.length; e < t; ++e) {
              const t = x[e]
                , n = t.start;
              for (let e = n, r = n + t.count; e < r; e += 3)
                S(i[e + 0]),
                  S(i[e + 1]),
                  S(i[e + 2])
            }
          }
          computeVertexNormals() {
            const e = this.index
              , t = this.getAttribute("position");
            if (void 0 !== t) {
              let i = this.getAttribute("normal");
              if (void 0 === i)
                i = new _a(new Float32Array(3 * t.count),3),
                  this.setAttribute("normal", i);
              else
                for (let e = 0, t = i.count; e < t; e++)
                  i.setXYZ(e, 0, 0, 0);
              const n = new ts
                , r = new ts
                , s = new ts
                , a = new ts
                , o = new ts
                , l = new ts
                , h = new ts
                , c = new ts;
              if (e)
                for (let u = 0, d = e.count; u < d; u += 3) {
                  const d = e.getX(u + 0)
                    , p = e.getX(u + 1)
                    , f = e.getX(u + 2);
                  n.fromBufferAttribute(t, d),
                    r.fromBufferAttribute(t, p),
                    s.fromBufferAttribute(t, f),
                    h.subVectors(s, r),
                    c.subVectors(n, r),
                    h.cross(c),
                    a.fromBufferAttribute(i, d),
                    o.fromBufferAttribute(i, p),
                    l.fromBufferAttribute(i, f),
                    a.add(h),
                    o.add(h),
                    l.add(h),
                    i.setXYZ(d, a.x, a.y, a.z),
                    i.setXYZ(p, o.x, o.y, o.z),
                    i.setXYZ(f, l.x, l.y, l.z)
                }
              else
                for (let e = 0, a = t.count; e < a; e += 3)
                  n.fromBufferAttribute(t, e + 0),
                    r.fromBufferAttribute(t, e + 1),
                    s.fromBufferAttribute(t, e + 2),
                    h.subVectors(s, r),
                    c.subVectors(n, r),
                    h.cross(c),
                    i.setXYZ(e + 0, h.x, h.y, h.z),
                    i.setXYZ(e + 1, h.x, h.y, h.z),
                    i.setXYZ(e + 2, h.x, h.y, h.z);
              this.normalizeNormals(),
                i.needsUpdate = !0
            }
          }
          merge(e, t) {
            if (!e || !e.isBufferGeometry)
              return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", e);
            void 0 === t && (t = 0,
              console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
            const i = this.attributes;
            for (const n in i) {
              if (void 0 === e.attributes[n])
                continue;
              const r = i[n].array
                , s = e.attributes[n]
                , a = s.array
                , o = s.itemSize * t
                , l = Math.min(a.length, r.length - o);
              for (let e = 0, t = o; e < l; e++,
                t++)
                r[t] = a[e]
            }
            return this
          }
          normalizeNormals() {
            const e = this.attributes.normal;
            for (let t = 0, i = e.count; t < i; t++)
              Da.fromBufferAttribute(e, t),
                Da.normalize(),
                e.setXYZ(t, Da.x, Da.y, Da.z)
          }
          toNonIndexed() {
            function e(e, t) {
              const i = e.array
                , n = e.itemSize
                , r = e.normalized
                , s = new i.constructor(t.length * n);
              let a = 0
                , o = 0;
              for (let r = 0, l = t.length; r < l; r++) {
                a = e.isInterleavedBufferAttribute ? t[r] * e.data.stride + e.offset : t[r] * n;
                for (let e = 0; e < n; e++)
                  s[o++] = i[a++]
              }
              return new _a(s,n,r)
            }
            if (null === this.index)
              return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),
                this;
            const t = new Ia
              , i = this.index.array
              , n = this.attributes;
            for (const r in n) {
              const s = e(n[r], i);
              t.setAttribute(r, s)
            }
            const r = this.morphAttributes;
            for (const n in r) {
              const s = []
                , a = r[n];
              for (let t = 0, n = a.length; t < n; t++) {
                const n = e(a[t], i);
                s.push(n)
              }
              t.morphAttributes[n] = s
            }
            t.morphTargetsRelative = this.morphTargetsRelative;
            const s = this.groups;
            for (let e = 0, i = s.length; e < i; e++) {
              const i = s[e];
              t.addGroup(i.start, i.count, i.materialIndex)
            }
            return t
          }
          toJSON() {
            const e = {
              metadata: {
                version: 4.5,
                type: "BufferGeometry",
                generator: "BufferGeometry.toJSON"
              }
            };
            if (e.uuid = this.uuid,
              e.type = this.type,
            "" !== this.name && (e.name = this.name),
            Object.keys(this.userData).length > 0 && (e.userData = this.userData),
            void 0 !== this.parameters) {
              const t = this.parameters;
              for (const i in t)
                void 0 !== t[i] && (e[i] = t[i]);
              return e
            }
            e.data = {
              attributes: {}
            };
            const t = this.index;
            null !== t && (e.data.index = {
              type: t.array.constructor.name,
              array: Array.prototype.slice.call(t.array)
            });
            const i = this.attributes;
            for (const t in i) {
              const n = i[t];
              e.data.attributes[t] = n.toJSON(e.data)
            }
            const n = {};
            let r = !1;
            for (const t in this.morphAttributes) {
              const i = this.morphAttributes[t]
                , s = [];
              for (let t = 0, n = i.length; t < n; t++) {
                const n = i[t];
                s.push(n.toJSON(e.data))
              }
              s.length > 0 && (n[t] = s,
                r = !0)
            }
            r && (e.data.morphAttributes = n,
              e.data.morphTargetsRelative = this.morphTargetsRelative);
            const s = this.groups;
            s.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(s)));
            const a = this.boundingSphere;
            return null !== a && (e.data.boundingSphere = {
              center: a.center.toArray(),
              radius: a.radius
            }),
              e
          }
          clone() {
            return (new this.constructor).copy(this)
          }
          copy(e) {
            this.index = null,
              this.attributes = {},
              this.morphAttributes = {},
              this.groups = [],
              this.boundingBox = null,
              this.boundingSphere = null;
            const t = {};
            this.name = e.name;
            const i = e.index;
            null !== i && this.setIndex(i.clone(t));
            const n = e.attributes;
            for (const e in n) {
              const i = n[e];
              this.setAttribute(e, i.clone(t))
            }
            const r = e.morphAttributes;
            for (const e in r) {
              const i = []
                , n = r[e];
              for (let e = 0, r = n.length; e < r; e++)
                i.push(n[e].clone(t));
              this.morphAttributes[e] = i
            }
            this.morphTargetsRelative = e.morphTargetsRelative;
            const s = e.groups;
            for (let e = 0, t = s.length; e < t; e++) {
              const t = s[e];
              this.addGroup(t.start, t.count, t.materialIndex)
            }
            const a = e.boundingBox;
            null !== a && (this.boundingBox = a.clone());
            const o = e.boundingSphere;
            return null !== o && (this.boundingSphere = o.clone()),
              this.drawRange.start = e.drawRange.start,
              this.drawRange.count = e.drawRange.count,
              this.userData = e.userData,
            void 0 !== e.parameters && (this.parameters = Object.assign({}, e.parameters)),
              this
          }
          dispose() {
            this.dispatchEvent({
              type: "dispose"
            })
          }
        }
        const Ra = new Rs
          , La = new Is
          , ka = new As
          , Fa = new ts
          , Ba = new ts
          , Oa = new ts
          , Na = new ts
          , za = new ts
          , Ua = new ts
          , Ga = new ts
          , Va = new ts
          , Ha = new ts
          , Wa = new Dr
          , ja = new Dr
          , Xa = new Dr
          , Ya = new ts
          , qa = new ts;
        class Qa extends na {
          constructor(e=new Ia, t=new va) {
            super(),
              this.isMesh = !0,
              this.type = "Mesh",
              this.geometry = e,
              this.material = t,
              this.updateMorphTargets()
          }
          copy(e, t) {
            return super.copy(e, t),
            void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
            void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)),
              this.material = e.material,
              this.geometry = e.geometry,
              this
          }
          updateMorphTargets() {
            const e = this.geometry.morphAttributes
              , t = Object.keys(e);
            if (t.length > 0) {
              const i = e[t[0]];
              if (void 0 !== i) {
                this.morphTargetInfluences = [],
                  this.morphTargetDictionary = {};
                for (let e = 0, t = i.length; e < t; e++) {
                  const t = i[e].name || String(e);
                  this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[t] = e
                }
              }
            }
          }
          raycast(e, t) {
            const i = this.geometry
              , n = this.material
              , r = this.matrixWorld;
            if (void 0 === n)
              return;
            if (null === i.boundingSphere && i.computeBoundingSphere(),
              ka.copy(i.boundingSphere),
              ka.applyMatrix4(r),
            !1 === e.ray.intersectsSphere(ka))
              return;
            if (Ra.copy(r).invert(),
              La.copy(e.ray).applyMatrix4(Ra),
            null !== i.boundingBox && !1 === La.intersectsBox(i.boundingBox))
              return;
            let s;
            const a = i.index
              , o = i.attributes.position
              , l = i.morphAttributes.position
              , h = i.morphTargetsRelative
              , c = i.attributes.uv
              , u = i.attributes.uv2
              , d = i.groups
              , p = i.drawRange;
            if (null !== a)
              if (Array.isArray(n))
                for (let i = 0, r = d.length; i < r; i++) {
                  const r = d[i]
                    , f = n[r.materialIndex];
                  for (let i = Math.max(r.start, p.start), n = Math.min(a.count, Math.min(r.start + r.count, p.start + p.count)); i < n; i += 3) {
                    const n = a.getX(i)
                      , d = a.getX(i + 1)
                      , p = a.getX(i + 2);
                    s = Ka(this, f, e, La, o, l, h, c, u, n, d, p),
                    s && (s.faceIndex = Math.floor(i / 3),
                      s.face.materialIndex = r.materialIndex,
                      t.push(s))
                  }
                }
              else
                for (let i = Math.max(0, p.start), r = Math.min(a.count, p.start + p.count); i < r; i += 3) {
                  const r = a.getX(i)
                    , d = a.getX(i + 1)
                    , p = a.getX(i + 2);
                  s = Ka(this, n, e, La, o, l, h, c, u, r, d, p),
                  s && (s.faceIndex = Math.floor(i / 3),
                    t.push(s))
                }
            else if (void 0 !== o)
              if (Array.isArray(n))
                for (let i = 0, r = d.length; i < r; i++) {
                  const r = d[i]
                    , a = n[r.materialIndex];
                  for (let i = Math.max(r.start, p.start), n = Math.min(o.count, Math.min(r.start + r.count, p.start + p.count)); i < n; i += 3)
                    s = Ka(this, a, e, La, o, l, h, c, u, i, i + 1, i + 2),
                    s && (s.faceIndex = Math.floor(i / 3),
                      s.face.materialIndex = r.materialIndex,
                      t.push(s))
                }
              else
                for (let i = Math.max(0, p.start), r = Math.min(o.count, p.start + p.count); i < r; i += 3)
                  s = Ka(this, n, e, La, o, l, h, c, u, i, i + 1, i + 2),
                  s && (s.faceIndex = Math.floor(i / 3),
                    t.push(s))
          }
        }
        function Ka(e, t, i, n, r, s, a, o, l, h, c, u) {
          Fa.fromBufferAttribute(r, h),
            Ba.fromBufferAttribute(r, c),
            Oa.fromBufferAttribute(r, u);
          const d = e.morphTargetInfluences;
          if (s && d) {
            Ga.set(0, 0, 0),
              Va.set(0, 0, 0),
              Ha.set(0, 0, 0);
            for (let e = 0, t = s.length; e < t; e++) {
              const t = d[e]
                , i = s[e];
              0 !== t && (Na.fromBufferAttribute(i, h),
                za.fromBufferAttribute(i, c),
                Ua.fromBufferAttribute(i, u),
                a ? (Ga.addScaledVector(Na, t),
                  Va.addScaledVector(za, t),
                  Ha.addScaledVector(Ua, t)) : (Ga.addScaledVector(Na.sub(Fa), t),
                  Va.addScaledVector(za.sub(Ba), t),
                  Ha.addScaledVector(Ua.sub(Oa), t)))
            }
            Fa.add(Ga),
              Ba.add(Va),
              Oa.add(Ha)
          }
          e.isSkinnedMesh && (e.boneTransform(h, Fa),
            e.boneTransform(c, Ba),
            e.boneTransform(u, Oa));
          const p = function(e, t, i, n, r, s, a, o) {
            let l;
            if (l = 1 === t.side ? n.intersectTriangle(a, s, r, !0, o) : n.intersectTriangle(r, s, a, 2 !== t.side, o),
            null === l)
              return null;
            qa.copy(o),
              qa.applyMatrix4(e.matrixWorld);
            const h = i.ray.origin.distanceTo(qa);
            return h < i.near || h > i.far ? null : {
              distance: h,
              point: qa.clone(),
              object: e
            }
          }(e, t, i, n, Fa, Ba, Oa, Ya);
          if (p) {
            o && (Wa.fromBufferAttribute(o, h),
              ja.fromBufferAttribute(o, c),
              Xa.fromBufferAttribute(o, u),
              p.uv = fa.getUV(Ya, Fa, Ba, Oa, Wa, ja, Xa, new Dr)),
            l && (Wa.fromBufferAttribute(l, h),
              ja.fromBufferAttribute(l, c),
              Xa.fromBufferAttribute(l, u),
              p.uv2 = fa.getUV(Ya, Fa, Ba, Oa, Wa, ja, Xa, new Dr));
            const e = {
              a: h,
              b: c,
              c: u,
              normal: new ts,
              materialIndex: 0
            };
            fa.getNormal(Fa, Ba, Oa, e.normal),
              p.face = e
          }
          return p
        }
        class Ja extends Ia {
          constructor(e=1, t=1, i=1, n=1, r=1, s=1) {
            super(),
              this.type = "BoxGeometry",
              this.parameters = {
                width: e,
                height: t,
                depth: i,
                widthSegments: n,
                heightSegments: r,
                depthSegments: s
              };
            const a = this;
            n = Math.floor(n),
              r = Math.floor(r),
              s = Math.floor(s);
            const o = []
              , l = []
              , h = []
              , c = [];
            let u = 0
              , d = 0;
            function p(e, t, i, n, r, s, p, f, m, g, v) {
              const y = s / m
                , x = p / g
                , _ = s / 2
                , b = p / 2
                , w = f / 2
                , A = m + 1
                , S = g + 1;
              let M = 0
                , T = 0;
              const E = new ts;
              for (let s = 0; s < S; s++) {
                const a = s * x - b;
                for (let o = 0; o < A; o++) {
                  const u = o * y - _;
                  E[e] = u * n,
                    E[t] = a * r,
                    E[i] = w,
                    l.push(E.x, E.y, E.z),
                    E[e] = 0,
                    E[t] = 0,
                    E[i] = f > 0 ? 1 : -1,
                    h.push(E.x, E.y, E.z),
                    c.push(o / m),
                    c.push(1 - s / g),
                    M += 1
                }
              }
              for (let e = 0; e < g; e++)
                for (let t = 0; t < m; t++) {
                  const i = u + t + A * e
                    , n = u + t + A * (e + 1)
                    , r = u + (t + 1) + A * (e + 1)
                    , s = u + (t + 1) + A * e;
                  o.push(i, n, s),
                    o.push(n, r, s),
                    T += 6
                }
              a.addGroup(d, T, v),
                d += T,
                u += M
            }
            p("z", "y", "x", -1, -1, i, t, e, s, r, 0),
              p("z", "y", "x", 1, -1, i, t, -e, s, r, 1),
              p("x", "z", "y", 1, 1, e, i, t, n, s, 2),
              p("x", "z", "y", 1, -1, e, i, -t, n, s, 3),
              p("x", "y", "z", 1, -1, e, t, i, n, r, 4),
              p("x", "y", "z", -1, -1, e, t, -i, n, r, 5),
              this.setIndex(o),
              this.setAttribute("position", new Aa(l,3)),
              this.setAttribute("normal", new Aa(h,3)),
              this.setAttribute("uv", new Aa(c,2))
          }
          static fromJSON(e) {
            return new Ja(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)
          }
        }
        function Za(e) {
          const t = {};
          for (const i in e) {
            t[i] = {};
            for (const n in e[i]) {
              const r = e[i][n];
              r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? t[i][n] = r.clone() : Array.isArray(r) ? t[i][n] = r.slice() : t[i][n] = r
            }
          }
          return t
        }
        function $a(e) {
          const t = {};
          for (let i = 0; i < e.length; i++) {
            const n = Za(e[i]);
            for (const e in n)
              t[e] = n[e]
          }
          return t
        }
        const eo = {
          clone: Za,
          merge: $a
        };
        class to extends ga {
          constructor(e) {
            super(),
              this.isShaderMaterial = !0,
              this.type = "ShaderMaterial",
              this.defines = {},
              this.uniforms = {},
              this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
              this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",
              this.linewidth = 1,
              this.wireframe = !1,
              this.wireframeLinewidth = 1,
              this.fog = !1,
              this.lights = !1,
              this.clipping = !1,
              this.extensions = {
                derivatives: !1,
                fragDepth: !1,
                drawBuffers: !1,
                shaderTextureLOD: !1
              },
              this.defaultAttributeValues = {
                color: [1, 1, 1],
                uv: [0, 0],
                uv2: [0, 0]
              },
              this.index0AttributeName = void 0,
              this.uniformsNeedUpdate = !1,
              this.glslVersion = null,
            void 0 !== e && (void 0 !== e.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),
              this.setValues(e))
          }
          copy(e) {
            return super.copy(e),
              this.fragmentShader = e.fragmentShader,
              this.vertexShader = e.vertexShader,
              this.uniforms = Za(e.uniforms),
              this.defines = Object.assign({}, e.defines),
              this.wireframe = e.wireframe,
              this.wireframeLinewidth = e.wireframeLinewidth,
              this.fog = e.fog,
              this.lights = e.lights,
              this.clipping = e.clipping,
              this.extensions = Object.assign({}, e.extensions),
              this.glslVersion = e.glslVersion,
              this
          }
          toJSON(e) {
            const t = super.toJSON(e);
            t.glslVersion = this.glslVersion,
              t.uniforms = {};
            for (const i in this.uniforms) {
              const n = this.uniforms[i].value;
              n && n.isTexture ? t.uniforms[i] = {
                type: "t",
                value: n.toJSON(e).uuid
              } : n && n.isColor ? t.uniforms[i] = {
                type: "c",
                value: n.getHex()
              } : n && n.isVector2 ? t.uniforms[i] = {
                type: "v2",
                value: n.toArray()
              } : n && n.isVector3 ? t.uniforms[i] = {
                type: "v3",
                value: n.toArray()
              } : n && n.isVector4 ? t.uniforms[i] = {
                type: "v4",
                value: n.toArray()
              } : n && n.isMatrix3 ? t.uniforms[i] = {
                type: "m3",
                value: n.toArray()
              } : n && n.isMatrix4 ? t.uniforms[i] = {
                type: "m4",
                value: n.toArray()
              } : t.uniforms[i] = {
                value: n
              }
            }
            Object.keys(this.defines).length > 0 && (t.defines = this.defines),
              t.vertexShader = this.vertexShader,
              t.fragmentShader = this.fragmentShader;
            const i = {};
            for (const e in this.extensions)
              !0 === this.extensions[e] && (i[e] = !0);
            return Object.keys(i).length > 0 && (t.extensions = i),
              t
          }
        }
        class io extends na {
          constructor() {
            super(),
              this.isCamera = !0,
              this.type = "Camera",
              this.matrixWorldInverse = new Rs,
              this.projectionMatrix = new Rs,
              this.projectionMatrixInverse = new Rs
          }
          copy(e, t) {
            return super.copy(e, t),
              this.matrixWorldInverse.copy(e.matrixWorldInverse),
              this.projectionMatrix.copy(e.projectionMatrix),
              this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
              this
          }
          getWorldDirection(e) {
            this.updateWorldMatrix(!0, !1);
            const t = this.matrixWorld.elements;
            return e.set(-t[8], -t[9], -t[10]).normalize()
          }
          updateMatrixWorld(e) {
            super.updateMatrixWorld(e),
              this.matrixWorldInverse.copy(this.matrixWorld).invert()
          }
          updateWorldMatrix(e, t) {
            super.updateWorldMatrix(e, t),
              this.matrixWorldInverse.copy(this.matrixWorld).invert()
          }
          clone() {
            return (new this.constructor).copy(this)
          }
        }
        class no extends io {
          constructor(e=50, t=1, i=.1, n=2e3) {
            super(),
              this.isPerspectiveCamera = !0,
              this.type = "PerspectiveCamera",
              this.fov = e,
              this.zoom = 1,
              this.near = i,
              this.far = n,
              this.focus = 10,
              this.aspect = t,
              this.view = null,
              this.filmGauge = 35,
              this.filmOffset = 0,
              this.updateProjectionMatrix()
          }
          copy(e, t) {
            return super.copy(e, t),
              this.fov = e.fov,
              this.zoom = e.zoom,
              this.near = e.near,
              this.far = e.far,
              this.focus = e.focus,
              this.aspect = e.aspect,
              this.view = null === e.view ? null : Object.assign({}, e.view),
              this.filmGauge = e.filmGauge,
              this.filmOffset = e.filmOffset,
              this
          }
          setFocalLength(e) {
            const t = .5 * this.getFilmHeight() / e;
            this.fov = 2 * br * Math.atan(t),
              this.updateProjectionMatrix()
          }
          getFocalLength() {
            const e = Math.tan(.5 * _r * this.fov);
            return .5 * this.getFilmHeight() / e
          }
          getEffectiveFOV() {
            return 2 * br * Math.atan(Math.tan(.5 * _r * this.fov) / this.zoom)
          }
          getFilmWidth() {
            return this.filmGauge * Math.min(this.aspect, 1)
          }
          getFilmHeight() {
            return this.filmGauge / Math.max(this.aspect, 1)
          }
          setViewOffset(e, t, i, n, r, s) {
            this.aspect = e / t,
            null === this.view && (this.view = {
              enabled: !0,
              fullWidth: 1,
              fullHeight: 1,
              offsetX: 0,
              offsetY: 0,
              width: 1,
              height: 1
            }),
              this.view.enabled = !0,
              this.view.fullWidth = e,
              this.view.fullHeight = t,
              this.view.offsetX = i,
              this.view.offsetY = n,
              this.view.width = r,
              this.view.height = s,
              this.updateProjectionMatrix()
          }
          clearViewOffset() {
            null !== this.view && (this.view.enabled = !1),
              this.updateProjectionMatrix()
          }
          updateProjectionMatrix() {
            const e = this.near;
            let t = e * Math.tan(.5 * _r * this.fov) / this.zoom
              , i = 2 * t
              , n = this.aspect * i
              , r = -.5 * n;
            const s = this.view;
            if (null !== this.view && this.view.enabled) {
              const e = s.fullWidth
                , a = s.fullHeight;
              r += s.offsetX * n / e,
                t -= s.offsetY * i / a,
                n *= s.width / e,
                i *= s.height / a
            }
            const a = this.filmOffset;
            0 !== a && (r += e * a / this.getFilmWidth()),
              this.projectionMatrix.makePerspective(r, r + n, t, t - i, e, this.far),
              this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
          }
          toJSON(e) {
            const t = super.toJSON(e);
            return t.object.fov = this.fov,
              t.object.zoom = this.zoom,
              t.object.near = this.near,
              t.object.far = this.far,
              t.object.focus = this.focus,
              t.object.aspect = this.aspect,
            null !== this.view && (t.object.view = Object.assign({}, this.view)),
              t.object.filmGauge = this.filmGauge,
              t.object.filmOffset = this.filmOffset,
              t
          }
        }
        const ro = 90;
        class so extends na {
          constructor(e, t, i) {
            if (super(),
              this.type = "CubeCamera",
            !0 !== i.isWebGLCubeRenderTarget)
              return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
            this.renderTarget = i;
            const n = new no(ro,1,e,t);
            n.layers = this.layers,
              n.up.set(0, -1, 0),
              n.lookAt(new ts(1,0,0)),
              this.add(n);
            const r = new no(ro,1,e,t);
            r.layers = this.layers,
              r.up.set(0, -1, 0),
              r.lookAt(new ts(-1,0,0)),
              this.add(r);
            const s = new no(ro,1,e,t);
            s.layers = this.layers,
              s.up.set(0, 0, 1),
              s.lookAt(new ts(0,1,0)),
              this.add(s);
            const a = new no(ro,1,e,t);
            a.layers = this.layers,
              a.up.set(0, 0, -1),
              a.lookAt(new ts(0,-1,0)),
              this.add(a);
            const o = new no(ro,1,e,t);
            o.layers = this.layers,
              o.up.set(0, -1, 0),
              o.lookAt(new ts(0,0,1)),
              this.add(o);
            const l = new no(ro,1,e,t);
            l.layers = this.layers,
              l.up.set(0, -1, 0),
              l.lookAt(new ts(0,0,-1)),
              this.add(l)
          }
          update(e, t) {
            null === this.parent && this.updateMatrixWorld();
            const i = this.renderTarget
              , [n,r,s,a,o,l] = this.children
              , h = e.getRenderTarget()
              , c = e.toneMapping
              , u = e.xr.enabled;
            e.toneMapping = 0,
              e.xr.enabled = !1;
            const d = i.texture.generateMipmaps;
            i.texture.generateMipmaps = !1,
              e.setRenderTarget(i, 0),
              e.render(t, n),
              e.setRenderTarget(i, 1),
              e.render(t, r),
              e.setRenderTarget(i, 2),
              e.render(t, s),
              e.setRenderTarget(i, 3),
              e.render(t, a),
              e.setRenderTarget(i, 4),
              e.render(t, o),
              i.texture.generateMipmaps = d,
              e.setRenderTarget(i, 5),
              e.render(t, l),
              e.setRenderTarget(h),
              e.toneMapping = c,
              e.xr.enabled = u,
              i.texture.needsPMREMUpdate = !0
          }
        }
        class ao extends Kr {
          constructor(e, t, i, n, r, s, a, o, l, h) {
            super(e = void 0 !== e ? e : [], t = void 0 !== t ? t : kn, i, n, r, s, a, o, l, h),
              this.isCubeTexture = !0,
              this.flipY = !1
          }
          get images() {
            return this.image
          }
          set images(e) {
            this.image = e
          }
        }
        class oo extends Zr {
          constructor(e, t={}) {
            super(e, e, t),
              this.isWebGLCubeRenderTarget = !0;
            const i = {
              width: e,
              height: e,
              depth: 1
            }
              , n = [i, i, i, i, i, i];
            this.texture = new ao(n,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.encoding),
              this.texture.isRenderTargetTexture = !0,
              this.texture.generateMipmaps = void 0 !== t.generateMipmaps && t.generateMipmaps,
              this.texture.minFilter = void 0 !== t.minFilter ? t.minFilter : Hn
          }
          fromEquirectangularTexture(e, t) {
            this.texture.type = t.type,
              this.texture.encoding = t.encoding,
              this.texture.generateMipmaps = t.generateMipmaps,
              this.texture.minFilter = t.minFilter,
              this.texture.magFilter = t.magFilter;
            const i = {
              tEquirect: {
                value: null
              }
            }
              , n = "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t"
              , r = "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"
              , s = new Ja(5,5,5)
              , a = new to({
              name: "CubemapFromEquirect",
              uniforms: Za(i),
              vertexShader: n,
              fragmentShader: r,
              side: 1,
              blending: 0
            });
            a.uniforms.tEquirect.value = t;
            const o = new Qa(s,a)
              , l = t.minFilter;
            return t.minFilter === Wn && (t.minFilter = Hn),
              new so(1,10,this).update(e, o),
              t.minFilter = l,
              o.geometry.dispose(),
              o.material.dispose(),
              this
          }
          clear(e, t, i, n) {
            const r = e.getRenderTarget();
            for (let r = 0; r < 6; r++)
              e.setRenderTarget(this, r),
                e.clear(t, i, n);
            e.setRenderTarget(r)
          }
        }
        const lo = new ts
          , ho = new ts
          , co = new Ir;
        class uo {
          constructor(e=new ts(1,0,0), t=0) {
            this.isPlane = !0,
              this.normal = e,
              this.constant = t
          }
          set(e, t) {
            return this.normal.copy(e),
              this.constant = t,
              this
          }
          setComponents(e, t, i, n) {
            return this.normal.set(e, t, i),
              this.constant = n,
              this
          }
          setFromNormalAndCoplanarPoint(e, t) {
            return this.normal.copy(e),
              this.constant = -t.dot(this.normal),
              this
          }
          setFromCoplanarPoints(e, t, i) {
            const n = lo.subVectors(i, t).cross(ho.subVectors(e, t)).normalize();
            return this.setFromNormalAndCoplanarPoint(n, e),
              this
          }
          copy(e) {
            return this.normal.copy(e.normal),
              this.constant = e.constant,
              this
          }
          normalize() {
            const e = 1 / this.normal.length();
            return this.normal.multiplyScalar(e),
              this.constant *= e,
              this
          }
          negate() {
            return this.constant *= -1,
              this.normal.negate(),
              this
          }
          distanceToPoint(e) {
            return this.normal.dot(e) + this.constant
          }
          distanceToSphere(e) {
            return this.distanceToPoint(e.center) - e.radius
          }
          projectPoint(e, t) {
            return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)
          }
          intersectLine(e, t) {
            const i = e.delta(lo)
              , n = this.normal.dot(i);
            if (0 === n)
              return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : null;
            const r = -(e.start.dot(this.normal) + this.constant) / n;
            return r < 0 || r > 1 ? null : t.copy(i).multiplyScalar(r).add(e.start)
          }
          intersectsLine(e) {
            const t = this.distanceToPoint(e.start)
              , i = this.distanceToPoint(e.end);
            return t < 0 && i > 0 || i < 0 && t > 0
          }
          intersectsBox(e) {
            return e.intersectsPlane(this)
          }
          intersectsSphere(e) {
            return e.intersectsPlane(this)
          }
          coplanarPoint(e) {
            return e.copy(this.normal).multiplyScalar(-this.constant)
          }
          applyMatrix4(e, t) {
            const i = t || co.getNormalMatrix(e)
              , n = this.coplanarPoint(lo).applyMatrix4(e)
              , r = this.normal.applyMatrix3(i).normalize();
            return this.constant = -n.dot(r),
              this
          }
          translate(e) {
            return this.constant -= e.dot(this.normal),
              this
          }
          equals(e) {
            return e.normal.equals(this.normal) && e.constant === this.constant
          }
          clone() {
            return (new this.constructor).copy(this)
          }
        }
        const po = new As
          , fo = new ts;
        class mo {
          constructor(e=new uo, t=new uo, i=new uo, n=new uo, r=new uo, s=new uo) {
            this.planes = [e, t, i, n, r, s]
          }
          set(e, t, i, n, r, s) {
            const a = this.planes;
            return a[0].copy(e),
              a[1].copy(t),
              a[2].copy(i),
              a[3].copy(n),
              a[4].copy(r),
              a[5].copy(s),
              this
          }
          copy(e) {
            const t = this.planes;
            for (let i = 0; i < 6; i++)
              t[i].copy(e.planes[i]);
            return this
          }
          setFromProjectionMatrix(e) {
            const t = this.planes
              , i = e.elements
              , n = i[0]
              , r = i[1]
              , s = i[2]
              , a = i[3]
              , o = i[4]
              , l = i[5]
              , h = i[6]
              , c = i[7]
              , u = i[8]
              , d = i[9]
              , p = i[10]
              , f = i[11]
              , m = i[12]
              , g = i[13]
              , v = i[14]
              , y = i[15];
            return t[0].setComponents(a - n, c - o, f - u, y - m).normalize(),
              t[1].setComponents(a + n, c + o, f + u, y + m).normalize(),
              t[2].setComponents(a + r, c + l, f + d, y + g).normalize(),
              t[3].setComponents(a - r, c - l, f - d, y - g).normalize(),
              t[4].setComponents(a - s, c - h, f - p, y - v).normalize(),
              t[5].setComponents(a + s, c + h, f + p, y + v).normalize(),
              this
          }
          intersectsObject(e) {
            const t = e.geometry;
            return null === t.boundingSphere && t.computeBoundingSphere(),
              po.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),
              this.intersectsSphere(po)
          }
          intersectsSprite(e) {
            return po.center.set(0, 0, 0),
              po.radius = .7071067811865476,
              po.applyMatrix4(e.matrixWorld),
              this.intersectsSphere(po)
          }
          intersectsSphere(e) {
            const t = this.planes
              , i = e.center
              , n = -e.radius;
            for (let e = 0; e < 6; e++)
              if (t[e].distanceToPoint(i) < n)
                return !1;
            return !0
          }
          intersectsBox(e) {
            const t = this.planes;
            for (let i = 0; i < 6; i++) {
              const n = t[i];
              if (fo.x = n.normal.x > 0 ? e.max.x : e.min.x,
                fo.y = n.normal.y > 0 ? e.max.y : e.min.y,
                fo.z = n.normal.z > 0 ? e.max.z : e.min.z,
              n.distanceToPoint(fo) < 0)
                return !1
            }
            return !0
          }
          containsPoint(e) {
            const t = this.planes;
            for (let i = 0; i < 6; i++)
              if (t[i].distanceToPoint(e) < 0)
                return !1;
            return !0
          }
          clone() {
            return (new this.constructor).copy(this)
          }
        }
        function go() {
          let e = null
            , t = !1
            , i = null
            , n = null;
          function r(t, s) {
            i(t, s),
              n = e.requestAnimationFrame(r)
          }
          return {
            start: function() {
              !0 !== t && null !== i && (n = e.requestAnimationFrame(r),
                t = !0)
            },
            stop: function() {
              e.cancelAnimationFrame(n),
                t = !1
            },
            setAnimationLoop: function(e) {
              i = e
            },
            setContext: function(t) {
              e = t
            }
          }
        }
        function vo(e, t) {
          const i = t.isWebGL2
            , n = new WeakMap;
          return {
            get: function(e) {
              return e.isInterleavedBufferAttribute && (e = e.data),
                n.get(e)
            },
            remove: function(t) {
              t.isInterleavedBufferAttribute && (t = t.data);
              const i = n.get(t);
              i && (e.deleteBuffer(i.buffer),
                n.delete(t))
            },
            update: function(t, r) {
              if (t.isGLBufferAttribute) {
                const e = n.get(t);
                return void ((!e || e.version < t.version) && n.set(t, {
                  buffer: t.buffer,
                  type: t.type,
                  bytesPerElement: t.elementSize,
                  version: t.version
                }))
              }
              t.isInterleavedBufferAttribute && (t = t.data);
              const s = n.get(t);
              void 0 === s ? n.set(t, function(t, n) {
                const r = t.array
                  , s = t.usage
                  , a = e.createBuffer();
                let o;
                if (e.bindBuffer(n, a),
                  e.bufferData(n, r, s),
                  t.onUploadCallback(),
                r instanceof Float32Array)
                  o = 5126;
                else if (r instanceof Uint16Array)
                  if (t.isFloat16BufferAttribute) {
                    if (!i)
                      throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
                    o = 5131
                  } else
                    o = 5123;
                else if (r instanceof Int16Array)
                  o = 5122;
                else if (r instanceof Uint32Array)
                  o = 5125;
                else if (r instanceof Int32Array)
                  o = 5124;
                else if (r instanceof Int8Array)
                  o = 5120;
                else if (r instanceof Uint8Array)
                  o = 5121;
                else {
                  if (!(r instanceof Uint8ClampedArray))
                    throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + r);
                  o = 5121
                }
                return {
                  buffer: a,
                  type: o,
                  bytesPerElement: r.BYTES_PER_ELEMENT,
                  version: t.version
                }
              }(t, r)) : s.version < t.version && (function(t, n, r) {
                const s = n.array
                  , a = n.updateRange;
                e.bindBuffer(r, t),
                  -1 === a.count ? e.bufferSubData(r, 0, s) : (i ? e.bufferSubData(r, a.offset * s.BYTES_PER_ELEMENT, s, a.offset, a.count) : e.bufferSubData(r, a.offset * s.BYTES_PER_ELEMENT, s.subarray(a.offset, a.offset + a.count)),
                    a.count = -1)
              }(s.buffer, t, r),
                s.version = t.version)
            }
          }
        }
        class yo extends Ia {
          constructor(e=1, t=1, i=1, n=1) {
            super(),
              this.type = "PlaneGeometry",
              this.parameters = {
                width: e,
                height: t,
                widthSegments: i,
                heightSegments: n
              };
            const r = e / 2
              , s = t / 2
              , a = Math.floor(i)
              , o = Math.floor(n)
              , l = a + 1
              , h = o + 1
              , c = e / a
              , u = t / o
              , d = []
              , p = []
              , f = []
              , m = [];
            for (let e = 0; e < h; e++) {
              const t = e * u - s;
              for (let i = 0; i < l; i++) {
                const n = i * c - r;
                p.push(n, -t, 0),
                  f.push(0, 0, 1),
                  m.push(i / a),
                  m.push(1 - e / o)
              }
            }
            for (let e = 0; e < o; e++)
              for (let t = 0; t < a; t++) {
                const i = t + l * e
                  , n = t + l * (e + 1)
                  , r = t + 1 + l * (e + 1)
                  , s = t + 1 + l * e;
                d.push(i, n, s),
                  d.push(n, r, s)
              }
            this.setIndex(d),
              this.setAttribute("position", new Aa(p,3)),
              this.setAttribute("normal", new Aa(f,3)),
              this.setAttribute("uv", new Aa(m,2))
          }
          static fromJSON(e) {
            return new yo(e.width,e.height,e.widthSegments,e.heightSegments)
          }
        }
        const xo = {
          alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
          alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
          alphatest_fragment: "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",
          alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
          aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
          aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
          begin_vertex: "vec3 transformed = vec3( position );",
          beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
          bsdfs: "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#ifdef USE_IRIDESCENCE\nvec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = mix(F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence);\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#endif\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif",
          iridescence_fragment: "#ifdef USE_IRIDESCENCE\nconst mat3 XYZ_TO_REC709 = mat3(\n    3.2404542, -0.9692660,  0.0556434,\n   -1.5371385,  1.8760108, -0.2040259,\n   -0.4985314,  0.0415560,  1.0572252\n);\nvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n   vec3 sqrtF0 = sqrt( fresnel0 );\n   return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n}\nvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n   return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n}\nfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n   return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n}\nvec3 evalSensitivity( float OPD, vec3 shift ) {\n   float phase = 2.0 * PI * OPD * 1.0e-9;\n   vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n   vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n   vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n   vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( -pow2( phase ) * var );\n   xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[0] ) * exp( -4.5282e+09 * pow2( phase ) );\n   xyz /= 1.0685e-7;\n   vec3 srgb = XYZ_TO_REC709 * xyz;\n   return srgb;\n}\nvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n   vec3 I;\n   float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n   float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n   float cosTheta2Sq = 1.0 - sinTheta2Sq;\n   if ( cosTheta2Sq < 0.0 ) {\n       return vec3( 1.0 );\n   }\n   float cosTheta2 = sqrt( cosTheta2Sq );\n   float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n   float R12 = F_Schlick( R0, 1.0, cosTheta1 );\n   float R21 = R12;\n   float T121 = 1.0 - R12;\n   float phi12 = 0.0;\n   if ( iridescenceIOR < outsideIOR ) phi12 = PI;\n   float phi21 = PI - phi12;\n   vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );   vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n   vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n   vec3 phi23 = vec3( 0.0 );\n   if ( baseIOR[0] < iridescenceIOR ) phi23[0] = PI;\n   if ( baseIOR[1] < iridescenceIOR ) phi23[1] = PI;\n   if ( baseIOR[2] < iridescenceIOR ) phi23[2] = PI;\n   float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n   vec3 phi = vec3( phi21 ) + phi23;\n   vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n   vec3 r123 = sqrt( R123 );\n   vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n   vec3 C0 = R12 + Rs;\n   I = C0;\n   vec3 Cm = Rs - T121;\n   for ( int m = 1; m <= 2; ++m ) {\n       Cm *= r123;\n       vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n       I += Cm * Sm;\n   }\n   return max( I, vec3( 0.0 ) );\n}\n#endif",
          bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
          clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
          clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
          clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
          clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
          color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
          color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
          color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
          color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
          common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
          cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
          defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
          displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
          displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
          emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
          emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
          encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
          encodings_pars_fragment: "vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",
          envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
          envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
          envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
          envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
          envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif",
          envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
          fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
          fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
          fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
          fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
          gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
          lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",
          lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
          lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
          lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
          lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
          lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
          lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
          lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
          lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif",
          lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );\n\t#else\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
          lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\nfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\nif ( material.iridescenceThickness == 0.0 ) {\n\tmaterial.iridescence = 0.0;\n} else {\n\tmaterial.iridescence = saturate( material.iridescence );\n}\nif ( material.iridescence > 0.0 ) {\n\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
          lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
          lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
          logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
          logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
          logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
          logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
          map_fragment: "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",
          map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
          map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
          map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
          metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
          metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
          morphcolor_vertex: "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",
          morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",
          morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",
          morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",
          normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
          normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
          normal_pars_fragment: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
          normal_pars_vertex: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
          normal_vertex: "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
          normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",
          clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
          clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",
          clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
          iridescence_pars_fragment: "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",
          output_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
          packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
          premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
          project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
          dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
          dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
          roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
          roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
          shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
          shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
          shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
          shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
          skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
          skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif",
          skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
          skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
          specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
          specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
          tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
          tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
          transmission_fragment: "#ifdef USE_TRANSMISSION\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif",
          transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef texture2DLodEXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif",
          uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
          uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
          uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
          uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
          uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
          uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
          worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
          background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
          background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tgl_FragColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tgl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );\n\t#endif\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
          cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
          cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
          depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
          depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
          distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
          distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
          equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
          equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
          linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
          linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
          meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
          meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
          meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
          meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
          meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",
          meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
          meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
          meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
          meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
          points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
          shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
          shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
          sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
          sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}"
        }
          , _o = {
          common: {
            diffuse: {
              value: new Wr(16777215)
            },
            opacity: {
              value: 1
            },
            map: {
              value: null
            },
            uvTransform: {
              value: new Ir
            },
            uv2Transform: {
              value: new Ir
            },
            alphaMap: {
              value: null
            },
            alphaTest: {
              value: 0
            }
          },
          specularmap: {
            specularMap: {
              value: null
            }
          },
          envmap: {
            envMap: {
              value: null
            },
            flipEnvMap: {
              value: -1
            },
            reflectivity: {
              value: 1
            },
            ior: {
              value: 1.5
            },
            refractionRatio: {
              value: .98
            }
          },
          aomap: {
            aoMap: {
              value: null
            },
            aoMapIntensity: {
              value: 1
            }
          },
          lightmap: {
            lightMap: {
              value: null
            },
            lightMapIntensity: {
              value: 1
            }
          },
          emissivemap: {
            emissiveMap: {
              value: null
            }
          },
          bumpmap: {
            bumpMap: {
              value: null
            },
            bumpScale: {
              value: 1
            }
          },
          normalmap: {
            normalMap: {
              value: null
            },
            normalScale: {
              value: new Dr(1,1)
            }
          },
          displacementmap: {
            displacementMap: {
              value: null
            },
            displacementScale: {
              value: 1
            },
            displacementBias: {
              value: 0
            }
          },
          roughnessmap: {
            roughnessMap: {
              value: null
            }
          },
          metalnessmap: {
            metalnessMap: {
              value: null
            }
          },
          gradientmap: {
            gradientMap: {
              value: null
            }
          },
          fog: {
            fogDensity: {
              value: 25e-5
            },
            fogNear: {
              value: 1
            },
            fogFar: {
              value: 2e3
            },
            fogColor: {
              value: new Wr(16777215)
            }
          },
          lights: {
            ambientLightColor: {
              value: []
            },
            lightProbe: {
              value: []
            },
            directionalLights: {
              value: [],
              properties: {
                direction: {},
                color: {}
              }
            },
            directionalLightShadows: {
              value: [],
              properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
              }
            },
            directionalShadowMap: {
              value: []
            },
            directionalShadowMatrix: {
              value: []
            },
            spotLights: {
              value: [],
              properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {}
              }
            },
            spotLightShadows: {
              value: [],
              properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
              }
            },
            spotShadowMap: {
              value: []
            },
            spotShadowMatrix: {
              value: []
            },
            pointLights: {
              value: [],
              properties: {
                color: {},
                position: {},
                decay: {},
                distance: {}
              }
            },
            pointLightShadows: {
              value: [],
              properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
                shadowCameraNear: {},
                shadowCameraFar: {}
              }
            },
            pointShadowMap: {
              value: []
            },
            pointShadowMatrix: {
              value: []
            },
            hemisphereLights: {
              value: [],
              properties: {
                direction: {},
                skyColor: {},
                groundColor: {}
              }
            },
            rectAreaLights: {
              value: [],
              properties: {
                color: {},
                position: {},
                width: {},
                height: {}
              }
            },
            ltc_1: {
              value: null
            },
            ltc_2: {
              value: null
            }
          },
          points: {
            diffuse: {
              value: new Wr(16777215)
            },
            opacity: {
              value: 1
            },
            size: {
              value: 1
            },
            scale: {
              value: 1
            },
            map: {
              value: null
            },
            alphaMap: {
              value: null
            },
            alphaTest: {
              value: 0
            },
            uvTransform: {
              value: new Ir
            }
          },
          sprite: {
            diffuse: {
              value: new Wr(16777215)
            },
            opacity: {
              value: 1
            },
            center: {
              value: new Dr(.5,.5)
            },
            rotation: {
              value: 0
            },
            map: {
              value: null
            },
            alphaMap: {
              value: null
            },
            alphaTest: {
              value: 0
            },
            uvTransform: {
              value: new Ir
            }
          }
        }
          , bo = {
          basic: {
            uniforms: $a([_o.common, _o.specularmap, _o.envmap, _o.aomap, _o.lightmap, _o.fog]),
            vertexShader: xo.meshbasic_vert,
            fragmentShader: xo.meshbasic_frag
          },
          lambert: {
            uniforms: $a([_o.common, _o.specularmap, _o.envmap, _o.aomap, _o.lightmap, _o.emissivemap, _o.fog, _o.lights, {
              emissive: {
                value: new Wr(0)
              }
            }]),
            vertexShader: xo.meshlambert_vert,
            fragmentShader: xo.meshlambert_frag
          },
          phong: {
            uniforms: $a([_o.common, _o.specularmap, _o.envmap, _o.aomap, _o.lightmap, _o.emissivemap, _o.bumpmap, _o.normalmap, _o.displacementmap, _o.fog, _o.lights, {
              emissive: {
                value: new Wr(0)
              },
              specular: {
                value: new Wr(1118481)
              },
              shininess: {
                value: 30
              }
            }]),
            vertexShader: xo.meshphong_vert,
            fragmentShader: xo.meshphong_frag
          },
          standard: {
            uniforms: $a([_o.common, _o.envmap, _o.aomap, _o.lightmap, _o.emissivemap, _o.bumpmap, _o.normalmap, _o.displacementmap, _o.roughnessmap, _o.metalnessmap, _o.fog, _o.lights, {
              emissive: {
                value: new Wr(0)
              },
              roughness: {
                value: 1
              },
              metalness: {
                value: 0
              },
              envMapIntensity: {
                value: 1
              }
            }]),
            vertexShader: xo.meshphysical_vert,
            fragmentShader: xo.meshphysical_frag
          },
          toon: {
            uniforms: $a([_o.common, _o.aomap, _o.lightmap, _o.emissivemap, _o.bumpmap, _o.normalmap, _o.displacementmap, _o.gradientmap, _o.fog, _o.lights, {
              emissive: {
                value: new Wr(0)
              }
            }]),
            vertexShader: xo.meshtoon_vert,
            fragmentShader: xo.meshtoon_frag
          },
          matcap: {
            uniforms: $a([_o.common, _o.bumpmap, _o.normalmap, _o.displacementmap, _o.fog, {
              matcap: {
                value: null
              }
            }]),
            vertexShader: xo.meshmatcap_vert,
            fragmentShader: xo.meshmatcap_frag
          },
          points: {
            uniforms: $a([_o.points, _o.fog]),
            vertexShader: xo.points_vert,
            fragmentShader: xo.points_frag
          },
          dashed: {
            uniforms: $a([_o.common, _o.fog, {
              scale: {
                value: 1
              },
              dashSize: {
                value: 1
              },
              totalSize: {
                value: 2
              }
            }]),
            vertexShader: xo.linedashed_vert,
            fragmentShader: xo.linedashed_frag
          },
          depth: {
            uniforms: $a([_o.common, _o.displacementmap]),
            vertexShader: xo.depth_vert,
            fragmentShader: xo.depth_frag
          },
          normal: {
            uniforms: $a([_o.common, _o.bumpmap, _o.normalmap, _o.displacementmap, {
              opacity: {
                value: 1
              }
            }]),
            vertexShader: xo.meshnormal_vert,
            fragmentShader: xo.meshnormal_frag
          },
          sprite: {
            uniforms: $a([_o.sprite, _o.fog]),
            vertexShader: xo.sprite_vert,
            fragmentShader: xo.sprite_frag
          },
          background: {
            uniforms: {
              uvTransform: {
                value: new Ir
              },
              t2D: {
                value: null
              }
            },
            vertexShader: xo.background_vert,
            fragmentShader: xo.background_frag
          },
          cube: {
            uniforms: $a([_o.envmap, {
              opacity: {
                value: 1
              }
            }]),
            vertexShader: xo.cube_vert,
            fragmentShader: xo.cube_frag
          },
          equirect: {
            uniforms: {
              tEquirect: {
                value: null
              }
            },
            vertexShader: xo.equirect_vert,
            fragmentShader: xo.equirect_frag
          },
          distanceRGBA: {
            uniforms: $a([_o.common, _o.displacementmap, {
              referencePosition: {
                value: new ts
              },
              nearDistance: {
                value: 1
              },
              farDistance: {
                value: 1e3
              }
            }]),
            vertexShader: xo.distanceRGBA_vert,
            fragmentShader: xo.distanceRGBA_frag
          },
          shadow: {
            uniforms: $a([_o.lights, _o.fog, {
              color: {
                value: new Wr(0)
              },
              opacity: {
                value: 1
              }
            }]),
            vertexShader: xo.shadow_vert,
            fragmentShader: xo.shadow_frag
          }
        };
        function wo(e, t, i, n, r, s) {
          const a = new Wr(0);
          let o, l, h = !0 === r ? 0 : 1, c = null, u = 0, d = null;
          function p(e, t) {
            i.buffers.color.setClear(e.r, e.g, e.b, t, s)
          }
          return {
            getClearColor: function() {
              return a
            },
            setClearColor: function(e, t=1) {
              a.set(e),
                h = t,
                p(a, h)
            },
            getClearAlpha: function() {
              return h
            },
            setClearAlpha: function(e) {
              h = e,
                p(a, h)
            },
            render: function(i, r) {
              let s = !1
                , f = !0 === r.isScene ? r.background : null;
              f && f.isTexture && (f = t.get(f));
              const m = e.xr
                , g = m.getSession && m.getSession();
              g && "additive" === g.environmentBlendMode && (f = null),
                null === f ? p(a, h) : f && f.isColor && (p(f, 1),
                  s = !0),
              (e.autoClear || s) && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil),
                f && (f.isCubeTexture || f.mapping === Bn) ? (void 0 === l && (l = new Qa(new Ja(1,1,1),new to({
                  name: "BackgroundCubeMaterial",
                  uniforms: Za(bo.cube.uniforms),
                  vertexShader: bo.cube.vertexShader,
                  fragmentShader: bo.cube.fragmentShader,
                  side: 1,
                  depthTest: !1,
                  depthWrite: !1,
                  fog: !1
                })),
                  l.geometry.deleteAttribute("normal"),
                  l.geometry.deleteAttribute("uv"),
                  l.onBeforeRender = function(e, t, i) {
                    this.matrixWorld.copyPosition(i.matrixWorld)
                  }
                  ,
                  Object.defineProperty(l.material, "envMap", {
                    get: function() {
                      return this.uniforms.envMap.value
                    }
                  }),
                  n.update(l)),
                  l.material.uniforms.envMap.value = f,
                  l.material.uniforms.flipEnvMap.value = f.isCubeTexture && !1 === f.isRenderTargetTexture ? -1 : 1,
                c === f && u === f.version && d === e.toneMapping || (l.material.needsUpdate = !0,
                  c = f,
                  u = f.version,
                  d = e.toneMapping),
                  l.layers.enableAll(),
                  i.unshift(l, l.geometry, l.material, 0, 0, null)) : f && f.isTexture && (void 0 === o && (o = new Qa(new yo(2,2),new to({
                  name: "BackgroundMaterial",
                  uniforms: Za(bo.background.uniforms),
                  vertexShader: bo.background.vertexShader,
                  fragmentShader: bo.background.fragmentShader,
                  side: 0,
                  depthTest: !1,
                  depthWrite: !1,
                  fog: !1
                })),
                  o.geometry.deleteAttribute("normal"),
                  Object.defineProperty(o.material, "map", {
                    get: function() {
                      return this.uniforms.t2D.value
                    }
                  }),
                  n.update(o)),
                  o.material.uniforms.t2D.value = f,
                !0 === f.matrixAutoUpdate && f.updateMatrix(),
                  o.material.uniforms.uvTransform.value.copy(f.matrix),
                c === f && u === f.version && d === e.toneMapping || (o.material.needsUpdate = !0,
                  c = f,
                  u = f.version,
                  d = e.toneMapping),
                  o.layers.enableAll(),
                  i.unshift(o, o.geometry, o.material, 0, 0, null))
            }
          }
        }
        function Ao(e, t, i, n) {
          const r = e.getParameter(34921)
            , s = n.isWebGL2 ? null : t.get("OES_vertex_array_object")
            , a = n.isWebGL2 || null !== s
            , o = {}
            , l = p(null);
          let h = l
            , c = !1;
          function u(t) {
            return n.isWebGL2 ? e.bindVertexArray(t) : s.bindVertexArrayOES(t)
          }
          function d(t) {
            return n.isWebGL2 ? e.deleteVertexArray(t) : s.deleteVertexArrayOES(t)
          }
          function p(e) {
            const t = []
              , i = []
              , n = [];
            for (let e = 0; e < r; e++)
              t[e] = 0,
                i[e] = 0,
                n[e] = 0;
            return {
              geometry: null,
              program: null,
              wireframe: !1,
              newAttributes: t,
              enabledAttributes: i,
              attributeDivisors: n,
              object: e,
              attributes: {},
              index: null
            }
          }
          function f() {
            const e = h.newAttributes;
            for (let t = 0, i = e.length; t < i; t++)
              e[t] = 0
          }
          function m(e) {
            g(e, 0)
          }
          function g(i, r) {
            const s = h.newAttributes
              , a = h.enabledAttributes
              , o = h.attributeDivisors;
            s[i] = 1,
            0 === a[i] && (e.enableVertexAttribArray(i),
              a[i] = 1),
            o[i] !== r && ((n.isWebGL2 ? e : t.get("ANGLE_instanced_arrays"))[n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](i, r),
              o[i] = r)
          }
          function v() {
            const t = h.newAttributes
              , i = h.enabledAttributes;
            for (let n = 0, r = i.length; n < r; n++)
              i[n] !== t[n] && (e.disableVertexAttribArray(n),
                i[n] = 0)
          }
          function y(t, i, r, s, a, o) {
            !0 !== n.isWebGL2 || 5124 !== r && 5125 !== r ? e.vertexAttribPointer(t, i, r, s, a, o) : e.vertexAttribIPointer(t, i, r, a, o)
          }
          function x() {
            _(),
              c = !0,
            h !== l && (h = l,
              u(h.object))
          }
          function _() {
            l.geometry = null,
              l.program = null,
              l.wireframe = !1
          }
          return {
            setup: function(r, l, d, x, _) {
              let b = !1;
              if (a) {
                const t = function(t, i, r) {
                  const a = !0 === r.wireframe;
                  let l = o[t.id];
                  void 0 === l && (l = {},
                    o[t.id] = l);
                  let h = l[i.id];
                  void 0 === h && (h = {},
                    l[i.id] = h);
                  let c = h[a];
                  return void 0 === c && (c = p(n.isWebGL2 ? e.createVertexArray() : s.createVertexArrayOES()),
                    h[a] = c),
                    c
                }(x, d, l);
                h !== t && (h = t,
                  u(h.object)),
                  b = function(e, t, i, n) {
                    const r = h.attributes
                      , s = t.attributes;
                    let a = 0;
                    const o = i.getAttributes();
                    for (const t in o)
                      if (o[t].location >= 0) {
                        const i = r[t];
                        let n = s[t];
                        if (void 0 === n && ("instanceMatrix" === t && e.instanceMatrix && (n = e.instanceMatrix),
                        "instanceColor" === t && e.instanceColor && (n = e.instanceColor)),
                        void 0 === i)
                          return !0;
                        if (i.attribute !== n)
                          return !0;
                        if (n && i.data !== n.data)
                          return !0;
                        a++
                      }
                    return h.attributesNum !== a || h.index !== n
                  }(r, x, d, _),
                b && function(e, t, i, n) {
                  const r = {}
                    , s = t.attributes;
                  let a = 0;
                  const o = i.getAttributes();
                  for (const t in o)
                    if (o[t].location >= 0) {
                      let i = s[t];
                      void 0 === i && ("instanceMatrix" === t && e.instanceMatrix && (i = e.instanceMatrix),
                      "instanceColor" === t && e.instanceColor && (i = e.instanceColor));
                      const n = {};
                      n.attribute = i,
                      i && i.data && (n.data = i.data),
                        r[t] = n,
                        a++
                    }
                  h.attributes = r,
                    h.attributesNum = a,
                    h.index = n
                }(r, x, d, _)
              } else {
                const e = !0 === l.wireframe;
                h.geometry === x.id && h.program === d.id && h.wireframe === e || (h.geometry = x.id,
                  h.program = d.id,
                  h.wireframe = e,
                  b = !0)
              }
              null !== _ && i.update(_, 34963),
              (b || c) && (c = !1,
                function(r, s, a, o) {
                  if (!1 === n.isWebGL2 && (r.isInstancedMesh || o.isInstancedBufferGeometry) && null === t.get("ANGLE_instanced_arrays"))
                    return;
                  f();
                  const l = o.attributes
                    , h = a.getAttributes()
                    , c = s.defaultAttributeValues;
                  for (const t in h) {
                    const n = h[t];
                    if (n.location >= 0) {
                      let s = l[t];
                      if (void 0 === s && ("instanceMatrix" === t && r.instanceMatrix && (s = r.instanceMatrix),
                      "instanceColor" === t && r.instanceColor && (s = r.instanceColor)),
                      void 0 !== s) {
                        const t = s.normalized
                          , a = s.itemSize
                          , l = i.get(s);
                        if (void 0 === l)
                          continue;
                        const h = l.buffer
                          , c = l.type
                          , u = l.bytesPerElement;
                        if (s.isInterleavedBufferAttribute) {
                          const i = s.data
                            , l = i.stride
                            , d = s.offset;
                          if (i.isInstancedInterleavedBuffer) {
                            for (let e = 0; e < n.locationSize; e++)
                              g(n.location + e, i.meshPerAttribute);
                            !0 !== r.isInstancedMesh && void 0 === o._maxInstanceCount && (o._maxInstanceCount = i.meshPerAttribute * i.count)
                          } else
                            for (let e = 0; e < n.locationSize; e++)
                              m(n.location + e);
                          e.bindBuffer(34962, h);
                          for (let e = 0; e < n.locationSize; e++)
                            y(n.location + e, a / n.locationSize, c, t, l * u, (d + a / n.locationSize * e) * u)
                        } else {
                          if (s.isInstancedBufferAttribute) {
                            for (let e = 0; e < n.locationSize; e++)
                              g(n.location + e, s.meshPerAttribute);
                            !0 !== r.isInstancedMesh && void 0 === o._maxInstanceCount && (o._maxInstanceCount = s.meshPerAttribute * s.count)
                          } else
                            for (let e = 0; e < n.locationSize; e++)
                              m(n.location + e);
                          e.bindBuffer(34962, h);
                          for (let e = 0; e < n.locationSize; e++)
                            y(n.location + e, a / n.locationSize, c, t, a * u, a / n.locationSize * e * u)
                        }
                      } else if (void 0 !== c) {
                        const i = c[t];
                        if (void 0 !== i)
                          switch (i.length) {
                            case 2:
                              e.vertexAttrib2fv(n.location, i);
                              break;
                            case 3:
                              e.vertexAttrib3fv(n.location, i);
                              break;
                            case 4:
                              e.vertexAttrib4fv(n.location, i);
                              break;
                            default:
                              e.vertexAttrib1fv(n.location, i)
                          }
                      }
                    }
                  }
                  v()
                }(r, l, d, x),
              null !== _ && e.bindBuffer(34963, i.get(_).buffer))
            },
            reset: x,
            resetDefaultState: _,
            dispose: function() {
              x();
              for (const e in o) {
                const t = o[e];
                for (const e in t) {
                  const i = t[e];
                  for (const e in i)
                    d(i[e].object),
                      delete i[e];
                  delete t[e]
                }
                delete o[e]
              }
            },
            releaseStatesOfGeometry: function(e) {
              if (void 0 === o[e.id])
                return;
              const t = o[e.id];
              for (const e in t) {
                const i = t[e];
                for (const e in i)
                  d(i[e].object),
                    delete i[e];
                delete t[e]
              }
              delete o[e.id]
            },
            releaseStatesOfProgram: function(e) {
              for (const t in o) {
                const i = o[t];
                if (void 0 === i[e.id])
                  continue;
                const n = i[e.id];
                for (const e in n)
                  d(n[e].object),
                    delete n[e];
                delete i[e.id]
              }
            },
            initAttributes: f,
            enableAttribute: m,
            disableUnusedAttributes: v
          }
        }
        function So(e, t, i, n) {
          const r = n.isWebGL2;
          let s;
          this.setMode = function(e) {
            s = e
          }
            ,
            this.render = function(t, n) {
              e.drawArrays(s, t, n),
                i.update(n, s, 1)
            }
            ,
            this.renderInstances = function(n, a, o) {
              if (0 === o)
                return;
              let l, h;
              if (r)
                l = e,
                  h = "drawArraysInstanced";
              else if (l = t.get("ANGLE_instanced_arrays"),
                h = "drawArraysInstancedANGLE",
              null === l)
                return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
              l[h](s, n, a, o),
                i.update(a, s, o)
            }
        }
        function Mo(e, t, i) {
          let n;
          function r(t) {
            if ("highp" === t) {
              if (e.getShaderPrecisionFormat(35633, 36338).precision > 0 && e.getShaderPrecisionFormat(35632, 36338).precision > 0)
                return "highp";
              t = "mediump"
            }
            return "mediump" === t && e.getShaderPrecisionFormat(35633, 36337).precision > 0 && e.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
          }
          const s = "undefined" != typeof WebGL2RenderingContext && e instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && e instanceof WebGL2ComputeRenderingContext;
          let a = void 0 !== i.precision ? i.precision : "highp";
          const o = r(a);
          o !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", o, "instead."),
            a = o);
          const l = s || t.has("WEBGL_draw_buffers")
            , h = !0 === i.logarithmicDepthBuffer
            , c = e.getParameter(34930)
            , u = e.getParameter(35660)
            , d = e.getParameter(3379)
            , p = e.getParameter(34076)
            , f = e.getParameter(34921)
            , m = e.getParameter(36347)
            , g = e.getParameter(36348)
            , v = e.getParameter(36349)
            , y = u > 0
            , x = s || t.has("OES_texture_float");
          return {
            isWebGL2: s,
            drawBuffers: l,
            getMaxAnisotropy: function() {
              if (void 0 !== n)
                return n;
              if (!0 === t.has("EXT_texture_filter_anisotropic")) {
                const i = t.get("EXT_texture_filter_anisotropic");
                n = e.getParameter(i.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
              } else
                n = 0;
              return n
            },
            getMaxPrecision: r,
            precision: a,
            logarithmicDepthBuffer: h,
            maxTextures: c,
            maxVertexTextures: u,
            maxTextureSize: d,
            maxCubemapSize: p,
            maxAttributes: f,
            maxVertexUniforms: m,
            maxVaryings: g,
            maxFragmentUniforms: v,
            vertexTextures: y,
            floatFragmentTextures: x,
            floatVertexTextures: y && x,
            maxSamples: s ? e.getParameter(36183) : 0
          }
        }
        function To(e) {
          const t = this;
          let i = null
            , n = 0
            , r = !1
            , s = !1;
          const a = new uo
            , o = new Ir
            , l = {
            value: null,
            needsUpdate: !1
          };
          function h() {
            l.value !== i && (l.value = i,
              l.needsUpdate = n > 0),
              t.numPlanes = n,
              t.numIntersection = 0
          }
          function c(e, i, n, r) {
            const s = null !== e ? e.length : 0;
            let h = null;
            if (0 !== s) {
              if (h = l.value,
              !0 !== r || null === h) {
                const t = n + 4 * s
                  , r = i.matrixWorldInverse;
                o.getNormalMatrix(r),
                (null === h || h.length < t) && (h = new Float32Array(t));
                for (let t = 0, i = n; t !== s; ++t,
                  i += 4)
                  a.copy(e[t]).applyMatrix4(r, o),
                    a.normal.toArray(h, i),
                    h[i + 3] = a.constant
              }
              l.value = h,
                l.needsUpdate = !0
            }
            return t.numPlanes = s,
              t.numIntersection = 0,
              h
          }
          this.uniform = l,
            this.numPlanes = 0,
            this.numIntersection = 0,
            this.init = function(e, t, s) {
              const a = 0 !== e.length || t || 0 !== n || r;
              return r = t,
                i = c(e, s, 0),
                n = e.length,
                a
            }
            ,
            this.beginShadows = function() {
              s = !0,
                c(null)
            }
            ,
            this.endShadows = function() {
              s = !1,
                h()
            }
            ,
            this.setState = function(t, a, o) {
              const u = t.clippingPlanes
                , d = t.clipIntersection
                , p = t.clipShadows
                , f = e.get(t);
              if (!r || null === u || 0 === u.length || s && !p)
                s ? c(null) : h();
              else {
                const e = s ? 0 : n
                  , t = 4 * e;
                let r = f.clippingState || null;
                l.value = r,
                  r = c(u, a, t, o);
                for (let e = 0; e !== t; ++e)
                  r[e] = i[e];
                f.clippingState = r,
                  this.numIntersection = d ? this.numPlanes : 0,
                  this.numPlanes += e
              }
            }
        }
        function Eo(e) {
          let t = new WeakMap;
          function i(e, t) {
            return 303 === t ? e.mapping = kn : 304 === t && (e.mapping = Fn),
              e
          }
          function n(e) {
            const i = e.target;
            i.removeEventListener("dispose", n);
            const r = t.get(i);
            void 0 !== r && (t.delete(i),
              r.dispose())
          }
          return {
            get: function(r) {
              if (r && r.isTexture && !1 === r.isRenderTargetTexture) {
                const s = r.mapping;
                if (303 === s || 304 === s) {
                  if (t.has(r))
                    return i(t.get(r).texture, r.mapping);
                  {
                    const s = r.image;
                    if (s && s.height > 0) {
                      const a = new oo(s.height / 2);
                      return a.fromEquirectangularTexture(e, r),
                        t.set(r, a),
                        r.addEventListener("dispose", n),
                        i(a.texture, r.mapping)
                    }
                    return null
                  }
                }
              }
              return r
            },
            dispose: function() {
              t = new WeakMap
            }
          }
        }
        bo.physical = {
          uniforms: $a([bo.standard.uniforms, {
            clearcoat: {
              value: 0
            },
            clearcoatMap: {
              value: null
            },
            clearcoatRoughness: {
              value: 0
            },
            clearcoatRoughnessMap: {
              value: null
            },
            clearcoatNormalScale: {
              value: new Dr(1,1)
            },
            clearcoatNormalMap: {
              value: null
            },
            iridescence: {
              value: 0
            },
            iridescenceMap: {
              value: null
            },
            iridescenceIOR: {
              value: 1.3
            },
            iridescenceThicknessMinimum: {
              value: 100
            },
            iridescenceThicknessMaximum: {
              value: 400
            },
            iridescenceThicknessMap: {
              value: null
            },
            sheen: {
              value: 0
            },
            sheenColor: {
              value: new Wr(0)
            },
            sheenColorMap: {
              value: null
            },
            sheenRoughness: {
              value: 1
            },
            sheenRoughnessMap: {
              value: null
            },
            transmission: {
              value: 0
            },
            transmissionMap: {
              value: null
            },
            transmissionSamplerSize: {
              value: new Dr
            },
            transmissionSamplerMap: {
              value: null
            },
            thickness: {
              value: 0
            },
            thicknessMap: {
              value: null
            },
            attenuationDistance: {
              value: 0
            },
            attenuationColor: {
              value: new Wr(0)
            },
            specularIntensity: {
              value: 1
            },
            specularIntensityMap: {
              value: null
            },
            specularColor: {
              value: new Wr(1,1,1)
            },
            specularColorMap: {
              value: null
            }
          }]),
          vertexShader: xo.meshphysical_vert,
          fragmentShader: xo.meshphysical_frag
        };
        class Co extends io {
          constructor(e=-1, t=1, i=1, n=-1, r=.1, s=2e3) {
            super(),
              this.isOrthographicCamera = !0,
              this.type = "OrthographicCamera",
              this.zoom = 1,
              this.view = null,
              this.left = e,
              this.right = t,
              this.top = i,
              this.bottom = n,
              this.near = r,
              this.far = s,
              this.updateProjectionMatrix()
          }
          copy(e, t) {
            return super.copy(e, t),
              this.left = e.left,
              this.right = e.right,
              this.top = e.top,
              this.bottom = e.bottom,
              this.near = e.near,
              this.far = e.far,
              this.zoom = e.zoom,
              this.view = null === e.view ? null : Object.assign({}, e.view),
              this
          }
          setViewOffset(e, t, i, n, r, s) {
            null === this.view && (this.view = {
              enabled: !0,
              fullWidth: 1,
              fullHeight: 1,
              offsetX: 0,
              offsetY: 0,
              width: 1,
              height: 1
            }),
              this.view.enabled = !0,
              this.view.fullWidth = e,
              this.view.fullHeight = t,
              this.view.offsetX = i,
              this.view.offsetY = n,
              this.view.width = r,
              this.view.height = s,
              this.updateProjectionMatrix()
          }
          clearViewOffset() {
            null !== this.view && (this.view.enabled = !1),
              this.updateProjectionMatrix()
          }
          updateProjectionMatrix() {
            const e = (this.right - this.left) / (2 * this.zoom)
              , t = (this.top - this.bottom) / (2 * this.zoom)
              , i = (this.right + this.left) / 2
              , n = (this.top + this.bottom) / 2;
            let r = i - e
              , s = i + e
              , a = n + t
              , o = n - t;
            if (null !== this.view && this.view.enabled) {
              const e = (this.right - this.left) / this.view.fullWidth / this.zoom
                , t = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
              r += e * this.view.offsetX,
                s = r + e * this.view.width,
                a -= t * this.view.offsetY,
                o = a - t * this.view.height
            }
            this.projectionMatrix.makeOrthographic(r, s, a, o, this.near, this.far),
              this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
          }
          toJSON(e) {
            const t = super.toJSON(e);
            return t.object.zoom = this.zoom,
              t.object.left = this.left,
              t.object.right = this.right,
              t.object.top = this.top,
              t.object.bottom = this.bottom,
              t.object.near = this.near,
              t.object.far = this.far,
            null !== this.view && (t.object.view = Object.assign({}, this.view)),
              t
          }
        }
        const Po = [.125, .215, .35, .446, .526, .582]
          , Do = new Co
          , Io = new Wr;
        let Ro = null;
        const Lo = (1 + Math.sqrt(5)) / 2
          , ko = 1 / Lo
          , Fo = [new ts(1,1,1), new ts(-1,1,1), new ts(1,1,-1), new ts(-1,1,-1), new ts(0,Lo,ko), new ts(0,Lo,-ko), new ts(ko,0,Lo), new ts(-ko,0,Lo), new ts(Lo,ko,0), new ts(-Lo,ko,0)];
        class Bo {
          constructor(e) {
            this._renderer = e,
              this._pingPongRenderTarget = null,
              this._lodMax = 0,
              this._cubeSize = 0,
              this._lodPlanes = [],
              this._sizeLods = [],
              this._sigmas = [],
              this._blurMaterial = null,
              this._cubemapMaterial = null,
              this._equirectMaterial = null,
              this._compileMaterial(this._blurMaterial)
          }
          fromScene(e, t=0, i=.1, n=100) {
            Ro = this._renderer.getRenderTarget(),
              this._setSize(256);
            const r = this._allocateTargets();
            return r.depthBuffer = !0,
              this._sceneToCubeUV(e, i, n, r),
            t > 0 && this._blur(r, 0, 0, t),
              this._applyPMREM(r),
              this._cleanup(r),
              r
          }
          fromEquirectangular(e, t=null) {
            return this._fromTexture(e, t)
          }
          fromCubemap(e, t=null) {
            return this._fromTexture(e, t)
          }
          compileCubemapShader() {
            null === this._cubemapMaterial && (this._cubemapMaterial = Uo(),
              this._compileMaterial(this._cubemapMaterial))
          }
          compileEquirectangularShader() {
            null === this._equirectMaterial && (this._equirectMaterial = zo(),
              this._compileMaterial(this._equirectMaterial))
          }
          dispose() {
            this._dispose(),
            null !== this._cubemapMaterial && this._cubemapMaterial.dispose(),
            null !== this._equirectMaterial && this._equirectMaterial.dispose()
          }
          _setSize(e) {
            this._lodMax = Math.floor(Math.log2(e)),
              this._cubeSize = Math.pow(2, this._lodMax)
          }
          _dispose() {
            null !== this._blurMaterial && this._blurMaterial.dispose(),
            null !== this._pingPongRenderTarget && this._pingPongRenderTarget.dispose();
            for (let e = 0; e < this._lodPlanes.length; e++)
              this._lodPlanes[e].dispose()
          }
          _cleanup(e) {
            this._renderer.setRenderTarget(Ro),
              e.scissorTest = !1,
              No(e, 0, 0, e.width, e.height)
          }
          _fromTexture(e, t) {
            e.mapping === kn || e.mapping === Fn ? this._setSize(0 === e.image.length ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4),
              Ro = this._renderer.getRenderTarget();
            const i = t || this._allocateTargets();
            return this._textureToCubeUV(e, i),
              this._applyPMREM(i),
              this._cleanup(i),
              i
          }
          _allocateTargets() {
            const e = 3 * Math.max(this._cubeSize, 112)
              , t = 4 * this._cubeSize
              , i = {
              magFilter: Hn,
              minFilter: Hn,
              generateMipmaps: !1,
              type: qn,
              format: Kn,
              encoding: hr,
              depthBuffer: !1
            }
              , n = Oo(e, t, i);
            if (null === this._pingPongRenderTarget || this._pingPongRenderTarget.width !== e) {
              null !== this._pingPongRenderTarget && this._dispose(),
                this._pingPongRenderTarget = Oo(e, t, i);
              const {_lodMax: n} = this;
              ({sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas} = function(e) {
                const t = []
                  , i = []
                  , n = [];
                let r = e;
                const s = e - 4 + 1 + Po.length;
                for (let a = 0; a < s; a++) {
                  const s = Math.pow(2, r);
                  i.push(s);
                  let o = 1 / s;
                  a > e - 4 ? o = Po[a - e + 4 - 1] : 0 === a && (o = 0),
                    n.push(o);
                  const l = 1 / (s - 2)
                    , h = -l
                    , c = 1 + l
                    , u = [h, h, c, h, c, c, h, h, c, c, h, c]
                    , d = 6
                    , p = 6
                    , f = 3
                    , m = 2
                    , g = 1
                    , v = new Float32Array(f * p * d)
                    , y = new Float32Array(m * p * d)
                    , x = new Float32Array(g * p * d);
                  for (let e = 0; e < d; e++) {
                    const t = e % 3 * 2 / 3 - 1
                      , i = e > 2 ? 0 : -1
                      , n = [t, i, 0, t + 2 / 3, i, 0, t + 2 / 3, i + 1, 0, t, i, 0, t + 2 / 3, i + 1, 0, t, i + 1, 0];
                    v.set(n, f * p * e),
                      y.set(u, m * p * e);
                    const r = [e, e, e, e, e, e];
                    x.set(r, g * p * e)
                  }
                  const _ = new Ia;
                  _.setAttribute("position", new _a(v,f)),
                    _.setAttribute("uv", new _a(y,m)),
                    _.setAttribute("faceIndex", new _a(x,g)),
                    t.push(_),
                  r > 4 && r--
                }
                return {
                  lodPlanes: t,
                  sizeLods: i,
                  sigmas: n
                }
              }(n)),
                this._blurMaterial = function(e, t, i) {
                  const n = new Float32Array(20)
                    , r = new ts(0,1,0);
                  return new to({
                    name: "SphericalGaussianBlur",
                    defines: {
                      n: 20,
                      CUBEUV_TEXEL_WIDTH: 1 / t,
                      CUBEUV_TEXEL_HEIGHT: 1 / i,
                      CUBEUV_MAX_MIP: `${e}.0`
                    },
                    uniforms: {
                      envMap: {
                        value: null
                      },
                      samples: {
                        value: 1
                      },
                      weights: {
                        value: n
                      },
                      latitudinal: {
                        value: !1
                      },
                      dTheta: {
                        value: 0
                      },
                      mipInt: {
                        value: 0
                      },
                      poleAxis: {
                        value: r
                      }
                    },
                    vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                    fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
                    blending: 0,
                    depthTest: !1,
                    depthWrite: !1
                  })
                }(n, e, t)
            }
            return n
          }
          _compileMaterial(e) {
            const t = new Qa(this._lodPlanes[0],e);
            this._renderer.compile(t, Do)
          }
          _sceneToCubeUV(e, t, i, n) {
            const r = new no(90,1,t,i)
              , s = [1, -1, 1, 1, 1, 1]
              , a = [1, 1, 1, -1, -1, -1]
              , o = this._renderer
              , l = o.autoClear
              , h = o.toneMapping;
            o.getClearColor(Io),
              o.toneMapping = 0,
              o.autoClear = !1;
            const c = new va({
              name: "PMREM.Background",
              side: 1,
              depthWrite: !1,
              depthTest: !1
            })
              , u = new Qa(new Ja,c);
            let d = !1;
            const p = e.background;
            p ? p.isColor && (c.color.copy(p),
              e.background = null,
              d = !0) : (c.color.copy(Io),
              d = !0);
            for (let t = 0; t < 6; t++) {
              const i = t % 3;
              0 === i ? (r.up.set(0, s[t], 0),
                r.lookAt(a[t], 0, 0)) : 1 === i ? (r.up.set(0, 0, s[t]),
                r.lookAt(0, a[t], 0)) : (r.up.set(0, s[t], 0),
                r.lookAt(0, 0, a[t]));
              const l = this._cubeSize;
              No(n, i * l, t > 2 ? l : 0, l, l),
                o.setRenderTarget(n),
              d && o.render(u, r),
                o.render(e, r)
            }
            u.geometry.dispose(),
              u.material.dispose(),
              o.toneMapping = h,
              o.autoClear = l,
              e.background = p
          }
          _textureToCubeUV(e, t) {
            const i = this._renderer
              , n = e.mapping === kn || e.mapping === Fn;
            n ? (null === this._cubemapMaterial && (this._cubemapMaterial = Uo()),
              this._cubemapMaterial.uniforms.flipEnvMap.value = !1 === e.isRenderTargetTexture ? -1 : 1) : null === this._equirectMaterial && (this._equirectMaterial = zo());
            const r = n ? this._cubemapMaterial : this._equirectMaterial
              , s = new Qa(this._lodPlanes[0],r);
            r.uniforms.envMap.value = e;
            const a = this._cubeSize;
            No(t, 0, 0, 3 * a, 2 * a),
              i.setRenderTarget(t),
              i.render(s, Do)
          }
          _applyPMREM(e) {
            const t = this._renderer
              , i = t.autoClear;
            t.autoClear = !1;
            for (let t = 1; t < this._lodPlanes.length; t++) {
              const i = Math.sqrt(this._sigmas[t] * this._sigmas[t] - this._sigmas[t - 1] * this._sigmas[t - 1])
                , n = Fo[(t - 1) % Fo.length];
              this._blur(e, t - 1, t, i, n)
            }
            t.autoClear = i
          }
          _blur(e, t, i, n, r) {
            const s = this._pingPongRenderTarget;
            this._halfBlur(e, s, t, i, n, "latitudinal", r),
              this._halfBlur(s, e, i, i, n, "longitudinal", r)
          }
          _halfBlur(e, t, i, n, r, s, a) {
            const o = this._renderer
              , l = this._blurMaterial;
            "latitudinal" !== s && "longitudinal" !== s && console.error("blur direction must be either latitudinal or longitudinal!");
            const h = new Qa(this._lodPlanes[n],l)
              , c = l.uniforms
              , u = this._sizeLods[i] - 1
              , d = isFinite(r) ? Math.PI / (2 * u) : 2 * Math.PI / 39
              , p = r / d
              , f = isFinite(r) ? 1 + Math.floor(3 * p) : 20;
            f > 20 && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`);
            const m = [];
            let g = 0;
            for (let e = 0; e < 20; ++e) {
              const t = e / p
                , i = Math.exp(-t * t / 2);
              m.push(i),
                0 === e ? g += i : e < f && (g += 2 * i)
            }
            for (let e = 0; e < m.length; e++)
              m[e] = m[e] / g;
            c.envMap.value = e.texture,
              c.samples.value = f,
              c.weights.value = m,
              c.latitudinal.value = "latitudinal" === s,
            a && (c.poleAxis.value = a);
            const {_lodMax: v} = this;
            c.dTheta.value = d,
              c.mipInt.value = v - i;
            const y = this._sizeLods[n];
            No(t, 3 * y * (n > v - 4 ? n - v + 4 : 0), 4 * (this._cubeSize - y), 3 * y, 2 * y),
              o.setRenderTarget(t),
              o.render(h, Do)
          }
        }
        function Oo(e, t, i) {
          const n = new Zr(e,t,i);
          return n.texture.mapping = Bn,
            n.texture.name = "PMREM.cubeUv",
            n.scissorTest = !0,
            n
        }
        function No(e, t, i, n, r) {
          e.viewport.set(t, i, n, r),
            e.scissor.set(t, i, n, r)
        }
        function zo() {
          return new to({
            name: "EquirectangularToCubeUV",
            uniforms: {
              envMap: {
                value: null
              }
            },
            vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
            fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",
            blending: 0,
            depthTest: !1,
            depthWrite: !1
          })
        }
        function Uo() {
          return new to({
            name: "CubemapToCubeUV",
            uniforms: {
              envMap: {
                value: null
              },
              flipEnvMap: {
                value: -1
              }
            },
            vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
            fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
            blending: 0,
            depthTest: !1,
            depthWrite: !1
          })
        }
        function Go(e) {
          let t = new WeakMap
            , i = null;
          function n(e) {
            const i = e.target;
            i.removeEventListener("dispose", n);
            const r = t.get(i);
            void 0 !== r && (t.delete(i),
              r.dispose())
          }
          return {
            get: function(r) {
              if (r && r.isTexture) {
                const s = r.mapping
                  , a = 303 === s || 304 === s
                  , o = s === kn || s === Fn;
                if (a || o) {
                  if (r.isRenderTargetTexture && !0 === r.needsPMREMUpdate) {
                    r.needsPMREMUpdate = !1;
                    let n = t.get(r);
                    return null === i && (i = new Bo(e)),
                      n = a ? i.fromEquirectangular(r, n) : i.fromCubemap(r, n),
                      t.set(r, n),
                      n.texture
                  }
                  if (t.has(r))
                    return t.get(r).texture;
                  {
                    const s = r.image;
                    if (a && s && s.height > 0 || o && s && function(e) {
                      let t = 0;
                      for (let i = 0; i < 6; i++)
                        void 0 !== e[i] && t++;
                      return 6 === t
                    }(s)) {
                      null === i && (i = new Bo(e));
                      const s = a ? i.fromEquirectangular(r) : i.fromCubemap(r);
                      return t.set(r, s),
                        r.addEventListener("dispose", n),
                        s.texture
                    }
                    return null
                  }
                }
              }
              return r
            },
            dispose: function() {
              t = new WeakMap,
              null !== i && (i.dispose(),
                i = null)
            }
          }
        }
        function Vo(e) {
          const t = {};
          function i(i) {
            if (void 0 !== t[i])
              return t[i];
            let n;
            switch (i) {
              case "WEBGL_depth_texture":
                n = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture");
                break;
              case "EXT_texture_filter_anisotropic":
                n = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                break;
              case "WEBGL_compressed_texture_s3tc":
                n = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                break;
              case "WEBGL_compressed_texture_pvrtc":
                n = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                break;
              default:
                n = e.getExtension(i)
            }
            return t[i] = n,
              n
          }
          return {
            has: function(e) {
              return null !== i(e)
            },
            init: function(e) {
              e.isWebGL2 ? i("EXT_color_buffer_float") : (i("WEBGL_depth_texture"),
                i("OES_texture_float"),
                i("OES_texture_half_float"),
                i("OES_texture_half_float_linear"),
                i("OES_standard_derivatives"),
                i("OES_element_index_uint"),
                i("OES_vertex_array_object"),
                i("ANGLE_instanced_arrays")),
                i("OES_texture_float_linear"),
                i("EXT_color_buffer_half_float"),
                i("WEBGL_multisampled_render_to_texture")
            },
            get: function(e) {
              const t = i(e);
              return null === t && console.warn("THREE.WebGLRenderer: " + e + " extension not supported."),
                t
            }
          }
        }
        function Ho(e, t, i, n) {
          const r = {}
            , s = new WeakMap;
          function a(e) {
            const o = e.target;
            null !== o.index && t.remove(o.index);
            for (const e in o.attributes)
              t.remove(o.attributes[e]);
            o.removeEventListener("dispose", a),
              delete r[o.id];
            const l = s.get(o);
            l && (t.remove(l),
              s.delete(o)),
              n.releaseStatesOfGeometry(o),
            !0 === o.isInstancedBufferGeometry && delete o._maxInstanceCount,
              i.memory.geometries--
          }
          function o(e) {
            const i = []
              , n = e.index
              , r = e.attributes.position;
            let a = 0;
            if (null !== n) {
              const e = n.array;
              a = n.version;
              for (let t = 0, n = e.length; t < n; t += 3) {
                const n = e[t + 0]
                  , r = e[t + 1]
                  , s = e[t + 2];
                i.push(n, r, r, s, s, n)
              }
            } else {
              const e = r.array;
              a = r.version;
              for (let t = 0, n = e.length / 3 - 1; t < n; t += 3) {
                const e = t + 0
                  , n = t + 1
                  , r = t + 2;
                i.push(e, n, n, r, r, e)
              }
            }
            const o = new (Rr(i) ? wa : ba)(i,1);
            o.version = a;
            const l = s.get(e);
            l && t.remove(l),
              s.set(e, o)
          }
          return {
            get: function(e, t) {
              return !0 === r[t.id] || (t.addEventListener("dispose", a),
                r[t.id] = !0,
                i.memory.geometries++),
                t
            },
            update: function(e) {
              const i = e.attributes;
              for (const e in i)
                t.update(i[e], 34962);
              const n = e.morphAttributes;
              for (const e in n) {
                const i = n[e];
                for (let e = 0, n = i.length; e < n; e++)
                  t.update(i[e], 34962)
              }
            },
            getWireframeAttribute: function(e) {
              const t = s.get(e);
              if (t) {
                const i = e.index;
                null !== i && t.version < i.version && o(e)
              } else
                o(e);
              return s.get(e)
            }
          }
        }
        function Wo(e, t, i, n) {
          const r = n.isWebGL2;
          let s, a, o;
          this.setMode = function(e) {
            s = e
          }
            ,
            this.setIndex = function(e) {
              a = e.type,
                o = e.bytesPerElement
            }
            ,
            this.render = function(t, n) {
              e.drawElements(s, n, a, t * o),
                i.update(n, s, 1)
            }
            ,
            this.renderInstances = function(n, l, h) {
              if (0 === h)
                return;
              let c, u;
              if (r)
                c = e,
                  u = "drawElementsInstanced";
              else if (c = t.get("ANGLE_instanced_arrays"),
                u = "drawElementsInstancedANGLE",
              null === c)
                return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
              c[u](s, l, a, n * o, h),
                i.update(l, s, h)
            }
        }
        function jo(e) {
          const t = {
            frame: 0,
            calls: 0,
            triangles: 0,
            points: 0,
            lines: 0
          };
          return {
            memory: {
              geometries: 0,
              textures: 0
            },
            render: t,
            programs: null,
            autoReset: !0,
            reset: function() {
              t.frame++,
                t.calls = 0,
                t.triangles = 0,
                t.points = 0,
                t.lines = 0
            },
            update: function(e, i, n) {
              switch (t.calls++,
                i) {
                case 4:
                  t.triangles += n * (e / 3);
                  break;
                case 1:
                  t.lines += n * (e / 2);
                  break;
                case 3:
                  t.lines += n * (e - 1);
                  break;
                case 2:
                  t.lines += n * e;
                  break;
                case 0:
                  t.points += n * e;
                  break;
                default:
                  console.error("THREE.WebGLInfo: Unknown draw mode:", i)
              }
            }
          }
        }
        function Xo(e, t) {
          return e[0] - t[0]
        }
        function Yo(e, t) {
          return Math.abs(t[1]) - Math.abs(e[1])
        }
        function qo(e, t) {
          let i = 1;
          const n = t.isInterleavedBufferAttribute ? t.data.array : t.array;
          n instanceof Int8Array ? i = 127 : n instanceof Int16Array ? i = 32767 : n instanceof Int32Array ? i = 2147483647 : console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ", n),
            e.divideScalar(i)
        }
        function Qo(e, t, i) {
          const n = {}
            , r = new Float32Array(8)
            , s = new WeakMap
            , a = new Jr
            , o = [];
          for (let e = 0; e < 8; e++)
            o[e] = [e, 0];
          return {
            update: function(l, h, c, u) {
              const d = l.morphTargetInfluences;
              if (!0 === t.isWebGL2) {
                const p = h.morphAttributes.position || h.morphAttributes.normal || h.morphAttributes.color
                  , f = void 0 !== p ? p.length : 0;
                let m = s.get(h);
                if (void 0 === m || m.count !== f) {
                  void 0 !== m && m.texture.dispose();
                  const y = void 0 !== h.morphAttributes.position
                    , x = void 0 !== h.morphAttributes.normal
                    , _ = void 0 !== h.morphAttributes.color
                    , b = h.morphAttributes.position || []
                    , w = h.morphAttributes.normal || []
                    , A = h.morphAttributes.color || [];
                  let S = 0;
                  !0 === y && (S = 1),
                  !0 === x && (S = 2),
                  !0 === _ && (S = 3);
                  let M = h.attributes.position.count * S
                    , T = 1;
                  M > t.maxTextureSize && (T = Math.ceil(M / t.maxTextureSize),
                    M = t.maxTextureSize);
                  const E = new Float32Array(M * T * 4 * f)
                    , C = new $r(E,M,T,f);
                  C.type = Yn,
                    C.needsUpdate = !0;
                  const P = 4 * S;
                  for (let I = 0; I < f; I++) {
                    const R = b[I]
                      , L = w[I]
                      , k = A[I]
                      , F = M * T * 4 * I;
                    for (let B = 0; B < R.count; B++) {
                      const O = B * P;
                      !0 === y && (a.fromBufferAttribute(R, B),
                      !0 === R.normalized && qo(a, R),
                        E[F + O + 0] = a.x,
                        E[F + O + 1] = a.y,
                        E[F + O + 2] = a.z,
                        E[F + O + 3] = 0),
                      !0 === x && (a.fromBufferAttribute(L, B),
                      !0 === L.normalized && qo(a, L),
                        E[F + O + 4] = a.x,
                        E[F + O + 5] = a.y,
                        E[F + O + 6] = a.z,
                        E[F + O + 7] = 0),
                      !0 === _ && (a.fromBufferAttribute(k, B),
                      !0 === k.normalized && qo(a, k),
                        E[F + O + 8] = a.x,
                        E[F + O + 9] = a.y,
                        E[F + O + 10] = a.z,
                        E[F + O + 11] = 4 === k.itemSize ? a.w : 1)
                    }
                  }
                  function D() {
                    C.dispose(),
                      s.delete(h),
                      h.removeEventListener("dispose", D)
                  }
                  m = {
                    count: f,
                    texture: C,
                    size: new Dr(M,T)
                  },
                    s.set(h, m),
                    h.addEventListener("dispose", D)
                }
                let g = 0;
                for (let N = 0; N < d.length; N++)
                  g += d[N];
                const v = h.morphTargetsRelative ? 1 : 1 - g;
                u.getUniforms().setValue(e, "morphTargetBaseInfluence", v),
                  u.getUniforms().setValue(e, "morphTargetInfluences", d),
                  u.getUniforms().setValue(e, "morphTargetsTexture", m.texture, i),
                  u.getUniforms().setValue(e, "morphTargetsTextureSize", m.size)
              } else {
                const z = void 0 === d ? 0 : d.length;
                let U = n[h.id];
                if (void 0 === U || U.length !== z) {
                  U = [];
                  for (let j = 0; j < z; j++)
                    U[j] = [j, 0];
                  n[h.id] = U
                }
                for (let X = 0; X < z; X++) {
                  const Y = U[X];
                  Y[0] = X,
                    Y[1] = d[X]
                }
                U.sort(Yo);
                for (let q = 0; q < 8; q++)
                  q < z && U[q][1] ? (o[q][0] = U[q][0],
                    o[q][1] = U[q][1]) : (o[q][0] = Number.MAX_SAFE_INTEGER,
                    o[q][1] = 0);
                o.sort(Xo);
                const G = h.morphAttributes.position
                  , V = h.morphAttributes.normal;
                let H = 0;
                for (let Q = 0; Q < 8; Q++) {
                  const K = o[Q]
                    , J = K[0]
                    , Z = K[1];
                  J !== Number.MAX_SAFE_INTEGER && Z ? (G && h.getAttribute("morphTarget" + Q) !== G[J] && h.setAttribute("morphTarget" + Q, G[J]),
                  V && h.getAttribute("morphNormal" + Q) !== V[J] && h.setAttribute("morphNormal" + Q, V[J]),
                    r[Q] = Z,
                    H += Z) : (G && !0 === h.hasAttribute("morphTarget" + Q) && h.deleteAttribute("morphTarget" + Q),
                  V && !0 === h.hasAttribute("morphNormal" + Q) && h.deleteAttribute("morphNormal" + Q),
                    r[Q] = 0)
                }
                const W = h.morphTargetsRelative ? 1 : 1 - H;
                u.getUniforms().setValue(e, "morphTargetBaseInfluence", W),
                  u.getUniforms().setValue(e, "morphTargetInfluences", r)
              }
            }
          }
        }
        function Ko(e, t, i, n) {
          let r = new WeakMap;
          function s(e) {
            const t = e.target;
            t.removeEventListener("dispose", s),
              i.remove(t.instanceMatrix),
            null !== t.instanceColor && i.remove(t.instanceColor)
          }
          return {
            update: function(e) {
              const a = n.render.frame
                , o = e.geometry
                , l = t.get(e, o);
              return r.get(l) !== a && (t.update(l),
                r.set(l, a)),
              e.isInstancedMesh && (!1 === e.hasEventListener("dispose", s) && e.addEventListener("dispose", s),
                i.update(e.instanceMatrix, 34962),
              null !== e.instanceColor && i.update(e.instanceColor, 34962)),
                l
            },
            dispose: function() {
              r = new WeakMap
            }
          }
        }
        const Jo = new Kr
          , Zo = new $r
          , $o = new class extends Kr {
          constructor(e=null, t=1, i=1, n=1) {
            super(null),
              this.isData3DTexture = !0,
              this.image = {
                data: e,
                width: t,
                height: i,
                depth: n
              },
              this.magFilter = Un,
              this.minFilter = Un,
              this.wrapR = Nn,
              this.generateMipmaps = !1,
              this.flipY = !1,
              this.unpackAlignment = 1
          }
        }
          , el = new ao
          , tl = []
          , il = []
          , nl = new Float32Array(16)
          , rl = new Float32Array(9)
          , sl = new Float32Array(4);
        function al(e, t, i) {
          const n = e[0];
          if (n <= 0 || n > 0)
            return e;
          const r = t * i;
          let s = tl[r];
          if (void 0 === s && (s = new Float32Array(r),
            tl[r] = s),
          0 !== t) {
            n.toArray(s, 0);
            for (let n = 1, r = 0; n !== t; ++n)
              r += i,
                e[n].toArray(s, r)
          }
          return s
        }
        function ol(e, t) {
          if (e.length !== t.length)
            return !1;
          for (let i = 0, n = e.length; i < n; i++)
            if (e[i] !== t[i])
              return !1;
          return !0
        }
        function ll(e, t) {
          for (let i = 0, n = t.length; i < n; i++)
            e[i] = t[i]
        }
        function hl(e, t) {
          let i = il[t];
          void 0 === i && (i = new Int32Array(t),
            il[t] = i);
          for (let n = 0; n !== t; ++n)
            i[n] = e.allocateTextureUnit();
          return i
        }
        function cl(e, t) {
          const i = this.cache;
          i[0] !== t && (e.uniform1f(this.addr, t),
            i[0] = t)
        }
        function ul(e, t) {
          const i = this.cache;
          if (void 0 !== t.x)
            i[0] === t.x && i[1] === t.y || (e.uniform2f(this.addr, t.x, t.y),
              i[0] = t.x,
              i[1] = t.y);
          else {
            if (ol(i, t))
              return;
            e.uniform2fv(this.addr, t),
              ll(i, t)
          }
        }
        function dl(e, t) {
          const i = this.cache;
          if (void 0 !== t.x)
            i[0] === t.x && i[1] === t.y && i[2] === t.z || (e.uniform3f(this.addr, t.x, t.y, t.z),
              i[0] = t.x,
              i[1] = t.y,
              i[2] = t.z);
          else if (void 0 !== t.r)
            i[0] === t.r && i[1] === t.g && i[2] === t.b || (e.uniform3f(this.addr, t.r, t.g, t.b),
              i[0] = t.r,
              i[1] = t.g,
              i[2] = t.b);
          else {
            if (ol(i, t))
              return;
            e.uniform3fv(this.addr, t),
              ll(i, t)
          }
        }
        function pl(e, t) {
          const i = this.cache;
          if (void 0 !== t.x)
            i[0] === t.x && i[1] === t.y && i[2] === t.z && i[3] === t.w || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w),
              i[0] = t.x,
              i[1] = t.y,
              i[2] = t.z,
              i[3] = t.w);
          else {
            if (ol(i, t))
              return;
            e.uniform4fv(this.addr, t),
              ll(i, t)
          }
        }
        function fl(e, t) {
          const i = this.cache
            , n = t.elements;
          if (void 0 === n) {
            if (ol(i, t))
              return;
            e.uniformMatrix2fv(this.addr, !1, t),
              ll(i, t)
          } else {
            if (ol(i, n))
              return;
            sl.set(n),
              e.uniformMatrix2fv(this.addr, !1, sl),
              ll(i, n)
          }
        }
        function ml(e, t) {
          const i = this.cache
            , n = t.elements;
          if (void 0 === n) {
            if (ol(i, t))
              return;
            e.uniformMatrix3fv(this.addr, !1, t),
              ll(i, t)
          } else {
            if (ol(i, n))
              return;
            rl.set(n),
              e.uniformMatrix3fv(this.addr, !1, rl),
              ll(i, n)
          }
        }
        function gl(e, t) {
          const i = this.cache
            , n = t.elements;
          if (void 0 === n) {
            if (ol(i, t))
              return;
            e.uniformMatrix4fv(this.addr, !1, t),
              ll(i, t)
          } else {
            if (ol(i, n))
              return;
            nl.set(n),
              e.uniformMatrix4fv(this.addr, !1, nl),
              ll(i, n)
          }
        }
        function vl(e, t) {
          const i = this.cache;
          i[0] !== t && (e.uniform1i(this.addr, t),
            i[0] = t)
        }
        function yl(e, t) {
          const i = this.cache;
          ol(i, t) || (e.uniform2iv(this.addr, t),
            ll(i, t))
        }
        function xl(e, t) {
          const i = this.cache;
          ol(i, t) || (e.uniform3iv(this.addr, t),
            ll(i, t))
        }
        function _l(e, t) {
          const i = this.cache;
          ol(i, t) || (e.uniform4iv(this.addr, t),
            ll(i, t))
        }
        function bl(e, t) {
          const i = this.cache;
          i[0] !== t && (e.uniform1ui(this.addr, t),
            i[0] = t)
        }
        function wl(e, t) {
          const i = this.cache;
          ol(i, t) || (e.uniform2uiv(this.addr, t),
            ll(i, t))
        }
        function Al(e, t) {
          const i = this.cache;
          ol(i, t) || (e.uniform3uiv(this.addr, t),
            ll(i, t))
        }
        function Sl(e, t) {
          const i = this.cache;
          ol(i, t) || (e.uniform4uiv(this.addr, t),
            ll(i, t))
        }
        function Ml(e, t, i) {
          const n = this.cache
            , r = i.allocateTextureUnit();
          n[0] !== r && (e.uniform1i(this.addr, r),
            n[0] = r),
            i.setTexture2D(t || Jo, r)
        }
        function Tl(e, t, i) {
          const n = this.cache
            , r = i.allocateTextureUnit();
          n[0] !== r && (e.uniform1i(this.addr, r),
            n[0] = r),
            i.setTexture3D(t || $o, r)
        }
        function El(e, t, i) {
          const n = this.cache
            , r = i.allocateTextureUnit();
          n[0] !== r && (e.uniform1i(this.addr, r),
            n[0] = r),
            i.setTextureCube(t || el, r)
        }
        function Cl(e, t, i) {
          const n = this.cache
            , r = i.allocateTextureUnit();
          n[0] !== r && (e.uniform1i(this.addr, r),
            n[0] = r),
            i.setTexture2DArray(t || Zo, r)
        }
        function Pl(e, t) {
          e.uniform1fv(this.addr, t)
        }
        function Dl(e, t) {
          const i = al(t, this.size, 2);
          e.uniform2fv(this.addr, i)
        }
        function Il(e, t) {
          const i = al(t, this.size, 3);
          e.uniform3fv(this.addr, i)
        }
        function Rl(e, t) {
          const i = al(t, this.size, 4);
          e.uniform4fv(this.addr, i)
        }
        function Ll(e, t) {
          const i = al(t, this.size, 4);
          e.uniformMatrix2fv(this.addr, !1, i)
        }
        function kl(e, t) {
          const i = al(t, this.size, 9);
          e.uniformMatrix3fv(this.addr, !1, i)
        }
        function Fl(e, t) {
          const i = al(t, this.size, 16);
          e.uniformMatrix4fv(this.addr, !1, i)
        }
        function Bl(e, t) {
          e.uniform1iv(this.addr, t)
        }
        function Ol(e, t) {
          e.uniform2iv(this.addr, t)
        }
        function Nl(e, t) {
          e.uniform3iv(this.addr, t)
        }
        function zl(e, t) {
          e.uniform4iv(this.addr, t)
        }
        function Ul(e, t) {
          e.uniform1uiv(this.addr, t)
        }
        function Gl(e, t) {
          e.uniform2uiv(this.addr, t)
        }
        function Vl(e, t) {
          e.uniform3uiv(this.addr, t)
        }
        function Hl(e, t) {
          e.uniform4uiv(this.addr, t)
        }
        function Wl(e, t, i) {
          const n = t.length
            , r = hl(i, n);
          e.uniform1iv(this.addr, r);
          for (let e = 0; e !== n; ++e)
            i.setTexture2D(t[e] || Jo, r[e])
        }
        function jl(e, t, i) {
          const n = t.length
            , r = hl(i, n);
          e.uniform1iv(this.addr, r);
          for (let e = 0; e !== n; ++e)
            i.setTexture3D(t[e] || $o, r[e])
        }
        function Xl(e, t, i) {
          const n = t.length
            , r = hl(i, n);
          e.uniform1iv(this.addr, r);
          for (let e = 0; e !== n; ++e)
            i.setTextureCube(t[e] || el, r[e])
        }
        function Yl(e, t, i) {
          const n = t.length
            , r = hl(i, n);
          e.uniform1iv(this.addr, r);
          for (let e = 0; e !== n; ++e)
            i.setTexture2DArray(t[e] || Zo, r[e])
        }
        class ql {
          constructor(e, t, i) {
            this.id = e,
              this.addr = i,
              this.cache = [],
              this.setValue = function(e) {
                switch (e) {
                  case 5126:
                    return cl;
                  case 35664:
                    return ul;
                  case 35665:
                    return dl;
                  case 35666:
                    return pl;
                  case 35674:
                    return fl;
                  case 35675:
                    return ml;
                  case 35676:
                    return gl;
                  case 5124:
                  case 35670:
                    return vl;
                  case 35667:
                  case 35671:
                    return yl;
                  case 35668:
                  case 35672:
                    return xl;
                  case 35669:
                  case 35673:
                    return _l;
                  case 5125:
                    return bl;
                  case 36294:
                    return wl;
                  case 36295:
                    return Al;
                  case 36296:
                    return Sl;
                  case 35678:
                  case 36198:
                  case 36298:
                  case 36306:
                  case 35682:
                    return Ml;
                  case 35679:
                  case 36299:
                  case 36307:
                    return Tl;
                  case 35680:
                  case 36300:
                  case 36308:
                  case 36293:
                    return El;
                  case 36289:
                  case 36303:
                  case 36311:
                  case 36292:
                    return Cl
                }
              }(t.type)
          }
        }
        class Ql {
          constructor(e, t, i) {
            this.id = e,
              this.addr = i,
              this.cache = [],
              this.size = t.size,
              this.setValue = function(e) {
                switch (e) {
                  case 5126:
                    return Pl;
                  case 35664:
                    return Dl;
                  case 35665:
                    return Il;
                  case 35666:
                    return Rl;
                  case 35674:
                    return Ll;
                  case 35675:
                    return kl;
                  case 35676:
                    return Fl;
                  case 5124:
                  case 35670:
                    return Bl;
                  case 35667:
                  case 35671:
                    return Ol;
                  case 35668:
                  case 35672:
                    return Nl;
                  case 35669:
                  case 35673:
                    return zl;
                  case 5125:
                    return Ul;
                  case 36294:
                    return Gl;
                  case 36295:
                    return Vl;
                  case 36296:
                    return Hl;
                  case 35678:
                  case 36198:
                  case 36298:
                  case 36306:
                  case 35682:
                    return Wl;
                  case 35679:
                  case 36299:
                  case 36307:
                    return jl;
                  case 35680:
                  case 36300:
                  case 36308:
                  case 36293:
                    return Xl;
                  case 36289:
                  case 36303:
                  case 36311:
                  case 36292:
                    return Yl
                }
              }(t.type)
          }
        }
        class Kl {
          constructor(e) {
            this.id = e,
              this.seq = [],
              this.map = {}
          }
          setValue(e, t, i) {
            const n = this.seq;
            for (let r = 0, s = n.length; r !== s; ++r) {
              const s = n[r];
              s.setValue(e, t[s.id], i)
            }
          }
        }
        const Jl = /(\w+)(\])?(\[|\.)?/g;
        function Zl(e, t) {
          e.seq.push(t),
            e.map[t.id] = t
        }
        function $l(e, t, i) {
          const n = e.name
            , r = n.length;
          for (Jl.lastIndex = 0; ; ) {
            const s = Jl.exec(n)
              , a = Jl.lastIndex;
            let o = s[1];
            const l = "]" === s[2]
              , h = s[3];
            if (l && (o |= 0),
            void 0 === h || "[" === h && a + 2 === r) {
              Zl(i, void 0 === h ? new ql(o,e,t) : new Ql(o,e,t));
              break
            }
            {
              let e = i.map[o];
              void 0 === e && (e = new Kl(o),
                Zl(i, e)),
                i = e
            }
          }
        }
        class eh {
          constructor(e, t) {
            this.seq = [],
              this.map = {};
            const i = e.getProgramParameter(t, 35718);
            for (let n = 0; n < i; ++n) {
              const i = e.getActiveUniform(t, n);
              $l(i, e.getUniformLocation(t, i.name), this)
            }
          }
          setValue(e, t, i, n) {
            const r = this.map[t];
            void 0 !== r && r.setValue(e, i, n)
          }
          setOptional(e, t, i) {
            const n = t[i];
            void 0 !== n && this.setValue(e, i, n)
          }
          static upload(e, t, i, n) {
            for (let r = 0, s = t.length; r !== s; ++r) {
              const s = t[r]
                , a = i[s.id];
              !1 !== a.needsUpdate && s.setValue(e, a.value, n)
            }
          }
          static seqWithValue(e, t) {
            const i = [];
            for (let n = 0, r = e.length; n !== r; ++n) {
              const r = e[n];
              r.id in t && i.push(r)
            }
            return i
          }
        }
        function th(e, t, i) {
          const n = e.createShader(t);
          return e.shaderSource(n, i),
            e.compileShader(n),
            n
        }
        let ih = 0;
        function nh(e, t, i) {
          const n = e.getShaderParameter(t, 35713)
            , r = e.getShaderInfoLog(t).trim();
          if (n && "" === r)
            return "";
          const s = /ERROR: 0:(\d+)/.exec(r);
          if (s) {
            const n = parseInt(s[1]);
            return i.toUpperCase() + "\n\n" + r + "\n\n" + function(e, t) {
              const i = e.split("\n")
                , n = []
                , r = Math.max(t - 6, 0)
                , s = Math.min(t + 6, i.length);
              for (let e = r; e < s; e++) {
                const r = e + 1;
                n.push(`${r === t ? ">" : " "} ${r}: ${i[e]}`)
              }
              return n.join("\n")
            }(e.getShaderSource(t), n)
          }
          return r
        }
        function rh(e, t) {
          const i = function(e) {
            switch (e) {
              case hr:
                return ["Linear", "( value )"];
              case cr:
                return ["sRGB", "( value )"];
              default:
                return console.warn("THREE.WebGLProgram: Unsupported encoding:", e),
                  ["Linear", "( value )"]
            }
          }(t);
          return "vec4 " + e + "( vec4 value ) { return LinearTo" + i[0] + i[1] + "; }"
        }
        function sh(e, t) {
          let i;
          switch (t) {
            case 1:
              i = "Linear";
              break;
            case 2:
              i = "Reinhard";
              break;
            case 3:
              i = "OptimizedCineon";
              break;
            case 4:
              i = "ACESFilmic";
              break;
            case 5:
              i = "Custom";
              break;
            default:
              console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t),
                i = "Linear"
          }
          return "vec3 " + e + "( vec3 color ) { return " + i + "ToneMapping( color ); }"
        }
        function ah(e) {
          return "" !== e
        }
        function oh(e, t) {
          return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows)
        }
        function lh(e, t) {
          return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection)
        }
        const hh = /^[ \t]*#include +<([\w\d./]+)>/gm;
        function ch(e) {
          return e.replace(hh, uh)
        }
        function uh(e, t) {
          const i = xo[t];
          if (void 0 === i)
            throw new Error("Can not resolve #include <" + t + ">");
          return ch(i)
        }
        const dh = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g
          , ph = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
        function fh(e) {
          return e.replace(ph, gh).replace(dh, mh)
        }
        function mh(e, t, i, n) {
          return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),
            gh(0, t, i, n)
        }
        function gh(e, t, i, n) {
          let r = "";
          for (let e = parseInt(t); e < parseInt(i); e++)
            r += n.replace(/\[\s*i\s*\]/g, "[ " + e + " ]").replace(/UNROLLED_LOOP_INDEX/g, e);
          return r
        }
        function vh(e) {
          let t = "precision " + e.precision + " float;\nprecision " + e.precision + " int;";
          return "highp" === e.precision ? t += "\n#define HIGH_PRECISION" : "mediump" === e.precision ? t += "\n#define MEDIUM_PRECISION" : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"),
            t
        }
        function yh(e, t, i, n) {
          const r = e.getContext()
            , s = i.defines;
          let a = i.vertexShader
            , o = i.fragmentShader;
          const l = function(e) {
            let t = "SHADOWMAP_TYPE_BASIC";
            return 1 === e.shadowMapType ? t = "SHADOWMAP_TYPE_PCF" : 2 === e.shadowMapType ? t = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === e.shadowMapType && (t = "SHADOWMAP_TYPE_VSM"),
              t
          }(i)
            , h = function(e) {
            let t = "ENVMAP_TYPE_CUBE";
            if (e.envMap)
              switch (e.envMapMode) {
                case kn:
                case Fn:
                  t = "ENVMAP_TYPE_CUBE";
                  break;
                case Bn:
                  t = "ENVMAP_TYPE_CUBE_UV"
              }
            return t
          }(i)
            , c = function(e) {
            let t = "ENVMAP_MODE_REFLECTION";
            return e.envMap && e.envMapMode === Fn && (t = "ENVMAP_MODE_REFRACTION"),
              t
          }(i)
            , u = function(e) {
            let t = "ENVMAP_BLENDING_NONE";
            if (e.envMap)
              switch (e.combine) {
                case 0:
                  t = "ENVMAP_BLENDING_MULTIPLY";
                  break;
                case 1:
                  t = "ENVMAP_BLENDING_MIX";
                  break;
                case 2:
                  t = "ENVMAP_BLENDING_ADD"
              }
            return t
          }(i)
            , d = function(e) {
            const t = e.envMapCubeUVHeight;
            if (null === t)
              return null;
            const i = Math.log2(t) - 2
              , n = 1 / t;
            return {
              texelWidth: 1 / (3 * Math.max(Math.pow(2, i), 112)),
              texelHeight: n,
              maxMip: i
            }
          }(i)
            , p = i.isWebGL2 ? "" : function(e) {
            return [e.extensionDerivatives || e.envMapCubeUVHeight || e.bumpMap || e.tangentSpaceNormalMap || e.clearcoatNormalMap || e.flatShading || "physical" === e.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (e.extensionFragDepth || e.logarithmicDepthBuffer) && e.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", e.extensionDrawBuffers && e.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (e.extensionShaderTextureLOD || e.envMap || e.transmission) && e.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(ah).join("\n")
          }(i)
            , f = function(e) {
            const t = [];
            for (const i in e) {
              const n = e[i];
              !1 !== n && t.push("#define " + i + " " + n)
            }
            return t.join("\n")
          }(s)
            , m = r.createProgram();
          let g, v, y = i.glslVersion ? "#version " + i.glslVersion + "\n" : "";
          i.isRawShaderMaterial ? (g = [f].filter(ah).join("\n"),
          g.length > 0 && (g += "\n"),
            v = [p, f].filter(ah).join("\n"),
          v.length > 0 && (v += "\n")) : (g = [vh(i), "#define SHADER_NAME " + i.shaderName, f, i.instancing ? "#define USE_INSTANCING" : "", i.instancingColor ? "#define USE_INSTANCING_COLOR" : "", i.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", i.useFog && i.fog ? "#define USE_FOG" : "", i.useFog && i.fogExp2 ? "#define FOG_EXP2" : "", i.map ? "#define USE_MAP" : "", i.envMap ? "#define USE_ENVMAP" : "", i.envMap ? "#define " + c : "", i.lightMap ? "#define USE_LIGHTMAP" : "", i.aoMap ? "#define USE_AOMAP" : "", i.emissiveMap ? "#define USE_EMISSIVEMAP" : "", i.bumpMap ? "#define USE_BUMPMAP" : "", i.normalMap ? "#define USE_NORMALMAP" : "", i.normalMap && i.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", i.normalMap && i.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", i.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", i.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", i.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", i.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", i.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", i.displacementMap && i.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", i.specularMap ? "#define USE_SPECULARMAP" : "", i.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", i.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", i.metalnessMap ? "#define USE_METALNESSMAP" : "", i.alphaMap ? "#define USE_ALPHAMAP" : "", i.transmission ? "#define USE_TRANSMISSION" : "", i.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", i.thicknessMap ? "#define USE_THICKNESSMAP" : "", i.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", i.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", i.vertexTangents ? "#define USE_TANGENT" : "", i.vertexColors ? "#define USE_COLOR" : "", i.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", i.vertexUvs ? "#define USE_UV" : "", i.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", i.flatShading ? "#define FLAT_SHADED" : "", i.skinning ? "#define USE_SKINNING" : "", i.morphTargets ? "#define USE_MORPHTARGETS" : "", i.morphNormals && !1 === i.flatShading ? "#define USE_MORPHNORMALS" : "", i.morphColors && i.isWebGL2 ? "#define USE_MORPHCOLORS" : "", i.morphTargetsCount > 0 && i.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", i.morphTargetsCount > 0 && i.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + i.morphTextureStride : "", i.morphTargetsCount > 0 && i.isWebGL2 ? "#define MORPHTARGETS_COUNT " + i.morphTargetsCount : "", i.doubleSided ? "#define DOUBLE_SIDED" : "", i.flipSided ? "#define FLIP_SIDED" : "", i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", i.shadowMapEnabled ? "#define " + l : "", i.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", i.logarithmicDepthBuffer && i.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(ah).join("\n"),
            v = [p, vh(i), "#define SHADER_NAME " + i.shaderName, f, i.useFog && i.fog ? "#define USE_FOG" : "", i.useFog && i.fogExp2 ? "#define FOG_EXP2" : "", i.map ? "#define USE_MAP" : "", i.matcap ? "#define USE_MATCAP" : "", i.envMap ? "#define USE_ENVMAP" : "", i.envMap ? "#define " + h : "", i.envMap ? "#define " + c : "", i.envMap ? "#define " + u : "", d ? "#define CUBEUV_TEXEL_WIDTH " + d.texelWidth : "", d ? "#define CUBEUV_TEXEL_HEIGHT " + d.texelHeight : "", d ? "#define CUBEUV_MAX_MIP " + d.maxMip + ".0" : "", i.lightMap ? "#define USE_LIGHTMAP" : "", i.aoMap ? "#define USE_AOMAP" : "", i.emissiveMap ? "#define USE_EMISSIVEMAP" : "", i.bumpMap ? "#define USE_BUMPMAP" : "", i.normalMap ? "#define USE_NORMALMAP" : "", i.normalMap && i.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", i.normalMap && i.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", i.clearcoat ? "#define USE_CLEARCOAT" : "", i.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", i.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", i.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", i.iridescence ? "#define USE_IRIDESCENCE" : "", i.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", i.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", i.specularMap ? "#define USE_SPECULARMAP" : "", i.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", i.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", i.metalnessMap ? "#define USE_METALNESSMAP" : "", i.alphaMap ? "#define USE_ALPHAMAP" : "", i.alphaTest ? "#define USE_ALPHATEST" : "", i.sheen ? "#define USE_SHEEN" : "", i.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", i.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", i.transmission ? "#define USE_TRANSMISSION" : "", i.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", i.thicknessMap ? "#define USE_THICKNESSMAP" : "", i.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", i.vertexTangents ? "#define USE_TANGENT" : "", i.vertexColors || i.instancingColor ? "#define USE_COLOR" : "", i.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", i.vertexUvs ? "#define USE_UV" : "", i.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", i.gradientMap ? "#define USE_GRADIENTMAP" : "", i.flatShading ? "#define FLAT_SHADED" : "", i.doubleSided ? "#define DOUBLE_SIDED" : "", i.flipSided ? "#define FLIP_SIDED" : "", i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", i.shadowMapEnabled ? "#define " + l : "", i.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", i.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", i.logarithmicDepthBuffer && i.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", 0 !== i.toneMapping ? "#define TONE_MAPPING" : "", 0 !== i.toneMapping ? xo.tonemapping_pars_fragment : "", 0 !== i.toneMapping ? sh("toneMapping", i.toneMapping) : "", i.dithering ? "#define DITHERING" : "", i.opaque ? "#define OPAQUE" : "", xo.encodings_pars_fragment, rh("linearToOutputTexel", i.outputEncoding), i.useDepthPacking ? "#define DEPTH_PACKING " + i.depthPacking : "", "\n"].filter(ah).join("\n")),
            a = ch(a),
            a = oh(a, i),
            a = lh(a, i),
            o = ch(o),
            o = oh(o, i),
            o = lh(o, i),
            a = fh(a),
            o = fh(o),
          i.isWebGL2 && !0 !== i.isRawShaderMaterial && (y = "#version 300 es\n",
            g = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + g,
            v = ["#define varying in", i.glslVersion === mr ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", i.glslVersion === mr ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + v);
          const x = y + v + o
            , _ = th(r, 35633, y + g + a)
            , b = th(r, 35632, x);
          if (r.attachShader(m, _),
            r.attachShader(m, b),
            void 0 !== i.index0AttributeName ? r.bindAttribLocation(m, 0, i.index0AttributeName) : !0 === i.morphTargets && r.bindAttribLocation(m, 0, "position"),
            r.linkProgram(m),
            e.debug.checkShaderErrors) {
            const e = r.getProgramInfoLog(m).trim()
              , t = r.getShaderInfoLog(_).trim()
              , i = r.getShaderInfoLog(b).trim();
            let n = !0
              , s = !0;
            if (!1 === r.getProgramParameter(m, 35714)) {
              n = !1;
              const t = nh(r, _, "vertex")
                , i = nh(r, b, "fragment");
              console.error("THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(m, 35715) + "\n\nProgram Info Log: " + e + "\n" + t + "\n" + i)
            } else
              "" !== e ? console.warn("THREE.WebGLProgram: Program Info Log:", e) : "" !== t && "" !== i || (s = !1);
            s && (this.diagnostics = {
              runnable: n,
              programLog: e,
              vertexShader: {
                log: t,
                prefix: g
              },
              fragmentShader: {
                log: i,
                prefix: v
              }
            })
          }
          let w, A;
          return r.deleteShader(_),
            r.deleteShader(b),
            this.getUniforms = function() {
              return void 0 === w && (w = new eh(r,m)),
                w
            }
            ,
            this.getAttributes = function() {
              return void 0 === A && (A = function(e, t) {
                const i = {}
                  , n = e.getProgramParameter(t, 35721);
                for (let r = 0; r < n; r++) {
                  const n = e.getActiveAttrib(t, r)
                    , s = n.name;
                  let a = 1;
                  35674 === n.type && (a = 2),
                  35675 === n.type && (a = 3),
                  35676 === n.type && (a = 4),
                    i[s] = {
                      type: n.type,
                      location: e.getAttribLocation(t, s),
                      locationSize: a
                    }
                }
                return i
              }(r, m)),
                A
            }
            ,
            this.destroy = function() {
              n.releaseStatesOfProgram(this),
                r.deleteProgram(m),
                this.program = void 0
            }
            ,
            this.name = i.shaderName,
            this.id = ih++,
            this.cacheKey = t,
            this.usedTimes = 1,
            this.program = m,
            this.vertexShader = _,
            this.fragmentShader = b,
            this
        }
        let xh = 0;
        class _h {
          constructor() {
            this.shaderCache = new Map,
              this.materialCache = new Map
          }
          update(e) {
            const t = e.vertexShader
              , i = e.fragmentShader
              , n = this._getShaderStage(t)
              , r = this._getShaderStage(i)
              , s = this._getShaderCacheForMaterial(e);
            return !1 === s.has(n) && (s.add(n),
              n.usedTimes++),
            !1 === s.has(r) && (s.add(r),
              r.usedTimes++),
              this
          }
          remove(e) {
            const t = this.materialCache.get(e);
            for (const e of t)
              e.usedTimes--,
              0 === e.usedTimes && this.shaderCache.delete(e.code);
            return this.materialCache.delete(e),
              this
          }
          getVertexShaderID(e) {
            return this._getShaderStage(e.vertexShader).id
          }
          getFragmentShaderID(e) {
            return this._getShaderStage(e.fragmentShader).id
          }
          dispose() {
            this.shaderCache.clear(),
              this.materialCache.clear()
          }
          _getShaderCacheForMaterial(e) {
            const t = this.materialCache;
            return !1 === t.has(e) && t.set(e, new Set),
              t.get(e)
          }
          _getShaderStage(e) {
            const t = this.shaderCache;
            if (!1 === t.has(e)) {
              const i = new bh(e);
              t.set(e, i)
            }
            return t.get(e)
          }
        }
        class bh {
          constructor(e) {
            this.id = xh++,
              this.code = e,
              this.usedTimes = 0
          }
        }
        function wh(e, t, i, n, r, s, a) {
          const o = new Hs
            , l = new _h
            , h = []
            , c = r.isWebGL2
            , u = r.logarithmicDepthBuffer
            , d = r.vertexTextures;
          let p = r.precision;
          const f = {
            MeshDepthMaterial: "depth",
            MeshDistanceMaterial: "distanceRGBA",
            MeshNormalMaterial: "normal",
            MeshBasicMaterial: "basic",
            MeshLambertMaterial: "lambert",
            MeshPhongMaterial: "phong",
            MeshToonMaterial: "toon",
            MeshStandardMaterial: "physical",
            MeshPhysicalMaterial: "physical",
            MeshMatcapMaterial: "matcap",
            LineBasicMaterial: "basic",
            LineDashedMaterial: "dashed",
            PointsMaterial: "points",
            ShadowMaterial: "shadow",
            SpriteMaterial: "sprite"
          };
          return {
            getParameters: function(s, o, h, m, g) {
              const v = m.fog
                , y = g.geometry
                , x = s.isMeshStandardMaterial ? m.environment : null
                , _ = (s.isMeshStandardMaterial ? i : t).get(s.envMap || x)
                , b = _ && _.mapping === Bn ? _.image.height : null
                , w = f[s.type];
              null !== s.precision && (p = r.getMaxPrecision(s.precision),
              p !== s.precision && console.warn("THREE.WebGLProgram.getParameters:", s.precision, "not supported, using", p, "instead."));
              const A = y.morphAttributes.position || y.morphAttributes.normal || y.morphAttributes.color
                , S = void 0 !== A ? A.length : 0;
              let M, T, E, C, P = 0;
              if (void 0 !== y.morphAttributes.position && (P = 1),
              void 0 !== y.morphAttributes.normal && (P = 2),
              void 0 !== y.morphAttributes.color && (P = 3),
                w) {
                const e = bo[w];
                M = e.vertexShader,
                  T = e.fragmentShader
              } else
                M = s.vertexShader,
                  T = s.fragmentShader,
                  l.update(s),
                  E = l.getVertexShaderID(s),
                  C = l.getFragmentShaderID(s);
              const D = e.getRenderTarget()
                , I = s.alphaTest > 0
                , R = s.clearcoat > 0
                , L = s.iridescence > 0;
              return {
                isWebGL2: c,
                shaderID: w,
                shaderName: s.type,
                vertexShader: M,
                fragmentShader: T,
                defines: s.defines,
                customVertexShaderID: E,
                customFragmentShaderID: C,
                isRawShaderMaterial: !0 === s.isRawShaderMaterial,
                glslVersion: s.glslVersion,
                precision: p,
                instancing: !0 === g.isInstancedMesh,
                instancingColor: !0 === g.isInstancedMesh && null !== g.instanceColor,
                supportsVertexTextures: d,
                outputEncoding: null === D ? e.outputEncoding : !0 === D.isXRRenderTarget ? D.texture.encoding : hr,
                map: !!s.map,
                matcap: !!s.matcap,
                envMap: !!_,
                envMapMode: _ && _.mapping,
                envMapCubeUVHeight: b,
                lightMap: !!s.lightMap,
                aoMap: !!s.aoMap,
                emissiveMap: !!s.emissiveMap,
                bumpMap: !!s.bumpMap,
                normalMap: !!s.normalMap,
                objectSpaceNormalMap: 1 === s.normalMapType,
                tangentSpaceNormalMap: 0 === s.normalMapType,
                decodeVideoTexture: !!s.map && !0 === s.map.isVideoTexture && s.map.encoding === cr,
                clearcoat: R,
                clearcoatMap: R && !!s.clearcoatMap,
                clearcoatRoughnessMap: R && !!s.clearcoatRoughnessMap,
                clearcoatNormalMap: R && !!s.clearcoatNormalMap,
                iridescence: L,
                iridescenceMap: L && !!s.iridescenceMap,
                iridescenceThicknessMap: L && !!s.iridescenceThicknessMap,
                displacementMap: !!s.displacementMap,
                roughnessMap: !!s.roughnessMap,
                metalnessMap: !!s.metalnessMap,
                specularMap: !!s.specularMap,
                specularIntensityMap: !!s.specularIntensityMap,
                specularColorMap: !!s.specularColorMap,
                opaque: !1 === s.transparent && 1 === s.blending,
                alphaMap: !!s.alphaMap,
                alphaTest: I,
                gradientMap: !!s.gradientMap,
                sheen: s.sheen > 0,
                sheenColorMap: !!s.sheenColorMap,
                sheenRoughnessMap: !!s.sheenRoughnessMap,
                transmission: s.transmission > 0,
                transmissionMap: !!s.transmissionMap,
                thicknessMap: !!s.thicknessMap,
                combine: s.combine,
                vertexTangents: !!s.normalMap && !!y.attributes.tangent,
                vertexColors: s.vertexColors,
                vertexAlphas: !0 === s.vertexColors && !!y.attributes.color && 4 === y.attributes.color.itemSize,
                vertexUvs: !!(s.map || s.bumpMap || s.normalMap || s.specularMap || s.alphaMap || s.emissiveMap || s.roughnessMap || s.metalnessMap || s.clearcoatMap || s.clearcoatRoughnessMap || s.clearcoatNormalMap || s.iridescenceMap || s.iridescenceThicknessMap || s.displacementMap || s.transmissionMap || s.thicknessMap || s.specularIntensityMap || s.specularColorMap || s.sheenColorMap || s.sheenRoughnessMap),
                uvsVertexOnly: !(s.map || s.bumpMap || s.normalMap || s.specularMap || s.alphaMap || s.emissiveMap || s.roughnessMap || s.metalnessMap || s.clearcoatNormalMap || s.iridescenceMap || s.iridescenceThicknessMap || s.transmission > 0 || s.transmissionMap || s.thicknessMap || s.specularIntensityMap || s.specularColorMap || s.sheen > 0 || s.sheenColorMap || s.sheenRoughnessMap || !s.displacementMap),
                fog: !!v,
                useFog: !0 === s.fog,
                fogExp2: v && v.isFogExp2,
                flatShading: !!s.flatShading,
                sizeAttenuation: s.sizeAttenuation,
                logarithmicDepthBuffer: u,
                skinning: !0 === g.isSkinnedMesh,
                morphTargets: void 0 !== y.morphAttributes.position,
                morphNormals: void 0 !== y.morphAttributes.normal,
                morphColors: void 0 !== y.morphAttributes.color,
                morphTargetsCount: S,
                morphTextureStride: P,
                numDirLights: o.directional.length,
                numPointLights: o.point.length,
                numSpotLights: o.spot.length,
                numRectAreaLights: o.rectArea.length,
                numHemiLights: o.hemi.length,
                numDirLightShadows: o.directionalShadowMap.length,
                numPointLightShadows: o.pointShadowMap.length,
                numSpotLightShadows: o.spotShadowMap.length,
                numClippingPlanes: a.numPlanes,
                numClipIntersection: a.numIntersection,
                dithering: s.dithering,
                shadowMapEnabled: e.shadowMap.enabled && h.length > 0,
                shadowMapType: e.shadowMap.type,
                toneMapping: s.toneMapped ? e.toneMapping : 0,
                physicallyCorrectLights: e.physicallyCorrectLights,
                premultipliedAlpha: s.premultipliedAlpha,
                doubleSided: 2 === s.side,
                flipSided: 1 === s.side,
                useDepthPacking: !!s.depthPacking,
                depthPacking: s.depthPacking || 0,
                index0AttributeName: s.index0AttributeName,
                extensionDerivatives: s.extensions && s.extensions.derivatives,
                extensionFragDepth: s.extensions && s.extensions.fragDepth,
                extensionDrawBuffers: s.extensions && s.extensions.drawBuffers,
                extensionShaderTextureLOD: s.extensions && s.extensions.shaderTextureLOD,
                rendererExtensionFragDepth: c || n.has("EXT_frag_depth"),
                rendererExtensionDrawBuffers: c || n.has("WEBGL_draw_buffers"),
                rendererExtensionShaderTextureLod: c || n.has("EXT_shader_texture_lod"),
                customProgramCacheKey: s.customProgramCacheKey()
              }
            },
            getProgramCacheKey: function(t) {
              const i = [];
              if (t.shaderID ? i.push(t.shaderID) : (i.push(t.customVertexShaderID),
                i.push(t.customFragmentShaderID)),
              void 0 !== t.defines)
                for (const e in t.defines)
                  i.push(e),
                    i.push(t.defines[e]);
              return !1 === t.isRawShaderMaterial && (function(e, t) {
                e.push(t.precision),
                  e.push(t.outputEncoding),
                  e.push(t.envMapMode),
                  e.push(t.envMapCubeUVHeight),
                  e.push(t.combine),
                  e.push(t.vertexUvs),
                  e.push(t.fogExp2),
                  e.push(t.sizeAttenuation),
                  e.push(t.morphTargetsCount),
                  e.push(t.morphAttributeCount),
                  e.push(t.numDirLights),
                  e.push(t.numPointLights),
                  e.push(t.numSpotLights),
                  e.push(t.numHemiLights),
                  e.push(t.numRectAreaLights),
                  e.push(t.numDirLightShadows),
                  e.push(t.numPointLightShadows),
                  e.push(t.numSpotLightShadows),
                  e.push(t.shadowMapType),
                  e.push(t.toneMapping),
                  e.push(t.numClippingPlanes),
                  e.push(t.numClipIntersection),
                  e.push(t.depthPacking)
              }(i, t),
                function(e, t) {
                  o.disableAll(),
                  t.isWebGL2 && o.enable(0),
                  t.supportsVertexTextures && o.enable(1),
                  t.instancing && o.enable(2),
                  t.instancingColor && o.enable(3),
                  t.map && o.enable(4),
                  t.matcap && o.enable(5),
                  t.envMap && o.enable(6),
                  t.lightMap && o.enable(7),
                  t.aoMap && o.enable(8),
                  t.emissiveMap && o.enable(9),
                  t.bumpMap && o.enable(10),
                  t.normalMap && o.enable(11),
                  t.objectSpaceNormalMap && o.enable(12),
                  t.tangentSpaceNormalMap && o.enable(13),
                  t.clearcoat && o.enable(14),
                  t.clearcoatMap && o.enable(15),
                  t.clearcoatRoughnessMap && o.enable(16),
                  t.clearcoatNormalMap && o.enable(17),
                  t.iridescence && o.enable(18),
                  t.iridescenceMap && o.enable(19),
                  t.iridescenceThicknessMap && o.enable(20),
                  t.displacementMap && o.enable(21),
                  t.specularMap && o.enable(22),
                  t.roughnessMap && o.enable(23),
                  t.metalnessMap && o.enable(24),
                  t.gradientMap && o.enable(25),
                  t.alphaMap && o.enable(26),
                  t.alphaTest && o.enable(27),
                  t.vertexColors && o.enable(28),
                  t.vertexAlphas && o.enable(29),
                  t.vertexUvs && o.enable(30),
                  t.vertexTangents && o.enable(31),
                  t.uvsVertexOnly && o.enable(32),
                  t.fog && o.enable(33),
                    e.push(o.mask),
                    o.disableAll(),
                  t.useFog && o.enable(0),
                  t.flatShading && o.enable(1),
                  t.logarithmicDepthBuffer && o.enable(2),
                  t.skinning && o.enable(3),
                  t.morphTargets && o.enable(4),
                  t.morphNormals && o.enable(5),
                  t.morphColors && o.enable(6),
                  t.premultipliedAlpha && o.enable(7),
                  t.shadowMapEnabled && o.enable(8),
                  t.physicallyCorrectLights && o.enable(9),
                  t.doubleSided && o.enable(10),
                  t.flipSided && o.enable(11),
                  t.useDepthPacking && o.enable(12),
                  t.dithering && o.enable(13),
                  t.specularIntensityMap && o.enable(14),
                  t.specularColorMap && o.enable(15),
                  t.transmission && o.enable(16),
                  t.transmissionMap && o.enable(17),
                  t.thicknessMap && o.enable(18),
                  t.sheen && o.enable(19),
                  t.sheenColorMap && o.enable(20),
                  t.sheenRoughnessMap && o.enable(21),
                  t.decodeVideoTexture && o.enable(22),
                  t.opaque && o.enable(23),
                    e.push(o.mask)
                }(i, t),
                i.push(e.outputEncoding)),
                i.push(t.customProgramCacheKey),
                i.join()
            },
            getUniforms: function(e) {
              const t = f[e.type];
              let i;
              if (t) {
                const e = bo[t];
                i = eo.clone(e.uniforms)
              } else
                i = e.uniforms;
              return i
            },
            acquireProgram: function(t, i) {
              let n;
              for (let e = 0, t = h.length; e < t; e++) {
                const t = h[e];
                if (t.cacheKey === i) {
                  n = t,
                    ++n.usedTimes;
                  break
                }
              }
              return void 0 === n && (n = new yh(e,i,t,s),
                h.push(n)),
                n
            },
            releaseProgram: function(e) {
              if (0 == --e.usedTimes) {
                const t = h.indexOf(e);
                h[t] = h[h.length - 1],
                  h.pop(),
                  e.destroy()
              }
            },
            releaseShaderCache: function(e) {
              l.remove(e)
            },
            programs: h,
            dispose: function() {
              l.dispose()
            }
          }
        }
        function Ah() {
          let e = new WeakMap;
          return {
            get: function(t) {
              let i = e.get(t);
              return void 0 === i && (i = {},
                e.set(t, i)),
                i
            },
            remove: function(t) {
              e.delete(t)
            },
            update: function(t, i, n) {
              e.get(t)[i] = n
            },
            dispose: function() {
              e = new WeakMap
            }
          }
        }
        function Sh(e, t) {
          return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id
        }
        function Mh(e, t) {
          return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id
        }
        function Th() {
          const e = [];
          let t = 0;
          const i = []
            , n = []
            , r = [];
          function s(i, n, r, s, a, o) {
            let l = e[t];
            return void 0 === l ? (l = {
              id: i.id,
              object: i,
              geometry: n,
              material: r,
              groupOrder: s,
              renderOrder: i.renderOrder,
              z: a,
              group: o
            },
              e[t] = l) : (l.id = i.id,
              l.object = i,
              l.geometry = n,
              l.material = r,
              l.groupOrder = s,
              l.renderOrder = i.renderOrder,
              l.z = a,
              l.group = o),
              t++,
              l
          }
          return {
            opaque: i,
            transmissive: n,
            transparent: r,
            init: function() {
              t = 0,
                i.length = 0,
                n.length = 0,
                r.length = 0
            },
            push: function(e, t, a, o, l, h) {
              const c = s(e, t, a, o, l, h);
              a.transmission > 0 ? n.push(c) : !0 === a.transparent ? r.push(c) : i.push(c)
            },
            unshift: function(e, t, a, o, l, h) {
              const c = s(e, t, a, o, l, h);
              a.transmission > 0 ? n.unshift(c) : !0 === a.transparent ? r.unshift(c) : i.unshift(c)
            },
            finish: function() {
              for (let i = t, n = e.length; i < n; i++) {
                const t = e[i];
                if (null === t.id)
                  break;
                t.id = null,
                  t.object = null,
                  t.geometry = null,
                  t.material = null,
                  t.group = null
              }
            },
            sort: function(e, t) {
              i.length > 1 && i.sort(e || Sh),
              n.length > 1 && n.sort(t || Mh),
              r.length > 1 && r.sort(t || Mh)
            }
          }
        }
        function Eh() {
          let e = new WeakMap;
          return {
            get: function(t, i) {
              let n;
              return !1 === e.has(t) ? (n = new Th,
                e.set(t, [n])) : i >= e.get(t).length ? (n = new Th,
                e.get(t).push(n)) : n = e.get(t)[i],
                n
            },
            dispose: function() {
              e = new WeakMap
            }
          }
        }
        function Ch() {
          const e = {};
          return {
            get: function(t) {
              if (void 0 !== e[t.id])
                return e[t.id];
              let i;
              switch (t.type) {
                case "DirectionalLight":
                  i = {
                    direction: new ts,
                    color: new Wr
                  };
                  break;
                case "SpotLight":
                  i = {
                    position: new ts,
                    direction: new ts,
                    color: new Wr,
                    distance: 0,
                    coneCos: 0,
                    penumbraCos: 0,
                    decay: 0
                  };
                  break;
                case "PointLight":
                  i = {
                    position: new ts,
                    color: new Wr,
                    distance: 0,
                    decay: 0
                  };
                  break;
                case "HemisphereLight":
                  i = {
                    direction: new ts,
                    skyColor: new Wr,
                    groundColor: new Wr
                  };
                  break;
                case "RectAreaLight":
                  i = {
                    color: new Wr,
                    position: new ts,
                    halfWidth: new ts,
                    halfHeight: new ts
                  }
              }
              return e[t.id] = i,
                i
            }
          }
        }
        let Ph = 0;
        function Dh(e, t) {
          return (t.castShadow ? 1 : 0) - (e.castShadow ? 1 : 0)
        }
        function Ih(e, t) {
          const i = new Ch
            , n = function() {
            const e = {};
            return {
              get: function(t) {
                if (void 0 !== e[t.id])
                  return e[t.id];
                let i;
                switch (t.type) {
                  case "DirectionalLight":
                  case "SpotLight":
                    i = {
                      shadowBias: 0,
                      shadowNormalBias: 0,
                      shadowRadius: 1,
                      shadowMapSize: new Dr
                    };
                    break;
                  case "PointLight":
                    i = {
                      shadowBias: 0,
                      shadowNormalBias: 0,
                      shadowRadius: 1,
                      shadowMapSize: new Dr,
                      shadowCameraNear: 1,
                      shadowCameraFar: 1e3
                    }
                }
                return e[t.id] = i,
                  i
              }
            }
          }()
            , r = {
            version: 0,
            hash: {
              directionalLength: -1,
              pointLength: -1,
              spotLength: -1,
              rectAreaLength: -1,
              hemiLength: -1,
              numDirectionalShadows: -1,
              numPointShadows: -1,
              numSpotShadows: -1
            },
            ambient: [0, 0, 0],
            probe: [],
            directional: [],
            directionalShadow: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotShadow: [],
            spotShadowMap: [],
            spotShadowMatrix: [],
            rectArea: [],
            rectAreaLTC1: null,
            rectAreaLTC2: null,
            point: [],
            pointShadow: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: []
          };
          for (let e = 0; e < 9; e++)
            r.probe.push(new ts);
          const s = new ts
            , a = new Rs
            , o = new Rs;
          return {
            setup: function(s, a) {
              let o = 0
                , l = 0
                , h = 0;
              for (let e = 0; e < 9; e++)
                r.probe[e].set(0, 0, 0);
              let c = 0
                , u = 0
                , d = 0
                , p = 0
                , f = 0
                , m = 0
                , g = 0
                , v = 0;
              s.sort(Dh);
              const y = !0 !== a ? Math.PI : 1;
              for (let e = 0, t = s.length; e < t; e++) {
                const t = s[e]
                  , a = t.color
                  , x = t.intensity
                  , _ = t.distance
                  , b = t.shadow && t.shadow.map ? t.shadow.map.texture : null;
                if (t.isAmbientLight)
                  o += a.r * x * y,
                    l += a.g * x * y,
                    h += a.b * x * y;
                else if (t.isLightProbe)
                  for (let e = 0; e < 9; e++)
                    r.probe[e].addScaledVector(t.sh.coefficients[e], x);
                else if (t.isDirectionalLight) {
                  const e = i.get(t);
                  if (e.color.copy(t.color).multiplyScalar(t.intensity * y),
                    t.castShadow) {
                    const e = t.shadow
                      , i = n.get(t);
                    i.shadowBias = e.bias,
                      i.shadowNormalBias = e.normalBias,
                      i.shadowRadius = e.radius,
                      i.shadowMapSize = e.mapSize,
                      r.directionalShadow[c] = i,
                      r.directionalShadowMap[c] = b,
                      r.directionalShadowMatrix[c] = t.shadow.matrix,
                      m++
                  }
                  r.directional[c] = e,
                    c++
                } else if (t.isSpotLight) {
                  const e = i.get(t);
                  if (e.position.setFromMatrixPosition(t.matrixWorld),
                    e.color.copy(a).multiplyScalar(x * y),
                    e.distance = _,
                    e.coneCos = Math.cos(t.angle),
                    e.penumbraCos = Math.cos(t.angle * (1 - t.penumbra)),
                    e.decay = t.decay,
                    t.castShadow) {
                    const e = t.shadow
                      , i = n.get(t);
                    i.shadowBias = e.bias,
                      i.shadowNormalBias = e.normalBias,
                      i.shadowRadius = e.radius,
                      i.shadowMapSize = e.mapSize,
                      r.spotShadow[d] = i,
                      r.spotShadowMap[d] = b,
                      r.spotShadowMatrix[d] = t.shadow.matrix,
                      v++
                  }
                  r.spot[d] = e,
                    d++
                } else if (t.isRectAreaLight) {
                  const e = i.get(t);
                  e.color.copy(a).multiplyScalar(x),
                    e.halfWidth.set(.5 * t.width, 0, 0),
                    e.halfHeight.set(0, .5 * t.height, 0),
                    r.rectArea[p] = e,
                    p++
                } else if (t.isPointLight) {
                  const e = i.get(t);
                  if (e.color.copy(t.color).multiplyScalar(t.intensity * y),
                    e.distance = t.distance,
                    e.decay = t.decay,
                    t.castShadow) {
                    const e = t.shadow
                      , i = n.get(t);
                    i.shadowBias = e.bias,
                      i.shadowNormalBias = e.normalBias,
                      i.shadowRadius = e.radius,
                      i.shadowMapSize = e.mapSize,
                      i.shadowCameraNear = e.camera.near,
                      i.shadowCameraFar = e.camera.far,
                      r.pointShadow[u] = i,
                      r.pointShadowMap[u] = b,
                      r.pointShadowMatrix[u] = t.shadow.matrix,
                      g++
                  }
                  r.point[u] = e,
                    u++
                } else if (t.isHemisphereLight) {
                  const e = i.get(t);
                  e.skyColor.copy(t.color).multiplyScalar(x * y),
                    e.groundColor.copy(t.groundColor).multiplyScalar(x * y),
                    r.hemi[f] = e,
                    f++
                }
              }
              p > 0 && (t.isWebGL2 || !0 === e.has("OES_texture_float_linear") ? (r.rectAreaLTC1 = _o.LTC_FLOAT_1,
                r.rectAreaLTC2 = _o.LTC_FLOAT_2) : !0 === e.has("OES_texture_half_float_linear") ? (r.rectAreaLTC1 = _o.LTC_HALF_1,
                r.rectAreaLTC2 = _o.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),
                r.ambient[0] = o,
                r.ambient[1] = l,
                r.ambient[2] = h;
              const x = r.hash;
              x.directionalLength === c && x.pointLength === u && x.spotLength === d && x.rectAreaLength === p && x.hemiLength === f && x.numDirectionalShadows === m && x.numPointShadows === g && x.numSpotShadows === v || (r.directional.length = c,
                r.spot.length = d,
                r.rectArea.length = p,
                r.point.length = u,
                r.hemi.length = f,
                r.directionalShadow.length = m,
                r.directionalShadowMap.length = m,
                r.pointShadow.length = g,
                r.pointShadowMap.length = g,
                r.spotShadow.length = v,
                r.spotShadowMap.length = v,
                r.directionalShadowMatrix.length = m,
                r.pointShadowMatrix.length = g,
                r.spotShadowMatrix.length = v,
                x.directionalLength = c,
                x.pointLength = u,
                x.spotLength = d,
                x.rectAreaLength = p,
                x.hemiLength = f,
                x.numDirectionalShadows = m,
                x.numPointShadows = g,
                x.numSpotShadows = v,
                r.version = Ph++)
            },
            setupView: function(e, t) {
              let i = 0
                , n = 0
                , l = 0
                , h = 0
                , c = 0;
              const u = t.matrixWorldInverse;
              for (let t = 0, d = e.length; t < d; t++) {
                const d = e[t];
                if (d.isDirectionalLight) {
                  const e = r.directional[i];
                  e.direction.setFromMatrixPosition(d.matrixWorld),
                    s.setFromMatrixPosition(d.target.matrixWorld),
                    e.direction.sub(s),
                    e.direction.transformDirection(u),
                    i++
                } else if (d.isSpotLight) {
                  const e = r.spot[l];
                  e.position.setFromMatrixPosition(d.matrixWorld),
                    e.position.applyMatrix4(u),
                    e.direction.setFromMatrixPosition(d.matrixWorld),
                    s.setFromMatrixPosition(d.target.matrixWorld),
                    e.direction.sub(s),
                    e.direction.transformDirection(u),
                    l++
                } else if (d.isRectAreaLight) {
                  const e = r.rectArea[h];
                  e.position.setFromMatrixPosition(d.matrixWorld),
                    e.position.applyMatrix4(u),
                    o.identity(),
                    a.copy(d.matrixWorld),
                    a.premultiply(u),
                    o.extractRotation(a),
                    e.halfWidth.set(.5 * d.width, 0, 0),
                    e.halfHeight.set(0, .5 * d.height, 0),
                    e.halfWidth.applyMatrix4(o),
                    e.halfHeight.applyMatrix4(o),
                    h++
                } else if (d.isPointLight) {
                  const e = r.point[n];
                  e.position.setFromMatrixPosition(d.matrixWorld),
                    e.position.applyMatrix4(u),
                    n++
                } else if (d.isHemisphereLight) {
                  const e = r.hemi[c];
                  e.direction.setFromMatrixPosition(d.matrixWorld),
                    e.direction.transformDirection(u),
                    c++
                }
              }
            },
            state: r
          }
        }
        function Rh(e, t) {
          const i = new Ih(e,t)
            , n = []
            , r = [];
          return {
            init: function() {
              n.length = 0,
                r.length = 0
            },
            state: {
              lightsArray: n,
              shadowsArray: r,
              lights: i
            },
            setupLights: function(e) {
              i.setup(n, e)
            },
            setupLightsView: function(e) {
              i.setupView(n, e)
            },
            pushLight: function(e) {
              n.push(e)
            },
            pushShadow: function(e) {
              r.push(e)
            }
          }
        }
        function Lh(e, t) {
          let i = new WeakMap;
          return {
            get: function(n, r=0) {
              let s;
              return !1 === i.has(n) ? (s = new Rh(e,t),
                i.set(n, [s])) : r >= i.get(n).length ? (s = new Rh(e,t),
                i.get(n).push(s)) : s = i.get(n)[r],
                s
            },
            dispose: function() {
              i = new WeakMap
            }
          }
        }
        class kh extends ga {
          constructor(e) {
            super(),
              this.isMeshDepthMaterial = !0,
              this.type = "MeshDepthMaterial",
              this.depthPacking = 3200,
              this.map = null,
              this.alphaMap = null,
              this.displacementMap = null,
              this.displacementScale = 1,
              this.displacementBias = 0,
              this.wireframe = !1,
              this.wireframeLinewidth = 1,
              this.setValues(e)
          }
          copy(e) {
            return super.copy(e),
              this.depthPacking = e.depthPacking,
              this.map = e.map,
              this.alphaMap = e.alphaMap,
              this.displacementMap = e.displacementMap,
              this.displacementScale = e.displacementScale,
              this.displacementBias = e.displacementBias,
              this.wireframe = e.wireframe,
              this.wireframeLinewidth = e.wireframeLinewidth,
              this
          }
        }
        class Fh extends ga {
          constructor(e) {
            super(),
              this.isMeshDistanceMaterial = !0,
              this.type = "MeshDistanceMaterial",
              this.referencePosition = new ts,
              this.nearDistance = 1,
              this.farDistance = 1e3,
              this.map = null,
              this.alphaMap = null,
              this.displacementMap = null,
              this.displacementScale = 1,
              this.displacementBias = 0,
              this.setValues(e)
          }
          copy(e) {
            return super.copy(e),
              this.referencePosition.copy(e.referencePosition),
              this.nearDistance = e.nearDistance,
              this.farDistance = e.farDistance,
              this.map = e.map,
              this.alphaMap = e.alphaMap,
              this.displacementMap = e.displacementMap,
              this.displacementScale = e.displacementScale,
              this.displacementBias = e.displacementBias,
              this
          }
        }
        function Bh(e, t, i) {
          let n = new mo;
          const r = new Dr
            , s = new Dr
            , a = new Jr
            , o = new kh({
            depthPacking: 3201
          })
            , l = new Fh
            , h = {}
            , c = i.maxTextureSize
            , u = {
            0: 1,
            1: 0,
            2: 2
          }
            , d = new to({
            defines: {
              VSM_SAMPLES: 8
            },
            uniforms: {
              shadow_pass: {
                value: null
              },
              resolution: {
                value: new Dr
              },
              radius: {
                value: 4
              }
            },
            vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
            fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
          })
            , p = d.clone();
          p.defines.HORIZONTAL_PASS = 1;
          const f = new Ia;
          f.setAttribute("position", new _a(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]),3));
          const m = new Qa(f,d)
            , g = this;
          function v(i, n) {
            const r = t.update(m);
            d.defines.VSM_SAMPLES !== i.blurSamples && (d.defines.VSM_SAMPLES = i.blurSamples,
              p.defines.VSM_SAMPLES = i.blurSamples,
              d.needsUpdate = !0,
              p.needsUpdate = !0),
              d.uniforms.shadow_pass.value = i.map.texture,
              d.uniforms.resolution.value = i.mapSize,
              d.uniforms.radius.value = i.radius,
              e.setRenderTarget(i.mapPass),
              e.clear(),
              e.renderBufferDirect(n, null, r, d, m, null),
              p.uniforms.shadow_pass.value = i.mapPass.texture,
              p.uniforms.resolution.value = i.mapSize,
              p.uniforms.radius.value = i.radius,
              e.setRenderTarget(i.map),
              e.clear(),
              e.renderBufferDirect(n, null, r, p, m, null)
          }
          function y(t, i, n, r, s, a) {
            let c = null;
            const d = !0 === n.isPointLight ? t.customDistanceMaterial : t.customDepthMaterial;
            if (c = void 0 !== d ? d : !0 === n.isPointLight ? l : o,
            e.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length || i.displacementMap && 0 !== i.displacementScale || i.alphaMap && i.alphaTest > 0) {
              const e = c.uuid
                , t = i.uuid;
              let n = h[e];
              void 0 === n && (n = {},
                h[e] = n);
              let r = n[t];
              void 0 === r && (r = c.clone(),
                n[t] = r),
                c = r
            }
            return c.visible = i.visible,
              c.wireframe = i.wireframe,
              c.side = 3 === a ? null !== i.shadowSide ? i.shadowSide : i.side : null !== i.shadowSide ? i.shadowSide : u[i.side],
              c.alphaMap = i.alphaMap,
              c.alphaTest = i.alphaTest,
              c.clipShadows = i.clipShadows,
              c.clippingPlanes = i.clippingPlanes,
              c.clipIntersection = i.clipIntersection,
              c.displacementMap = i.displacementMap,
              c.displacementScale = i.displacementScale,
              c.displacementBias = i.displacementBias,
              c.wireframeLinewidth = i.wireframeLinewidth,
              c.linewidth = i.linewidth,
            !0 === n.isPointLight && !0 === c.isMeshDistanceMaterial && (c.referencePosition.setFromMatrixPosition(n.matrixWorld),
              c.nearDistance = r,
              c.farDistance = s),
              c
          }
          function x(i, r, s, a, o) {
            if (!1 === i.visible)
              return;
            if (i.layers.test(r.layers) && (i.isMesh || i.isLine || i.isPoints) && (i.castShadow || i.receiveShadow && 3 === o) && (!i.frustumCulled || n.intersectsObject(i))) {
              i.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse, i.matrixWorld);
              const n = t.update(i)
                , r = i.material;
              if (Array.isArray(r)) {
                const t = n.groups;
                for (let l = 0, h = t.length; l < h; l++) {
                  const h = t[l]
                    , c = r[h.materialIndex];
                  if (c && c.visible) {
                    const t = y(i, c, a, s.near, s.far, o);
                    e.renderBufferDirect(s, null, n, t, i, h)
                  }
                }
              } else if (r.visible) {
                const t = y(i, r, a, s.near, s.far, o);
                e.renderBufferDirect(s, null, n, t, i, null)
              }
            }
            const l = i.children;
            for (let e = 0, t = l.length; e < t; e++)
              x(l[e], r, s, a, o)
          }
          this.enabled = !1,
            this.autoUpdate = !0,
            this.needsUpdate = !1,
            this.type = 1,
            this.render = function(t, i, o) {
              if (!1 === g.enabled)
                return;
              if (!1 === g.autoUpdate && !1 === g.needsUpdate)
                return;
              if (0 === t.length)
                return;
              const l = e.getRenderTarget()
                , h = e.getActiveCubeFace()
                , u = e.getActiveMipmapLevel()
                , d = e.state;
              d.setBlending(0),
                d.buffers.color.setClear(1, 1, 1, 1),
                d.buffers.depth.setTest(!0),
                d.setScissorTest(!1);
              for (let l = 0, h = t.length; l < h; l++) {
                const h = t[l]
                  , u = h.shadow;
                if (void 0 === u) {
                  console.warn("THREE.WebGLShadowMap:", h, "has no shadow.");
                  continue
                }
                if (!1 === u.autoUpdate && !1 === u.needsUpdate)
                  continue;
                r.copy(u.mapSize);
                const p = u.getFrameExtents();
                if (r.multiply(p),
                  s.copy(u.mapSize),
                (r.x > c || r.y > c) && (r.x > c && (s.x = Math.floor(c / p.x),
                  r.x = s.x * p.x,
                  u.mapSize.x = s.x),
                r.y > c && (s.y = Math.floor(c / p.y),
                  r.y = s.y * p.y,
                  u.mapSize.y = s.y)),
                null !== u.map || u.isPointLightShadow || 3 !== this.type || (u.map = new Zr(r.x,r.y),
                  u.map.texture.name = h.name + ".shadowMap",
                  u.mapPass = new Zr(r.x,r.y),
                  u.camera.updateProjectionMatrix()),
                null === u.map) {
                  const e = {
                    minFilter: Un,
                    magFilter: Un,
                    format: Kn
                  };
                  u.map = new Zr(r.x,r.y,e),
                    u.map.texture.name = h.name + ".shadowMap",
                    u.camera.updateProjectionMatrix()
                }
                e.setRenderTarget(u.map),
                  e.clear();
                const f = u.getViewportCount();
                for (let e = 0; e < f; e++) {
                  const t = u.getViewport(e);
                  a.set(s.x * t.x, s.y * t.y, s.x * t.z, s.y * t.w),
                    d.viewport(a),
                    u.updateMatrices(h, e),
                    n = u.getFrustum(),
                    x(i, o, u.camera, h, this.type)
                }
                u.isPointLightShadow || 3 !== this.type || v(u, o),
                  u.needsUpdate = !1
              }
              g.needsUpdate = !1,
                e.setRenderTarget(l, h, u)
            }
        }
        function Oh(e, t, i) {
          const n = i.isWebGL2
            , r = new function() {
              let t = !1;
              const i = new Jr;
              let n = null;
              const r = new Jr(0,0,0,0);
              return {
                setMask: function(i) {
                  n === i || t || (e.colorMask(i, i, i, i),
                    n = i)
                },
                setLocked: function(e) {
                  t = e
                },
                setClear: function(t, n, s, a, o) {
                  !0 === o && (t *= a,
                    n *= a,
                    s *= a),
                    i.set(t, n, s, a),
                  !1 === r.equals(i) && (e.clearColor(t, n, s, a),
                    r.copy(i))
                },
                reset: function() {
                  t = !1,
                    n = null,
                    r.set(-1, 0, 0, 0)
                }
              }
            }
            , s = new function() {
              let t = !1
                , i = null
                , n = null
                , r = null;
              return {
                setTest: function(e) {
                  e ? N(2929) : z(2929)
                },
                setMask: function(n) {
                  i === n || t || (e.depthMask(n),
                    i = n)
                },
                setFunc: function(t) {
                  if (n !== t) {
                    if (t)
                      switch (t) {
                        case 0:
                          e.depthFunc(512);
                          break;
                        case 1:
                          e.depthFunc(519);
                          break;
                        case 2:
                          e.depthFunc(513);
                          break;
                        case 3:
                        default:
                          e.depthFunc(515);
                          break;
                        case 4:
                          e.depthFunc(514);
                          break;
                        case 5:
                          e.depthFunc(518);
                          break;
                        case 6:
                          e.depthFunc(516);
                          break;
                        case 7:
                          e.depthFunc(517)
                      }
                    else
                      e.depthFunc(515);
                    n = t
                  }
                },
                setLocked: function(e) {
                  t = e
                },
                setClear: function(t) {
                  r !== t && (e.clearDepth(t),
                    r = t)
                },
                reset: function() {
                  t = !1,
                    i = null,
                    n = null,
                    r = null
                }
              }
            }
            , a = new function() {
              let t = !1
                , i = null
                , n = null
                , r = null
                , s = null
                , a = null
                , o = null
                , l = null
                , h = null;
              return {
                setTest: function(e) {
                  t || (e ? N(2960) : z(2960))
                },
                setMask: function(n) {
                  i === n || t || (e.stencilMask(n),
                    i = n)
                },
                setFunc: function(t, i, a) {
                  n === t && r === i && s === a || (e.stencilFunc(t, i, a),
                    n = t,
                    r = i,
                    s = a)
                },
                setOp: function(t, i, n) {
                  a === t && o === i && l === n || (e.stencilOp(t, i, n),
                    a = t,
                    o = i,
                    l = n)
                },
                setLocked: function(e) {
                  t = e
                },
                setClear: function(t) {
                  h !== t && (e.clearStencil(t),
                    h = t)
                },
                reset: function() {
                  t = !1,
                    i = null,
                    n = null,
                    r = null,
                    s = null,
                    a = null,
                    o = null,
                    l = null,
                    h = null
                }
              }
            }
          ;
          let o = {}
            , l = {}
            , h = new WeakMap
            , c = []
            , u = null
            , d = !1
            , p = null
            , f = null
            , m = null
            , g = null
            , v = null
            , y = null
            , x = null
            , _ = !1
            , b = null
            , w = null
            , A = null
            , S = null
            , M = null;
          const T = e.getParameter(35661);
          let E = !1
            , C = 0;
          const P = e.getParameter(7938);
          -1 !== P.indexOf("WebGL") ? (C = parseFloat(/^WebGL (\d)/.exec(P)[1]),
            E = C >= 1) : -1 !== P.indexOf("OpenGL ES") && (C = parseFloat(/^OpenGL ES (\d)/.exec(P)[1]),
            E = C >= 2);
          let D = null
            , I = {};
          const R = e.getParameter(3088)
            , L = e.getParameter(2978)
            , k = (new Jr).fromArray(R)
            , F = (new Jr).fromArray(L);
          function B(t, i, n) {
            const r = new Uint8Array(4)
              , s = e.createTexture();
            e.bindTexture(t, s),
              e.texParameteri(t, 10241, 9728),
              e.texParameteri(t, 10240, 9728);
            for (let t = 0; t < n; t++)
              e.texImage2D(i + t, 0, 6408, 1, 1, 0, 6408, 5121, r);
            return s
          }
          const O = {};
          function N(t) {
            !0 !== o[t] && (e.enable(t),
              o[t] = !0)
          }
          function z(t) {
            !1 !== o[t] && (e.disable(t),
              o[t] = !1)
          }
          O[3553] = B(3553, 3553, 1),
            O[34067] = B(34067, 34069, 6),
            r.setClear(0, 0, 0, 1),
            s.setClear(1),
            a.setClear(0),
            N(2929),
            s.setFunc(3),
            H(!1),
            W(1),
            N(2884),
            V(0);
          const U = {
            [Ln]: 32774,
            101: 32778,
            102: 32779
          };
          if (n)
            U[103] = 32775,
              U[104] = 32776;
          else {
            const e = t.get("EXT_blend_minmax");
            null !== e && (U[103] = e.MIN_EXT,
              U[104] = e.MAX_EXT)
          }
          const G = {
            200: 0,
            201: 1,
            202: 768,
            204: 770,
            210: 776,
            208: 774,
            206: 772,
            203: 769,
            205: 771,
            209: 775,
            207: 773
          };
          function V(t, i, n, r, s, a, o, l) {
            if (0 !== t) {
              if (!1 === d && (N(3042),
                d = !0),
              5 === t)
                s = s || i,
                  a = a || n,
                  o = o || r,
                i === f && s === v || (e.blendEquationSeparate(U[i], U[s]),
                  f = i,
                  v = s),
                n === m && r === g && a === y && o === x || (e.blendFuncSeparate(G[n], G[r], G[a], G[o]),
                  m = n,
                  g = r,
                  y = a,
                  x = o),
                  p = t,
                  _ = null;
              else if (t !== p || l !== _) {
                if (f === Ln && v === Ln || (e.blendEquation(32774),
                  f = Ln,
                  v = Ln),
                  l)
                  switch (t) {
                    case 1:
                      e.blendFuncSeparate(1, 771, 1, 771);
                      break;
                    case 2:
                      e.blendFunc(1, 1);
                      break;
                    case 3:
                      e.blendFuncSeparate(0, 769, 0, 1);
                      break;
                    case 4:
                      e.blendFuncSeparate(0, 768, 0, 770);
                      break;
                    default:
                      console.error("THREE.WebGLState: Invalid blending: ", t)
                  }
                else
                  switch (t) {
                    case 1:
                      e.blendFuncSeparate(770, 771, 1, 771);
                      break;
                    case 2:
                      e.blendFunc(770, 1);
                      break;
                    case 3:
                      e.blendFuncSeparate(0, 769, 0, 1);
                      break;
                    case 4:
                      e.blendFunc(0, 768);
                      break;
                    default:
                      console.error("THREE.WebGLState: Invalid blending: ", t)
                  }
                m = null,
                  g = null,
                  y = null,
                  x = null,
                  p = t,
                  _ = l
              }
            } else
              !0 === d && (z(3042),
                d = !1)
          }
          function H(t) {
            b !== t && (t ? e.frontFace(2304) : e.frontFace(2305),
              b = t)
          }
          function W(t) {
            0 !== t ? (N(2884),
            t !== w && (1 === t ? e.cullFace(1029) : 2 === t ? e.cullFace(1028) : e.cullFace(1032))) : z(2884),
              w = t
          }
          function j(t, i, n) {
            t ? (N(32823),
            S === i && M === n || (e.polygonOffset(i, n),
              S = i,
              M = n)) : z(32823)
          }
          function X(t) {
            void 0 === t && (t = 33984 + T - 1),
            D !== t && (e.activeTexture(t),
              D = t)
          }
          return {
            buffers: {
              color: r,
              depth: s,
              stencil: a
            },
            enable: N,
            disable: z,
            bindFramebuffer: function(t, i) {
              return l[t] !== i && (e.bindFramebuffer(t, i),
                l[t] = i,
              n && (36009 === t && (l[36160] = i),
              36160 === t && (l[36009] = i)),
                !0)
            },
            drawBuffers: function(n, r) {
              let s = c
                , a = !1;
              if (n)
                if (s = h.get(r),
                void 0 === s && (s = [],
                  h.set(r, s)),
                  n.isWebGLMultipleRenderTargets) {
                  const e = n.texture;
                  if (s.length !== e.length || 36064 !== s[0]) {
                    for (let t = 0, i = e.length; t < i; t++)
                      s[t] = 36064 + t;
                    s.length = e.length,
                      a = !0
                  }
                } else
                  36064 !== s[0] && (s[0] = 36064,
                    a = !0);
              else
                1029 !== s[0] && (s[0] = 1029,
                  a = !0);
              a && (i.isWebGL2 ? e.drawBuffers(s) : t.get("WEBGL_draw_buffers").drawBuffersWEBGL(s))
            },
            useProgram: function(t) {
              return u !== t && (e.useProgram(t),
                u = t,
                !0)
            },
            setBlending: V,
            setMaterial: function(e, t) {
              2 === e.side ? z(2884) : N(2884);
              let i = 1 === e.side;
              t && (i = !i),
                H(i),
                1 === e.blending && !1 === e.transparent ? V(0) : V(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha),
                s.setFunc(e.depthFunc),
                s.setTest(e.depthTest),
                s.setMask(e.depthWrite),
                r.setMask(e.colorWrite);
              const n = e.stencilWrite;
              a.setTest(n),
              n && (a.setMask(e.stencilWriteMask),
                a.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask),
                a.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)),
                j(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits),
                !0 === e.alphaToCoverage ? N(32926) : z(32926)
            },
            setFlipSided: H,
            setCullFace: W,
            setLineWidth: function(t) {
              t !== A && (E && e.lineWidth(t),
                A = t)
            },
            setPolygonOffset: j,
            setScissorTest: function(e) {
              e ? N(3089) : z(3089)
            },
            activeTexture: X,
            bindTexture: function(t, i) {
              null === D && X();
              let n = I[D];
              void 0 === n && (n = {
                type: void 0,
                texture: void 0
              },
                I[D] = n),
              n.type === t && n.texture === i || (e.bindTexture(t, i || O[t]),
                n.type = t,
                n.texture = i)
            },
            unbindTexture: function() {
              const t = I[D];
              void 0 !== t && void 0 !== t.type && (e.bindTexture(t.type, null),
                t.type = void 0,
                t.texture = void 0)
            },
            compressedTexImage2D: function() {
              try {
                e.compressedTexImage2D.apply(e, arguments)
              } catch (e) {
                console.error("THREE.WebGLState:", e)
              }
            },
            texImage2D: function() {
              try {
                e.texImage2D.apply(e, arguments)
              } catch (e) {
                console.error("THREE.WebGLState:", e)
              }
            },
            texImage3D: function() {
              try {
                e.texImage3D.apply(e, arguments)
              } catch (e) {
                console.error("THREE.WebGLState:", e)
              }
            },
            texStorage2D: function() {
              try {
                e.texStorage2D.apply(e, arguments)
              } catch (e) {
                console.error("THREE.WebGLState:", e)
              }
            },
            texStorage3D: function() {
              try {
                e.texStorage3D.apply(e, arguments)
              } catch (e) {
                console.error("THREE.WebGLState:", e)
              }
            },
            texSubImage2D: function() {
              try {
                e.texSubImage2D.apply(e, arguments)
              } catch (e) {
                console.error("THREE.WebGLState:", e)
              }
            },
            texSubImage3D: function() {
              try {
                e.texSubImage3D.apply(e, arguments)
              } catch (e) {
                console.error("THREE.WebGLState:", e)
              }
            },
            compressedTexSubImage2D: function() {
              try {
                e.compressedTexSubImage2D.apply(e, arguments)
              } catch (e) {
                console.error("THREE.WebGLState:", e)
              }
            },
            scissor: function(t) {
              !1 === k.equals(t) && (e.scissor(t.x, t.y, t.z, t.w),
                k.copy(t))
            },
            viewport: function(t) {
              !1 === F.equals(t) && (e.viewport(t.x, t.y, t.z, t.w),
                F.copy(t))
            },
            reset: function() {
              e.disable(3042),
                e.disable(2884),
                e.disable(2929),
                e.disable(32823),
                e.disable(3089),
                e.disable(2960),
                e.disable(32926),
                e.blendEquation(32774),
                e.blendFunc(1, 0),
                e.blendFuncSeparate(1, 0, 1, 0),
                e.colorMask(!0, !0, !0, !0),
                e.clearColor(0, 0, 0, 0),
                e.depthMask(!0),
                e.depthFunc(513),
                e.clearDepth(1),
                e.stencilMask(4294967295),
                e.stencilFunc(519, 0, 4294967295),
                e.stencilOp(7680, 7680, 7680),
                e.clearStencil(0),
                e.cullFace(1029),
                e.frontFace(2305),
                e.polygonOffset(0, 0),
                e.activeTexture(33984),
                e.bindFramebuffer(36160, null),
              !0 === n && (e.bindFramebuffer(36009, null),
                e.bindFramebuffer(36008, null)),
                e.useProgram(null),
                e.lineWidth(1),
                e.scissor(0, 0, e.canvas.width, e.canvas.height),
                e.viewport(0, 0, e.canvas.width, e.canvas.height),
                o = {},
                D = null,
                I = {},
                l = {},
                h = new WeakMap,
                c = [],
                u = null,
                d = !1,
                p = null,
                f = null,
                m = null,
                g = null,
                v = null,
                y = null,
                x = null,
                _ = !1,
                b = null,
                w = null,
                A = null,
                S = null,
                M = null,
                k.set(0, 0, e.canvas.width, e.canvas.height),
                F.set(0, 0, e.canvas.width, e.canvas.height),
                r.reset(),
                s.reset(),
                a.reset()
            }
          }
        }
        function Nh(e, t, i, n, r, s, a) {
          const o = r.isWebGL2
            , l = r.maxTextures
            , h = r.maxCubemapSize
            , c = r.maxTextureSize
            , u = r.maxSamples
            , d = t.has("WEBGL_multisampled_render_to_texture") ? t.get("WEBGL_multisampled_render_to_texture") : null
            , p = /OculusBrowser/g.test(navigator.userAgent)
            , f = new WeakMap;
          let m;
          const g = new WeakMap;
          let v = !1;
          try {
            v = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1,1).getContext("2d")
          } catch (e) {}
          function y(e, t) {
            return v ? new OffscreenCanvas(e,t) : Lr("canvas")
          }
          function x(e, t, i, n) {
            let r = 1;
            if ((e.width > n || e.height > n) && (r = n / Math.max(e.width, e.height)),
            r < 1 || !0 === t) {
              if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) {
                const n = t ? Cr : Math.floor
                  , s = n(r * e.width)
                  , a = n(r * e.height);
                void 0 === m && (m = y(s, a));
                const o = i ? y(s, a) : m;
                return o.width = s,
                  o.height = a,
                  o.getContext("2d").drawImage(e, 0, 0, s, a),
                  console.warn("THREE.WebGLRenderer: Texture has been resized from (" + e.width + "x" + e.height + ") to (" + s + "x" + a + ")."),
                  o
              }
              return "data"in e && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + e.width + "x" + e.height + ")."),
                e
            }
            return e
          }
          function _(e) {
            return Tr(e.width) && Tr(e.height)
          }
          function b(e, t) {
            return e.generateMipmaps && t && e.minFilter !== Un && e.minFilter !== Hn
          }
          function w(t) {
            e.generateMipmap(t)
          }
          function A(i, n, r, s, a=!1) {
            if (!1 === o)
              return n;
            if (null !== i) {
              if (void 0 !== e[i])
                return e[i];
              console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + i + "'")
            }
            let l = n;
            return 6403 === n && (5126 === r && (l = 33326),
            5131 === r && (l = 33325),
            5121 === r && (l = 33321)),
            33319 === n && (5126 === r && (l = 33328),
            5131 === r && (l = 33327),
            5121 === r && (l = 33323)),
            6408 === n && (5126 === r && (l = 34836),
            5131 === r && (l = 34842),
            5121 === r && (l = s === cr && !1 === a ? 35907 : 32856),
            32819 === r && (l = 32854),
            32820 === r && (l = 32855)),
            33325 !== l && 33326 !== l && 33327 !== l && 33328 !== l && 34842 !== l && 34836 !== l || t.get("EXT_color_buffer_float"),
              l
          }
          function S(e, t, i) {
            return !0 === b(e, i) || e.isFramebufferTexture && e.minFilter !== Un && e.minFilter !== Hn ? Math.log2(Math.max(t.width, t.height)) + 1 : void 0 !== e.mipmaps && e.mipmaps.length > 0 ? e.mipmaps.length : e.isCompressedTexture && Array.isArray(e.image) ? t.mipmaps.length : 1
          }
          function M(e) {
            return e === Un || e === Gn || e === Vn ? 9728 : 9729
          }
          function T(e) {
            const t = e.target;
            t.removeEventListener("dispose", T),
              function(e) {
                const t = n.get(e);
                if (void 0 === t.__webglInit)
                  return;
                const i = e.source
                  , r = g.get(i);
                if (r) {
                  const n = r[t.__cacheKey];
                  n.usedTimes--,
                  0 === n.usedTimes && C(e),
                  0 === Object.keys(r).length && g.delete(i)
                }
                n.remove(e)
              }(t),
            t.isVideoTexture && f.delete(t)
          }
          function E(t) {
            const i = t.target;
            i.removeEventListener("dispose", E),
              function(t) {
                const i = t.texture
                  , r = n.get(t)
                  , s = n.get(i);
                if (void 0 !== s.__webglTexture && (e.deleteTexture(s.__webglTexture),
                  a.memory.textures--),
                t.depthTexture && t.depthTexture.dispose(),
                  t.isWebGLCubeRenderTarget)
                  for (let t = 0; t < 6; t++)
                    e.deleteFramebuffer(r.__webglFramebuffer[t]),
                    r.__webglDepthbuffer && e.deleteRenderbuffer(r.__webglDepthbuffer[t]);
                else {
                  if (e.deleteFramebuffer(r.__webglFramebuffer),
                  r.__webglDepthbuffer && e.deleteRenderbuffer(r.__webglDepthbuffer),
                  r.__webglMultisampledFramebuffer && e.deleteFramebuffer(r.__webglMultisampledFramebuffer),
                    r.__webglColorRenderbuffer)
                    for (let t = 0; t < r.__webglColorRenderbuffer.length; t++)
                      r.__webglColorRenderbuffer[t] && e.deleteRenderbuffer(r.__webglColorRenderbuffer[t]);
                  r.__webglDepthRenderbuffer && e.deleteRenderbuffer(r.__webglDepthRenderbuffer)
                }
                if (t.isWebGLMultipleRenderTargets)
                  for (let t = 0, r = i.length; t < r; t++) {
                    const r = n.get(i[t]);
                    r.__webglTexture && (e.deleteTexture(r.__webglTexture),
                      a.memory.textures--),
                      n.remove(i[t])
                  }
                n.remove(i),
                  n.remove(t)
              }(i)
          }
          function C(t) {
            const i = n.get(t);
            e.deleteTexture(i.__webglTexture);
            const r = t.source;
            delete g.get(r)[i.__cacheKey],
              a.memory.textures--
          }
          let P = 0;
          function D(e, t) {
            const r = n.get(e);
            if (e.isVideoTexture && function(e) {
              const t = a.render.frame;
              f.get(e) !== t && (f.set(e, t),
                e.update())
            }(e),
            !1 === e.isRenderTargetTexture && e.version > 0 && r.__version !== e.version) {
              const i = e.image;
              if (null === i)
                console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
              else {
                if (!1 !== i.complete)
                  return void F(r, e, t);
                console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
              }
            }
            i.activeTexture(33984 + t),
              i.bindTexture(3553, r.__webglTexture)
          }
          const I = {
            [On]: 10497,
            [Nn]: 33071,
            [zn]: 33648
          }
            , R = {
            [Un]: 9728,
            [Gn]: 9984,
            [Vn]: 9986,
            [Hn]: 9729,
            1007: 9985,
            [Wn]: 9987
          };
          function L(i, s, a) {
            if (a ? (e.texParameteri(i, 10242, I[s.wrapS]),
              e.texParameteri(i, 10243, I[s.wrapT]),
            32879 !== i && 35866 !== i || e.texParameteri(i, 32882, I[s.wrapR]),
              e.texParameteri(i, 10240, R[s.magFilter]),
              e.texParameteri(i, 10241, R[s.minFilter])) : (e.texParameteri(i, 10242, 33071),
              e.texParameteri(i, 10243, 33071),
            32879 !== i && 35866 !== i || e.texParameteri(i, 32882, 33071),
            s.wrapS === Nn && s.wrapT === Nn || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),
              e.texParameteri(i, 10240, M(s.magFilter)),
              e.texParameteri(i, 10241, M(s.minFilter)),
            s.minFilter !== Un && s.minFilter !== Hn && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),
            !0 === t.has("EXT_texture_filter_anisotropic")) {
              const a = t.get("EXT_texture_filter_anisotropic");
              if (s.type === Yn && !1 === t.has("OES_texture_float_linear"))
                return;
              if (!1 === o && s.type === qn && !1 === t.has("OES_texture_half_float_linear"))
                return;
              (s.anisotropy > 1 || n.get(s).__currentAnisotropy) && (e.texParameterf(i, a.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(s.anisotropy, r.getMaxAnisotropy())),
                n.get(s).__currentAnisotropy = s.anisotropy)
            }
          }
          function k(t, i) {
            let n = !1;
            void 0 === t.__webglInit && (t.__webglInit = !0,
              i.addEventListener("dispose", T));
            const r = i.source;
            let s = g.get(r);
            void 0 === s && (s = {},
              g.set(r, s));
            const o = function(e) {
              const t = [];
              return t.push(e.wrapS),
                t.push(e.wrapT),
                t.push(e.magFilter),
                t.push(e.minFilter),
                t.push(e.anisotropy),
                t.push(e.internalFormat),
                t.push(e.format),
                t.push(e.type),
                t.push(e.generateMipmaps),
                t.push(e.premultiplyAlpha),
                t.push(e.flipY),
                t.push(e.unpackAlignment),
                t.push(e.encoding),
                t.join()
            }(i);
            if (o !== t.__cacheKey) {
              void 0 === s[o] && (s[o] = {
                texture: e.createTexture(),
                usedTimes: 0
              },
                a.memory.textures++,
                n = !0),
                s[o].usedTimes++;
              const r = s[t.__cacheKey];
              void 0 !== r && (s[t.__cacheKey].usedTimes--,
              0 === r.usedTimes && C(i)),
                t.__cacheKey = o,
                t.__webglTexture = s[o].texture
            }
            return n
          }
          function F(t, n, r) {
            let a = 3553;
            n.isDataArrayTexture && (a = 35866),
            n.isData3DTexture && (a = 32879);
            const l = k(t, n)
              , h = n.source;
            if (i.activeTexture(33984 + r),
              i.bindTexture(a, t.__webglTexture),
            h.version !== h.__currentVersion || !0 === l) {
              e.pixelStorei(37440, n.flipY),
                e.pixelStorei(37441, n.premultiplyAlpha),
                e.pixelStorei(3317, n.unpackAlignment),
                e.pixelStorei(37443, 0);
              const t = function(e) {
                return !o && (e.wrapS !== Nn || e.wrapT !== Nn || e.minFilter !== Un && e.minFilter !== Hn)
              }(n) && !1 === _(n.image);
              let r = x(n.image, t, !1, c);
              r = G(n, r);
              const u = _(r) || o
                , d = s.convert(n.format, n.encoding);
              let p, f = s.convert(n.type), m = A(n.internalFormat, d, f, n.encoding, n.isVideoTexture);
              L(a, n, u);
              const g = n.mipmaps
                , v = o && !0 !== n.isVideoTexture
                , y = void 0 === h.__currentVersion || !0 === l
                , M = S(n, r, u);
              if (n.isDepthTexture)
                m = 6402,
                  o ? m = n.type === Yn ? 36012 : n.type === Xn ? 33190 : n.type === Qn ? 35056 : 33189 : n.type === Yn && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),
                n.format === Jn && 6402 === m && 1012 !== n.type && n.type !== Xn && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),
                  n.type = Xn,
                  f = s.convert(n.type)),
                n.format === Zn && 6402 === m && (m = 34041,
                n.type !== Qn && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),
                  n.type = Qn,
                  f = s.convert(n.type))),
                y && (v ? i.texStorage2D(3553, 1, m, r.width, r.height) : i.texImage2D(3553, 0, m, r.width, r.height, 0, d, f, null));
              else if (n.isDataTexture)
                if (g.length > 0 && u) {
                  v && y && i.texStorage2D(3553, M, m, g[0].width, g[0].height);
                  for (let e = 0, t = g.length; e < t; e++)
                    p = g[e],
                      v ? i.texSubImage2D(3553, e, 0, 0, p.width, p.height, d, f, p.data) : i.texImage2D(3553, e, m, p.width, p.height, 0, d, f, p.data);
                  n.generateMipmaps = !1
                } else
                  v ? (y && i.texStorage2D(3553, M, m, r.width, r.height),
                    i.texSubImage2D(3553, 0, 0, 0, r.width, r.height, d, f, r.data)) : i.texImage2D(3553, 0, m, r.width, r.height, 0, d, f, r.data);
              else if (n.isCompressedTexture) {
                v && y && i.texStorage2D(3553, M, m, g[0].width, g[0].height);
                for (let e = 0, t = g.length; e < t; e++)
                  p = g[e],
                    n.format !== Kn ? null !== d ? v ? i.compressedTexSubImage2D(3553, e, 0, 0, p.width, p.height, d, p.data) : i.compressedTexImage2D(3553, e, m, p.width, p.height, 0, p.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : v ? i.texSubImage2D(3553, e, 0, 0, p.width, p.height, d, f, p.data) : i.texImage2D(3553, e, m, p.width, p.height, 0, d, f, p.data)
              } else if (n.isDataArrayTexture)
                v ? (y && i.texStorage3D(35866, M, m, r.width, r.height, r.depth),
                  i.texSubImage3D(35866, 0, 0, 0, 0, r.width, r.height, r.depth, d, f, r.data)) : i.texImage3D(35866, 0, m, r.width, r.height, r.depth, 0, d, f, r.data);
              else if (n.isData3DTexture)
                v ? (y && i.texStorage3D(32879, M, m, r.width, r.height, r.depth),
                  i.texSubImage3D(32879, 0, 0, 0, 0, r.width, r.height, r.depth, d, f, r.data)) : i.texImage3D(32879, 0, m, r.width, r.height, r.depth, 0, d, f, r.data);
              else if (n.isFramebufferTexture) {
                if (y)
                  if (v)
                    i.texStorage2D(3553, M, m, r.width, r.height);
                  else {
                    let e = r.width
                      , t = r.height;
                    for (let n = 0; n < M; n++)
                      i.texImage2D(3553, n, m, e, t, 0, d, f, null),
                        e >>= 1,
                        t >>= 1
                  }
              } else if (g.length > 0 && u) {
                v && y && i.texStorage2D(3553, M, m, g[0].width, g[0].height);
                for (let e = 0, t = g.length; e < t; e++)
                  p = g[e],
                    v ? i.texSubImage2D(3553, e, 0, 0, d, f, p) : i.texImage2D(3553, e, m, d, f, p);
                n.generateMipmaps = !1
              } else
                v ? (y && i.texStorage2D(3553, M, m, r.width, r.height),
                  i.texSubImage2D(3553, 0, 0, 0, d, f, r)) : i.texImage2D(3553, 0, m, d, f, r);
              b(n, u) && w(a),
                h.__currentVersion = h.version,
              n.onUpdate && n.onUpdate(n)
            }
            t.__version = n.version
          }
          function B(t, r, a, o, l) {
            const h = s.convert(a.format, a.encoding)
              , c = s.convert(a.type)
              , u = A(a.internalFormat, h, c, a.encoding);
            n.get(r).__hasExternalTextures || (32879 === l || 35866 === l ? i.texImage3D(l, 0, u, r.width, r.height, r.depth, 0, h, c, null) : i.texImage2D(l, 0, u, r.width, r.height, 0, h, c, null)),
              i.bindFramebuffer(36160, t),
              U(r) ? d.framebufferTexture2DMultisampleEXT(36160, o, l, n.get(a).__webglTexture, 0, z(r)) : e.framebufferTexture2D(36160, o, l, n.get(a).__webglTexture, 0),
              i.bindFramebuffer(36160, null)
          }
          function O(t, i, n) {
            if (e.bindRenderbuffer(36161, t),
            i.depthBuffer && !i.stencilBuffer) {
              let r = 33189;
              if (n || U(i)) {
                const t = i.depthTexture;
                t && t.isDepthTexture && (t.type === Yn ? r = 36012 : t.type === Xn && (r = 33190));
                const n = z(i);
                U(i) ? d.renderbufferStorageMultisampleEXT(36161, n, r, i.width, i.height) : e.renderbufferStorageMultisample(36161, n, r, i.width, i.height)
              } else
                e.renderbufferStorage(36161, r, i.width, i.height);
              e.framebufferRenderbuffer(36160, 36096, 36161, t)
            } else if (i.depthBuffer && i.stencilBuffer) {
              const r = z(i);
              n && !1 === U(i) ? e.renderbufferStorageMultisample(36161, r, 35056, i.width, i.height) : U(i) ? d.renderbufferStorageMultisampleEXT(36161, r, 35056, i.width, i.height) : e.renderbufferStorage(36161, 34041, i.width, i.height),
                e.framebufferRenderbuffer(36160, 33306, 36161, t)
            } else {
              const t = !0 === i.isWebGLMultipleRenderTargets ? i.texture : [i.texture];
              for (let r = 0; r < t.length; r++) {
                const a = t[r]
                  , o = s.convert(a.format, a.encoding)
                  , l = s.convert(a.type)
                  , h = A(a.internalFormat, o, l, a.encoding)
                  , c = z(i);
                n && !1 === U(i) ? e.renderbufferStorageMultisample(36161, c, h, i.width, i.height) : U(i) ? d.renderbufferStorageMultisampleEXT(36161, c, h, i.width, i.height) : e.renderbufferStorage(36161, h, i.width, i.height)
              }
            }
            e.bindRenderbuffer(36161, null)
          }
          function N(t) {
            const r = n.get(t)
              , s = !0 === t.isWebGLCubeRenderTarget;
            if (t.depthTexture && !r.__autoAllocateDepthBuffer) {
              if (s)
                throw new Error("target.depthTexture not supported in Cube render targets");
              !function(t, r) {
                if (r && r.isWebGLCubeRenderTarget)
                  throw new Error("Depth Texture with cube render targets is not supported");
                if (i.bindFramebuffer(36160, t),
                !r.depthTexture || !r.depthTexture.isDepthTexture)
                  throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                n.get(r.depthTexture).__webglTexture && r.depthTexture.image.width === r.width && r.depthTexture.image.height === r.height || (r.depthTexture.image.width = r.width,
                  r.depthTexture.image.height = r.height,
                  r.depthTexture.needsUpdate = !0),
                  D(r.depthTexture, 0);
                const s = n.get(r.depthTexture).__webglTexture
                  , a = z(r);
                if (r.depthTexture.format === Jn)
                  U(r) ? d.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, s, 0, a) : e.framebufferTexture2D(36160, 36096, 3553, s, 0);
                else {
                  if (r.depthTexture.format !== Zn)
                    throw new Error("Unknown depthTexture format");
                  U(r) ? d.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, s, 0, a) : e.framebufferTexture2D(36160, 33306, 3553, s, 0)
                }
              }(r.__webglFramebuffer, t)
            } else if (s) {
              r.__webglDepthbuffer = [];
              for (let n = 0; n < 6; n++)
                i.bindFramebuffer(36160, r.__webglFramebuffer[n]),
                  r.__webglDepthbuffer[n] = e.createRenderbuffer(),
                  O(r.__webglDepthbuffer[n], t, !1)
            } else
              i.bindFramebuffer(36160, r.__webglFramebuffer),
                r.__webglDepthbuffer = e.createRenderbuffer(),
                O(r.__webglDepthbuffer, t, !1);
            i.bindFramebuffer(36160, null)
          }
          function z(e) {
            return Math.min(u, e.samples)
          }
          function U(e) {
            const i = n.get(e);
            return o && e.samples > 0 && !0 === t.has("WEBGL_multisampled_render_to_texture") && !1 !== i.__useRenderToTexture
          }
          function G(e, i) {
            const n = e.encoding
              , r = e.format
              , s = e.type;
            return !0 === e.isCompressedTexture || !0 === e.isVideoTexture || e.format === gr || n !== hr && (n === cr ? !1 === o ? !0 === t.has("EXT_sRGB") && r === Kn ? (e.format = gr,
              e.minFilter = Hn,
              e.generateMipmaps = !1) : i = Xr.sRGBToLinear(i) : r === Kn && s === jn || console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture encoding:", n)),
              i
          }
          this.allocateTextureUnit = function() {
            const e = P;
            return e >= l && console.warn("THREE.WebGLTextures: Trying to use " + e + " texture units while this GPU supports only " + l),
              P += 1,
              e
          }
            ,
            this.resetTextureUnits = function() {
              P = 0
            }
            ,
            this.setTexture2D = D,
            this.setTexture2DArray = function(e, t) {
              const r = n.get(e);
              e.version > 0 && r.__version !== e.version ? F(r, e, t) : (i.activeTexture(33984 + t),
                i.bindTexture(35866, r.__webglTexture))
            }
            ,
            this.setTexture3D = function(e, t) {
              const r = n.get(e);
              e.version > 0 && r.__version !== e.version ? F(r, e, t) : (i.activeTexture(33984 + t),
                i.bindTexture(32879, r.__webglTexture))
            }
            ,
            this.setTextureCube = function(t, r) {
              const a = n.get(t);
              t.version > 0 && a.__version !== t.version ? function(t, n, r) {
                if (6 !== n.image.length)
                  return;
                const a = k(t, n)
                  , l = n.source;
                if (i.activeTexture(33984 + r),
                  i.bindTexture(34067, t.__webglTexture),
                l.version !== l.__currentVersion || !0 === a) {
                  e.pixelStorei(37440, n.flipY),
                    e.pixelStorei(37441, n.premultiplyAlpha),
                    e.pixelStorei(3317, n.unpackAlignment),
                    e.pixelStorei(37443, 0);
                  const t = n.isCompressedTexture || n.image[0].isCompressedTexture
                    , r = n.image[0] && n.image[0].isDataTexture
                    , c = [];
                  for (let e = 0; e < 6; e++)
                    c[e] = t || r ? r ? n.image[e].image : n.image[e] : x(n.image[e], !1, !0, h),
                      c[e] = G(n, c[e]);
                  const u = c[0]
                    , d = _(u) || o
                    , p = s.convert(n.format, n.encoding)
                    , f = s.convert(n.type)
                    , m = A(n.internalFormat, p, f, n.encoding)
                    , g = o && !0 !== n.isVideoTexture
                    , v = void 0 === l.__currentVersion || !0 === a;
                  let y, M = S(n, u, d);
                  if (L(34067, n, d),
                    t) {
                    g && v && i.texStorage2D(34067, M, m, u.width, u.height);
                    for (let e = 0; e < 6; e++) {
                      y = c[e].mipmaps;
                      for (let t = 0; t < y.length; t++) {
                        const r = y[t];
                        n.format !== Kn ? null !== p ? g ? i.compressedTexSubImage2D(34069 + e, t, 0, 0, r.width, r.height, p, r.data) : i.compressedTexImage2D(34069 + e, t, m, r.width, r.height, 0, r.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : g ? i.texSubImage2D(34069 + e, t, 0, 0, r.width, r.height, p, f, r.data) : i.texImage2D(34069 + e, t, m, r.width, r.height, 0, p, f, r.data)
                      }
                    }
                  } else {
                    y = n.mipmaps,
                    g && v && (y.length > 0 && M++,
                      i.texStorage2D(34067, M, m, c[0].width, c[0].height));
                    for (let e = 0; e < 6; e++)
                      if (r) {
                        g ? i.texSubImage2D(34069 + e, 0, 0, 0, c[e].width, c[e].height, p, f, c[e].data) : i.texImage2D(34069 + e, 0, m, c[e].width, c[e].height, 0, p, f, c[e].data);
                        for (let t = 0; t < y.length; t++) {
                          const n = y[t].image[e].image;
                          g ? i.texSubImage2D(34069 + e, t + 1, 0, 0, n.width, n.height, p, f, n.data) : i.texImage2D(34069 + e, t + 1, m, n.width, n.height, 0, p, f, n.data)
                        }
                      } else {
                        g ? i.texSubImage2D(34069 + e, 0, 0, 0, p, f, c[e]) : i.texImage2D(34069 + e, 0, m, p, f, c[e]);
                        for (let t = 0; t < y.length; t++) {
                          const n = y[t];
                          g ? i.texSubImage2D(34069 + e, t + 1, 0, 0, p, f, n.image[e]) : i.texImage2D(34069 + e, t + 1, m, p, f, n.image[e])
                        }
                      }
                  }
                  b(n, d) && w(34067),
                    l.__currentVersion = l.version,
                  n.onUpdate && n.onUpdate(n)
                }
                t.__version = n.version
              }(a, t, r) : (i.activeTexture(33984 + r),
                i.bindTexture(34067, a.__webglTexture))
            }
            ,
            this.rebindTextures = function(e, t, i) {
              const r = n.get(e);
              void 0 !== t && B(r.__webglFramebuffer, e, e.texture, 36064, 3553),
              void 0 !== i && N(e)
            }
            ,
            this.setupRenderTarget = function(t) {
              const l = t.texture
                , h = n.get(t)
                , c = n.get(l);
              t.addEventListener("dispose", E),
              !0 !== t.isWebGLMultipleRenderTargets && (void 0 === c.__webglTexture && (c.__webglTexture = e.createTexture()),
                c.__version = l.version,
                a.memory.textures++);
              const u = !0 === t.isWebGLCubeRenderTarget
                , d = !0 === t.isWebGLMultipleRenderTargets
                , p = _(t) || o;
              if (u) {
                h.__webglFramebuffer = [];
                for (let t = 0; t < 6; t++)
                  h.__webglFramebuffer[t] = e.createFramebuffer()
              } else {
                if (h.__webglFramebuffer = e.createFramebuffer(),
                  d)
                  if (r.drawBuffers) {
                    const i = t.texture;
                    for (let t = 0, r = i.length; t < r; t++) {
                      const r = n.get(i[t]);
                      void 0 === r.__webglTexture && (r.__webglTexture = e.createTexture(),
                        a.memory.textures++)
                    }
                  } else
                    console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
                if (o && t.samples > 0 && !1 === U(t)) {
                  const n = d ? l : [l];
                  h.__webglMultisampledFramebuffer = e.createFramebuffer(),
                    h.__webglColorRenderbuffer = [],
                    i.bindFramebuffer(36160, h.__webglMultisampledFramebuffer);
                  for (let i = 0; i < n.length; i++) {
                    const r = n[i];
                    h.__webglColorRenderbuffer[i] = e.createRenderbuffer(),
                      e.bindRenderbuffer(36161, h.__webglColorRenderbuffer[i]);
                    const a = s.convert(r.format, r.encoding)
                      , o = s.convert(r.type)
                      , l = A(r.internalFormat, a, o, r.encoding)
                      , c = z(t);
                    e.renderbufferStorageMultisample(36161, c, l, t.width, t.height),
                      e.framebufferRenderbuffer(36160, 36064 + i, 36161, h.__webglColorRenderbuffer[i])
                  }
                  e.bindRenderbuffer(36161, null),
                  t.depthBuffer && (h.__webglDepthRenderbuffer = e.createRenderbuffer(),
                    O(h.__webglDepthRenderbuffer, t, !0)),
                    i.bindFramebuffer(36160, null)
                }
              }
              if (u) {
                i.bindTexture(34067, c.__webglTexture),
                  L(34067, l, p);
                for (let e = 0; e < 6; e++)
                  B(h.__webglFramebuffer[e], t, l, 36064, 34069 + e);
                b(l, p) && w(34067),
                  i.unbindTexture()
              } else if (d) {
                const e = t.texture;
                for (let r = 0, s = e.length; r < s; r++) {
                  const s = e[r]
                    , a = n.get(s);
                  i.bindTexture(3553, a.__webglTexture),
                    L(3553, s, p),
                    B(h.__webglFramebuffer, t, s, 36064 + r, 3553),
                  b(s, p) && w(3553)
                }
                i.unbindTexture()
              } else {
                let e = 3553;
                (t.isWebGL3DRenderTarget || t.isWebGLArrayRenderTarget) && (o ? e = t.isWebGL3DRenderTarget ? 32879 : 35866 : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),
                  i.bindTexture(e, c.__webglTexture),
                  L(e, l, p),
                  B(h.__webglFramebuffer, t, l, 36064, e),
                b(l, p) && w(e),
                  i.unbindTexture()
              }
              t.depthBuffer && N(t)
            }
            ,
            this.updateRenderTargetMipmap = function(e) {
              const t = _(e) || o
                , r = !0 === e.isWebGLMultipleRenderTargets ? e.texture : [e.texture];
              for (let s = 0, a = r.length; s < a; s++) {
                const a = r[s];
                if (b(a, t)) {
                  const t = e.isWebGLCubeRenderTarget ? 34067 : 3553
                    , r = n.get(a).__webglTexture;
                  i.bindTexture(t, r),
                    w(t),
                    i.unbindTexture()
                }
              }
            }
            ,
            this.updateMultisampleRenderTarget = function(t) {
              if (o && t.samples > 0 && !1 === U(t)) {
                const r = t.isWebGLMultipleRenderTargets ? t.texture : [t.texture]
                  , s = t.width
                  , a = t.height;
                let o = 16384;
                const l = []
                  , h = t.stencilBuffer ? 33306 : 36096
                  , c = n.get(t)
                  , u = !0 === t.isWebGLMultipleRenderTargets;
                if (u)
                  for (let t = 0; t < r.length; t++)
                    i.bindFramebuffer(36160, c.__webglMultisampledFramebuffer),
                      e.framebufferRenderbuffer(36160, 36064 + t, 36161, null),
                      i.bindFramebuffer(36160, c.__webglFramebuffer),
                      e.framebufferTexture2D(36009, 36064 + t, 3553, null, 0);
                i.bindFramebuffer(36008, c.__webglMultisampledFramebuffer),
                  i.bindFramebuffer(36009, c.__webglFramebuffer);
                for (let i = 0; i < r.length; i++) {
                  l.push(36064 + i),
                  t.depthBuffer && l.push(h);
                  const d = void 0 !== c.__ignoreDepthValues && c.__ignoreDepthValues;
                  if (!1 === d && (t.depthBuffer && (o |= 256),
                  t.stencilBuffer && (o |= 1024)),
                  u && e.framebufferRenderbuffer(36008, 36064, 36161, c.__webglColorRenderbuffer[i]),
                  !0 === d && (e.invalidateFramebuffer(36008, [h]),
                    e.invalidateFramebuffer(36009, [h])),
                    u) {
                    const t = n.get(r[i]).__webglTexture;
                    e.framebufferTexture2D(36009, 36064, 3553, t, 0)
                  }
                  e.blitFramebuffer(0, 0, s, a, 0, 0, s, a, o, 9728),
                  p && e.invalidateFramebuffer(36008, l)
                }
                if (i.bindFramebuffer(36008, null),
                  i.bindFramebuffer(36009, null),
                  u)
                  for (let t = 0; t < r.length; t++) {
                    i.bindFramebuffer(36160, c.__webglMultisampledFramebuffer),
                      e.framebufferRenderbuffer(36160, 36064 + t, 36161, c.__webglColorRenderbuffer[t]);
                    const s = n.get(r[t]).__webglTexture;
                    i.bindFramebuffer(36160, c.__webglFramebuffer),
                      e.framebufferTexture2D(36009, 36064 + t, 3553, s, 0)
                  }
                i.bindFramebuffer(36009, c.__webglMultisampledFramebuffer)
              }
            }
            ,
            this.setupDepthRenderbuffer = N,
            this.setupFrameBufferTexture = B,
            this.useMultisampledRTT = U
        }
        function zh(e, t, i) {
          const n = i.isWebGL2;
          return {
            convert: function(i, r=null) {
              let s;
              if (i === jn)
                return 5121;
              if (1017 === i)
                return 32819;
              if (1018 === i)
                return 32820;
              if (1010 === i)
                return 5120;
              if (1011 === i)
                return 5122;
              if (1012 === i)
                return 5123;
              if (1013 === i)
                return 5124;
              if (i === Xn)
                return 5125;
              if (i === Yn)
                return 5126;
              if (i === qn)
                return n ? 5131 : (s = t.get("OES_texture_half_float"),
                  null !== s ? s.HALF_FLOAT_OES : null);
              if (1021 === i)
                return 6406;
              if (i === Kn)
                return 6408;
              if (1024 === i)
                return 6409;
              if (1025 === i)
                return 6410;
              if (i === Jn)
                return 6402;
              if (i === Zn)
                return 34041;
              if (1028 === i)
                return 6403;
              if (1022 === i)
                return console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"),
                  6408;
              if (i === gr)
                return s = t.get("EXT_sRGB"),
                  null !== s ? s.SRGB_ALPHA_EXT : null;
              if (1029 === i)
                return 36244;
              if (1030 === i)
                return 33319;
              if (1031 === i)
                return 33320;
              if (1033 === i)
                return 36249;
              if (i === $n || i === er || i === tr || i === ir)
                if (r === cr) {
                  if (s = t.get("WEBGL_compressed_texture_s3tc_srgb"),
                  null === s)
                    return null;
                  if (i === $n)
                    return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                  if (i === er)
                    return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                  if (i === tr)
                    return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                  if (i === ir)
                    return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                } else {
                  if (s = t.get("WEBGL_compressed_texture_s3tc"),
                  null === s)
                    return null;
                  if (i === $n)
                    return s.COMPRESSED_RGB_S3TC_DXT1_EXT;
                  if (i === er)
                    return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                  if (i === tr)
                    return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                  if (i === ir)
                    return s.COMPRESSED_RGBA_S3TC_DXT5_EXT
                }
              if (35840 === i || 35841 === i || 35842 === i || 35843 === i) {
                if (s = t.get("WEBGL_compressed_texture_pvrtc"),
                null === s)
                  return null;
                if (35840 === i)
                  return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (35841 === i)
                  return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (35842 === i)
                  return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (35843 === i)
                  return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
              }
              if (36196 === i)
                return s = t.get("WEBGL_compressed_texture_etc1"),
                  null !== s ? s.COMPRESSED_RGB_ETC1_WEBGL : null;
              if (37492 === i || 37496 === i) {
                if (s = t.get("WEBGL_compressed_texture_etc"),
                null === s)
                  return null;
                if (37492 === i)
                  return r === cr ? s.COMPRESSED_SRGB8_ETC2 : s.COMPRESSED_RGB8_ETC2;
                if (37496 === i)
                  return r === cr ? s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : s.COMPRESSED_RGBA8_ETC2_EAC
              }
              if (37808 === i || 37809 === i || 37810 === i || 37811 === i || 37812 === i || 37813 === i || 37814 === i || 37815 === i || 37816 === i || 37817 === i || 37818 === i || 37819 === i || 37820 === i || 37821 === i) {
                if (s = t.get("WEBGL_compressed_texture_astc"),
                null === s)
                  return null;
                if (37808 === i)
                  return r === cr ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : s.COMPRESSED_RGBA_ASTC_4x4_KHR;
                if (37809 === i)
                  return r === cr ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : s.COMPRESSED_RGBA_ASTC_5x4_KHR;
                if (37810 === i)
                  return r === cr ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : s.COMPRESSED_RGBA_ASTC_5x5_KHR;
                if (37811 === i)
                  return r === cr ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : s.COMPRESSED_RGBA_ASTC_6x5_KHR;
                if (37812 === i)
                  return r === cr ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : s.COMPRESSED_RGBA_ASTC_6x6_KHR;
                if (37813 === i)
                  return r === cr ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : s.COMPRESSED_RGBA_ASTC_8x5_KHR;
                if (37814 === i)
                  return r === cr ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : s.COMPRESSED_RGBA_ASTC_8x6_KHR;
                if (37815 === i)
                  return r === cr ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : s.COMPRESSED_RGBA_ASTC_8x8_KHR;
                if (37816 === i)
                  return r === cr ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : s.COMPRESSED_RGBA_ASTC_10x5_KHR;
                if (37817 === i)
                  return r === cr ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : s.COMPRESSED_RGBA_ASTC_10x6_KHR;
                if (37818 === i)
                  return r === cr ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : s.COMPRESSED_RGBA_ASTC_10x8_KHR;
                if (37819 === i)
                  return r === cr ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : s.COMPRESSED_RGBA_ASTC_10x10_KHR;
                if (37820 === i)
                  return r === cr ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : s.COMPRESSED_RGBA_ASTC_12x10_KHR;
                if (37821 === i)
                  return r === cr ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : s.COMPRESSED_RGBA_ASTC_12x12_KHR
              }
              if (36492 === i) {
                if (s = t.get("EXT_texture_compression_bptc"),
                null === s)
                  return null;
                if (36492 === i)
                  return r === cr ? s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : s.COMPRESSED_RGBA_BPTC_UNORM_EXT
              }
              return i === Qn ? n ? 34042 : (s = t.get("WEBGL_depth_texture"),
                null !== s ? s.UNSIGNED_INT_24_8_WEBGL : null) : void 0 !== e[i] ? e[i] : null
            }
          }
        }
        class Uh extends no {
          constructor(e=[]) {
            super(),
              this.isArrayCamera = !0,
              this.cameras = e
          }
        }
        class Gh extends na {
          constructor() {
            super(),
              this.isGroup = !0,
              this.type = "Group"
          }
        }
        const Vh = {
          type: "move"
        };
        class Hh {
          constructor() {
            this._targetRay = null,
              this._grip = null,
              this._hand = null
          }
          getHandSpace() {
            return null === this._hand && (this._hand = new Gh,
              this._hand.matrixAutoUpdate = !1,
              this._hand.visible = !1,
              this._hand.joints = {},
              this._hand.inputState = {
                pinching: !1
              }),
              this._hand
          }
          getTargetRaySpace() {
            return null === this._targetRay && (this._targetRay = new Gh,
              this._targetRay.matrixAutoUpdate = !1,
              this._targetRay.visible = !1,
              this._targetRay.hasLinearVelocity = !1,
              this._targetRay.linearVelocity = new ts,
              this._targetRay.hasAngularVelocity = !1,
              this._targetRay.angularVelocity = new ts),
              this._targetRay
          }
          getGripSpace() {
            return null === this._grip && (this._grip = new Gh,
              this._grip.matrixAutoUpdate = !1,
              this._grip.visible = !1,
              this._grip.hasLinearVelocity = !1,
              this._grip.linearVelocity = new ts,
              this._grip.hasAngularVelocity = !1,
              this._grip.angularVelocity = new ts),
              this._grip
          }
          dispatchEvent(e) {
            return null !== this._targetRay && this._targetRay.dispatchEvent(e),
            null !== this._grip && this._grip.dispatchEvent(e),
            null !== this._hand && this._hand.dispatchEvent(e),
              this
          }
          disconnect(e) {
            return this.dispatchEvent({
              type: "disconnected",
              data: e
            }),
            null !== this._targetRay && (this._targetRay.visible = !1),
            null !== this._grip && (this._grip.visible = !1),
            null !== this._hand && (this._hand.visible = !1),
              this
          }
          update(e, t, i) {
            let n = null
              , r = null
              , s = null;
            const a = this._targetRay
              , o = this._grip
              , l = this._hand;
            if (e && "visible-blurred" !== t.session.visibilityState)
              if (null !== a && (n = t.getPose(e.targetRaySpace, i),
              null !== n && (a.matrix.fromArray(n.transform.matrix),
                a.matrix.decompose(a.position, a.rotation, a.scale),
                n.linearVelocity ? (a.hasLinearVelocity = !0,
                  a.linearVelocity.copy(n.linearVelocity)) : a.hasLinearVelocity = !1,
                n.angularVelocity ? (a.hasAngularVelocity = !0,
                  a.angularVelocity.copy(n.angularVelocity)) : a.hasAngularVelocity = !1,
                this.dispatchEvent(Vh))),
              l && e.hand) {
                s = !0;
                for (const n of e.hand.values()) {
                  const e = t.getJointPose(n, i);
                  if (void 0 === l.joints[n.jointName]) {
                    const e = new Gh;
                    e.matrixAutoUpdate = !1,
                      e.visible = !1,
                      l.joints[n.jointName] = e,
                      l.add(e)
                  }
                  const r = l.joints[n.jointName];
                  null !== e && (r.matrix.fromArray(e.transform.matrix),
                    r.matrix.decompose(r.position, r.rotation, r.scale),
                    r.jointRadius = e.radius),
                    r.visible = null !== e
                }
                const n = l.joints["index-finger-tip"]
                  , r = l.joints["thumb-tip"]
                  , a = n.position.distanceTo(r.position)
                  , o = .02
                  , h = .005;
                l.inputState.pinching && a > o + h ? (l.inputState.pinching = !1,
                  this.dispatchEvent({
                    type: "pinchend",
                    handedness: e.handedness,
                    target: this
                  })) : !l.inputState.pinching && a <= o - h && (l.inputState.pinching = !0,
                  this.dispatchEvent({
                    type: "pinchstart",
                    handedness: e.handedness,
                    target: this
                  }))
              } else
                null !== o && e.gripSpace && (r = t.getPose(e.gripSpace, i),
                null !== r && (o.matrix.fromArray(r.transform.matrix),
                  o.matrix.decompose(o.position, o.rotation, o.scale),
                  r.linearVelocity ? (o.hasLinearVelocity = !0,
                    o.linearVelocity.copy(r.linearVelocity)) : o.hasLinearVelocity = !1,
                  r.angularVelocity ? (o.hasAngularVelocity = !0,
                    o.angularVelocity.copy(r.angularVelocity)) : o.hasAngularVelocity = !1));
            return null !== a && (a.visible = null !== n),
            null !== o && (o.visible = null !== r),
            null !== l && (l.visible = null !== s),
              this
          }
        }
        class Wh extends Kr {
          constructor(e, t, i, n, r, s, a, o, l, h) {
            if ((h = void 0 !== h ? h : Jn) !== Jn && h !== Zn)
              throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
            void 0 === i && h === Jn && (i = Xn),
            void 0 === i && h === Zn && (i = Qn),
              super(null, n, r, s, a, o, h, i, l),
              this.isDepthTexture = !0,
              this.image = {
                width: e,
                height: t
              },
              this.magFilter = void 0 !== a ? a : Un,
              this.minFilter = void 0 !== o ? o : Un,
              this.flipY = !1,
              this.generateMipmaps = !1
          }
        }
        class jh extends vr {
          constructor(e, t) {
            super();
            const i = this;
            let n = null
              , r = 1
              , s = null
              , a = "local-floor"
              , o = null
              , l = null
              , h = null
              , c = null
              , u = null
              , d = null;
            const p = t.getContextAttributes();
            let f = null
              , m = null;
            const g = []
              , v = new Map
              , y = new no;
            y.layers.enable(1),
              y.viewport = new Jr;
            const x = new no;
            x.layers.enable(2),
              x.viewport = new Jr;
            const _ = [y, x]
              , b = new Uh;
            b.layers.enable(1),
              b.layers.enable(2);
            let w = null
              , A = null;
            function S(e) {
              const t = v.get(e.inputSource);
              void 0 !== t && t.dispatchEvent({
                type: e.type,
                data: e.inputSource
              })
            }
            function M() {
              n.removeEventListener("select", S),
                n.removeEventListener("selectstart", S),
                n.removeEventListener("selectend", S),
                n.removeEventListener("squeeze", S),
                n.removeEventListener("squeezestart", S),
                n.removeEventListener("squeezeend", S),
                n.removeEventListener("end", M),
                n.removeEventListener("inputsourceschange", T),
                v.forEach((function(e, t) {
                    void 0 !== e && e.disconnect(t)
                  }
                )),
                v.clear(),
                w = null,
                A = null,
                e.setRenderTarget(f),
                u = null,
                c = null,
                h = null,
                n = null,
                m = null,
                I.stop(),
                i.isPresenting = !1,
                i.dispatchEvent({
                  type: "sessionend"
                })
            }
            function T(e) {
              const t = n.inputSources;
              for (let e = 0; e < t.length; e++) {
                const i = "right" === t[e].handedness ? 1 : 0;
                v.set(t[e], g[i])
              }
              for (let t = 0; t < e.removed.length; t++) {
                const i = e.removed[t]
                  , n = v.get(i);
                n && (n.dispatchEvent({
                  type: "disconnected",
                  data: i
                }),
                  v.delete(i))
              }
              for (let t = 0; t < e.added.length; t++) {
                const i = e.added[t]
                  , n = v.get(i);
                n && n.dispatchEvent({
                  type: "connected",
                  data: i
                })
              }
            }
            this.cameraAutoUpdate = !0,
              this.enabled = !1,
              this.isPresenting = !1,
              this.getController = function(e) {
                let t = g[e];
                return void 0 === t && (t = new Hh,
                  g[e] = t),
                  t.getTargetRaySpace()
              }
              ,
              this.getControllerGrip = function(e) {
                let t = g[e];
                return void 0 === t && (t = new Hh,
                  g[e] = t),
                  t.getGripSpace()
              }
              ,
              this.getHand = function(e) {
                let t = g[e];
                return void 0 === t && (t = new Hh,
                  g[e] = t),
                  t.getHandSpace()
              }
              ,
              this.setFramebufferScaleFactor = function(e) {
                r = e,
                !0 === i.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
              }
              ,
              this.setReferenceSpaceType = function(e) {
                a = e,
                !0 === i.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
              }
              ,
              this.getReferenceSpace = function() {
                return o || s
              }
              ,
              this.setReferenceSpace = function(e) {
                o = e
              }
              ,
              this.getBaseLayer = function() {
                return null !== c ? c : u
              }
              ,
              this.getBinding = function() {
                return h
              }
              ,
              this.getFrame = function() {
                return d
              }
              ,
              this.getSession = function() {
                return n
              }
              ,
              this.setSession = async function(l) {
                if (n = l,
                null !== n) {
                  if (f = e.getRenderTarget(),
                    n.addEventListener("select", S),
                    n.addEventListener("selectstart", S),
                    n.addEventListener("selectend", S),
                    n.addEventListener("squeeze", S),
                    n.addEventListener("squeezestart", S),
                    n.addEventListener("squeezeend", S),
                    n.addEventListener("end", M),
                    n.addEventListener("inputsourceschange", T),
                  !0 !== p.xrCompatible && await t.makeXRCompatible(),
                  void 0 === n.renderState.layers || !1 === e.capabilities.isWebGL2) {
                    const i = {
                      antialias: void 0 !== n.renderState.layers || p.antialias,
                      alpha: p.alpha,
                      depth: p.depth,
                      stencil: p.stencil,
                      framebufferScaleFactor: r
                    };
                    u = new XRWebGLLayer(n,t,i),
                      n.updateRenderState({
                        baseLayer: u
                      }),
                      m = new Zr(u.framebufferWidth,u.framebufferHeight,{
                        format: Kn,
                        type: jn,
                        encoding: e.outputEncoding
                      })
                  } else {
                    let i = null
                      , s = null
                      , a = null;
                    p.depth && (a = p.stencil ? 35056 : 33190,
                      i = p.stencil ? Zn : Jn,
                      s = p.stencil ? Qn : Xn);
                    const o = {
                      colorFormat: e.outputEncoding === cr ? 35907 : 32856,
                      depthFormat: a,
                      scaleFactor: r
                    };
                    h = new XRWebGLBinding(n,t),
                      c = h.createProjectionLayer(o),
                      n.updateRenderState({
                        layers: [c]
                      }),
                      m = new Zr(c.textureWidth,c.textureHeight,{
                        format: Kn,
                        type: jn,
                        depthTexture: new Wh(c.textureWidth,c.textureHeight,s,void 0,void 0,void 0,void 0,void 0,void 0,i),
                        stencilBuffer: p.stencil,
                        encoding: e.outputEncoding,
                        samples: p.antialias ? 4 : 0
                      }),
                      e.properties.get(m).__ignoreDepthValues = c.ignoreDepthValues
                  }
                  m.isXRRenderTarget = !0,
                    this.setFoveation(1),
                    o = null,
                    s = await n.requestReferenceSpace(a),
                    I.setContext(n),
                    I.start(),
                    i.isPresenting = !0,
                    i.dispatchEvent({
                      type: "sessionstart"
                    })
                }
              }
            ;
            const E = new ts
              , C = new ts;
            function P(e, t) {
              null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix),
                e.matrixWorldInverse.copy(e.matrixWorld).invert()
            }
            this.updateCamera = function(e) {
              if (null === n)
                return;
              b.near = x.near = y.near = e.near,
                b.far = x.far = y.far = e.far,
              w === b.near && A === b.far || (n.updateRenderState({
                depthNear: b.near,
                depthFar: b.far
              }),
                w = b.near,
                A = b.far);
              const t = e.parent
                , i = b.cameras;
              P(b, t);
              for (let e = 0; e < i.length; e++)
                P(i[e], t);
              b.matrixWorld.decompose(b.position, b.quaternion, b.scale),
                e.position.copy(b.position),
                e.quaternion.copy(b.quaternion),
                e.scale.copy(b.scale),
                e.matrix.copy(b.matrix),
                e.matrixWorld.copy(b.matrixWorld);
              const r = e.children;
              for (let e = 0, t = r.length; e < t; e++)
                r[e].updateMatrixWorld(!0);
              2 === i.length ? function(e, t, i) {
                E.setFromMatrixPosition(t.matrixWorld),
                  C.setFromMatrixPosition(i.matrixWorld);
                const n = E.distanceTo(C)
                  , r = t.projectionMatrix.elements
                  , s = i.projectionMatrix.elements
                  , a = r[14] / (r[10] - 1)
                  , o = r[14] / (r[10] + 1)
                  , l = (r[9] + 1) / r[5]
                  , h = (r[9] - 1) / r[5]
                  , c = (r[8] - 1) / r[0]
                  , u = (s[8] + 1) / s[0]
                  , d = a * c
                  , p = a * u
                  , f = n / (-c + u)
                  , m = f * -c;
                t.matrixWorld.decompose(e.position, e.quaternion, e.scale),
                  e.translateX(m),
                  e.translateZ(f),
                  e.matrixWorld.compose(e.position, e.quaternion, e.scale),
                  e.matrixWorldInverse.copy(e.matrixWorld).invert();
                const g = a + f
                  , v = o + f
                  , y = d - m
                  , x = p + (n - m)
                  , _ = l * o / v * g
                  , b = h * o / v * g;
                e.projectionMatrix.makePerspective(y, x, _, b, g, v)
              }(b, y, x) : b.projectionMatrix.copy(y.projectionMatrix)
            }
              ,
              this.getCamera = function() {
                return b
              }
              ,
              this.getFoveation = function() {
                return null !== c ? c.fixedFoveation : null !== u ? u.fixedFoveation : void 0
              }
              ,
              this.setFoveation = function(e) {
                null !== c && (c.fixedFoveation = e),
                null !== u && void 0 !== u.fixedFoveation && (u.fixedFoveation = e)
              }
            ;
            let D = null;
            const I = new go;
            I.setAnimationLoop((function(t, i) {
                if (l = i.getViewerPose(o || s),
                  d = i,
                null !== l) {
                  const t = l.views;
                  null !== u && (e.setRenderTargetFramebuffer(m, u.framebuffer),
                    e.setRenderTarget(m));
                  let i = !1;
                  t.length !== b.cameras.length && (b.cameras.length = 0,
                    i = !0);
                  for (let n = 0; n < t.length; n++) {
                    const r = t[n];
                    let s = null;
                    if (null !== u)
                      s = u.getViewport(r);
                    else {
                      const t = h.getViewSubImage(c, r);
                      s = t.viewport,
                      0 === n && (e.setRenderTargetTextures(m, t.colorTexture, c.ignoreDepthValues ? void 0 : t.depthStencilTexture),
                        e.setRenderTarget(m))
                    }
                    let a = _[n];
                    void 0 === a && (a = new no,
                      a.layers.enable(n),
                      a.viewport = new Jr,
                      _[n] = a),
                      a.matrix.fromArray(r.transform.matrix),
                      a.projectionMatrix.fromArray(r.projectionMatrix),
                      a.viewport.set(s.x, s.y, s.width, s.height),
                    0 === n && b.matrix.copy(a.matrix),
                    !0 === i && b.cameras.push(a)
                  }
                }
                const r = n.inputSources;
                for (let e = 0; e < g.length; e++) {
                  const t = r[e]
                    , n = v.get(t);
                  void 0 !== n && n.update(t, i, o || s)
                }
                D && D(t, i),
                  d = null
              }
            )),
              this.setAnimationLoop = function(e) {
                D = e
              }
              ,
              this.dispose = function() {}
          }
        }
        function Xh(e, t) {
          function i(i, n) {
            i.opacity.value = n.opacity,
            n.color && i.diffuse.value.copy(n.color),
            n.emissive && i.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity),
            n.map && (i.map.value = n.map),
            n.alphaMap && (i.alphaMap.value = n.alphaMap),
            n.bumpMap && (i.bumpMap.value = n.bumpMap,
              i.bumpScale.value = n.bumpScale,
            1 === n.side && (i.bumpScale.value *= -1)),
            n.displacementMap && (i.displacementMap.value = n.displacementMap,
              i.displacementScale.value = n.displacementScale,
              i.displacementBias.value = n.displacementBias),
            n.emissiveMap && (i.emissiveMap.value = n.emissiveMap),
            n.normalMap && (i.normalMap.value = n.normalMap,
              i.normalScale.value.copy(n.normalScale),
            1 === n.side && i.normalScale.value.negate()),
            n.specularMap && (i.specularMap.value = n.specularMap),
            n.alphaTest > 0 && (i.alphaTest.value = n.alphaTest);
            const r = t.get(n).envMap;
            if (r && (i.envMap.value = r,
              i.flipEnvMap.value = r.isCubeTexture && !1 === r.isRenderTargetTexture ? -1 : 1,
              i.reflectivity.value = n.reflectivity,
              i.ior.value = n.ior,
              i.refractionRatio.value = n.refractionRatio),
              n.lightMap) {
              i.lightMap.value = n.lightMap;
              const t = !0 !== e.physicallyCorrectLights ? Math.PI : 1;
              i.lightMapIntensity.value = n.lightMapIntensity * t
            }
            let s, a;
            n.aoMap && (i.aoMap.value = n.aoMap,
              i.aoMapIntensity.value = n.aoMapIntensity),
              n.map ? s = n.map : n.specularMap ? s = n.specularMap : n.displacementMap ? s = n.displacementMap : n.normalMap ? s = n.normalMap : n.bumpMap ? s = n.bumpMap : n.roughnessMap ? s = n.roughnessMap : n.metalnessMap ? s = n.metalnessMap : n.alphaMap ? s = n.alphaMap : n.emissiveMap ? s = n.emissiveMap : n.clearcoatMap ? s = n.clearcoatMap : n.clearcoatNormalMap ? s = n.clearcoatNormalMap : n.clearcoatRoughnessMap ? s = n.clearcoatRoughnessMap : n.iridescenceMap ? s = n.iridescenceMap : n.iridescenceThicknessMap ? s = n.iridescenceThicknessMap : n.specularIntensityMap ? s = n.specularIntensityMap : n.specularColorMap ? s = n.specularColorMap : n.transmissionMap ? s = n.transmissionMap : n.thicknessMap ? s = n.thicknessMap : n.sheenColorMap ? s = n.sheenColorMap : n.sheenRoughnessMap && (s = n.sheenRoughnessMap),
            void 0 !== s && (s.isWebGLRenderTarget && (s = s.texture),
            !0 === s.matrixAutoUpdate && s.updateMatrix(),
              i.uvTransform.value.copy(s.matrix)),
              n.aoMap ? a = n.aoMap : n.lightMap && (a = n.lightMap),
            void 0 !== a && (a.isWebGLRenderTarget && (a = a.texture),
            !0 === a.matrixAutoUpdate && a.updateMatrix(),
              i.uv2Transform.value.copy(a.matrix))
          }
          return {
            refreshFogUniforms: function(e, t) {
              e.fogColor.value.copy(t.color),
                t.isFog ? (e.fogNear.value = t.near,
                  e.fogFar.value = t.far) : t.isFogExp2 && (e.fogDensity.value = t.density)
            },
            refreshMaterialUniforms: function(e, n, r, s, a) {
              n.isMeshBasicMaterial || n.isMeshLambertMaterial ? i(e, n) : n.isMeshToonMaterial ? (i(e, n),
                function(e, t) {
                  t.gradientMap && (e.gradientMap.value = t.gradientMap)
                }(e, n)) : n.isMeshPhongMaterial ? (i(e, n),
                function(e, t) {
                  e.specular.value.copy(t.specular),
                    e.shininess.value = Math.max(t.shininess, 1e-4)
                }(e, n)) : n.isMeshStandardMaterial ? (i(e, n),
                function(e, i) {
                  e.roughness.value = i.roughness,
                    e.metalness.value = i.metalness,
                  i.roughnessMap && (e.roughnessMap.value = i.roughnessMap),
                  i.metalnessMap && (e.metalnessMap.value = i.metalnessMap),
                  t.get(i).envMap && (e.envMapIntensity.value = i.envMapIntensity)
                }(e, n),
              n.isMeshPhysicalMaterial && function(e, t, i) {
                e.ior.value = t.ior,
                t.sheen > 0 && (e.sheenColor.value.copy(t.sheenColor).multiplyScalar(t.sheen),
                  e.sheenRoughness.value = t.sheenRoughness,
                t.sheenColorMap && (e.sheenColorMap.value = t.sheenColorMap),
                t.sheenRoughnessMap && (e.sheenRoughnessMap.value = t.sheenRoughnessMap)),
                t.clearcoat > 0 && (e.clearcoat.value = t.clearcoat,
                  e.clearcoatRoughness.value = t.clearcoatRoughness,
                t.clearcoatMap && (e.clearcoatMap.value = t.clearcoatMap),
                t.clearcoatRoughnessMap && (e.clearcoatRoughnessMap.value = t.clearcoatRoughnessMap),
                t.clearcoatNormalMap && (e.clearcoatNormalScale.value.copy(t.clearcoatNormalScale),
                  e.clearcoatNormalMap.value = t.clearcoatNormalMap,
                1 === t.side && e.clearcoatNormalScale.value.negate())),
                t.iridescence > 0 && (e.iridescence.value = t.iridescence,
                  e.iridescenceIOR.value = t.iridescenceIOR,
                  e.iridescenceThicknessMinimum.value = t.iridescenceThicknessRange[0],
                  e.iridescenceThicknessMaximum.value = t.iridescenceThicknessRange[1],
                t.iridescenceMap && (e.iridescenceMap.value = t.iridescenceMap),
                t.iridescenceThicknessMap && (e.iridescenceThicknessMap.value = t.iridescenceThicknessMap)),
                t.transmission > 0 && (e.transmission.value = t.transmission,
                  e.transmissionSamplerMap.value = i.texture,
                  e.transmissionSamplerSize.value.set(i.width, i.height),
                t.transmissionMap && (e.transmissionMap.value = t.transmissionMap),
                  e.thickness.value = t.thickness,
                t.thicknessMap && (e.thicknessMap.value = t.thicknessMap),
                  e.attenuationDistance.value = t.attenuationDistance,
                  e.attenuationColor.value.copy(t.attenuationColor)),
                  e.specularIntensity.value = t.specularIntensity,
                  e.specularColor.value.copy(t.specularColor),
                t.specularIntensityMap && (e.specularIntensityMap.value = t.specularIntensityMap),
                t.specularColorMap && (e.specularColorMap.value = t.specularColorMap)
              }(e, n, a)) : n.isMeshMatcapMaterial ? (i(e, n),
                function(e, t) {
                  t.matcap && (e.matcap.value = t.matcap)
                }(e, n)) : n.isMeshDepthMaterial ? i(e, n) : n.isMeshDistanceMaterial ? (i(e, n),
                function(e, t) {
                  e.referencePosition.value.copy(t.referencePosition),
                    e.nearDistance.value = t.nearDistance,
                    e.farDistance.value = t.farDistance
                }(e, n)) : n.isMeshNormalMaterial ? i(e, n) : n.isLineBasicMaterial ? (function(e, t) {
                e.diffuse.value.copy(t.color),
                  e.opacity.value = t.opacity
              }(e, n),
              n.isLineDashedMaterial && function(e, t) {
                e.dashSize.value = t.dashSize,
                  e.totalSize.value = t.dashSize + t.gapSize,
                  e.scale.value = t.scale
              }(e, n)) : n.isPointsMaterial ? function(e, t, i, n) {
                let r;
                e.diffuse.value.copy(t.color),
                  e.opacity.value = t.opacity,
                  e.size.value = t.size * i,
                  e.scale.value = .5 * n,
                t.map && (e.map.value = t.map),
                t.alphaMap && (e.alphaMap.value = t.alphaMap),
                t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest),
                  t.map ? r = t.map : t.alphaMap && (r = t.alphaMap),
                void 0 !== r && (!0 === r.matrixAutoUpdate && r.updateMatrix(),
                  e.uvTransform.value.copy(r.matrix))
              }(e, n, r, s) : n.isSpriteMaterial ? function(e, t) {
                let i;
                e.diffuse.value.copy(t.color),
                  e.opacity.value = t.opacity,
                  e.rotation.value = t.rotation,
                t.map && (e.map.value = t.map),
                t.alphaMap && (e.alphaMap.value = t.alphaMap),
                t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest),
                  t.map ? i = t.map : t.alphaMap && (i = t.alphaMap),
                void 0 !== i && (!0 === i.matrixAutoUpdate && i.updateMatrix(),
                  e.uvTransform.value.copy(i.matrix))
              }(e, n) : n.isShadowMaterial ? (e.color.value.copy(n.color),
                e.opacity.value = n.opacity) : n.isShaderMaterial && (n.uniformsNeedUpdate = !1)
            }
          }
        }
        function Yh(e={}) {
          this.isWebGLRenderer = !0;
          const t = void 0 !== e.canvas ? e.canvas : function() {
            const e = Lr("canvas");
            return e.style.display = "block",
              e
          }()
            , i = void 0 !== e.context ? e.context : null
            , n = void 0 === e.depth || e.depth
            , r = void 0 === e.stencil || e.stencil
            , s = void 0 !== e.antialias && e.antialias
            , a = void 0 === e.premultipliedAlpha || e.premultipliedAlpha
            , o = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer
            , l = void 0 !== e.powerPreference ? e.powerPreference : "default"
            , h = void 0 !== e.failIfMajorPerformanceCaveat && e.failIfMajorPerformanceCaveat;
          let c;
          c = null !== i ? i.getContextAttributes().alpha : void 0 !== e.alpha && e.alpha;
          let u = null
            , d = null;
          const p = []
            , f = [];
          this.domElement = t,
            this.debug = {
              checkShaderErrors: !0
            },
            this.autoClear = !0,
            this.autoClearColor = !0,
            this.autoClearDepth = !0,
            this.autoClearStencil = !0,
            this.sortObjects = !0,
            this.clippingPlanes = [],
            this.localClippingEnabled = !1,
            this.outputEncoding = hr,
            this.physicallyCorrectLights = !1,
            this.toneMapping = 0,
            this.toneMappingExposure = 1,
            Object.defineProperties(this, {
              gammaFactor: {
                get: function() {
                  return console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."),
                    2
                },
                set: function() {
                  console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.")
                }
              }
            });
          const m = this;
          let g = !1
            , v = 0
            , y = 0
            , x = null
            , _ = -1
            , b = null;
          const w = new Jr
            , A = new Jr;
          let S = null
            , M = t.width
            , T = t.height
            , E = 1
            , C = null
            , P = null;
          const D = new Jr(0,0,M,T)
            , I = new Jr(0,0,M,T);
          let R = !1;
          const L = new mo;
          let k = !1
            , F = !1
            , B = null;
          const O = new Rs
            , N = new Dr
            , z = new ts
            , U = {
            background: null,
            fog: null,
            environment: null,
            overrideMaterial: null,
            isScene: !0
          };
          function G() {
            return null === x ? E : 1
          }
          let V, H, W, j, X, Y, q, Q, K, J, Z, $, ee, te, ie, ne, re, se, ae, oe, le, he, ce, ue = i;
          function de(e, i) {
            for (let n = 0; n < e.length; n++) {
              const r = e[n]
                , s = t.getContext(r, i);
              if (null !== s)
                return s
            }
            return null
          }
          try {
            const e = {
              alpha: !0,
              depth: n,
              stencil: r,
              antialias: s,
              premultipliedAlpha: a,
              preserveDrawingBuffer: o,
              powerPreference: l,
              failIfMajorPerformanceCaveat: h
            };
            if ("setAttribute"in t && t.setAttribute("data-engine", "three.js r141"),
              t.addEventListener("webglcontextlost", me, !1),
              t.addEventListener("webglcontextrestored", ge, !1),
              t.addEventListener("webglcontextcreationerror", ve, !1),
            null === ue) {
              const t = ["webgl2", "webgl", "experimental-webgl"];
              if (!0 === m.isWebGL1Renderer && t.shift(),
                ue = de(t, e),
              null === ue)
                throw de(t) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
            }
            void 0 === ue.getShaderPrecisionFormat && (ue.getShaderPrecisionFormat = function() {
                return {
                  rangeMin: 1,
                  rangeMax: 1,
                  precision: 1
                }
              }
            )
          } catch (e) {
            throw console.error("THREE.WebGLRenderer: " + e.message),
              e
          }
          function pe() {
            V = new Vo(ue),
              H = new Mo(ue,V,e),
              V.init(H),
              he = new zh(ue,V,H),
              W = new Oh(ue,V,H),
              j = new jo(ue),
              X = new Ah,
              Y = new Nh(ue,V,W,X,H,he,j),
              q = new Eo(m),
              Q = new Go(m),
              K = new vo(ue,H),
              ce = new Ao(ue,V,K,H),
              J = new Ho(ue,K,j,ce),
              Z = new Ko(ue,J,K,j),
              ae = new Qo(ue,H,Y),
              ne = new To(X),
              $ = new wh(m,q,Q,V,H,ce,ne),
              ee = new Xh(m,X),
              te = new Eh,
              ie = new Lh(V,H),
              se = new wo(m,q,W,Z,c,a),
              re = new Bh(m,Z,H),
              oe = new So(ue,V,j,H),
              le = new Wo(ue,V,j,H),
              j.programs = $.programs,
              m.capabilities = H,
              m.extensions = V,
              m.properties = X,
              m.renderLists = te,
              m.shadowMap = re,
              m.state = W,
              m.info = j
          }
          pe();
          const fe = new jh(m,ue);
          function me(e) {
            e.preventDefault(),
              console.log("THREE.WebGLRenderer: Context Lost."),
              g = !0
          }
          function ge() {
            console.log("THREE.WebGLRenderer: Context Restored."),
              g = !1;
            const e = j.autoReset
              , t = re.enabled
              , i = re.autoUpdate
              , n = re.needsUpdate
              , r = re.type;
            pe(),
              j.autoReset = e,
              re.enabled = t,
              re.autoUpdate = i,
              re.needsUpdate = n,
              re.type = r
          }
          function ve(e) {
            console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", e.statusMessage)
          }
          function ye(e) {
            const t = e.target;
            t.removeEventListener("dispose", ye),
              function(e) {
                (function(e) {
                    const t = X.get(e).programs;
                    void 0 !== t && (t.forEach((function(e) {
                        $.releaseProgram(e)
                      }
                    )),
                    e.isShaderMaterial && $.releaseShaderCache(e))
                  }
                )(e),
                  X.remove(e)
              }(t)
          }
          this.xr = fe,
            this.getContext = function() {
              return ue
            }
            ,
            this.getContextAttributes = function() {
              return ue.getContextAttributes()
            }
            ,
            this.forceContextLoss = function() {
              const e = V.get("WEBGL_lose_context");
              e && e.loseContext()
            }
            ,
            this.forceContextRestore = function() {
              const e = V.get("WEBGL_lose_context");
              e && e.restoreContext()
            }
            ,
            this.getPixelRatio = function() {
              return E
            }
            ,
            this.setPixelRatio = function(e) {
              void 0 !== e && (E = e,
                this.setSize(M, T, !1))
            }
            ,
            this.getSize = function(e) {
              return e.set(M, T)
            }
            ,
            this.setSize = function(e, i, n) {
              fe.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (M = e,
                T = i,
                t.width = Math.floor(e * E),
                t.height = Math.floor(i * E),
              !1 !== n && (t.style.width = e + "px",
                t.style.height = i + "px"),
                this.setViewport(0, 0, e, i))
            }
            ,
            this.getDrawingBufferSize = function(e) {
              return e.set(M * E, T * E).floor()
            }
            ,
            this.setDrawingBufferSize = function(e, i, n) {
              M = e,
                T = i,
                E = n,
                t.width = Math.floor(e * n),
                t.height = Math.floor(i * n),
                this.setViewport(0, 0, e, i)
            }
            ,
            this.getCurrentViewport = function(e) {
              return e.copy(w)
            }
            ,
            this.getViewport = function(e) {
              return e.copy(D)
            }
            ,
            this.setViewport = function(e, t, i, n) {
              e.isVector4 ? D.set(e.x, e.y, e.z, e.w) : D.set(e, t, i, n),
                W.viewport(w.copy(D).multiplyScalar(E).floor())
            }
            ,
            this.getScissor = function(e) {
              return e.copy(I)
            }
            ,
            this.setScissor = function(e, t, i, n) {
              e.isVector4 ? I.set(e.x, e.y, e.z, e.w) : I.set(e, t, i, n),
                W.scissor(A.copy(I).multiplyScalar(E).floor())
            }
            ,
            this.getScissorTest = function() {
              return R
            }
            ,
            this.setScissorTest = function(e) {
              W.setScissorTest(R = e)
            }
            ,
            this.setOpaqueSort = function(e) {
              C = e
            }
            ,
            this.setTransparentSort = function(e) {
              P = e
            }
            ,
            this.getClearColor = function(e) {
              return e.copy(se.getClearColor())
            }
            ,
            this.setClearColor = function() {
              se.setClearColor.apply(se, arguments)
            }
            ,
            this.getClearAlpha = function() {
              return se.getClearAlpha()
            }
            ,
            this.setClearAlpha = function() {
              se.setClearAlpha.apply(se, arguments)
            }
            ,
            this.clear = function(e=!0, t=!0, i=!0) {
              let n = 0;
              e && (n |= 16384),
              t && (n |= 256),
              i && (n |= 1024),
                ue.clear(n)
            }
            ,
            this.clearColor = function() {
              this.clear(!0, !1, !1)
            }
            ,
            this.clearDepth = function() {
              this.clear(!1, !0, !1)
            }
            ,
            this.clearStencil = function() {
              this.clear(!1, !1, !0)
            }
            ,
            this.dispose = function() {
              t.removeEventListener("webglcontextlost", me, !1),
                t.removeEventListener("webglcontextrestored", ge, !1),
                t.removeEventListener("webglcontextcreationerror", ve, !1),
                te.dispose(),
                ie.dispose(),
                X.dispose(),
                q.dispose(),
                Q.dispose(),
                Z.dispose(),
                ce.dispose(),
                $.dispose(),
                fe.dispose(),
                fe.removeEventListener("sessionstart", _e),
                fe.removeEventListener("sessionend", be),
              B && (B.dispose(),
                B = null),
                we.stop()
            }
            ,
            this.renderBufferDirect = function(e, t, i, n, r, s) {
              null === t && (t = U);
              const a = r.isMesh && r.matrixWorld.determinant() < 0
                , o = function(e, t, i, n, r) {
                !0 !== t.isScene && (t = U),
                  Y.resetTextureUnits();
                const s = t.fog
                  , a = n.isMeshStandardMaterial ? t.environment : null
                  , o = null === x ? m.outputEncoding : !0 === x.isXRRenderTarget ? x.texture.encoding : hr
                  , l = (n.isMeshStandardMaterial ? Q : q).get(n.envMap || a)
                  , h = !0 === n.vertexColors && !!i.attributes.color && 4 === i.attributes.color.itemSize
                  , c = !!n.normalMap && !!i.attributes.tangent
                  , u = !!i.morphAttributes.position
                  , p = !!i.morphAttributes.normal
                  , f = !!i.morphAttributes.color
                  , g = n.toneMapped ? m.toneMapping : 0
                  , v = i.morphAttributes.position || i.morphAttributes.normal || i.morphAttributes.color
                  , y = void 0 !== v ? v.length : 0
                  , w = X.get(n)
                  , A = d.state.lights;
                if (!0 === k && (!0 === F || e !== b)) {
                  const t = e === b && n.id === _;
                  ne.setState(n, e, t)
                }
                let S = !1;
                n.version === w.__version ? w.needsLights && w.lightsStateVersion !== A.state.version || w.outputEncoding !== o || r.isInstancedMesh && !1 === w.instancing ? S = !0 : r.isInstancedMesh || !0 !== w.instancing ? r.isSkinnedMesh && !1 === w.skinning ? S = !0 : r.isSkinnedMesh || !0 !== w.skinning ? w.envMap !== l || !0 === n.fog && w.fog !== s ? S = !0 : void 0 === w.numClippingPlanes || w.numClippingPlanes === ne.numPlanes && w.numIntersection === ne.numIntersection ? (w.vertexAlphas !== h || w.vertexTangents !== c || w.morphTargets !== u || w.morphNormals !== p || w.morphColors !== f || w.toneMapping !== g || !0 === H.isWebGL2 && w.morphTargetsCount !== y) && (S = !0) : S = !0 : S = !0 : S = !0 : (S = !0,
                  w.__version = n.version);
                let M = w.currentProgram;
                !0 === S && (M = Ee(n, t, r));
                let C = !1
                  , P = !1
                  , D = !1;
                const I = M.getUniforms()
                  , R = w.uniforms;
                if (W.useProgram(M.program) && (C = !0,
                  P = !0,
                  D = !0),
                n.id !== _ && (_ = n.id,
                  P = !0),
                C || b !== e) {
                  if (I.setValue(ue, "projectionMatrix", e.projectionMatrix),
                  H.logarithmicDepthBuffer && I.setValue(ue, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)),
                  b !== e && (b = e,
                    P = !0,
                    D = !0),
                  n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshStandardMaterial || n.envMap) {
                    const t = I.map.cameraPosition;
                    void 0 !== t && t.setValue(ue, z.setFromMatrixPosition(e.matrixWorld))
                  }
                  (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial) && I.setValue(ue, "isOrthographic", !0 === e.isOrthographicCamera),
                  (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.isShadowMaterial || r.isSkinnedMesh) && I.setValue(ue, "viewMatrix", e.matrixWorldInverse)
                }
                if (r.isSkinnedMesh) {
                  I.setOptional(ue, r, "bindMatrix"),
                    I.setOptional(ue, r, "bindMatrixInverse");
                  const e = r.skeleton;
                  e && (H.floatVertexTextures ? (null === e.boneTexture && e.computeBoneTexture(),
                    I.setValue(ue, "boneTexture", e.boneTexture, Y),
                    I.setValue(ue, "boneTextureSize", e.boneTextureSize)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))
                }
                const L = i.morphAttributes;
                var O, N;
                return (void 0 !== L.position || void 0 !== L.normal || void 0 !== L.color && !0 === H.isWebGL2) && ae.update(r, i, n, M),
                (P || w.receiveShadow !== r.receiveShadow) && (w.receiveShadow = r.receiveShadow,
                  I.setValue(ue, "receiveShadow", r.receiveShadow)),
                P && (I.setValue(ue, "toneMappingExposure", m.toneMappingExposure),
                w.needsLights && (N = D,
                  (O = R).ambientLightColor.needsUpdate = N,
                  O.lightProbe.needsUpdate = N,
                  O.directionalLights.needsUpdate = N,
                  O.directionalLightShadows.needsUpdate = N,
                  O.pointLights.needsUpdate = N,
                  O.pointLightShadows.needsUpdate = N,
                  O.spotLights.needsUpdate = N,
                  O.spotLightShadows.needsUpdate = N,
                  O.rectAreaLights.needsUpdate = N,
                  O.hemisphereLights.needsUpdate = N),
                s && !0 === n.fog && ee.refreshFogUniforms(R, s),
                  ee.refreshMaterialUniforms(R, n, E, T, B),
                  eh.upload(ue, w.uniformsList, R, Y)),
                n.isShaderMaterial && !0 === n.uniformsNeedUpdate && (eh.upload(ue, w.uniformsList, R, Y),
                  n.uniformsNeedUpdate = !1),
                n.isSpriteMaterial && I.setValue(ue, "center", r.center),
                  I.setValue(ue, "modelViewMatrix", r.modelViewMatrix),
                  I.setValue(ue, "normalMatrix", r.normalMatrix),
                  I.setValue(ue, "modelMatrix", r.matrixWorld),
                  M
              }(e, t, i, n, r);
              W.setMaterial(n, a);
              let l = i.index;
              const h = i.attributes.position;
              if (null === l) {
                if (void 0 === h || 0 === h.count)
                  return
              } else if (0 === l.count)
                return;
              let c, u = 1;
              !0 === n.wireframe && (l = J.getWireframeAttribute(i),
                u = 2),
                ce.setup(r, n, o, i, l);
              let p = oe;
              null !== l && (c = K.get(l),
                p = le,
                p.setIndex(c));
              const f = null !== l ? l.count : h.count
                , g = i.drawRange.start * u
                , v = i.drawRange.count * u
                , y = null !== s ? s.start * u : 0
                , w = null !== s ? s.count * u : 1 / 0
                , A = Math.max(g, y)
                , S = Math.min(f, g + v, y + w) - 1
                , M = Math.max(0, S - A + 1);
              if (0 !== M) {
                if (r.isMesh)
                  !0 === n.wireframe ? (W.setLineWidth(n.wireframeLinewidth * G()),
                    p.setMode(1)) : p.setMode(4);
                else if (r.isLine) {
                  let e = n.linewidth;
                  void 0 === e && (e = 1),
                    W.setLineWidth(e * G()),
                    r.isLineSegments ? p.setMode(1) : r.isLineLoop ? p.setMode(2) : p.setMode(3)
                } else
                  r.isPoints ? p.setMode(0) : r.isSprite && p.setMode(4);
                if (r.isInstancedMesh)
                  p.renderInstances(A, M, r.count);
                else if (i.isInstancedBufferGeometry) {
                  const e = Math.min(i.instanceCount, i._maxInstanceCount);
                  p.renderInstances(A, M, e)
                } else
                  p.render(A, M)
              }
            }
            ,
            this.compile = function(e, t) {
              d = ie.get(e),
                d.init(),
                f.push(d),
                e.traverseVisible((function(e) {
                    e.isLight && e.layers.test(t.layers) && (d.pushLight(e),
                    e.castShadow && d.pushShadow(e))
                  }
                )),
                d.setupLights(m.physicallyCorrectLights),
                e.traverse((function(t) {
                    const i = t.material;
                    if (i)
                      if (Array.isArray(i))
                        for (let n = 0; n < i.length; n++)
                          Ee(i[n], e, t);
                      else
                        Ee(i, e, t)
                  }
                )),
                f.pop(),
                d = null
            }
          ;
          let xe = null;
          function _e() {
            we.stop()
          }
          function be() {
            we.start()
          }
          const we = new go;
          function Ae(e, t, i, n) {
            if (!1 === e.visible)
              return;
            if (e.layers.test(t.layers))
              if (e.isGroup)
                i = e.renderOrder;
              else if (e.isLOD)
                !0 === e.autoUpdate && e.update(t);
              else if (e.isLight)
                d.pushLight(e),
                e.castShadow && d.pushShadow(e);
              else if (e.isSprite) {
                if (!e.frustumCulled || L.intersectsSprite(e)) {
                  n && z.setFromMatrixPosition(e.matrixWorld).applyMatrix4(O);
                  const t = Z.update(e)
                    , r = e.material;
                  r.visible && u.push(e, t, r, i, z.z, null)
                }
              } else if ((e.isMesh || e.isLine || e.isPoints) && (e.isSkinnedMesh && e.skeleton.frame !== j.render.frame && (e.skeleton.update(),
                e.skeleton.frame = j.render.frame),
              !e.frustumCulled || L.intersectsObject(e))) {
                n && z.setFromMatrixPosition(e.matrixWorld).applyMatrix4(O);
                const t = Z.update(e)
                  , r = e.material;
                if (Array.isArray(r)) {
                  const n = t.groups;
                  for (let s = 0, a = n.length; s < a; s++) {
                    const a = n[s]
                      , o = r[a.materialIndex];
                    o && o.visible && u.push(e, t, o, i, z.z, a)
                  }
                } else
                  r.visible && u.push(e, t, r, i, z.z, null)
              }
            const r = e.children;
            for (let e = 0, s = r.length; e < s; e++)
              Ae(r[e], t, i, n)
          }
          function Se(e, t, i, n) {
            const r = e.opaque
              , a = e.transmissive
              , o = e.transparent;
            d.setupLightsView(i),
            a.length > 0 && function(e, t, i) {
              const n = H.isWebGL2;
              null === B && (B = new Zr(1,1,{
                generateMipmaps: !0,
                type: V.has("EXT_color_buffer_half_float") ? qn : jn,
                minFilter: Wn,
                samples: n && !0 === s ? 4 : 0
              })),
                m.getDrawingBufferSize(N),
                n ? B.setSize(N.x, N.y) : B.setSize(Cr(N.x), Cr(N.y));
              const r = m.getRenderTarget();
              m.setRenderTarget(B),
                m.clear();
              const a = m.toneMapping;
              m.toneMapping = 0,
                Me(e, t, i),
                m.toneMapping = a,
                Y.updateMultisampleRenderTarget(B),
                Y.updateRenderTargetMipmap(B),
                m.setRenderTarget(r)
            }(r, t, i),
            n && W.viewport(w.copy(n)),
            r.length > 0 && Me(r, t, i),
            a.length > 0 && Me(a, t, i),
            o.length > 0 && Me(o, t, i),
              W.buffers.depth.setTest(!0),
              W.buffers.depth.setMask(!0),
              W.buffers.color.setMask(!0),
              W.setPolygonOffset(!1)
          }
          function Me(e, t, i) {
            const n = !0 === t.isScene ? t.overrideMaterial : null;
            for (let r = 0, s = e.length; r < s; r++) {
              const s = e[r]
                , a = s.object
                , o = s.geometry
                , l = null === n ? s.material : n
                , h = s.group;
              a.layers.test(i.layers) && Te(a, t, i, o, l, h)
            }
          }
          function Te(e, t, i, n, r, s) {
            e.onBeforeRender(m, t, i, n, r, s),
              e.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, e.matrixWorld),
              e.normalMatrix.getNormalMatrix(e.modelViewMatrix),
              r.onBeforeRender(m, t, i, n, e, s),
              !0 === r.transparent && 2 === r.side ? (r.side = 1,
                r.needsUpdate = !0,
                m.renderBufferDirect(i, t, n, r, e, s),
                r.side = 0,
                r.needsUpdate = !0,
                m.renderBufferDirect(i, t, n, r, e, s),
                r.side = 2) : m.renderBufferDirect(i, t, n, r, e, s),
              e.onAfterRender(m, t, i, n, r, s)
          }
          function Ee(e, t, i) {
            !0 !== t.isScene && (t = U);
            const n = X.get(e)
              , r = d.state.lights
              , s = d.state.shadowsArray
              , a = r.state.version
              , o = $.getParameters(e, r.state, s, t, i)
              , l = $.getProgramCacheKey(o);
            let h = n.programs;
            n.environment = e.isMeshStandardMaterial ? t.environment : null,
              n.fog = t.fog,
              n.envMap = (e.isMeshStandardMaterial ? Q : q).get(e.envMap || n.environment),
            void 0 === h && (e.addEventListener("dispose", ye),
              h = new Map,
              n.programs = h);
            let c = h.get(l);
            if (void 0 !== c) {
              if (n.currentProgram === c && n.lightsStateVersion === a)
                return Ce(e, o),
                  c
            } else
              o.uniforms = $.getUniforms(e),
                e.onBuild(i, o, m),
                e.onBeforeCompile(o, m),
                c = $.acquireProgram(o, l),
                h.set(l, c),
                n.uniforms = o.uniforms;
            const u = n.uniforms;
            (e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (u.clippingPlanes = ne.uniform),
              Ce(e, o),
              n.needsLights = function(e) {
                return e.isMeshLambertMaterial || e.isMeshToonMaterial || e.isMeshPhongMaterial || e.isMeshStandardMaterial || e.isShadowMaterial || e.isShaderMaterial && !0 === e.lights
              }(e),
              n.lightsStateVersion = a,
            n.needsLights && (u.ambientLightColor.value = r.state.ambient,
              u.lightProbe.value = r.state.probe,
              u.directionalLights.value = r.state.directional,
              u.directionalLightShadows.value = r.state.directionalShadow,
              u.spotLights.value = r.state.spot,
              u.spotLightShadows.value = r.state.spotShadow,
              u.rectAreaLights.value = r.state.rectArea,
              u.ltc_1.value = r.state.rectAreaLTC1,
              u.ltc_2.value = r.state.rectAreaLTC2,
              u.pointLights.value = r.state.point,
              u.pointLightShadows.value = r.state.pointShadow,
              u.hemisphereLights.value = r.state.hemi,
              u.directionalShadowMap.value = r.state.directionalShadowMap,
              u.directionalShadowMatrix.value = r.state.directionalShadowMatrix,
              u.spotShadowMap.value = r.state.spotShadowMap,
              u.spotShadowMatrix.value = r.state.spotShadowMatrix,
              u.pointShadowMap.value = r.state.pointShadowMap,
              u.pointShadowMatrix.value = r.state.pointShadowMatrix);
            const p = c.getUniforms()
              , f = eh.seqWithValue(p.seq, u);
            return n.currentProgram = c,
              n.uniformsList = f,
              c
          }
          function Ce(e, t) {
            const i = X.get(e);
            i.outputEncoding = t.outputEncoding,
              i.instancing = t.instancing,
              i.skinning = t.skinning,
              i.morphTargets = t.morphTargets,
              i.morphNormals = t.morphNormals,
              i.morphColors = t.morphColors,
              i.morphTargetsCount = t.morphTargetsCount,
              i.numClippingPlanes = t.numClippingPlanes,
              i.numIntersection = t.numClipIntersection,
              i.vertexAlphas = t.vertexAlphas,
              i.vertexTangents = t.vertexTangents,
              i.toneMapping = t.toneMapping
          }
          we.setAnimationLoop((function(e) {
              xe && xe(e)
            }
          )),
          "undefined" != typeof self && we.setContext(self),
            this.setAnimationLoop = function(e) {
              xe = e,
                fe.setAnimationLoop(e),
                null === e ? we.stop() : we.start()
            }
            ,
            fe.addEventListener("sessionstart", _e),
            fe.addEventListener("sessionend", be),
            this.render = function(e, t) {
              if (void 0 !== t && !0 !== t.isCamera)
                return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
              if (!0 === g)
                return;
              !0 === e.autoUpdate && e.updateMatrixWorld(),
              null === t.parent && t.updateMatrixWorld(),
              !0 === fe.enabled && !0 === fe.isPresenting && (!0 === fe.cameraAutoUpdate && fe.updateCamera(t),
                t = fe.getCamera()),
              !0 === e.isScene && e.onBeforeRender(m, e, t, x),
                d = ie.get(e, f.length),
                d.init(),
                f.push(d),
                O.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
                L.setFromProjectionMatrix(O),
                F = this.localClippingEnabled,
                k = ne.init(this.clippingPlanes, F, t),
                u = te.get(e, p.length),
                u.init(),
                p.push(u),
                Ae(e, t, 0, m.sortObjects),
                u.finish(),
              !0 === m.sortObjects && u.sort(C, P),
              !0 === k && ne.beginShadows();
              const i = d.state.shadowsArray;
              if (re.render(i, e, t),
              !0 === k && ne.endShadows(),
              !0 === this.info.autoReset && this.info.reset(),
                se.render(u, e),
                d.setupLights(m.physicallyCorrectLights),
                t.isArrayCamera) {
                const i = t.cameras;
                for (let t = 0, n = i.length; t < n; t++) {
                  const n = i[t];
                  Se(u, e, n, n.viewport)
                }
              } else
                Se(u, e, t);
              null !== x && (Y.updateMultisampleRenderTarget(x),
                Y.updateRenderTargetMipmap(x)),
              !0 === e.isScene && e.onAfterRender(m, e, t),
                ce.resetDefaultState(),
                _ = -1,
                b = null,
                f.pop(),
                d = f.length > 0 ? f[f.length - 1] : null,
                p.pop(),
                u = p.length > 0 ? p[p.length - 1] : null
            }
            ,
            this.getActiveCubeFace = function() {
              return v
            }
            ,
            this.getActiveMipmapLevel = function() {
              return y
            }
            ,
            this.getRenderTarget = function() {
              return x
            }
            ,
            this.setRenderTargetTextures = function(e, t, i) {
              X.get(e.texture).__webglTexture = t,
                X.get(e.depthTexture).__webglTexture = i;
              const n = X.get(e);
              n.__hasExternalTextures = !0,
              n.__hasExternalTextures && (n.__autoAllocateDepthBuffer = void 0 === i,
              n.__autoAllocateDepthBuffer || !0 === V.has("WEBGL_multisampled_render_to_texture") && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),
                n.__useRenderToTexture = !1))
            }
            ,
            this.setRenderTargetFramebuffer = function(e, t) {
              const i = X.get(e);
              i.__webglFramebuffer = t,
                i.__useDefaultFramebuffer = void 0 === t
            }
            ,
            this.setRenderTarget = function(e, t=0, i=0) {
              x = e,
                v = t,
                y = i;
              let n = !0;
              if (e) {
                const t = X.get(e);
                void 0 !== t.__useDefaultFramebuffer ? (W.bindFramebuffer(36160, null),
                  n = !1) : void 0 === t.__webglFramebuffer ? Y.setupRenderTarget(e) : t.__hasExternalTextures && Y.rebindTextures(e, X.get(e.texture).__webglTexture, X.get(e.depthTexture).__webglTexture)
              }
              let r = null
                , s = !1
                , a = !1;
              if (e) {
                const i = e.texture;
                (i.isData3DTexture || i.isDataArrayTexture) && (a = !0);
                const n = X.get(e).__webglFramebuffer;
                e.isWebGLCubeRenderTarget ? (r = n[t],
                  s = !0) : r = H.isWebGL2 && e.samples > 0 && !1 === Y.useMultisampledRTT(e) ? X.get(e).__webglMultisampledFramebuffer : n,
                  w.copy(e.viewport),
                  A.copy(e.scissor),
                  S = e.scissorTest
              } else
                w.copy(D).multiplyScalar(E).floor(),
                  A.copy(I).multiplyScalar(E).floor(),
                  S = R;
              if (W.bindFramebuffer(36160, r) && H.drawBuffers && n && W.drawBuffers(e, r),
                W.viewport(w),
                W.scissor(A),
                W.setScissorTest(S),
                s) {
                const n = X.get(e.texture);
                ue.framebufferTexture2D(36160, 36064, 34069 + t, n.__webglTexture, i)
              } else if (a) {
                const n = X.get(e.texture)
                  , r = t || 0;
                ue.framebufferTextureLayer(36160, 36064, n.__webglTexture, i || 0, r)
              }
              _ = -1
            }
            ,
            this.readRenderTargetPixels = function(e, t, i, n, r, s, a) {
              if (!e || !e.isWebGLRenderTarget)
                return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
              let o = X.get(e).__webglFramebuffer;
              if (e.isWebGLCubeRenderTarget && void 0 !== a && (o = o[a]),
                o) {
                W.bindFramebuffer(36160, o);
                try {
                  const a = e.texture
                    , o = a.format
                    , l = a.type;
                  if (o !== Kn && he.convert(o) !== ue.getParameter(35739))
                    return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                  const h = l === qn && (V.has("EXT_color_buffer_half_float") || H.isWebGL2 && V.has("EXT_color_buffer_float"));
                  if (!(l === jn || he.convert(l) === ue.getParameter(35738) || l === Yn && (H.isWebGL2 || V.has("OES_texture_float") || V.has("WEBGL_color_buffer_float")) || h))
                    return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                  t >= 0 && t <= e.width - n && i >= 0 && i <= e.height - r && ue.readPixels(t, i, n, r, he.convert(o), he.convert(l), s)
                } finally {
                  const e = null !== x ? X.get(x).__webglFramebuffer : null;
                  W.bindFramebuffer(36160, e)
                }
              }
            }
            ,
            this.copyFramebufferToTexture = function(e, t, i=0) {
              const n = Math.pow(2, -i)
                , r = Math.floor(t.image.width * n)
                , s = Math.floor(t.image.height * n);
              Y.setTexture2D(t, 0),
                ue.copyTexSubImage2D(3553, i, 0, 0, e.x, e.y, r, s),
                W.unbindTexture()
            }
            ,
            this.copyTextureToTexture = function(e, t, i, n=0) {
              const r = t.image.width
                , s = t.image.height
                , a = he.convert(i.format)
                , o = he.convert(i.type);
              Y.setTexture2D(i, 0),
                ue.pixelStorei(37440, i.flipY),
                ue.pixelStorei(37441, i.premultiplyAlpha),
                ue.pixelStorei(3317, i.unpackAlignment),
                t.isDataTexture ? ue.texSubImage2D(3553, n, e.x, e.y, r, s, a, o, t.image.data) : t.isCompressedTexture ? ue.compressedTexSubImage2D(3553, n, e.x, e.y, t.mipmaps[0].width, t.mipmaps[0].height, a, t.mipmaps[0].data) : ue.texSubImage2D(3553, n, e.x, e.y, a, o, t.image),
              0 === n && i.generateMipmaps && ue.generateMipmap(3553),
                W.unbindTexture()
            }
            ,
            this.copyTextureToTexture3D = function(e, t, i, n, r=0) {
              if (m.isWebGL1Renderer)
                return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
              const s = e.max.x - e.min.x + 1
                , a = e.max.y - e.min.y + 1
                , o = e.max.z - e.min.z + 1
                , l = he.convert(n.format)
                , h = he.convert(n.type);
              let c;
              if (n.isData3DTexture)
                Y.setTexture3D(n, 0),
                  c = 32879;
              else {
                if (!n.isDataArrayTexture)
                  return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                Y.setTexture2DArray(n, 0),
                  c = 35866
              }
              ue.pixelStorei(37440, n.flipY),
                ue.pixelStorei(37441, n.premultiplyAlpha),
                ue.pixelStorei(3317, n.unpackAlignment);
              const u = ue.getParameter(3314)
                , d = ue.getParameter(32878)
                , p = ue.getParameter(3316)
                , f = ue.getParameter(3315)
                , g = ue.getParameter(32877)
                , v = i.isCompressedTexture ? i.mipmaps[0] : i.image;
              ue.pixelStorei(3314, v.width),
                ue.pixelStorei(32878, v.height),
                ue.pixelStorei(3316, e.min.x),
                ue.pixelStorei(3315, e.min.y),
                ue.pixelStorei(32877, e.min.z),
                i.isDataTexture || i.isData3DTexture ? ue.texSubImage3D(c, r, t.x, t.y, t.z, s, a, o, l, h, v.data) : i.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),
                  ue.compressedTexSubImage3D(c, r, t.x, t.y, t.z, s, a, o, l, v.data)) : ue.texSubImage3D(c, r, t.x, t.y, t.z, s, a, o, l, h, v),
                ue.pixelStorei(3314, u),
                ue.pixelStorei(32878, d),
                ue.pixelStorei(3316, p),
                ue.pixelStorei(3315, f),
                ue.pixelStorei(32877, g),
              0 === r && n.generateMipmaps && ue.generateMipmap(c),
                W.unbindTexture()
            }
            ,
            this.initTexture = function(e) {
              Y.setTexture2D(e, 0),
                W.unbindTexture()
            }
            ,
            this.resetState = function() {
              v = 0,
                y = 0,
                x = null,
                W.reset(),
                ce.reset()
            }
            ,
          "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
            detail: this
          }))
        }
        (class extends Yh {
          }
        ).prototype.isWebGL1Renderer = !0;
        class qh extends na {
          constructor() {
            super(),
              this.isScene = !0,
              this.type = "Scene",
              this.background = null,
              this.environment = null,
              this.fog = null,
              this.overrideMaterial = null,
              this.autoUpdate = !0,
            "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
              detail: this
            }))
          }
          copy(e, t) {
            return super.copy(e, t),
            null !== e.background && (this.background = e.background.clone()),
            null !== e.environment && (this.environment = e.environment.clone()),
            null !== e.fog && (this.fog = e.fog.clone()),
            null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()),
              this.autoUpdate = e.autoUpdate,
              this.matrixAutoUpdate = e.matrixAutoUpdate,
              this
          }
          toJSON(e) {
            const t = super.toJSON(e);
            return null !== this.fog && (t.object.fog = this.fog.toJSON()),
              t
          }
        }
        class Qh {
          constructor(e, t) {
            this.isInterleavedBuffer = !0,
              this.array = e,
              this.stride = t,
              this.count = void 0 !== e ? e.length / t : 0,
              this.usage = fr,
              this.updateRange = {
                offset: 0,
                count: -1
              },
              this.version = 0,
              this.uuid = wr()
          }
          onUploadCallback() {}
          set needsUpdate(e) {
            !0 === e && this.version++
          }
          setUsage(e) {
            return this.usage = e,
              this
          }
          copy(e) {
            return this.array = new e.array.constructor(e.array),
              this.count = e.count,
              this.stride = e.stride,
              this.usage = e.usage,
              this
          }
          copyAt(e, t, i) {
            e *= this.stride,
              i *= t.stride;
            for (let n = 0, r = this.stride; n < r; n++)
              this.array[e + n] = t.array[i + n];
            return this
          }
          set(e, t=0) {
            return this.array.set(e, t),
              this
          }
          clone(e) {
            void 0 === e.arrayBuffers && (e.arrayBuffers = {}),
            void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = wr()),
            void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
            const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid])
              , i = new this.constructor(t,this.stride);
            return i.setUsage(this.usage),
              i
          }
          onUpload(e) {
            return this.onUploadCallback = e,
              this
          }
          toJSON(e) {
            return void 0 === e.arrayBuffers && (e.arrayBuffers = {}),
            void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = wr()),
            void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))),
              {
                uuid: this.uuid,
                buffer: this.array.buffer._uuid,
                type: this.array.constructor.name,
                stride: this.stride
              }
          }
        }
        const Kh = new ts;
        class Jh {
          constructor(e, t, i, n=!1) {
            this.isInterleavedBufferAttribute = !0,
              this.name = "",
              this.data = e,
              this.itemSize = t,
              this.offset = i,
              this.normalized = !0 === n
          }
          get count() {
            return this.data.count
          }
          get array() {
            return this.data.array
          }
          set needsUpdate(e) {
            this.data.needsUpdate = e
          }
          applyMatrix4(e) {
            for (let t = 0, i = this.data.count; t < i; t++)
              Kh.fromBufferAttribute(this, t),
                Kh.applyMatrix4(e),
                this.setXYZ(t, Kh.x, Kh.y, Kh.z);
            return this
          }
          applyNormalMatrix(e) {
            for (let t = 0, i = this.count; t < i; t++)
              Kh.fromBufferAttribute(this, t),
                Kh.applyNormalMatrix(e),
                this.setXYZ(t, Kh.x, Kh.y, Kh.z);
            return this
          }
          transformDirection(e) {
            for (let t = 0, i = this.count; t < i; t++)
              Kh.fromBufferAttribute(this, t),
                Kh.transformDirection(e),
                this.setXYZ(t, Kh.x, Kh.y, Kh.z);
            return this
          }
          setX(e, t) {
            return this.data.array[e * this.data.stride + this.offset] = t,
              this
          }
          setY(e, t) {
            return this.data.array[e * this.data.stride + this.offset + 1] = t,
              this
          }
          setZ(e, t) {
            return this.data.array[e * this.data.stride + this.offset + 2] = t,
              this
          }
          setW(e, t) {
            return this.data.array[e * this.data.stride + this.offset + 3] = t,
              this
          }
          getX(e) {
            return this.data.array[e * this.data.stride + this.offset]
          }
          getY(e) {
            return this.data.array[e * this.data.stride + this.offset + 1]
          }
          getZ(e) {
            return this.data.array[e * this.data.stride + this.offset + 2]
          }
          getW(e) {
            return this.data.array[e * this.data.stride + this.offset + 3]
          }
          setXY(e, t, i) {
            return e = e * this.data.stride + this.offset,
              this.data.array[e + 0] = t,
              this.data.array[e + 1] = i,
              this
          }
          setXYZ(e, t, i, n) {
            return e = e * this.data.stride + this.offset,
              this.data.array[e + 0] = t,
              this.data.array[e + 1] = i,
              this.data.array[e + 2] = n,
              this
          }
          setXYZW(e, t, i, n, r) {
            return e = e * this.data.stride + this.offset,
              this.data.array[e + 0] = t,
              this.data.array[e + 1] = i,
              this.data.array[e + 2] = n,
              this.data.array[e + 3] = r,
              this
          }
          clone(e) {
            if (void 0 === e) {
              console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
              const e = [];
              for (let t = 0; t < this.count; t++) {
                const i = t * this.data.stride + this.offset;
                for (let t = 0; t < this.itemSize; t++)
                  e.push(this.data.array[i + t])
              }
              return new _a(new this.array.constructor(e),this.itemSize,this.normalized)
            }
            return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}),
            void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
              new Jh(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)
          }
          toJSON(e) {
            if (void 0 === e) {
              console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
              const e = [];
              for (let t = 0; t < this.count; t++) {
                const i = t * this.data.stride + this.offset;
                for (let t = 0; t < this.itemSize; t++)
                  e.push(this.data.array[i + t])
              }
              return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: e,
                normalized: this.normalized
              }
            }
            return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}),
            void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
              {
                isInterleavedBufferAttribute: !0,
                itemSize: this.itemSize,
                data: this.data.uuid,
                offset: this.offset,
                normalized: this.normalized
              }
          }
        }
        const Zh = new ts
          , $h = new Jr
          , ec = new Jr
          , tc = new ts
          , ic = new Rs;
        class nc extends Qa {
          constructor(e, t) {
            super(e, t),
              this.isSkinnedMesh = !0,
              this.type = "SkinnedMesh",
              this.bindMode = "attached",
              this.bindMatrix = new Rs,
              this.bindMatrixInverse = new Rs
          }
          copy(e, t) {
            return super.copy(e, t),
              this.bindMode = e.bindMode,
              this.bindMatrix.copy(e.bindMatrix),
              this.bindMatrixInverse.copy(e.bindMatrixInverse),
              this.skeleton = e.skeleton,
              this
          }
          bind(e, t) {
            this.skeleton = e,
            void 0 === t && (this.updateMatrixWorld(!0),
              this.skeleton.calculateInverses(),
              t = this.matrixWorld),
              this.bindMatrix.copy(t),
              this.bindMatrixInverse.copy(t).invert()
          }
          pose() {
            this.skeleton.pose()
          }
          normalizeSkinWeights() {
            const e = new Jr
              , t = this.geometry.attributes.skinWeight;
            for (let i = 0, n = t.count; i < n; i++) {
              e.fromBufferAttribute(t, i);
              const n = 1 / e.manhattanLength();
              n !== 1 / 0 ? e.multiplyScalar(n) : e.set(1, 0, 0, 0),
                t.setXYZW(i, e.x, e.y, e.z, e.w)
            }
          }
          updateMatrixWorld(e) {
            super.updateMatrixWorld(e),
              "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
          }
          boneTransform(e, t) {
            const i = this.skeleton
              , n = this.geometry;
            $h.fromBufferAttribute(n.attributes.skinIndex, e),
              ec.fromBufferAttribute(n.attributes.skinWeight, e),
              Zh.copy(t).applyMatrix4(this.bindMatrix),
              t.set(0, 0, 0);
            for (let e = 0; e < 4; e++) {
              const n = ec.getComponent(e);
              if (0 !== n) {
                const r = $h.getComponent(e);
                ic.multiplyMatrices(i.bones[r].matrixWorld, i.boneInverses[r]),
                  t.addScaledVector(tc.copy(Zh).applyMatrix4(ic), n)
              }
            }
            return t.applyMatrix4(this.bindMatrixInverse)
          }
        }
        class rc extends na {
          constructor() {
            super(),
              this.isBone = !0,
              this.type = "Bone"
          }
        }
        class sc extends Kr {
          constructor(e=null, t=1, i=1, n, r, s, a, o, l=1003, h=1003, c, u) {
            super(null, s, a, o, l, h, n, r, c, u),
              this.isDataTexture = !0,
              this.image = {
                data: e,
                width: t,
                height: i
              },
              this.generateMipmaps = !1,
              this.flipY = !1,
              this.unpackAlignment = 1
          }
        }
        const ac = new Rs
          , oc = new Rs;
        class lc {
          constructor(e=[], t=[]) {
            this.uuid = wr(),
              this.bones = e.slice(0),
              this.boneInverses = t,
              this.boneMatrices = null,
              this.boneTexture = null,
              this.boneTextureSize = 0,
              this.frame = -1,
              this.init()
          }
          init() {
            const e = this.bones
              , t = this.boneInverses;
            if (this.boneMatrices = new Float32Array(16 * e.length),
            0 === t.length)
              this.calculateInverses();
            else if (e.length !== t.length) {
              console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),
                this.boneInverses = [];
              for (let e = 0, t = this.bones.length; e < t; e++)
                this.boneInverses.push(new Rs)
            }
          }
          calculateInverses() {
            this.boneInverses.length = 0;
            for (let e = 0, t = this.bones.length; e < t; e++) {
              const t = new Rs;
              this.bones[e] && t.copy(this.bones[e].matrixWorld).invert(),
                this.boneInverses.push(t)
            }
          }
          pose() {
            for (let e = 0, t = this.bones.length; e < t; e++) {
              const t = this.bones[e];
              t && t.matrixWorld.copy(this.boneInverses[e]).invert()
            }
            for (let e = 0, t = this.bones.length; e < t; e++) {
              const t = this.bones[e];
              t && (t.parent && t.parent.isBone ? (t.matrix.copy(t.parent.matrixWorld).invert(),
                t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld),
                t.matrix.decompose(t.position, t.quaternion, t.scale))
            }
          }
          update() {
            const e = this.bones
              , t = this.boneInverses
              , i = this.boneMatrices
              , n = this.boneTexture;
            for (let n = 0, r = e.length; n < r; n++) {
              const r = e[n] ? e[n].matrixWorld : oc;
              ac.multiplyMatrices(r, t[n]),
                ac.toArray(i, 16 * n)
            }
            null !== n && (n.needsUpdate = !0)
          }
          clone() {
            return new lc(this.bones,this.boneInverses)
          }
          computeBoneTexture() {
            let e = Math.sqrt(4 * this.bones.length);
            e = Er(e),
              e = Math.max(e, 4);
            const t = new Float32Array(e * e * 4);
            t.set(this.boneMatrices);
            const i = new sc(t,e,e,Kn,Yn);
            return i.needsUpdate = !0,
              this.boneMatrices = t,
              this.boneTexture = i,
              this.boneTextureSize = e,
              this
          }
          getBoneByName(e) {
            for (let t = 0, i = this.bones.length; t < i; t++) {
              const i = this.bones[t];
              if (i.name === e)
                return i
            }
          }
          dispose() {
            null !== this.boneTexture && (this.boneTexture.dispose(),
              this.boneTexture = null)
          }
          fromJSON(e, t) {
            this.uuid = e.uuid;
            for (let i = 0, n = e.bones.length; i < n; i++) {
              const n = e.bones[i];
              let r = t[n];
              void 0 === r && (console.warn("THREE.Skeleton: No bone found with UUID:", n),
                r = new rc),
                this.bones.push(r),
                this.boneInverses.push((new Rs).fromArray(e.boneInverses[i]))
            }
            return this.init(),
              this
          }
          toJSON() {
            const e = {
              metadata: {
                version: 4.5,
                type: "Skeleton",
                generator: "Skeleton.toJSON"
              },
              bones: [],
              boneInverses: []
            };
            e.uuid = this.uuid;
            const t = this.bones
              , i = this.boneInverses;
            for (let n = 0, r = t.length; n < r; n++) {
              const r = t[n];
              e.bones.push(r.uuid);
              const s = i[n];
              e.boneInverses.push(s.toArray())
            }
            return e
          }
        }
        class hc extends _a {
          constructor(e, t, i, n=1) {
            "number" == typeof i && (n = i,
              i = !1,
              console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),
              super(e, t, i),
              this.isInstancedBufferAttribute = !0,
              this.meshPerAttribute = n
          }
          copy(e) {
            return super.copy(e),
              this.meshPerAttribute = e.meshPerAttribute,
              this
          }
          toJSON() {
            const e = super.toJSON();
            return e.meshPerAttribute = this.meshPerAttribute,
              e.isInstancedBufferAttribute = !0,
              e
          }
        }
        const cc = new Rs
          , uc = new Rs
          , dc = []
          , pc = new Qa;
        class fc extends Qa {
          constructor(e, t, i) {
            super(e, t),
              this.isInstancedMesh = !0,
              this.instanceMatrix = new hc(new Float32Array(16 * i),16),
              this.instanceColor = null,
              this.count = i,
              this.frustumCulled = !1
          }
          copy(e, t) {
            return super.copy(e, t),
              this.instanceMatrix.copy(e.instanceMatrix),
            null !== e.instanceColor && (this.instanceColor = e.instanceColor.clone()),
              this.count = e.count,
              this
          }
          getColorAt(e, t) {
            t.fromArray(this.instanceColor.array, 3 * e)
          }
          getMatrixAt(e, t) {
            t.fromArray(this.instanceMatrix.array, 16 * e)
          }
          raycast(e, t) {
            const i = this.matrixWorld
              , n = this.count;
            if (pc.geometry = this.geometry,
              pc.material = this.material,
            void 0 !== pc.material)
              for (let r = 0; r < n; r++) {
                this.getMatrixAt(r, cc),
                  uc.multiplyMatrices(i, cc),
                  pc.matrixWorld = uc,
                  pc.raycast(e, dc);
                for (let e = 0, i = dc.length; e < i; e++) {
                  const i = dc[e];
                  i.instanceId = r,
                    i.object = this,
                    t.push(i)
                }
                dc.length = 0
              }
          }
          setColorAt(e, t) {
            null === this.instanceColor && (this.instanceColor = new hc(new Float32Array(3 * this.instanceMatrix.count),3)),
              t.toArray(this.instanceColor.array, 3 * e)
          }
          setMatrixAt(e, t) {
            t.toArray(this.instanceMatrix.array, 16 * e)
          }
          updateMorphTargets() {}
          dispose() {
            this.dispatchEvent({
              type: "dispose"
            })
          }
        }
        class mc extends ga {
          constructor(e) {
            super(),
              this.isLineBasicMaterial = !0,
              this.type = "LineBasicMaterial",
              this.color = new Wr(16777215),
              this.linewidth = 1,
              this.linecap = "round",
              this.linejoin = "round",
              this.fog = !0,
              this.setValues(e)
          }
          copy(e) {
            return super.copy(e),
              this.color.copy(e.color),
              this.linewidth = e.linewidth,
              this.linecap = e.linecap,
              this.linejoin = e.linejoin,
              this.fog = e.fog,
              this
          }
        }
        const gc = new ts
          , vc = new ts
          , yc = new Rs
          , xc = new Is
          , _c = new As;
        class bc extends na {
          constructor(e=new Ia, t=new mc) {
            super(),
              this.isLine = !0,
              this.type = "Line",
              this.geometry = e,
              this.material = t,
              this.updateMorphTargets()
          }
          copy(e, t) {
            return super.copy(e, t),
              this.material = e.material,
              this.geometry = e.geometry,
              this
          }
          computeLineDistances() {
            const e = this.geometry;
            if (null === e.index) {
              const t = e.attributes.position
                , i = [0];
              for (let e = 1, n = t.count; e < n; e++)
                gc.fromBufferAttribute(t, e - 1),
                  vc.fromBufferAttribute(t, e),
                  i[e] = i[e - 1],
                  i[e] += gc.distanceTo(vc);
              e.setAttribute("lineDistance", new Aa(i,1))
            } else
              console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
            return this
          }
          raycast(e, t) {
            const i = this.geometry
              , n = this.matrixWorld
              , r = e.params.Line.threshold
              , s = i.drawRange;
            if (null === i.boundingSphere && i.computeBoundingSphere(),
              _c.copy(i.boundingSphere),
              _c.applyMatrix4(n),
              _c.radius += r,
            !1 === e.ray.intersectsSphere(_c))
              return;
            yc.copy(n).invert(),
              xc.copy(e.ray).applyMatrix4(yc);
            const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3)
              , o = a * a
              , l = new ts
              , h = new ts
              , c = new ts
              , u = new ts
              , d = this.isLineSegments ? 2 : 1
              , p = i.index
              , f = i.attributes.position;
            if (null !== p)
              for (let i = Math.max(0, s.start), n = Math.min(p.count, s.start + s.count) - 1; i < n; i += d) {
                const n = p.getX(i)
                  , r = p.getX(i + 1);
                if (l.fromBufferAttribute(f, n),
                  h.fromBufferAttribute(f, r),
                xc.distanceSqToSegment(l, h, u, c) > o)
                  continue;
                u.applyMatrix4(this.matrixWorld);
                const s = e.ray.origin.distanceTo(u);
                s < e.near || s > e.far || t.push({
                  distance: s,
                  point: c.clone().applyMatrix4(this.matrixWorld),
                  index: i,
                  face: null,
                  faceIndex: null,
                  object: this
                })
              }
            else
              for (let i = Math.max(0, s.start), n = Math.min(f.count, s.start + s.count) - 1; i < n; i += d) {
                if (l.fromBufferAttribute(f, i),
                  h.fromBufferAttribute(f, i + 1),
                xc.distanceSqToSegment(l, h, u, c) > o)
                  continue;
                u.applyMatrix4(this.matrixWorld);
                const n = e.ray.origin.distanceTo(u);
                n < e.near || n > e.far || t.push({
                  distance: n,
                  point: c.clone().applyMatrix4(this.matrixWorld),
                  index: i,
                  face: null,
                  faceIndex: null,
                  object: this
                })
              }
          }
          updateMorphTargets() {
            const e = this.geometry.morphAttributes
              , t = Object.keys(e);
            if (t.length > 0) {
              const i = e[t[0]];
              if (void 0 !== i) {
                this.morphTargetInfluences = [],
                  this.morphTargetDictionary = {};
                for (let e = 0, t = i.length; e < t; e++) {
                  const t = i[e].name || String(e);
                  this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[t] = e
                }
              }
            }
          }
        }
        const wc = new ts
          , Ac = new ts;
        class Sc extends bc {
          constructor(e, t) {
            super(e, t),
              this.isLineSegments = !0,
              this.type = "LineSegments"
          }
          computeLineDistances() {
            const e = this.geometry;
            if (null === e.index) {
              const t = e.attributes.position
                , i = [];
              for (let e = 0, n = t.count; e < n; e += 2)
                wc.fromBufferAttribute(t, e),
                  Ac.fromBufferAttribute(t, e + 1),
                  i[e] = 0 === e ? 0 : i[e - 1],
                  i[e + 1] = i[e] + wc.distanceTo(Ac);
              e.setAttribute("lineDistance", new Aa(i,1))
            } else
              console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
            return this
          }
        }
        class Mc extends bc {
          constructor(e, t) {
            super(e, t),
              this.isLineLoop = !0,
              this.type = "LineLoop"
          }
        }
        class Tc extends ga {
          constructor(e) {
            super(),
              this.isPointsMaterial = !0,
              this.type = "PointsMaterial",
              this.color = new Wr(16777215),
              this.map = null,
              this.alphaMap = null,
              this.size = 1,
              this.sizeAttenuation = !0,
              this.fog = !0,
              this.setValues(e)
          }
          copy(e) {
            return super.copy(e),
              this.color.copy(e.color),
              this.map = e.map,
              this.alphaMap = e.alphaMap,
              this.size = e.size,
              this.sizeAttenuation = e.sizeAttenuation,
              this.fog = e.fog,
              this
          }
        }
        const Ec = new Rs
          , Cc = new Is
          , Pc = new As
          , Dc = new ts;
        class Ic extends na {
          constructor(e=new Ia, t=new Tc) {
            super(),
              this.isPoints = !0,
              this.type = "Points",
              this.geometry = e,
              this.material = t,
              this.updateMorphTargets()
          }
          copy(e, t) {
            return super.copy(e, t),
              this.material = e.material,
              this.geometry = e.geometry,
              this
          }
          raycast(e, t) {
            const i = this.geometry
              , n = this.matrixWorld
              , r = e.params.Points.threshold
              , s = i.drawRange;
            if (null === i.boundingSphere && i.computeBoundingSphere(),
              Pc.copy(i.boundingSphere),
              Pc.applyMatrix4(n),
              Pc.radius += r,
            !1 === e.ray.intersectsSphere(Pc))
              return;
            Ec.copy(n).invert(),
              Cc.copy(e.ray).applyMatrix4(Ec);
            const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3)
              , o = a * a
              , l = i.index
              , h = i.attributes.position;
            if (null !== l)
              for (let i = Math.max(0, s.start), r = Math.min(l.count, s.start + s.count); i < r; i++) {
                const r = l.getX(i);
                Dc.fromBufferAttribute(h, r),
                  Rc(Dc, r, o, n, e, t, this)
              }
            else
              for (let i = Math.max(0, s.start), r = Math.min(h.count, s.start + s.count); i < r; i++)
                Dc.fromBufferAttribute(h, i),
                  Rc(Dc, i, o, n, e, t, this)
          }
          updateMorphTargets() {
            const e = this.geometry.morphAttributes
              , t = Object.keys(e);
            if (t.length > 0) {
              const i = e[t[0]];
              if (void 0 !== i) {
                this.morphTargetInfluences = [],
                  this.morphTargetDictionary = {};
                for (let e = 0, t = i.length; e < t; e++) {
                  const t = i[e].name || String(e);
                  this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[t] = e
                }
              }
            }
          }
        }
        function Rc(e, t, i, n, r, s, a) {
          const o = Cc.distanceSqToPoint(e);
          if (o < i) {
            const i = new ts;
            Cc.closestPointToPoint(e, i),
              i.applyMatrix4(n);
            const l = r.ray.origin.distanceTo(i);
            if (l < r.near || l > r.far)
              return;
            s.push({
              distance: l,
              distanceToRay: Math.sqrt(o),
              point: i,
              index: t,
              face: null,
              object: a
            })
          }
        }
        class Lc {
          constructor() {
            this.type = "Curve",
              this.arcLengthDivisions = 200
          }
          getPoint() {
            return console.warn("THREE.Curve: .getPoint() not implemented."),
              null
          }
          getPointAt(e, t) {
            const i = this.getUtoTmapping(e);
            return this.getPoint(i, t)
          }
          getPoints(e=5) {
            const t = [];
            for (let i = 0; i <= e; i++)
              t.push(this.getPoint(i / e));
            return t
          }
          getSpacedPoints(e=5) {
            const t = [];
            for (let i = 0; i <= e; i++)
              t.push(this.getPointAt(i / e));
            return t
          }
          getLength() {
            const e = this.getLengths();
            return e[e.length - 1]
          }
          getLengths(e=this.arcLengthDivisions) {
            if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
              return this.cacheArcLengths;
            this.needsUpdate = !1;
            const t = [];
            let i, n = this.getPoint(0), r = 0;
            t.push(0);
            for (let s = 1; s <= e; s++)
              i = this.getPoint(s / e),
                r += i.distanceTo(n),
                t.push(r),
                n = i;
            return this.cacheArcLengths = t,
              t
          }
          updateArcLengths() {
            this.needsUpdate = !0,
              this.getLengths()
          }
          getUtoTmapping(e, t) {
            const i = this.getLengths();
            let n = 0;
            const r = i.length;
            let s;
            s = t || e * i[r - 1];
            let a, o = 0, l = r - 1;
            for (; o <= l; )
              if (n = Math.floor(o + (l - o) / 2),
                a = i[n] - s,
              a < 0)
                o = n + 1;
              else {
                if (!(a > 0)) {
                  l = n;
                  break
                }
                l = n - 1
              }
            if (n = l,
            i[n] === s)
              return n / (r - 1);
            const h = i[n];
            return (n + (s - h) / (i[n + 1] - h)) / (r - 1)
          }
          getTangent(e, t) {
            const i = 1e-4;
            let n = e - i
              , r = e + i;
            n < 0 && (n = 0),
            r > 1 && (r = 1);
            const s = this.getPoint(n)
              , a = this.getPoint(r)
              , o = t || (s.isVector2 ? new Dr : new ts);
            return o.copy(a).sub(s).normalize(),
              o
          }
          getTangentAt(e, t) {
            const i = this.getUtoTmapping(e);
            return this.getTangent(i, t)
          }
          computeFrenetFrames(e, t) {
            const i = new ts
              , n = []
              , r = []
              , s = []
              , a = new ts
              , o = new Rs;
            for (let t = 0; t <= e; t++) {
              const i = t / e;
              n[t] = this.getTangentAt(i, new ts)
            }
            r[0] = new ts,
              s[0] = new ts;
            let l = Number.MAX_VALUE;
            const h = Math.abs(n[0].x)
              , c = Math.abs(n[0].y)
              , u = Math.abs(n[0].z);
            h <= l && (l = h,
              i.set(1, 0, 0)),
            c <= l && (l = c,
              i.set(0, 1, 0)),
            u <= l && i.set(0, 0, 1),
              a.crossVectors(n[0], i).normalize(),
              r[0].crossVectors(n[0], a),
              s[0].crossVectors(n[0], r[0]);
            for (let t = 1; t <= e; t++) {
              if (r[t] = r[t - 1].clone(),
                s[t] = s[t - 1].clone(),
                a.crossVectors(n[t - 1], n[t]),
              a.length() > Number.EPSILON) {
                a.normalize();
                const e = Math.acos(Ar(n[t - 1].dot(n[t]), -1, 1));
                r[t].applyMatrix4(o.makeRotationAxis(a, e))
              }
              s[t].crossVectors(n[t], r[t])
            }
            if (!0 === t) {
              let t = Math.acos(Ar(r[0].dot(r[e]), -1, 1));
              t /= e,
              n[0].dot(a.crossVectors(r[0], r[e])) > 0 && (t = -t);
              for (let i = 1; i <= e; i++)
                r[i].applyMatrix4(o.makeRotationAxis(n[i], t * i)),
                  s[i].crossVectors(n[i], r[i])
            }
            return {
              tangents: n,
              normals: r,
              binormals: s
            }
          }
          clone() {
            return (new this.constructor).copy(this)
          }
          copy(e) {
            return this.arcLengthDivisions = e.arcLengthDivisions,
              this
          }
          toJSON() {
            const e = {
              metadata: {
                version: 4.5,
                type: "Curve",
                generator: "Curve.toJSON"
              }
            };
            return e.arcLengthDivisions = this.arcLengthDivisions,
              e.type = this.type,
              e
          }
          fromJSON(e) {
            return this.arcLengthDivisions = e.arcLengthDivisions,
              this
          }
        }
        class kc extends Lc {
          constructor(e=0, t=0, i=1, n=1, r=0, s=2 * Math.PI, a=!1, o=0) {
            super(),
              this.isEllipseCurve = !0,
              this.type = "EllipseCurve",
              this.aX = e,
              this.aY = t,
              this.xRadius = i,
              this.yRadius = n,
              this.aStartAngle = r,
              this.aEndAngle = s,
              this.aClockwise = a,
              this.aRotation = o
          }
          getPoint(e, t) {
            const i = t || new Dr
              , n = 2 * Math.PI;
            let r = this.aEndAngle - this.aStartAngle;
            const s = Math.abs(r) < Number.EPSILON;
            for (; r < 0; )
              r += n;
            for (; r > n; )
              r -= n;
            r < Number.EPSILON && (r = s ? 0 : n),
            !0 !== this.aClockwise || s || (r === n ? r = -n : r -= n);
            const a = this.aStartAngle + e * r;
            let o = this.aX + this.xRadius * Math.cos(a)
              , l = this.aY + this.yRadius * Math.sin(a);
            if (0 !== this.aRotation) {
              const e = Math.cos(this.aRotation)
                , t = Math.sin(this.aRotation)
                , i = o - this.aX
                , n = l - this.aY;
              o = i * e - n * t + this.aX,
                l = i * t + n * e + this.aY
            }
            return i.set(o, l)
          }
          copy(e) {
            return super.copy(e),
              this.aX = e.aX,
              this.aY = e.aY,
              this.xRadius = e.xRadius,
              this.yRadius = e.yRadius,
              this.aStartAngle = e.aStartAngle,
              this.aEndAngle = e.aEndAngle,
              this.aClockwise = e.aClockwise,
              this.aRotation = e.aRotation,
              this
          }
          toJSON() {
            const e = super.toJSON();
            return e.aX = this.aX,
              e.aY = this.aY,
              e.xRadius = this.xRadius,
              e.yRadius = this.yRadius,
              e.aStartAngle = this.aStartAngle,
              e.aEndAngle = this.aEndAngle,
              e.aClockwise = this.aClockwise,
              e.aRotation = this.aRotation,
              e
          }
          fromJSON(e) {
            return super.fromJSON(e),
              this.aX = e.aX,
              this.aY = e.aY,
              this.xRadius = e.xRadius,
              this.yRadius = e.yRadius,
              this.aStartAngle = e.aStartAngle,
              this.aEndAngle = e.aEndAngle,
              this.aClockwise = e.aClockwise,
              this.aRotation = e.aRotation,
              this
          }
        }
        function Fc() {
          let e = 0
            , t = 0
            , i = 0
            , n = 0;
          function r(r, s, a, o) {
            e = r,
              t = a,
              i = -3 * r + 3 * s - 2 * a - o,
              n = 2 * r - 2 * s + a + o
          }
          return {
            initCatmullRom: function(e, t, i, n, s) {
              r(t, i, s * (i - e), s * (n - t))
            },
            initNonuniformCatmullRom: function(e, t, i, n, s, a, o) {
              let l = (t - e) / s - (i - e) / (s + a) + (i - t) / a
                , h = (i - t) / a - (n - t) / (a + o) + (n - i) / o;
              l *= a,
                h *= a,
                r(t, i, l, h)
            },
            calc: function(r) {
              const s = r * r;
              return e + t * r + i * s + n * (s * r)
            }
          }
        }
        const Bc = new ts
          , Oc = new Fc
          , Nc = new Fc
          , zc = new Fc;
        class Uc extends Lc {
          constructor(e=[], t=!1, i="centripetal", n=.5) {
            super(),
              this.isCatmullRomCurve3 = !0,
              this.type = "CatmullRomCurve3",
              this.points = e,
              this.closed = t,
              this.curveType = i,
              this.tension = n
          }
          getPoint(e, t=new ts) {
            const i = t
              , n = this.points
              , r = n.length
              , s = (r - (this.closed ? 0 : 1)) * e;
            let a, o, l = Math.floor(s), h = s - l;
            this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / r) + 1) * r : 0 === h && l === r - 1 && (l = r - 2,
              h = 1),
              this.closed || l > 0 ? a = n[(l - 1) % r] : (Bc.subVectors(n[0], n[1]).add(n[0]),
                a = Bc);
            const c = n[l % r]
              , u = n[(l + 1) % r];
            if (this.closed || l + 2 < r ? o = n[(l + 2) % r] : (Bc.subVectors(n[r - 1], n[r - 2]).add(n[r - 1]),
              o = Bc),
            "centripetal" === this.curveType || "chordal" === this.curveType) {
              const e = "chordal" === this.curveType ? .5 : .25;
              let t = Math.pow(a.distanceToSquared(c), e)
                , i = Math.pow(c.distanceToSquared(u), e)
                , n = Math.pow(u.distanceToSquared(o), e);
              i < 1e-4 && (i = 1),
              t < 1e-4 && (t = i),
              n < 1e-4 && (n = i),
                Oc.initNonuniformCatmullRom(a.x, c.x, u.x, o.x, t, i, n),
                Nc.initNonuniformCatmullRom(a.y, c.y, u.y, o.y, t, i, n),
                zc.initNonuniformCatmullRom(a.z, c.z, u.z, o.z, t, i, n)
            } else
              "catmullrom" === this.curveType && (Oc.initCatmullRom(a.x, c.x, u.x, o.x, this.tension),
                Nc.initCatmullRom(a.y, c.y, u.y, o.y, this.tension),
                zc.initCatmullRom(a.z, c.z, u.z, o.z, this.tension));
            return i.set(Oc.calc(h), Nc.calc(h), zc.calc(h)),
              i
          }
          copy(e) {
            super.copy(e),
              this.points = [];
            for (let t = 0, i = e.points.length; t < i; t++) {
              const i = e.points[t];
              this.points.push(i.clone())
            }
            return this.closed = e.closed,
              this.curveType = e.curveType,
              this.tension = e.tension,
              this
          }
          toJSON() {
            const e = super.toJSON();
            e.points = [];
            for (let t = 0, i = this.points.length; t < i; t++) {
              const i = this.points[t];
              e.points.push(i.toArray())
            }
            return e.closed = this.closed,
              e.curveType = this.curveType,
              e.tension = this.tension,
              e
          }
          fromJSON(e) {
            super.fromJSON(e),
              this.points = [];
            for (let t = 0, i = e.points.length; t < i; t++) {
              const i = e.points[t];
              this.points.push((new ts).fromArray(i))
            }
            return this.closed = e.closed,
              this.curveType = e.curveType,
              this.tension = e.tension,
              this
          }
        }
        function Gc(e, t, i, n, r) {
          const s = .5 * (n - t)
            , a = .5 * (r - i)
            , o = e * e;
          return (2 * i - 2 * n + s + a) * (e * o) + (-3 * i + 3 * n - 2 * s - a) * o + s * e + i
        }
        function Vc(e, t, i, n) {
          return function(e, t) {
            const i = 1 - e;
            return i * i * t
          }(e, t) + function(e, t) {
            return 2 * (1 - e) * e * t
          }(e, i) + function(e, t) {
            return e * e * t
          }(e, n)
        }
        function Hc(e, t, i, n, r) {
          return function(e, t) {
            const i = 1 - e;
            return i * i * i * t
          }(e, t) + function(e, t) {
            const i = 1 - e;
            return 3 * i * i * e * t
          }(e, i) + function(e, t) {
            return 3 * (1 - e) * e * e * t
          }(e, n) + function(e, t) {
            return e * e * e * t
          }(e, r)
        }
        class Wc extends Lc {
          constructor(e=new ts, t=new ts, i=new ts) {
            super(),
              this.isQuadraticBezierCurve3 = !0,
              this.type = "QuadraticBezierCurve3",
              this.v0 = e,
              this.v1 = t,
              this.v2 = i
          }
          getPoint(e, t=new ts) {
            const i = t
              , n = this.v0
              , r = this.v1
              , s = this.v2;
            return i.set(Vc(e, n.x, r.x, s.x), Vc(e, n.y, r.y, s.y), Vc(e, n.z, r.z, s.z)),
              i
          }
          copy(e) {
            return super.copy(e),
              this.v0.copy(e.v0),
              this.v1.copy(e.v1),
              this.v2.copy(e.v2),
              this
          }
          toJSON() {
            const e = super.toJSON();
            return e.v0 = this.v0.toArray(),
              e.v1 = this.v1.toArray(),
              e.v2 = this.v2.toArray(),
              e
          }
          fromJSON(e) {
            return super.fromJSON(e),
              this.v0.fromArray(e.v0),
              this.v1.fromArray(e.v1),
              this.v2.fromArray(e.v2),
              this
          }
        }
        var jc = Object.freeze({
          __proto__: null,
          ArcCurve: class extends kc {
            constructor(e, t, i, n, r, s) {
              super(e, t, i, i, n, r, s),
                this.isArcCurve = !0,
                this.type = "ArcCurve"
            }
          }
          ,
          CatmullRomCurve3: Uc,
          CubicBezierCurve: class extends Lc {
            constructor(e=new Dr, t=new Dr, i=new Dr, n=new Dr) {
              super(),
                this.isCubicBezierCurve = !0,
                this.type = "CubicBezierCurve",
                this.v0 = e,
                this.v1 = t,
                this.v2 = i,
                this.v3 = n
            }
            getPoint(e, t=new Dr) {
              const i = t
                , n = this.v0
                , r = this.v1
                , s = this.v2
                , a = this.v3;
              return i.set(Hc(e, n.x, r.x, s.x, a.x), Hc(e, n.y, r.y, s.y, a.y)),
                i
            }
            copy(e) {
              return super.copy(e),
                this.v0.copy(e.v0),
                this.v1.copy(e.v1),
                this.v2.copy(e.v2),
                this.v3.copy(e.v3),
                this
            }
            toJSON() {
              const e = super.toJSON();
              return e.v0 = this.v0.toArray(),
                e.v1 = this.v1.toArray(),
                e.v2 = this.v2.toArray(),
                e.v3 = this.v3.toArray(),
                e
            }
            fromJSON(e) {
              return super.fromJSON(e),
                this.v0.fromArray(e.v0),
                this.v1.fromArray(e.v1),
                this.v2.fromArray(e.v2),
                this.v3.fromArray(e.v3),
                this
            }
          }
          ,
          CubicBezierCurve3: class extends Lc {
            constructor(e=new ts, t=new ts, i=new ts, n=new ts) {
              super(),
                this.isCubicBezierCurve3 = !0,
                this.type = "CubicBezierCurve3",
                this.v0 = e,
                this.v1 = t,
                this.v2 = i,
                this.v3 = n
            }
            getPoint(e, t=new ts) {
              const i = t
                , n = this.v0
                , r = this.v1
                , s = this.v2
                , a = this.v3;
              return i.set(Hc(e, n.x, r.x, s.x, a.x), Hc(e, n.y, r.y, s.y, a.y), Hc(e, n.z, r.z, s.z, a.z)),
                i
            }
            copy(e) {
              return super.copy(e),
                this.v0.copy(e.v0),
                this.v1.copy(e.v1),
                this.v2.copy(e.v2),
                this.v3.copy(e.v3),
                this
            }
            toJSON() {
              const e = super.toJSON();
              return e.v0 = this.v0.toArray(),
                e.v1 = this.v1.toArray(),
                e.v2 = this.v2.toArray(),
                e.v3 = this.v3.toArray(),
                e
            }
            fromJSON(e) {
              return super.fromJSON(e),
                this.v0.fromArray(e.v0),
                this.v1.fromArray(e.v1),
                this.v2.fromArray(e.v2),
                this.v3.fromArray(e.v3),
                this
            }
          }
          ,
          EllipseCurve: kc,
          LineCurve: class extends Lc {
            constructor(e=new Dr, t=new Dr) {
              super(),
                this.isLineCurve = !0,
                this.type = "LineCurve",
                this.v1 = e,
                this.v2 = t
            }
            getPoint(e, t=new Dr) {
              const i = t;
              return 1 === e ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1),
                i.multiplyScalar(e).add(this.v1)),
                i
            }
            getPointAt(e, t) {
              return this.getPoint(e, t)
            }
            getTangent(e, t) {
              const i = t || new Dr;
              return i.copy(this.v2).sub(this.v1).normalize(),
                i
            }
            copy(e) {
              return super.copy(e),
                this.v1.copy(e.v1),
                this.v2.copy(e.v2),
                this
            }
            toJSON() {
              const e = super.toJSON();
              return e.v1 = this.v1.toArray(),
                e.v2 = this.v2.toArray(),
                e
            }
            fromJSON(e) {
              return super.fromJSON(e),
                this.v1.fromArray(e.v1),
                this.v2.fromArray(e.v2),
                this
            }
          }
          ,
          LineCurve3: class extends Lc {
            constructor(e=new ts, t=new ts) {
              super(),
                this.isLineCurve3 = !0,
                this.type = "LineCurve3",
                this.v1 = e,
                this.v2 = t
            }
            getPoint(e, t=new ts) {
              const i = t;
              return 1 === e ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1),
                i.multiplyScalar(e).add(this.v1)),
                i
            }
            getPointAt(e, t) {
              return this.getPoint(e, t)
            }
            copy(e) {
              return super.copy(e),
                this.v1.copy(e.v1),
                this.v2.copy(e.v2),
                this
            }
            toJSON() {
              const e = super.toJSON();
              return e.v1 = this.v1.toArray(),
                e.v2 = this.v2.toArray(),
                e
            }
            fromJSON(e) {
              return super.fromJSON(e),
                this.v1.fromArray(e.v1),
                this.v2.fromArray(e.v2),
                this
            }
          }
          ,
          QuadraticBezierCurve: class extends Lc {
            constructor(e=new Dr, t=new Dr, i=new Dr) {
              super(),
                this.isQuadraticBezierCurve = !0,
                this.type = "QuadraticBezierCurve",
                this.v0 = e,
                this.v1 = t,
                this.v2 = i
            }
            getPoint(e, t=new Dr) {
              const i = t
                , n = this.v0
                , r = this.v1
                , s = this.v2;
              return i.set(Vc(e, n.x, r.x, s.x), Vc(e, n.y, r.y, s.y)),
                i
            }
            copy(e) {
              return super.copy(e),
                this.v0.copy(e.v0),
                this.v1.copy(e.v1),
                this.v2.copy(e.v2),
                this
            }
            toJSON() {
              const e = super.toJSON();
              return e.v0 = this.v0.toArray(),
                e.v1 = this.v1.toArray(),
                e.v2 = this.v2.toArray(),
                e
            }
            fromJSON(e) {
              return super.fromJSON(e),
                this.v0.fromArray(e.v0),
                this.v1.fromArray(e.v1),
                this.v2.fromArray(e.v2),
                this
            }
          }
          ,
          QuadraticBezierCurve3: Wc,
          SplineCurve: class extends Lc {
            constructor(e=[]) {
              super(),
                this.isSplineCurve = !0,
                this.type = "SplineCurve",
                this.points = e
            }
            getPoint(e, t=new Dr) {
              const i = t
                , n = this.points
                , r = (n.length - 1) * e
                , s = Math.floor(r)
                , a = r - s
                , o = n[0 === s ? s : s - 1]
                , l = n[s]
                , h = n[s > n.length - 2 ? n.length - 1 : s + 1]
                , c = n[s > n.length - 3 ? n.length - 1 : s + 2];
              return i.set(Gc(a, o.x, l.x, h.x, c.x), Gc(a, o.y, l.y, h.y, c.y)),
                i
            }
            copy(e) {
              super.copy(e),
                this.points = [];
              for (let t = 0, i = e.points.length; t < i; t++) {
                const i = e.points[t];
                this.points.push(i.clone())
              }
              return this
            }
            toJSON() {
              const e = super.toJSON();
              e.points = [];
              for (let t = 0, i = this.points.length; t < i; t++) {
                const i = this.points[t];
                e.points.push(i.toArray())
              }
              return e
            }
            fromJSON(e) {
              super.fromJSON(e),
                this.points = [];
              for (let t = 0, i = e.points.length; t < i; t++) {
                const i = e.points[t];
                this.points.push((new Dr).fromArray(i))
              }
              return this
            }
          }
        });
        class Xc extends Ia {
          constructor(e=[], t=[], i=1, n=0) {
            super(),
              this.type = "PolyhedronGeometry",
              this.parameters = {
                vertices: e,
                indices: t,
                radius: i,
                detail: n
              };
            const r = []
              , s = [];
            function a(e, t, i, n) {
              const r = n + 1
                , s = [];
              for (let n = 0; n <= r; n++) {
                s[n] = [];
                const a = e.clone().lerp(i, n / r)
                  , o = t.clone().lerp(i, n / r)
                  , l = r - n;
                for (let e = 0; e <= l; e++)
                  s[n][e] = 0 === e && n === r ? a : a.clone().lerp(o, e / l)
              }
              for (let e = 0; e < r; e++)
                for (let t = 0; t < 2 * (r - e) - 1; t++) {
                  const i = Math.floor(t / 2);
                  t % 2 == 0 ? (o(s[e][i + 1]),
                    o(s[e + 1][i]),
                    o(s[e][i])) : (o(s[e][i + 1]),
                    o(s[e + 1][i + 1]),
                    o(s[e + 1][i]))
                }
            }
            function o(e) {
              r.push(e.x, e.y, e.z)
            }
            function l(t, i) {
              const n = 3 * t;
              i.x = e[n + 0],
                i.y = e[n + 1],
                i.z = e[n + 2]
            }
            function h(e, t, i, n) {
              n < 0 && 1 === e.x && (s[t] = e.x - 1),
              0 === i.x && 0 === i.z && (s[t] = n / 2 / Math.PI + .5)
            }
            function c(e) {
              return Math.atan2(e.z, -e.x)
            }
            !function(e) {
              const i = new ts
                , n = new ts
                , r = new ts;
              for (let s = 0; s < t.length; s += 3)
                l(t[s + 0], i),
                  l(t[s + 1], n),
                  l(t[s + 2], r),
                  a(i, n, r, e)
            }(n),
              function(e) {
                const t = new ts;
                for (let i = 0; i < r.length; i += 3)
                  t.x = r[i + 0],
                    t.y = r[i + 1],
                    t.z = r[i + 2],
                    t.normalize().multiplyScalar(e),
                    r[i + 0] = t.x,
                    r[i + 1] = t.y,
                    r[i + 2] = t.z
              }(i),
              function() {
                const e = new ts;
                for (let i = 0; i < r.length; i += 3) {
                  e.x = r[i + 0],
                    e.y = r[i + 1],
                    e.z = r[i + 2];
                  const n = c(e) / 2 / Math.PI + .5
                    , a = (t = e,
                  Math.atan2(-t.y, Math.sqrt(t.x * t.x + t.z * t.z)) / Math.PI + .5);
                  s.push(n, 1 - a)
                }
                var t;
                (function() {
                    const e = new ts
                      , t = new ts
                      , i = new ts
                      , n = new ts
                      , a = new Dr
                      , o = new Dr
                      , l = new Dr;
                    for (let u = 0, d = 0; u < r.length; u += 9,
                      d += 6) {
                      e.set(r[u + 0], r[u + 1], r[u + 2]),
                        t.set(r[u + 3], r[u + 4], r[u + 5]),
                        i.set(r[u + 6], r[u + 7], r[u + 8]),
                        a.set(s[d + 0], s[d + 1]),
                        o.set(s[d + 2], s[d + 3]),
                        l.set(s[d + 4], s[d + 5]),
                        n.copy(e).add(t).add(i).divideScalar(3);
                      const p = c(n);
                      h(a, d + 0, e, p),
                        h(o, d + 2, t, p),
                        h(l, d + 4, i, p)
                    }
                  }
                )(),
                  function() {
                    for (let e = 0; e < s.length; e += 6) {
                      const t = s[e + 0]
                        , i = s[e + 2]
                        , n = s[e + 4]
                        , r = Math.max(t, i, n)
                        , a = Math.min(t, i, n);
                      r > .9 && a < .1 && (t < .2 && (s[e + 0] += 1),
                      i < .2 && (s[e + 2] += 1),
                      n < .2 && (s[e + 4] += 1))
                    }
                  }()
              }(),
              this.setAttribute("position", new Aa(r,3)),
              this.setAttribute("normal", new Aa(r.slice(),3)),
              this.setAttribute("uv", new Aa(s,2)),
              0 === n ? this.computeVertexNormals() : this.normalizeNormals()
          }
          static fromJSON(e) {
            return new Xc(e.vertices,e.indices,e.radius,e.details)
          }
        }
        new ts,
          new ts,
          new ts,
          new fa;
        class Yc extends Xc {
          constructor(e=1, t=0) {
            super([1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], e, t),
              this.type = "OctahedronGeometry",
              this.parameters = {
                radius: e,
                detail: t
              }
          }
          static fromJSON(e) {
            return new Yc(e.radius,e.detail)
          }
        }
        class qc extends Ia {
          constructor(e=1, t=32, i=16, n=0, r=2 * Math.PI, s=0, a=Math.PI) {
            super(),
              this.type = "SphereGeometry",
              this.parameters = {
                radius: e,
                widthSegments: t,
                heightSegments: i,
                phiStart: n,
                phiLength: r,
                thetaStart: s,
                thetaLength: a
              },
              t = Math.max(3, Math.floor(t)),
              i = Math.max(2, Math.floor(i));
            const o = Math.min(s + a, Math.PI);
            let l = 0;
            const h = []
              , c = new ts
              , u = new ts
              , d = []
              , p = []
              , f = []
              , m = [];
            for (let d = 0; d <= i; d++) {
              const g = []
                , v = d / i;
              let y = 0;
              0 == d && 0 == s ? y = .5 / t : d == i && o == Math.PI && (y = -.5 / t);
              for (let i = 0; i <= t; i++) {
                const o = i / t;
                c.x = -e * Math.cos(n + o * r) * Math.sin(s + v * a),
                  c.y = e * Math.cos(s + v * a),
                  c.z = e * Math.sin(n + o * r) * Math.sin(s + v * a),
                  p.push(c.x, c.y, c.z),
                  u.copy(c).normalize(),
                  f.push(u.x, u.y, u.z),
                  m.push(o + y, 1 - v),
                  g.push(l++)
              }
              h.push(g)
            }
            for (let e = 0; e < i; e++)
              for (let n = 0; n < t; n++) {
                const t = h[e][n + 1]
                  , r = h[e][n]
                  , a = h[e + 1][n]
                  , l = h[e + 1][n + 1];
                (0 !== e || s > 0) && d.push(t, r, l),
                (e !== i - 1 || o < Math.PI) && d.push(r, a, l)
              }
            this.setIndex(d),
              this.setAttribute("position", new Aa(p,3)),
              this.setAttribute("normal", new Aa(f,3)),
              this.setAttribute("uv", new Aa(m,2))
          }
          static fromJSON(e) {
            return new qc(e.radius,e.widthSegments,e.heightSegments,e.phiStart,e.phiLength,e.thetaStart,e.thetaLength)
          }
        }
        class Qc extends Ia {
          constructor(e=new Wc(new ts(-1,-1,0),new ts(-1,1,0),new ts(1,1,0)), t=64, i=1, n=8, r=!1) {
            super(),
              this.type = "TubeGeometry",
              this.parameters = {
                path: e,
                tubularSegments: t,
                radius: i,
                radialSegments: n,
                closed: r
              };
            const s = e.computeFrenetFrames(t, r);
            this.tangents = s.tangents,
              this.normals = s.normals,
              this.binormals = s.binormals;
            const a = new ts
              , o = new ts
              , l = new Dr;
            let h = new ts;
            const c = []
              , u = []
              , d = []
              , p = [];
            function f(r) {
              h = e.getPointAt(r / t, h);
              const l = s.normals[r]
                , d = s.binormals[r];
              for (let e = 0; e <= n; e++) {
                const t = e / n * Math.PI * 2
                  , r = Math.sin(t)
                  , s = -Math.cos(t);
                o.x = s * l.x + r * d.x,
                  o.y = s * l.y + r * d.y,
                  o.z = s * l.z + r * d.z,
                  o.normalize(),
                  u.push(o.x, o.y, o.z),
                  a.x = h.x + i * o.x,
                  a.y = h.y + i * o.y,
                  a.z = h.z + i * o.z,
                  c.push(a.x, a.y, a.z)
              }
            }
            !function() {
              for (let e = 0; e < t; e++)
                f(e);
              f(!1 === r ? t : 0),
                function() {
                  for (let e = 0; e <= t; e++)
                    for (let i = 0; i <= n; i++)
                      l.x = e / t,
                        l.y = i / n,
                        d.push(l.x, l.y)
                }(),
                function() {
                  for (let e = 1; e <= t; e++)
                    for (let t = 1; t <= n; t++) {
                      const i = (n + 1) * (e - 1) + (t - 1)
                        , r = (n + 1) * e + (t - 1)
                        , s = (n + 1) * e + t
                        , a = (n + 1) * (e - 1) + t;
                      p.push(i, r, a),
                        p.push(r, s, a)
                    }
                }()
            }(),
              this.setIndex(p),
              this.setAttribute("position", new Aa(c,3)),
              this.setAttribute("normal", new Aa(u,3)),
              this.setAttribute("uv", new Aa(d,2))
          }
          toJSON() {
            const e = super.toJSON();
            return e.path = this.parameters.path.toJSON(),
              e
          }
          static fromJSON(e) {
            return new Qc((new jc[e.path.type]).fromJSON(e.path),e.tubularSegments,e.radius,e.radialSegments,e.closed)
          }
        }
        class Kc extends ga {
          constructor(e) {
            super(),
              this.isMeshStandardMaterial = !0,
              this.defines = {
                STANDARD: ""
              },
              this.type = "MeshStandardMaterial",
              this.color = new Wr(16777215),
              this.roughness = 1,
              this.metalness = 0,
              this.map = null,
              this.lightMap = null,
              this.lightMapIntensity = 1,
              this.aoMap = null,
              this.aoMapIntensity = 1,
              this.emissive = new Wr(0),
              this.emissiveIntensity = 1,
              this.emissiveMap = null,
              this.bumpMap = null,
              this.bumpScale = 1,
              this.normalMap = null,
              this.normalMapType = 0,
              this.normalScale = new Dr(1,1),
              this.displacementMap = null,
              this.displacementScale = 1,
              this.displacementBias = 0,
              this.roughnessMap = null,
              this.metalnessMap = null,
              this.alphaMap = null,
              this.envMap = null,
              this.envMapIntensity = 1,
              this.wireframe = !1,
              this.wireframeLinewidth = 1,
              this.wireframeLinecap = "round",
              this.wireframeLinejoin = "round",
              this.flatShading = !1,
              this.fog = !0,
              this.setValues(e)
          }
          copy(e) {
            return super.copy(e),
              this.defines = {
                STANDARD: ""
              },
              this.color.copy(e.color),
              this.roughness = e.roughness,
              this.metalness = e.metalness,
              this.map = e.map,
              this.lightMap = e.lightMap,
              this.lightMapIntensity = e.lightMapIntensity,
              this.aoMap = e.aoMap,
              this.aoMapIntensity = e.aoMapIntensity,
              this.emissive.copy(e.emissive),
              this.emissiveMap = e.emissiveMap,
              this.emissiveIntensity = e.emissiveIntensity,
              this.bumpMap = e.bumpMap,
              this.bumpScale = e.bumpScale,
              this.normalMap = e.normalMap,
              this.normalMapType = e.normalMapType,
              this.normalScale.copy(e.normalScale),
              this.displacementMap = e.displacementMap,
              this.displacementScale = e.displacementScale,
              this.displacementBias = e.displacementBias,
              this.roughnessMap = e.roughnessMap,
              this.metalnessMap = e.metalnessMap,
              this.alphaMap = e.alphaMap,
              this.envMap = e.envMap,
              this.envMapIntensity = e.envMapIntensity,
              this.wireframe = e.wireframe,
              this.wireframeLinewidth = e.wireframeLinewidth,
              this.wireframeLinecap = e.wireframeLinecap,
              this.wireframeLinejoin = e.wireframeLinejoin,
              this.flatShading = e.flatShading,
              this.fog = e.fog,
              this
          }
        }
        class Jc extends Kc {
          constructor(e) {
            super(),
              this.isMeshPhysicalMaterial = !0,
              this.defines = {
                STANDARD: "",
                PHYSICAL: ""
              },
              this.type = "MeshPhysicalMaterial",
              this.clearcoatMap = null,
              this.clearcoatRoughness = 0,
              this.clearcoatRoughnessMap = null,
              this.clearcoatNormalScale = new Dr(1,1),
              this.clearcoatNormalMap = null,
              this.ior = 1.5,
              Object.defineProperty(this, "reflectivity", {
                get: function() {
                  return Ar(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
                },
                set: function(e) {
                  this.ior = (1 + .4 * e) / (1 - .4 * e)
                }
              }),
              this.iridescenceMap = null,
              this.iridescenceIOR = 1.3,
              this.iridescenceThicknessRange = [100, 400],
              this.iridescenceThicknessMap = null,
              this.sheenColor = new Wr(0),
              this.sheenColorMap = null,
              this.sheenRoughness = 1,
              this.sheenRoughnessMap = null,
              this.transmissionMap = null,
              this.thickness = 0,
              this.thicknessMap = null,
              this.attenuationDistance = 0,
              this.attenuationColor = new Wr(1,1,1),
              this.specularIntensity = 1,
              this.specularIntensityMap = null,
              this.specularColor = new Wr(1,1,1),
              this.specularColorMap = null,
              this._sheen = 0,
              this._clearcoat = 0,
              this._iridescence = 0,
              this._transmission = 0,
              this.setValues(e)
          }
          get sheen() {
            return this._sheen
          }
          set sheen(e) {
            this._sheen > 0 != e > 0 && this.version++,
              this._sheen = e
          }
          get clearcoat() {
            return this._clearcoat
          }
          set clearcoat(e) {
            this._clearcoat > 0 != e > 0 && this.version++,
              this._clearcoat = e
          }
          get iridescence() {
            return this._iridescence
          }
          set iridescence(e) {
            this._iridescence > 0 != e > 0 && this.version++,
              this._iridescence = e
          }
          get transmission() {
            return this._transmission
          }
          set transmission(e) {
            this._transmission > 0 != e > 0 && this.version++,
              this._transmission = e
          }
          copy(e) {
            return super.copy(e),
              this.defines = {
                STANDARD: "",
                PHYSICAL: ""
              },
              this.clearcoat = e.clearcoat,
              this.clearcoatMap = e.clearcoatMap,
              this.clearcoatRoughness = e.clearcoatRoughness,
              this.clearcoatRoughnessMap = e.clearcoatRoughnessMap,
              this.clearcoatNormalMap = e.clearcoatNormalMap,
              this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
              this.ior = e.ior,
              this.iridescence = e.iridescence,
              this.iridescenceMap = e.iridescenceMap,
              this.iridescenceIOR = e.iridescenceIOR,
              this.iridescenceThicknessRange = [...e.iridescenceThicknessRange],
              this.iridescenceThicknessMap = e.iridescenceThicknessMap,
              this.sheen = e.sheen,
              this.sheenColor.copy(e.sheenColor),
              this.sheenColorMap = e.sheenColorMap,
              this.sheenRoughness = e.sheenRoughness,
              this.sheenRoughnessMap = e.sheenRoughnessMap,
              this.transmission = e.transmission,
              this.transmissionMap = e.transmissionMap,
              this.thickness = e.thickness,
              this.thicknessMap = e.thicknessMap,
              this.attenuationDistance = e.attenuationDistance,
              this.attenuationColor.copy(e.attenuationColor),
              this.specularIntensity = e.specularIntensity,
              this.specularIntensityMap = e.specularIntensityMap,
              this.specularColor.copy(e.specularColor),
              this.specularColorMap = e.specularColorMap,
              this
          }
        }
        class Zc extends ga {
          constructor(e) {
            super(),
              this.isMeshLambertMaterial = !0,
              this.type = "MeshLambertMaterial",
              this.color = new Wr(16777215),
              this.map = null,
              this.lightMap = null,
              this.lightMapIntensity = 1,
              this.aoMap = null,
              this.aoMapIntensity = 1,
              this.emissive = new Wr(0),
              this.emissiveIntensity = 1,
              this.emissiveMap = null,
              this.specularMap = null,
              this.alphaMap = null,
              this.envMap = null,
              this.combine = 0,
              this.reflectivity = 1,
              this.refractionRatio = .98,
              this.wireframe = !1,
              this.wireframeLinewidth = 1,
              this.wireframeLinecap = "round",
              this.wireframeLinejoin = "round",
              this.fog = !0,
              this.setValues(e)
          }
          copy(e) {
            return super.copy(e),
              this.color.copy(e.color),
              this.map = e.map,
              this.lightMap = e.lightMap,
              this.lightMapIntensity = e.lightMapIntensity,
              this.aoMap = e.aoMap,
              this.aoMapIntensity = e.aoMapIntensity,
              this.emissive.copy(e.emissive),
              this.emissiveMap = e.emissiveMap,
              this.emissiveIntensity = e.emissiveIntensity,
              this.specularMap = e.specularMap,
              this.alphaMap = e.alphaMap,
              this.envMap = e.envMap,
              this.combine = e.combine,
              this.reflectivity = e.reflectivity,
              this.refractionRatio = e.refractionRatio,
              this.wireframe = e.wireframe,
              this.wireframeLinewidth = e.wireframeLinewidth,
              this.wireframeLinecap = e.wireframeLinecap,
              this.wireframeLinejoin = e.wireframeLinejoin,
              this.fog = e.fog,
              this
          }
        }
        const $c = {
          ShadowMaterial: class extends ga {
            constructor(e) {
              super(),
                this.isShadowMaterial = !0,
                this.type = "ShadowMaterial",
                this.color = new Wr(0),
                this.transparent = !0,
                this.fog = !0,
                this.setValues(e)
            }
            copy(e) {
              return super.copy(e),
                this.color.copy(e.color),
                this.fog = e.fog,
                this
            }
          }
          ,
          SpriteMaterial: class extends ga {
            constructor(e) {
              super(),
                this.isSpriteMaterial = !0,
                this.type = "SpriteMaterial",
                this.color = new Wr(16777215),
                this.map = null,
                this.alphaMap = null,
                this.rotation = 0,
                this.sizeAttenuation = !0,
                this.transparent = !0,
                this.fog = !0,
                this.setValues(e)
            }
            copy(e) {
              return super.copy(e),
                this.color.copy(e.color),
                this.map = e.map,
                this.alphaMap = e.alphaMap,
                this.rotation = e.rotation,
                this.sizeAttenuation = e.sizeAttenuation,
                this.fog = e.fog,
                this
            }
          }
          ,
          RawShaderMaterial: class extends to {
            constructor(e) {
              super(e),
                this.isRawShaderMaterial = !0,
                this.type = "RawShaderMaterial"
            }
          }
          ,
          ShaderMaterial: to,
          PointsMaterial: Tc,
          MeshPhysicalMaterial: Jc,
          MeshStandardMaterial: Kc,
          MeshPhongMaterial: class extends ga {
            constructor(e) {
              super(),
                this.isMeshPhongMaterial = !0,
                this.type = "MeshPhongMaterial",
                this.color = new Wr(16777215),
                this.specular = new Wr(1118481),
                this.shininess = 30,
                this.map = null,
                this.lightMap = null,
                this.lightMapIntensity = 1,
                this.aoMap = null,
                this.aoMapIntensity = 1,
                this.emissive = new Wr(0),
                this.emissiveIntensity = 1,
                this.emissiveMap = null,
                this.bumpMap = null,
                this.bumpScale = 1,
                this.normalMap = null,
                this.normalMapType = 0,
                this.normalScale = new Dr(1,1),
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.specularMap = null,
                this.alphaMap = null,
                this.envMap = null,
                this.combine = 0,
                this.reflectivity = 1,
                this.refractionRatio = .98,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.wireframeLinecap = "round",
                this.wireframeLinejoin = "round",
                this.flatShading = !1,
                this.fog = !0,
                this.setValues(e)
            }
            copy(e) {
              return super.copy(e),
                this.color.copy(e.color),
                this.specular.copy(e.specular),
                this.shininess = e.shininess,
                this.map = e.map,
                this.lightMap = e.lightMap,
                this.lightMapIntensity = e.lightMapIntensity,
                this.aoMap = e.aoMap,
                this.aoMapIntensity = e.aoMapIntensity,
                this.emissive.copy(e.emissive),
                this.emissiveMap = e.emissiveMap,
                this.emissiveIntensity = e.emissiveIntensity,
                this.bumpMap = e.bumpMap,
                this.bumpScale = e.bumpScale,
                this.normalMap = e.normalMap,
                this.normalMapType = e.normalMapType,
                this.normalScale.copy(e.normalScale),
                this.displacementMap = e.displacementMap,
                this.displacementScale = e.displacementScale,
                this.displacementBias = e.displacementBias,
                this.specularMap = e.specularMap,
                this.alphaMap = e.alphaMap,
                this.envMap = e.envMap,
                this.combine = e.combine,
                this.reflectivity = e.reflectivity,
                this.refractionRatio = e.refractionRatio,
                this.wireframe = e.wireframe,
                this.wireframeLinewidth = e.wireframeLinewidth,
                this.wireframeLinecap = e.wireframeLinecap,
                this.wireframeLinejoin = e.wireframeLinejoin,
                this.flatShading = e.flatShading,
                this.fog = e.fog,
                this
            }
          }
          ,
          MeshToonMaterial: class extends ga {
            constructor(e) {
              super(),
                this.isMeshToonMaterial = !0,
                this.defines = {
                  TOON: ""
                },
                this.type = "MeshToonMaterial",
                this.color = new Wr(16777215),
                this.map = null,
                this.gradientMap = null,
                this.lightMap = null,
                this.lightMapIntensity = 1,
                this.aoMap = null,
                this.aoMapIntensity = 1,
                this.emissive = new Wr(0),
                this.emissiveIntensity = 1,
                this.emissiveMap = null,
                this.bumpMap = null,
                this.bumpScale = 1,
                this.normalMap = null,
                this.normalMapType = 0,
                this.normalScale = new Dr(1,1),
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.alphaMap = null,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.wireframeLinecap = "round",
                this.wireframeLinejoin = "round",
                this.fog = !0,
                this.setValues(e)
            }
            copy(e) {
              return super.copy(e),
                this.color.copy(e.color),
                this.map = e.map,
                this.gradientMap = e.gradientMap,
                this.lightMap = e.lightMap,
                this.lightMapIntensity = e.lightMapIntensity,
                this.aoMap = e.aoMap,
                this.aoMapIntensity = e.aoMapIntensity,
                this.emissive.copy(e.emissive),
                this.emissiveMap = e.emissiveMap,
                this.emissiveIntensity = e.emissiveIntensity,
                this.bumpMap = e.bumpMap,
                this.bumpScale = e.bumpScale,
                this.normalMap = e.normalMap,
                this.normalMapType = e.normalMapType,
                this.normalScale.copy(e.normalScale),
                this.displacementMap = e.displacementMap,
                this.displacementScale = e.displacementScale,
                this.displacementBias = e.displacementBias,
                this.alphaMap = e.alphaMap,
                this.wireframe = e.wireframe,
                this.wireframeLinewidth = e.wireframeLinewidth,
                this.wireframeLinecap = e.wireframeLinecap,
                this.wireframeLinejoin = e.wireframeLinejoin,
                this.fog = e.fog,
                this
            }
          }
          ,
          MeshNormalMaterial: class extends ga {
            constructor(e) {
              super(),
                this.isMeshNormalMaterial = !0,
                this.type = "MeshNormalMaterial",
                this.bumpMap = null,
                this.bumpScale = 1,
                this.normalMap = null,
                this.normalMapType = 0,
                this.normalScale = new Dr(1,1),
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.flatShading = !1,
                this.setValues(e)
            }
            copy(e) {
              return super.copy(e),
                this.bumpMap = e.bumpMap,
                this.bumpScale = e.bumpScale,
                this.normalMap = e.normalMap,
                this.normalMapType = e.normalMapType,
                this.normalScale.copy(e.normalScale),
                this.displacementMap = e.displacementMap,
                this.displacementScale = e.displacementScale,
                this.displacementBias = e.displacementBias,
                this.wireframe = e.wireframe,
                this.wireframeLinewidth = e.wireframeLinewidth,
                this.flatShading = e.flatShading,
                this
            }
          }
          ,
          MeshLambertMaterial: Zc,
          MeshDepthMaterial: kh,
          MeshDistanceMaterial: Fh,
          MeshBasicMaterial: va,
          MeshMatcapMaterial: class extends ga {
            constructor(e) {
              super(),
                this.isMeshMatcapMaterial = !0,
                this.defines = {
                  MATCAP: ""
                },
                this.type = "MeshMatcapMaterial",
                this.color = new Wr(16777215),
                this.matcap = null,
                this.map = null,
                this.bumpMap = null,
                this.bumpScale = 1,
                this.normalMap = null,
                this.normalMapType = 0,
                this.normalScale = new Dr(1,1),
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.alphaMap = null,
                this.flatShading = !1,
                this.fog = !0,
                this.setValues(e)
            }
            copy(e) {
              return super.copy(e),
                this.defines = {
                  MATCAP: ""
                },
                this.color.copy(e.color),
                this.matcap = e.matcap,
                this.map = e.map,
                this.bumpMap = e.bumpMap,
                this.bumpScale = e.bumpScale,
                this.normalMap = e.normalMap,
                this.normalMapType = e.normalMapType,
                this.normalScale.copy(e.normalScale),
                this.displacementMap = e.displacementMap,
                this.displacementScale = e.displacementScale,
                this.displacementBias = e.displacementBias,
                this.alphaMap = e.alphaMap,
                this.flatShading = e.flatShading,
                this.fog = e.fog,
                this
            }
          }
          ,
          LineDashedMaterial: class extends mc {
            constructor(e) {
              super(),
                this.isLineDashedMaterial = !0,
                this.type = "LineDashedMaterial",
                this.scale = 1,
                this.dashSize = 3,
                this.gapSize = 1,
                this.setValues(e)
            }
            copy(e) {
              return super.copy(e),
                this.scale = e.scale,
                this.dashSize = e.dashSize,
                this.gapSize = e.gapSize,
                this
            }
          }
          ,
          LineBasicMaterial: mc,
          Material: ga
        };
        ga.fromType = function(e) {
          return new $c[e]
        }
        ;
        const eu = {
          arraySlice: function(e, t, i) {
            return eu.isTypedArray(e) ? new e.constructor(e.subarray(t, void 0 !== i ? i : e.length)) : e.slice(t, i)
          },
          convertArray: function(e, t, i) {
            return !e || !i && e.constructor === t ? e : "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e)
          },
          isTypedArray: function(e) {
            return ArrayBuffer.isView(e) && !(e instanceof DataView)
          },
          getKeyframeOrder: function(e) {
            const t = e.length
              , i = new Array(t);
            for (let e = 0; e !== t; ++e)
              i[e] = e;
            return i.sort((function(t, i) {
                return e[t] - e[i]
              }
            )),
              i
          },
          sortedArray: function(e, t, i) {
            const n = e.length
              , r = new e.constructor(n);
            for (let s = 0, a = 0; a !== n; ++s) {
              const n = i[s] * t;
              for (let i = 0; i !== t; ++i)
                r[a++] = e[n + i]
            }
            return r
          },
          flattenJSON: function(e, t, i, n) {
            let r = 1
              , s = e[0];
            for (; void 0 !== s && void 0 === s[n]; )
              s = e[r++];
            if (void 0 === s)
              return;
            let a = s[n];
            if (void 0 !== a)
              if (Array.isArray(a))
                do {
                  a = s[n],
                  void 0 !== a && (t.push(s.time),
                    i.push.apply(i, a)),
                    s = e[r++]
                } while (void 0 !== s);
              else if (void 0 !== a.toArray)
                do {
                  a = s[n],
                  void 0 !== a && (t.push(s.time),
                    a.toArray(i, i.length)),
                    s = e[r++]
                } while (void 0 !== s);
              else
                do {
                  a = s[n],
                  void 0 !== a && (t.push(s.time),
                    i.push(a)),
                    s = e[r++]
                } while (void 0 !== s)
          },
          subclip: function(e, t, i, n, r=30) {
            const s = e.clone();
            s.name = t;
            const a = [];
            for (let e = 0; e < s.tracks.length; ++e) {
              const t = s.tracks[e]
                , o = t.getValueSize()
                , l = []
                , h = [];
              for (let e = 0; e < t.times.length; ++e) {
                const s = t.times[e] * r;
                if (!(s < i || s >= n)) {
                  l.push(t.times[e]);
                  for (let i = 0; i < o; ++i)
                    h.push(t.values[e * o + i])
                }
              }
              0 !== l.length && (t.times = eu.convertArray(l, t.times.constructor),
                t.values = eu.convertArray(h, t.values.constructor),
                a.push(t))
            }
            s.tracks = a;
            let o = 1 / 0;
            for (let e = 0; e < s.tracks.length; ++e)
              o > s.tracks[e].times[0] && (o = s.tracks[e].times[0]);
            for (let e = 0; e < s.tracks.length; ++e)
              s.tracks[e].shift(-1 * o);
            return s.resetDuration(),
              s
          },
          makeClipAdditive: function(e, t=0, i=e, n=30) {
            n <= 0 && (n = 30);
            const r = i.tracks.length
              , s = t / n;
            for (let t = 0; t < r; ++t) {
              const n = i.tracks[t]
                , r = n.ValueTypeName;
              if ("bool" === r || "string" === r)
                continue;
              const a = e.tracks.find((function(e) {
                  return e.name === n.name && e.ValueTypeName === r
                }
              ));
              if (void 0 === a)
                continue;
              let o = 0;
              const l = n.getValueSize();
              n.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (o = l / 3);
              let h = 0;
              const c = a.getValueSize();
              a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (h = c / 3);
              const u = n.times.length - 1;
              let d;
              if (s <= n.times[0]) {
                const e = o
                  , t = l - o;
                d = eu.arraySlice(n.values, e, t)
              } else if (s >= n.times[u]) {
                const e = u * l + o
                  , t = e + l - o;
                d = eu.arraySlice(n.values, e, t)
              } else {
                const e = n.createInterpolant()
                  , t = o
                  , i = l - o;
                e.evaluate(s),
                  d = eu.arraySlice(e.resultBuffer, t, i)
              }
              "quaternion" === r && (new es).fromArray(d).normalize().conjugate().toArray(d);
              const p = a.times.length;
              for (let e = 0; e < p; ++e) {
                const t = e * c + h;
                if ("quaternion" === r)
                  es.multiplyQuaternionsFlat(a.values, t, d, 0, a.values, t);
                else {
                  const e = c - 2 * h;
                  for (let i = 0; i < e; ++i)
                    a.values[t + i] -= d[i]
                }
              }
            }
            return e.blendMode = 2501,
              e
          }
        };
        class tu {
          constructor(e, t, i, n) {
            this.parameterPositions = e,
              this._cachedIndex = 0,
              this.resultBuffer = void 0 !== n ? n : new t.constructor(i),
              this.sampleValues = t,
              this.valueSize = i,
              this.settings = null,
              this.DefaultSettings_ = {}
          }
          evaluate(e) {
            const t = this.parameterPositions;
            let i = this._cachedIndex
              , n = t[i]
              , r = t[i - 1];
            e: {
              t: {
                let s;
                i: {
                  n: if (!(e < n)) {
                    for (let s = i + 2; ; ) {
                      if (void 0 === n) {
                        if (e < r)
                          break n;
                        return i = t.length,
                          this._cachedIndex = i,
                          this.copySampleValue_(i - 1)
                      }
                      if (i === s)
                        break;
                      if (r = n,
                        n = t[++i],
                      e < n)
                        break t
                    }
                    s = t.length;
                    break i
                  }
                  if (e >= r)
                    break e;
                  {
                    const a = t[1];
                    e < a && (i = 2,
                      r = a);
                    for (let s = i - 2; ; ) {
                      if (void 0 === r)
                        return this._cachedIndex = 0,
                          this.copySampleValue_(0);
                      if (i === s)
                        break;
                      if (n = r,
                        r = t[--i - 1],
                      e >= r)
                        break t
                    }
                    s = i,
                      i = 0
                  }
                }
                for (; i < s; ) {
                  const n = i + s >>> 1;
                  e < t[n] ? s = n : i = n + 1
                }
                if (n = t[i],
                  r = t[i - 1],
                void 0 === r)
                  return this._cachedIndex = 0,
                    this.copySampleValue_(0);
                if (void 0 === n)
                  return i = t.length,
                    this._cachedIndex = i,
                    this.copySampleValue_(i - 1)
              }
              this._cachedIndex = i,
                this.intervalChanged_(i, r, n)
            }
            return this.interpolate_(i, r, e, n)
          }
          getSettings_() {
            return this.settings || this.DefaultSettings_
          }
          copySampleValue_(e) {
            const t = this.resultBuffer
              , i = this.sampleValues
              , n = this.valueSize
              , r = e * n;
            for (let e = 0; e !== n; ++e)
              t[e] = i[r + e];
            return t
          }
          interpolate_() {
            throw new Error("call to abstract method")
          }
          intervalChanged_() {}
        }
        class iu extends tu {
          constructor(e, t, i, n) {
            super(e, t, i, n),
              this._weightPrev = -0,
              this._offsetPrev = -0,
              this._weightNext = -0,
              this._offsetNext = -0,
              this.DefaultSettings_ = {
                endingStart: ar,
                endingEnd: ar
              }
          }
          intervalChanged_(e, t, i) {
            const n = this.parameterPositions;
            let r = e - 2
              , s = e + 1
              , a = n[r]
              , o = n[s];
            if (void 0 === a)
              switch (this.getSettings_().endingStart) {
                case or:
                  r = e,
                    a = 2 * t - i;
                  break;
                case lr:
                  r = n.length - 2,
                    a = t + n[r] - n[r + 1];
                  break;
                default:
                  r = e,
                    a = i
              }
            if (void 0 === o)
              switch (this.getSettings_().endingEnd) {
                case or:
                  s = e,
                    o = 2 * i - t;
                  break;
                case lr:
                  s = 1,
                    o = i + n[1] - n[0];
                  break;
                default:
                  s = e - 1,
                    o = t
              }
            const l = .5 * (i - t)
              , h = this.valueSize;
            this._weightPrev = l / (t - a),
              this._weightNext = l / (o - i),
              this._offsetPrev = r * h,
              this._offsetNext = s * h
          }
          interpolate_(e, t, i, n) {
            const r = this.resultBuffer
              , s = this.sampleValues
              , a = this.valueSize
              , o = e * a
              , l = o - a
              , h = this._offsetPrev
              , c = this._offsetNext
              , u = this._weightPrev
              , d = this._weightNext
              , p = (i - t) / (n - t)
              , f = p * p
              , m = f * p
              , g = -u * m + 2 * u * f - u * p
              , v = (1 + u) * m + (-1.5 - 2 * u) * f + (-.5 + u) * p + 1
              , y = (-1 - d) * m + (1.5 + d) * f + .5 * p
              , x = d * m - d * f;
            for (let e = 0; e !== a; ++e)
              r[e] = g * s[h + e] + v * s[l + e] + y * s[o + e] + x * s[c + e];
            return r
          }
        }
        class nu extends tu {
          constructor(e, t, i, n) {
            super(e, t, i, n)
          }
          interpolate_(e, t, i, n) {
            const r = this.resultBuffer
              , s = this.sampleValues
              , a = this.valueSize
              , o = e * a
              , l = o - a
              , h = (i - t) / (n - t)
              , c = 1 - h;
            for (let e = 0; e !== a; ++e)
              r[e] = s[l + e] * c + s[o + e] * h;
            return r
          }
        }
        class ru extends tu {
          constructor(e, t, i, n) {
            super(e, t, i, n)
          }
          interpolate_(e) {
            return this.copySampleValue_(e - 1)
          }
        }
        class su {
          constructor(e, t, i, n) {
            if (void 0 === e)
              throw new Error("THREE.KeyframeTrack: track name is undefined");
            if (void 0 === t || 0 === t.length)
              throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
            this.name = e,
              this.times = eu.convertArray(t, this.TimeBufferType),
              this.values = eu.convertArray(i, this.ValueBufferType),
              this.setInterpolation(n || this.DefaultInterpolation)
          }
          static toJSON(e) {
            const t = e.constructor;
            let i;
            if (t.toJSON !== this.toJSON)
              i = t.toJSON(e);
            else {
              i = {
                name: e.name,
                times: eu.convertArray(e.times, Array),
                values: eu.convertArray(e.values, Array)
              };
              const t = e.getInterpolation();
              t !== e.DefaultInterpolation && (i.interpolation = t)
            }
            return i.type = e.ValueTypeName,
              i
          }
          InterpolantFactoryMethodDiscrete(e) {
            return new ru(this.times,this.values,this.getValueSize(),e)
          }
          InterpolantFactoryMethodLinear(e) {
            return new nu(this.times,this.values,this.getValueSize(),e)
          }
          InterpolantFactoryMethodSmooth(e) {
            return new iu(this.times,this.values,this.getValueSize(),e)
          }
          setInterpolation(e) {
            let t;
            switch (e) {
              case nr:
                t = this.InterpolantFactoryMethodDiscrete;
                break;
              case rr:
                t = this.InterpolantFactoryMethodLinear;
                break;
              case sr:
                t = this.InterpolantFactoryMethodSmooth
            }
            if (void 0 === t) {
              const t = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
              if (void 0 === this.createInterpolant) {
                if (e === this.DefaultInterpolation)
                  throw new Error(t);
                this.setInterpolation(this.DefaultInterpolation)
              }
              return console.warn("THREE.KeyframeTrack:", t),
                this
            }
            return this.createInterpolant = t,
              this
          }
          getInterpolation() {
            switch (this.createInterpolant) {
              case this.InterpolantFactoryMethodDiscrete:
                return nr;
              case this.InterpolantFactoryMethodLinear:
                return rr;
              case this.InterpolantFactoryMethodSmooth:
                return sr
            }
          }
          getValueSize() {
            return this.values.length / this.times.length
          }
          shift(e) {
            if (0 !== e) {
              const t = this.times;
              for (let i = 0, n = t.length; i !== n; ++i)
                t[i] += e
            }
            return this
          }
          scale(e) {
            if (1 !== e) {
              const t = this.times;
              for (let i = 0, n = t.length; i !== n; ++i)
                t[i] *= e
            }
            return this
          }
          trim(e, t) {
            const i = this.times
              , n = i.length;
            let r = 0
              , s = n - 1;
            for (; r !== n && i[r] < e; )
              ++r;
            for (; -1 !== s && i[s] > t; )
              --s;
            if (++s,
            0 !== r || s !== n) {
              r >= s && (s = Math.max(s, 1),
                r = s - 1);
              const e = this.getValueSize();
              this.times = eu.arraySlice(i, r, s),
                this.values = eu.arraySlice(this.values, r * e, s * e)
            }
            return this
          }
          validate() {
            let e = !0;
            const t = this.getValueSize();
            t - Math.floor(t) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
              e = !1);
            const i = this.times
              , n = this.values
              , r = i.length;
            0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this),
              e = !1);
            let s = null;
            for (let t = 0; t !== r; t++) {
              const n = i[t];
              if ("number" == typeof n && isNaN(n)) {
                console.error("THREE.KeyframeTrack: Time is not a valid number.", this, t, n),
                  e = !1;
                break
              }
              if (null !== s && s > n) {
                console.error("THREE.KeyframeTrack: Out of order keys.", this, t, n, s),
                  e = !1;
                break
              }
              s = n
            }
            if (void 0 !== n && eu.isTypedArray(n))
              for (let t = 0, i = n.length; t !== i; ++t) {
                const i = n[t];
                if (isNaN(i)) {
                  console.error("THREE.KeyframeTrack: Value is not a valid number.", this, t, i),
                    e = !1;
                  break
                }
              }
            return e
          }
          optimize() {
            const e = eu.arraySlice(this.times)
              , t = eu.arraySlice(this.values)
              , i = this.getValueSize()
              , n = this.getInterpolation() === sr
              , r = e.length - 1;
            let s = 1;
            for (let a = 1; a < r; ++a) {
              let r = !1;
              const o = e[a];
              if (o !== e[a + 1] && (1 !== a || o !== e[0]))
                if (n)
                  r = !0;
                else {
                  const e = a * i
                    , n = e - i
                    , s = e + i;
                  for (let a = 0; a !== i; ++a) {
                    const i = t[e + a];
                    if (i !== t[n + a] || i !== t[s + a]) {
                      r = !0;
                      break
                    }
                  }
                }
              if (r) {
                if (a !== s) {
                  e[s] = e[a];
                  const n = a * i
                    , r = s * i;
                  for (let e = 0; e !== i; ++e)
                    t[r + e] = t[n + e]
                }
                ++s
              }
            }
            if (r > 0) {
              e[s] = e[r];
              for (let e = r * i, n = s * i, a = 0; a !== i; ++a)
                t[n + a] = t[e + a];
              ++s
            }
            return s !== e.length ? (this.times = eu.arraySlice(e, 0, s),
              this.values = eu.arraySlice(t, 0, s * i)) : (this.times = e,
              this.values = t),
              this
          }
          clone() {
            const e = eu.arraySlice(this.times, 0)
              , t = eu.arraySlice(this.values, 0)
              , i = new (0,
              this.constructor)(this.name,e,t);
            return i.createInterpolant = this.createInterpolant,
              i
          }
        }
        su.prototype.TimeBufferType = Float32Array,
          su.prototype.ValueBufferType = Float32Array,
          su.prototype.DefaultInterpolation = rr;
        class au extends su {
        }
        au.prototype.ValueTypeName = "bool",
          au.prototype.ValueBufferType = Array,
          au.prototype.DefaultInterpolation = nr,
          au.prototype.InterpolantFactoryMethodLinear = void 0,
          au.prototype.InterpolantFactoryMethodSmooth = void 0;
        class ou extends su {
        }
        ou.prototype.ValueTypeName = "color";
        class lu extends su {
        }
        lu.prototype.ValueTypeName = "number";
        class hu extends tu {
          constructor(e, t, i, n) {
            super(e, t, i, n)
          }
          interpolate_(e, t, i, n) {
            const r = this.resultBuffer
              , s = this.sampleValues
              , a = this.valueSize
              , o = (i - t) / (n - t);
            let l = e * a;
            for (let e = l + a; l !== e; l += 4)
              es.slerpFlat(r, 0, s, l - a, s, l, o);
            return r
          }
        }
        class cu extends su {
          InterpolantFactoryMethodLinear(e) {
            return new hu(this.times,this.values,this.getValueSize(),e)
          }
        }
        cu.prototype.ValueTypeName = "quaternion",
          cu.prototype.DefaultInterpolation = rr,
          cu.prototype.InterpolantFactoryMethodSmooth = void 0;
        class uu extends su {
        }
        uu.prototype.ValueTypeName = "string",
          uu.prototype.ValueBufferType = Array,
          uu.prototype.DefaultInterpolation = nr,
          uu.prototype.InterpolantFactoryMethodLinear = void 0,
          uu.prototype.InterpolantFactoryMethodSmooth = void 0;
        class du extends su {
        }
        du.prototype.ValueTypeName = "vector";
        class pu {
          constructor(e, t=-1, i, n=2500) {
            this.name = e,
              this.tracks = i,
              this.duration = t,
              this.blendMode = n,
              this.uuid = wr(),
            this.duration < 0 && this.resetDuration()
          }
          static parse(e) {
            const t = []
              , i = e.tracks
              , n = 1 / (e.fps || 1);
            for (let e = 0, r = i.length; e !== r; ++e)
              t.push(fu(i[e]).scale(n));
            const r = new this(e.name,e.duration,t,e.blendMode);
            return r.uuid = e.uuid,
              r
          }
          static toJSON(e) {
            const t = []
              , i = e.tracks
              , n = {
              name: e.name,
              duration: e.duration,
              tracks: t,
              uuid: e.uuid,
              blendMode: e.blendMode
            };
            for (let e = 0, n = i.length; e !== n; ++e)
              t.push(su.toJSON(i[e]));
            return n
          }
          static CreateFromMorphTargetSequence(e, t, i, n) {
            const r = t.length
              , s = [];
            for (let e = 0; e < r; e++) {
              let a = []
                , o = [];
              a.push((e + r - 1) % r, e, (e + 1) % r),
                o.push(0, 1, 0);
              const l = eu.getKeyframeOrder(a);
              a = eu.sortedArray(a, 1, l),
                o = eu.sortedArray(o, 1, l),
              n || 0 !== a[0] || (a.push(r),
                o.push(o[0])),
                s.push(new lu(".morphTargetInfluences[" + t[e].name + "]",a,o).scale(1 / i))
            }
            return new this(e,-1,s)
          }
          static findByName(e, t) {
            let i = e;
            if (!Array.isArray(e)) {
              const t = e;
              i = t.geometry && t.geometry.animations || t.animations
            }
            for (let e = 0; e < i.length; e++)
              if (i[e].name === t)
                return i[e];
            return null
          }
          static CreateClipsFromMorphTargetSequences(e, t, i) {
            const n = {}
              , r = /^([\w-]*?)([\d]+)$/;
            for (let t = 0, i = e.length; t < i; t++) {
              const i = e[t]
                , s = i.name.match(r);
              if (s && s.length > 1) {
                const e = s[1];
                let t = n[e];
                t || (n[e] = t = []),
                  t.push(i)
              }
            }
            const s = [];
            for (const e in n)
              s.push(this.CreateFromMorphTargetSequence(e, n[e], t, i));
            return s
          }
          static parseAnimation(e, t) {
            if (!e)
              return console.error("THREE.AnimationClip: No animation in JSONLoader data."),
                null;
            const i = function(e, t, i, n, r) {
              if (0 !== i.length) {
                const s = []
                  , a = [];
                eu.flattenJSON(i, s, a, n),
                0 !== s.length && r.push(new e(t,s,a))
              }
            }
              , n = []
              , r = e.name || "default"
              , s = e.fps || 30
              , a = e.blendMode;
            let o = e.length || -1;
            const l = e.hierarchy || [];
            for (let e = 0; e < l.length; e++) {
              const r = l[e].keys;
              if (r && 0 !== r.length)
                if (r[0].morphTargets) {
                  const e = {};
                  let t;
                  for (t = 0; t < r.length; t++)
                    if (r[t].morphTargets)
                      for (let i = 0; i < r[t].morphTargets.length; i++)
                        e[r[t].morphTargets[i]] = -1;
                  for (const i in e) {
                    const e = []
                      , s = [];
                    for (let n = 0; n !== r[t].morphTargets.length; ++n) {
                      const n = r[t];
                      e.push(n.time),
                        s.push(n.morphTarget === i ? 1 : 0)
                    }
                    n.push(new lu(".morphTargetInfluence[" + i + "]",e,s))
                  }
                  o = e.length * s
                } else {
                  const s = ".bones[" + t[e].name + "]";
                  i(du, s + ".position", r, "pos", n),
                    i(cu, s + ".quaternion", r, "rot", n),
                    i(du, s + ".scale", r, "scl", n)
                }
            }
            return 0 === n.length ? null : new this(r,o,n,a)
          }
          resetDuration() {
            let e = 0;
            for (let t = 0, i = this.tracks.length; t !== i; ++t) {
              const i = this.tracks[t];
              e = Math.max(e, i.times[i.times.length - 1])
            }
            return this.duration = e,
              this
          }
          trim() {
            for (let e = 0; e < this.tracks.length; e++)
              this.tracks[e].trim(0, this.duration);
            return this
          }
          validate() {
            let e = !0;
            for (let t = 0; t < this.tracks.length; t++)
              e = e && this.tracks[t].validate();
            return e
          }
          optimize() {
            for (let e = 0; e < this.tracks.length; e++)
              this.tracks[e].optimize();
            return this
          }
          clone() {
            const e = [];
            for (let t = 0; t < this.tracks.length; t++)
              e.push(this.tracks[t].clone());
            return new this.constructor(this.name,this.duration,e,this.blendMode)
          }
          toJSON() {
            return this.constructor.toJSON(this)
          }
        }
        function fu(e) {
          if (void 0 === e.type)
            throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
          const t = function(e) {
            switch (e.toLowerCase()) {
              case "scalar":
              case "double":
              case "float":
              case "number":
              case "integer":
                return lu;
              case "vector":
              case "vector2":
              case "vector3":
              case "vector4":
                return du;
              case "color":
                return ou;
              case "quaternion":
                return cu;
              case "bool":
              case "boolean":
                return au;
              case "string":
                return uu
            }
            throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e)
          }(e.type);
          if (void 0 === e.times) {
            const t = []
              , i = [];
            eu.flattenJSON(e.keys, t, i, "value"),
              e.times = t,
              e.values = i
          }
          return void 0 !== t.parse ? t.parse(e) : new t(e.name,e.times,e.values,e.interpolation)
        }
        const mu = {
          enabled: !1,
          files: {},
          add: function(e, t) {
            !1 !== this.enabled && (this.files[e] = t)
          },
          get: function(e) {
            if (!1 !== this.enabled)
              return this.files[e]
          },
          remove: function(e) {
            delete this.files[e]
          },
          clear: function() {
            this.files = {}
          }
        };
        class gu {
          constructor(e, t, i) {
            const n = this;
            let r, s = !1, a = 0, o = 0;
            const l = [];
            this.onStart = void 0,
              this.onLoad = e,
              this.onProgress = t,
              this.onError = i,
              this.itemStart = function(e) {
                o++,
                !1 === s && void 0 !== n.onStart && n.onStart(e, a, o),
                  s = !0
              }
              ,
              this.itemEnd = function(e) {
                a++,
                void 0 !== n.onProgress && n.onProgress(e, a, o),
                a === o && (s = !1,
                void 0 !== n.onLoad && n.onLoad())
              }
              ,
              this.itemError = function(e) {
                void 0 !== n.onError && n.onError(e)
              }
              ,
              this.resolveURL = function(e) {
                return r ? r(e) : e
              }
              ,
              this.setURLModifier = function(e) {
                return r = e,
                  this
              }
              ,
              this.addHandler = function(e, t) {
                return l.push(e, t),
                  this
              }
              ,
              this.removeHandler = function(e) {
                const t = l.indexOf(e);
                return -1 !== t && l.splice(t, 2),
                  this
              }
              ,
              this.getHandler = function(e) {
                for (let t = 0, i = l.length; t < i; t += 2) {
                  const i = l[t]
                    , n = l[t + 1];
                  if (i.global && (i.lastIndex = 0),
                    i.test(e))
                    return n
                }
                return null
              }
          }
        }
        const vu = new gu;
        class yu {
          constructor(e) {
            this.manager = void 0 !== e ? e : vu,
              this.crossOrigin = "anonymous",
              this.withCredentials = !1,
              this.path = "",
              this.resourcePath = "",
              this.requestHeader = {}
          }
          load() {}
          loadAsync(e, t) {
            const i = this;
            return new Promise((function(n, r) {
                i.load(e, n, t, r)
              }
            ))
          }
          parse() {}
          setCrossOrigin(e) {
            return this.crossOrigin = e,
              this
          }
          setWithCredentials(e) {
            return this.withCredentials = e,
              this
          }
          setPath(e) {
            return this.path = e,
              this
          }
          setResourcePath(e) {
            return this.resourcePath = e,
              this
          }
          setRequestHeader(e) {
            return this.requestHeader = e,
              this
          }
        }
        const xu = {};
        class _u extends yu {
          constructor(e) {
            super(e)
          }
          load(e, t, i, n) {
            void 0 === e && (e = ""),
            void 0 !== this.path && (e = this.path + e),
              e = this.manager.resolveURL(e);
            const r = mu.get(e);
            if (void 0 !== r)
              return this.manager.itemStart(e),
                setTimeout((()=>{
                    t && t(r),
                      this.manager.itemEnd(e)
                  }
                ), 0),
                r;
            if (void 0 !== xu[e])
              return void xu[e].push({
                onLoad: t,
                onProgress: i,
                onError: n
              });
            xu[e] = [],
              xu[e].push({
                onLoad: t,
                onProgress: i,
                onError: n
              });
            const s = new Request(e,{
              headers: new Headers(this.requestHeader),
              credentials: this.withCredentials ? "include" : "same-origin"
            })
              , a = this.mimeType
              , o = this.responseType;
            fetch(s).then((t=>{
                if (200 === t.status || 0 === t.status) {
                  if (0 === t.status && console.warn("THREE.FileLoader: HTTP Status 0 received."),
                  "undefined" == typeof ReadableStream || void 0 === t.body || void 0 === t.body.getReader)
                    return t;
                  const i = xu[e]
                    , n = t.body.getReader()
                    , r = t.headers.get("Content-Length")
                    , s = r ? parseInt(r) : 0
                    , a = 0 !== s;
                  let o = 0;
                  const l = new ReadableStream({
                    start(e) {
                      !function t() {
                        n.read().then((({done: n, value: r})=>{
                            if (n)
                              e.close();
                            else {
                              o += r.byteLength;
                              const n = new ProgressEvent("progress",{
                                lengthComputable: a,
                                loaded: o,
                                total: s
                              });
                              for (let e = 0, t = i.length; e < t; e++) {
                                const t = i[e];
                                t.onProgress && t.onProgress(n)
                              }
                              e.enqueue(r),
                                t()
                            }
                          }
                        ))
                      }()
                    }
                  });
                  return new Response(l)
                }
                throw Error(`fetch for "${t.url}" responded with ${t.status}: ${t.statusText}`)
              }
            )).then((e=>{
                switch (o) {
                  case "arraybuffer":
                    return e.arrayBuffer();
                  case "blob":
                    return e.blob();
                  case "document":
                    return e.text().then((e=>(new DOMParser).parseFromString(e, a)));
                  case "json":
                    return e.json();
                  default:
                    if (void 0 === a)
                      return e.text();
                  {
                    const t = /charset="?([^;"\s]*)"?/i.exec(a)
                      , i = t && t[1] ? t[1].toLowerCase() : void 0
                      , n = new TextDecoder(i);
                    return e.arrayBuffer().then((e=>n.decode(e)))
                  }
                }
              }
            )).then((t=>{
                mu.add(e, t);
                const i = xu[e];
                delete xu[e];
                for (let e = 0, n = i.length; e < n; e++) {
                  const n = i[e];
                  n.onLoad && n.onLoad(t)
                }
              }
            )).catch((t=>{
                const i = xu[e];
                if (void 0 === i)
                  throw this.manager.itemError(e),
                    t;
                delete xu[e];
                for (let e = 0, n = i.length; e < n; e++) {
                  const n = i[e];
                  n.onError && n.onError(t)
                }
                this.manager.itemError(e)
              }
            )).finally((()=>{
                this.manager.itemEnd(e)
              }
            )),
              this.manager.itemStart(e)
          }
          setResponseType(e) {
            return this.responseType = e,
              this
          }
          setMimeType(e) {
            return this.mimeType = e,
              this
          }
        }
        class bu extends yu {
          constructor(e) {
            super(e)
          }
          load(e, t, i, n) {
            void 0 !== this.path && (e = this.path + e),
              e = this.manager.resolveURL(e);
            const r = this
              , s = mu.get(e);
            if (void 0 !== s)
              return r.manager.itemStart(e),
                setTimeout((function() {
                    t && t(s),
                      r.manager.itemEnd(e)
                  }
                ), 0),
                s;
            const a = Lr("img");
            function o() {
              h(),
                mu.add(e, this),
              t && t(this),
                r.manager.itemEnd(e)
            }
            function l(t) {
              h(),
              n && n(t),
                r.manager.itemError(e),
                r.manager.itemEnd(e)
            }
            function h() {
              a.removeEventListener("load", o, !1),
                a.removeEventListener("error", l, !1)
            }
            return a.addEventListener("load", o, !1),
              a.addEventListener("error", l, !1),
            "data:" !== e.slice(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin),
              r.manager.itemStart(e),
              a.src = e,
              a
          }
        }
        class wu extends yu {
          constructor(e) {
            super(e)
          }
          load(e, t, i, n) {
            const r = new Kr
              , s = new bu(this.manager);
            return s.setCrossOrigin(this.crossOrigin),
              s.setPath(this.path),
              s.load(e, (function(e) {
                  r.image = e,
                    r.needsUpdate = !0,
                  void 0 !== t && t(r)
                }
              ), i, n),
              r
          }
        }
        class Au extends na {
          constructor(e, t=1) {
            super(),
              this.isLight = !0,
              this.type = "Light",
              this.color = new Wr(e),
              this.intensity = t
          }
          dispose() {}
          copy(e, t) {
            return super.copy(e, t),
              this.color.copy(e.color),
              this.intensity = e.intensity,
              this
          }
          toJSON(e) {
            const t = super.toJSON(e);
            return t.object.color = this.color.getHex(),
              t.object.intensity = this.intensity,
            void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()),
            void 0 !== this.distance && (t.object.distance = this.distance),
            void 0 !== this.angle && (t.object.angle = this.angle),
            void 0 !== this.decay && (t.object.decay = this.decay),
            void 0 !== this.penumbra && (t.object.penumbra = this.penumbra),
            void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()),
              t
          }
        }
        class Su extends Au {
          constructor(e, t, i) {
            super(e, i),
              this.isHemisphereLight = !0,
              this.type = "HemisphereLight",
              this.position.copy(na.DefaultUp),
              this.updateMatrix(),
              this.groundColor = new Wr(t)
          }
          copy(e, t) {
            return super.copy(e, t),
              this.groundColor.copy(e.groundColor),
              this
          }
        }
        const Mu = new Rs
          , Tu = new ts
          , Eu = new ts;
        class Cu {
          constructor(e) {
            this.camera = e,
              this.bias = 0,
              this.normalBias = 0,
              this.radius = 1,
              this.blurSamples = 8,
              this.mapSize = new Dr(512,512),
              this.map = null,
              this.mapPass = null,
              this.matrix = new Rs,
              this.autoUpdate = !0,
              this.needsUpdate = !1,
              this._frustum = new mo,
              this._frameExtents = new Dr(1,1),
              this._viewportCount = 1,
              this._viewports = [new Jr(0,0,1,1)]
          }
          getViewportCount() {
            return this._viewportCount
          }
          getFrustum() {
            return this._frustum
          }
          updateMatrices(e) {
            const t = this.camera
              , i = this.matrix;
            Tu.setFromMatrixPosition(e.matrixWorld),
              t.position.copy(Tu),
              Eu.setFromMatrixPosition(e.target.matrixWorld),
              t.lookAt(Eu),
              t.updateMatrixWorld(),
              Mu.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
              this._frustum.setFromProjectionMatrix(Mu),
              i.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
              i.multiply(t.projectionMatrix),
              i.multiply(t.matrixWorldInverse)
          }
          getViewport(e) {
            return this._viewports[e]
          }
          getFrameExtents() {
            return this._frameExtents
          }
          dispose() {
            this.map && this.map.dispose(),
            this.mapPass && this.mapPass.dispose()
          }
          copy(e) {
            return this.camera = e.camera.clone(),
              this.bias = e.bias,
              this.radius = e.radius,
              this.mapSize.copy(e.mapSize),
              this
          }
          clone() {
            return (new this.constructor).copy(this)
          }
          toJSON() {
            const e = {};
            return 0 !== this.bias && (e.bias = this.bias),
            0 !== this.normalBias && (e.normalBias = this.normalBias),
            1 !== this.radius && (e.radius = this.radius),
            512 === this.mapSize.x && 512 === this.mapSize.y || (e.mapSize = this.mapSize.toArray()),
              e.camera = this.camera.toJSON(!1).object,
              delete e.camera.matrix,
              e
          }
        }
        class Pu extends Cu {
          constructor() {
            super(new no(50,1,.5,500)),
              this.isSpotLightShadow = !0,
              this.focus = 1
          }
          updateMatrices(e) {
            const t = this.camera
              , i = 2 * br * e.angle * this.focus
              , n = this.mapSize.width / this.mapSize.height
              , r = e.distance || t.far;
            i === t.fov && n === t.aspect && r === t.far || (t.fov = i,
              t.aspect = n,
              t.far = r,
              t.updateProjectionMatrix()),
              super.updateMatrices(e)
          }
          copy(e) {
            return super.copy(e),
              this.focus = e.focus,
              this
          }
        }
        class Du extends Au {
          constructor(e, t, i=0, n=Math.PI / 3, r=0, s=1) {
            super(e, t),
              this.isSpotLight = !0,
              this.type = "SpotLight",
              this.position.copy(na.DefaultUp),
              this.updateMatrix(),
              this.target = new na,
              this.distance = i,
              this.angle = n,
              this.penumbra = r,
              this.decay = s,
              this.shadow = new Pu
          }
          get power() {
            return this.intensity * Math.PI
          }
          set power(e) {
            this.intensity = e / Math.PI
          }
          dispose() {
            this.shadow.dispose()
          }
          copy(e, t) {
            return super.copy(e, t),
              this.distance = e.distance,
              this.angle = e.angle,
              this.penumbra = e.penumbra,
              this.decay = e.decay,
              this.target = e.target.clone(),
              this.shadow = e.shadow.clone(),
              this
          }
        }
        const Iu = new Rs
          , Ru = new ts
          , Lu = new ts;
        class ku extends Cu {
          constructor() {
            super(new no(90,1,.5,500)),
              this.isPointLightShadow = !0,
              this._frameExtents = new Dr(4,2),
              this._viewportCount = 6,
              this._viewports = [new Jr(2,1,1,1), new Jr(0,1,1,1), new Jr(3,1,1,1), new Jr(1,1,1,1), new Jr(3,0,1,1), new Jr(1,0,1,1)],
              this._cubeDirections = [new ts(1,0,0), new ts(-1,0,0), new ts(0,0,1), new ts(0,0,-1), new ts(0,1,0), new ts(0,-1,0)],
              this._cubeUps = [new ts(0,1,0), new ts(0,1,0), new ts(0,1,0), new ts(0,1,0), new ts(0,0,1), new ts(0,0,-1)]
          }
          updateMatrices(e, t=0) {
            const i = this.camera
              , n = this.matrix
              , r = e.distance || i.far;
            r !== i.far && (i.far = r,
              i.updateProjectionMatrix()),
              Ru.setFromMatrixPosition(e.matrixWorld),
              i.position.copy(Ru),
              Lu.copy(i.position),
              Lu.add(this._cubeDirections[t]),
              i.up.copy(this._cubeUps[t]),
              i.lookAt(Lu),
              i.updateMatrixWorld(),
              n.makeTranslation(-Ru.x, -Ru.y, -Ru.z),
              Iu.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse),
              this._frustum.setFromProjectionMatrix(Iu)
          }
        }
        class Fu extends Au {
          constructor(e, t, i=0, n=1) {
            super(e, t),
              this.isPointLight = !0,
              this.type = "PointLight",
              this.distance = i,
              this.decay = n,
              this.shadow = new ku
          }
          get power() {
            return 4 * this.intensity * Math.PI
          }
          set power(e) {
            this.intensity = e / (4 * Math.PI)
          }
          dispose() {
            this.shadow.dispose()
          }
          copy(e, t) {
            return super.copy(e, t),
              this.distance = e.distance,
              this.decay = e.decay,
              this.shadow = e.shadow.clone(),
              this
          }
        }
        class Bu extends Cu {
          constructor() {
            super(new Co(-5,5,5,-5,.5,500)),
              this.isDirectionalLightShadow = !0
          }
        }
        class Ou extends Au {
          constructor(e, t) {
            super(e, t),
              this.isDirectionalLight = !0,
              this.type = "DirectionalLight",
              this.position.copy(na.DefaultUp),
              this.updateMatrix(),
              this.target = new na,
              this.shadow = new Bu
          }
          dispose() {
            this.shadow.dispose()
          }
          copy(e) {
            return super.copy(e),
              this.target = e.target.clone(),
              this.shadow = e.shadow.clone(),
              this
          }
        }
        class Nu {
          static decodeText(e) {
            if ("undefined" != typeof TextDecoder)
              return (new TextDecoder).decode(e);
            let t = "";
            for (let i = 0, n = e.length; i < n; i++)
              t += String.fromCharCode(e[i]);
            try {
              return decodeURIComponent(escape(t))
            } catch (e) {
              return t
            }
          }
          static extractUrlBase(e) {
            const t = e.lastIndexOf("/");
            return -1 === t ? "./" : e.slice(0, t + 1)
          }
          static resolveURL(e, t) {
            return "string" != typeof e || "" === e ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
              /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e)
          }
        }
        class zu extends Ia {
          constructor() {
            super(),
              this.isInstancedBufferGeometry = !0,
              this.type = "InstancedBufferGeometry",
              this.instanceCount = 1 / 0
          }
          copy(e) {
            return super.copy(e),
              this.instanceCount = e.instanceCount,
              this
          }
          clone() {
            return (new this.constructor).copy(this)
          }
          toJSON() {
            const e = super.toJSON(this);
            return e.instanceCount = this.instanceCount,
              e.isInstancedBufferGeometry = !0,
              e
          }
        }
        class Uu extends yu {
          constructor(e) {
            super(e),
              this.isImageBitmapLoader = !0,
            "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),
            "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
              this.options = {
                premultiplyAlpha: "none"
              }
          }
          setOptions(e) {
            return this.options = e,
              this
          }
          load(e, t, i, n) {
            void 0 === e && (e = ""),
            void 0 !== this.path && (e = this.path + e),
              e = this.manager.resolveURL(e);
            const r = this
              , s = mu.get(e);
            if (void 0 !== s)
              return r.manager.itemStart(e),
                setTimeout((function() {
                    t && t(s),
                      r.manager.itemEnd(e)
                  }
                ), 0),
                s;
            const a = {};
            a.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include",
              a.headers = this.requestHeader,
              fetch(e, a).then((function(e) {
                  return e.blob()
                }
              )).then((function(e) {
                  return createImageBitmap(e, Object.assign(r.options, {
                    colorSpaceConversion: "none"
                  }))
                }
              )).then((function(i) {
                  mu.add(e, i),
                  t && t(i),
                    r.manager.itemEnd(e)
                }
              )).catch((function(t) {
                  n && n(t),
                    r.manager.itemError(e),
                    r.manager.itemEnd(e)
                }
              )),
              r.manager.itemStart(e)
          }
        }
        class Gu {
          constructor(e, t, i) {
            let n, r, s;
            switch (this.binding = e,
              this.valueSize = i,
              t) {
              case "quaternion":
                n = this._slerp,
                  r = this._slerpAdditive,
                  s = this._setAdditiveIdentityQuaternion,
                  this.buffer = new Float64Array(6 * i),
                  this._workIndex = 5;
                break;
              case "string":
              case "bool":
                n = this._select,
                  r = this._select,
                  s = this._setAdditiveIdentityOther,
                  this.buffer = new Array(5 * i);
                break;
              default:
                n = this._lerp,
                  r = this._lerpAdditive,
                  s = this._setAdditiveIdentityNumeric,
                  this.buffer = new Float64Array(5 * i)
            }
            this._mixBufferRegion = n,
              this._mixBufferRegionAdditive = r,
              this._setIdentity = s,
              this._origIndex = 3,
              this._addIndex = 4,
              this.cumulativeWeight = 0,
              this.cumulativeWeightAdditive = 0,
              this.useCount = 0,
              this.referenceCount = 0
          }
          accumulate(e, t) {
            const i = this.buffer
              , n = this.valueSize
              , r = e * n + n;
            let s = this.cumulativeWeight;
            if (0 === s) {
              for (let e = 0; e !== n; ++e)
                i[r + e] = i[e];
              s = t
            } else {
              s += t;
              const e = t / s;
              this._mixBufferRegion(i, r, 0, e, n)
            }
            this.cumulativeWeight = s
          }
          accumulateAdditive(e) {
            const t = this.buffer
              , i = this.valueSize
              , n = i * this._addIndex;
            0 === this.cumulativeWeightAdditive && this._setIdentity(),
              this._mixBufferRegionAdditive(t, n, 0, e, i),
              this.cumulativeWeightAdditive += e
          }
          apply(e) {
            const t = this.valueSize
              , i = this.buffer
              , n = e * t + t
              , r = this.cumulativeWeight
              , s = this.cumulativeWeightAdditive
              , a = this.binding;
            if (this.cumulativeWeight = 0,
              this.cumulativeWeightAdditive = 0,
            r < 1) {
              const e = t * this._origIndex;
              this._mixBufferRegion(i, n, e, 1 - r, t)
            }
            s > 0 && this._mixBufferRegionAdditive(i, n, this._addIndex * t, 1, t);
            for (let e = t, r = t + t; e !== r; ++e)
              if (i[e] !== i[e + t]) {
                a.setValue(i, n);
                break
              }
          }
          saveOriginalState() {
            const e = this.binding
              , t = this.buffer
              , i = this.valueSize
              , n = i * this._origIndex;
            e.getValue(t, n);
            for (let e = i, r = n; e !== r; ++e)
              t[e] = t[n + e % i];
            this._setIdentity(),
              this.cumulativeWeight = 0,
              this.cumulativeWeightAdditive = 0
          }
          restoreOriginalState() {
            const e = 3 * this.valueSize;
            this.binding.setValue(this.buffer, e)
          }
          _setAdditiveIdentityNumeric() {
            const e = this._addIndex * this.valueSize
              , t = e + this.valueSize;
            for (let i = e; i < t; i++)
              this.buffer[i] = 0
          }
          _setAdditiveIdentityQuaternion() {
            this._setAdditiveIdentityNumeric(),
              this.buffer[this._addIndex * this.valueSize + 3] = 1
          }
          _setAdditiveIdentityOther() {
            const e = this._origIndex * this.valueSize
              , t = this._addIndex * this.valueSize;
            for (let i = 0; i < this.valueSize; i++)
              this.buffer[t + i] = this.buffer[e + i]
          }
          _select(e, t, i, n, r) {
            if (n >= .5)
              for (let n = 0; n !== r; ++n)
                e[t + n] = e[i + n]
          }
          _slerp(e, t, i, n) {
            es.slerpFlat(e, t, e, t, e, i, n)
          }
          _slerpAdditive(e, t, i, n, r) {
            const s = this._workIndex * r;
            es.multiplyQuaternionsFlat(e, s, e, t, e, i),
              es.slerpFlat(e, t, e, t, e, s, n)
          }
          _lerp(e, t, i, n, r) {
            const s = 1 - n;
            for (let a = 0; a !== r; ++a) {
              const r = t + a;
              e[r] = e[r] * s + e[i + a] * n
            }
          }
          _lerpAdditive(e, t, i, n, r) {
            for (let s = 0; s !== r; ++s) {
              const r = t + s;
              e[r] = e[r] + e[i + s] * n
            }
          }
        }
        const Vu = new RegExp("[\\[\\]\\.:\\/]","g")
          , Hu = "[^\\[\\]\\.:\\/]"
          , Wu = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]"
          , ju = /((?:WC+[\/:])*)/.source.replace("WC", Hu)
          , Xu = /(WCOD+)?/.source.replace("WCOD", Wu)
          , Yu = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Hu)
          , qu = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Hu)
          , Qu = new RegExp("^" + ju + Xu + Yu + qu + "$")
          , Ku = ["material", "materials", "bones"];
        class Ju {
          constructor(e, t, i) {
            this.path = t,
              this.parsedPath = i || Ju.parseTrackName(t),
              this.node = Ju.findNode(e, this.parsedPath.nodeName) || e,
              this.rootNode = e,
              this.getValue = this._getValue_unbound,
              this.setValue = this._setValue_unbound
          }
          static create(e, t, i) {
            return e && e.isAnimationObjectGroup ? new Ju.Composite(e,t,i) : new Ju(e,t,i)
          }
          static sanitizeNodeName(e) {
            return e.replace(/\s/g, "_").replace(Vu, "")
          }
          static parseTrackName(e) {
            const t = Qu.exec(e);
            if (null === t)
              throw new Error("PropertyBinding: Cannot parse trackName: " + e);
            const i = {
              nodeName: t[2],
              objectName: t[3],
              objectIndex: t[4],
              propertyName: t[5],
              propertyIndex: t[6]
            }
              , n = i.nodeName && i.nodeName.lastIndexOf(".");
            if (void 0 !== n && -1 !== n) {
              const e = i.nodeName.substring(n + 1);
              -1 !== Ku.indexOf(e) && (i.nodeName = i.nodeName.substring(0, n),
                i.objectName = e)
            }
            if (null === i.propertyName || 0 === i.propertyName.length)
              throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
            return i
          }
          static findNode(e, t) {
            if (void 0 === t || "" === t || "." === t || -1 === t || t === e.name || t === e.uuid)
              return e;
            if (e.skeleton) {
              const i = e.skeleton.getBoneByName(t);
              if (void 0 !== i)
                return i
            }
            if (e.children) {
              const i = function(e) {
                for (let n = 0; n < e.length; n++) {
                  const r = e[n];
                  if (r.name === t || r.uuid === t)
                    return r;
                  const s = i(r.children);
                  if (s)
                    return s
                }
                return null
              }
                , n = i(e.children);
              if (n)
                return n
            }
            return null
          }
          _getValue_unavailable() {}
          _setValue_unavailable() {}
          _getValue_direct(e, t) {
            e[t] = this.targetObject[this.propertyName]
          }
          _getValue_array(e, t) {
            const i = this.resolvedProperty;
            for (let n = 0, r = i.length; n !== r; ++n)
              e[t++] = i[n]
          }
          _getValue_arrayElement(e, t) {
            e[t] = this.resolvedProperty[this.propertyIndex]
          }
          _getValue_toArray(e, t) {
            this.resolvedProperty.toArray(e, t)
          }
          _setValue_direct(e, t) {
            this.targetObject[this.propertyName] = e[t]
          }
          _setValue_direct_setNeedsUpdate(e, t) {
            this.targetObject[this.propertyName] = e[t],
              this.targetObject.needsUpdate = !0
          }
          _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
            this.targetObject[this.propertyName] = e[t],
              this.targetObject.matrixWorldNeedsUpdate = !0
          }
          _setValue_array(e, t) {
            const i = this.resolvedProperty;
            for (let n = 0, r = i.length; n !== r; ++n)
              i[n] = e[t++]
          }
          _setValue_array_setNeedsUpdate(e, t) {
            const i = this.resolvedProperty;
            for (let n = 0, r = i.length; n !== r; ++n)
              i[n] = e[t++];
            this.targetObject.needsUpdate = !0
          }
          _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
            const i = this.resolvedProperty;
            for (let n = 0, r = i.length; n !== r; ++n)
              i[n] = e[t++];
            this.targetObject.matrixWorldNeedsUpdate = !0
          }
          _setValue_arrayElement(e, t) {
            this.resolvedProperty[this.propertyIndex] = e[t]
          }
          _setValue_arrayElement_setNeedsUpdate(e, t) {
            this.resolvedProperty[this.propertyIndex] = e[t],
              this.targetObject.needsUpdate = !0
          }
          _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
            this.resolvedProperty[this.propertyIndex] = e[t],
              this.targetObject.matrixWorldNeedsUpdate = !0
          }
          _setValue_fromArray(e, t) {
            this.resolvedProperty.fromArray(e, t)
          }
          _setValue_fromArray_setNeedsUpdate(e, t) {
            this.resolvedProperty.fromArray(e, t),
              this.targetObject.needsUpdate = !0
          }
          _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
            this.resolvedProperty.fromArray(e, t),
              this.targetObject.matrixWorldNeedsUpdate = !0
          }
          _getValue_unbound(e, t) {
            this.bind(),
              this.getValue(e, t)
          }
          _setValue_unbound(e, t) {
            this.bind(),
              this.setValue(e, t)
          }
          bind() {
            let e = this.node;
            const t = this.parsedPath
              , i = t.objectName
              , n = t.propertyName;
            let r = t.propertyIndex;
            if (e || (e = Ju.findNode(this.rootNode, t.nodeName) || this.rootNode,
              this.node = e),
              this.getValue = this._getValue_unavailable,
              this.setValue = this._setValue_unavailable,
              !e)
              return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
            if (i) {
              let n = t.objectIndex;
              switch (i) {
                case "materials":
                  if (!e.material)
                    return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                  if (!e.material.materials)
                    return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                  e = e.material.materials;
                  break;
                case "bones":
                  if (!e.skeleton)
                    return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                  e = e.skeleton.bones;
                  for (let t = 0; t < e.length; t++)
                    if (e[t].name === n) {
                      n = t;
                      break
                    }
                  break;
                default:
                  if (void 0 === e[i])
                    return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                  e = e[i]
              }
              if (void 0 !== n) {
                if (void 0 === e[n])
                  return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                e = e[n]
              }
            }
            const s = e[n];
            if (void 0 === s) {
              const i = t.nodeName;
              return void console.error("THREE.PropertyBinding: Trying to update property for track: " + i + "." + n + " but it wasn't found.", e)
            }
            let a = this.Versioning.None;
            this.targetObject = e,
              void 0 !== e.needsUpdate ? a = this.Versioning.NeedsUpdate : void 0 !== e.matrixWorldNeedsUpdate && (a = this.Versioning.MatrixWorldNeedsUpdate);
            let o = this.BindingType.Direct;
            if (void 0 !== r) {
              if ("morphTargetInfluences" === n) {
                if (!e.geometry)
                  return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                if (!e.geometry.morphAttributes)
                  return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                void 0 !== e.morphTargetDictionary[r] && (r = e.morphTargetDictionary[r])
              }
              o = this.BindingType.ArrayElement,
                this.resolvedProperty = s,
                this.propertyIndex = r
            } else
              void 0 !== s.fromArray && void 0 !== s.toArray ? (o = this.BindingType.HasFromToArray,
                this.resolvedProperty = s) : Array.isArray(s) ? (o = this.BindingType.EntireArray,
                this.resolvedProperty = s) : this.propertyName = n;
            this.getValue = this.GetterByBindingType[o],
              this.setValue = this.SetterByBindingTypeAndVersioning[o][a]
          }
          unbind() {
            this.node = null,
              this.getValue = this._getValue_unbound,
              this.setValue = this._setValue_unbound
          }
        }
        Ju.Composite = class {
          constructor(e, t, i) {
            const n = i || Ju.parseTrackName(t);
            this._targetGroup = e,
              this._bindings = e.subscribe_(t, n)
          }
          getValue(e, t) {
            this.bind();
            const i = this._targetGroup.nCachedObjects_
              , n = this._bindings[i];
            void 0 !== n && n.getValue(e, t)
          }
          setValue(e, t) {
            const i = this._bindings;
            for (let n = this._targetGroup.nCachedObjects_, r = i.length; n !== r; ++n)
              i[n].setValue(e, t)
          }
          bind() {
            const e = this._bindings;
            for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)
              e[t].bind()
          }
          unbind() {
            const e = this._bindings;
            for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)
              e[t].unbind()
          }
        }
          ,
          Ju.prototype.BindingType = {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3
          },
          Ju.prototype.Versioning = {
            None: 0,
            NeedsUpdate: 1,
            MatrixWorldNeedsUpdate: 2
          },
          Ju.prototype.GetterByBindingType = [Ju.prototype._getValue_direct, Ju.prototype._getValue_array, Ju.prototype._getValue_arrayElement, Ju.prototype._getValue_toArray],
          Ju.prototype.SetterByBindingTypeAndVersioning = [[Ju.prototype._setValue_direct, Ju.prototype._setValue_direct_setNeedsUpdate, Ju.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [Ju.prototype._setValue_array, Ju.prototype._setValue_array_setNeedsUpdate, Ju.prototype._setValue_array_setMatrixWorldNeedsUpdate], [Ju.prototype._setValue_arrayElement, Ju.prototype._setValue_arrayElement_setNeedsUpdate, Ju.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [Ju.prototype._setValue_fromArray, Ju.prototype._setValue_fromArray_setNeedsUpdate, Ju.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
        class Zu {
          constructor(e, t, i=null, n=t.blendMode) {
            this._mixer = e,
              this._clip = t,
              this._localRoot = i,
              this.blendMode = n;
            const r = t.tracks
              , s = r.length
              , a = new Array(s)
              , o = {
              endingStart: ar,
              endingEnd: ar
            };
            for (let e = 0; e !== s; ++e) {
              const t = r[e].createInterpolant(null);
              a[e] = t,
                t.settings = o
            }
            this._interpolantSettings = o,
              this._interpolants = a,
              this._propertyBindings = new Array(s),
              this._cacheIndex = null,
              this._byClipCacheIndex = null,
              this._timeScaleInterpolant = null,
              this._weightInterpolant = null,
              this.loop = 2201,
              this._loopCount = -1,
              this._startTime = null,
              this.time = 0,
              this.timeScale = 1,
              this._effectiveTimeScale = 1,
              this.weight = 1,
              this._effectiveWeight = 1,
              this.repetitions = 1 / 0,
              this.paused = !1,
              this.enabled = !0,
              this.clampWhenFinished = !1,
              this.zeroSlopeAtStart = !0,
              this.zeroSlopeAtEnd = !0
          }
          play() {
            return this._mixer._activateAction(this),
              this
          }
          stop() {
            return this._mixer._deactivateAction(this),
              this.reset()
          }
          reset() {
            return this.paused = !1,
              this.enabled = !0,
              this.time = 0,
              this._loopCount = -1,
              this._startTime = null,
              this.stopFading().stopWarping()
          }
          isRunning() {
            return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
          }
          isScheduled() {
            return this._mixer._isActiveAction(this)
          }
          startAt(e) {
            return this._startTime = e,
              this
          }
          setLoop(e, t) {
            return this.loop = e,
              this.repetitions = t,
              this
          }
          setEffectiveWeight(e) {
            return this.weight = e,
              this._effectiveWeight = this.enabled ? e : 0,
              this.stopFading()
          }
          getEffectiveWeight() {
            return this._effectiveWeight
          }
          fadeIn(e) {
            return this._scheduleFading(e, 0, 1)
          }
          fadeOut(e) {
            return this._scheduleFading(e, 1, 0)
          }
          crossFadeFrom(e, t, i) {
            if (e.fadeOut(t),
              this.fadeIn(t),
              i) {
              const i = this._clip.duration
                , n = e._clip.duration
                , r = n / i
                , s = i / n;
              e.warp(1, r, t),
                this.warp(s, 1, t)
            }
            return this
          }
          crossFadeTo(e, t, i) {
            return e.crossFadeFrom(this, t, i)
          }
          stopFading() {
            const e = this._weightInterpolant;
            return null !== e && (this._weightInterpolant = null,
              this._mixer._takeBackControlInterpolant(e)),
              this
          }
          setEffectiveTimeScale(e) {
            return this.timeScale = e,
              this._effectiveTimeScale = this.paused ? 0 : e,
              this.stopWarping()
          }
          getEffectiveTimeScale() {
            return this._effectiveTimeScale
          }
          setDuration(e) {
            return this.timeScale = this._clip.duration / e,
              this.stopWarping()
          }
          syncWith(e) {
            return this.time = e.time,
              this.timeScale = e.timeScale,
              this.stopWarping()
          }
          halt(e) {
            return this.warp(this._effectiveTimeScale, 0, e)
          }
          warp(e, t, i) {
            const n = this._mixer
              , r = n.time
              , s = this.timeScale;
            let a = this._timeScaleInterpolant;
            null === a && (a = n._lendControlInterpolant(),
              this._timeScaleInterpolant = a);
            const o = a.parameterPositions
              , l = a.sampleValues;
            return o[0] = r,
              o[1] = r + i,
              l[0] = e / s,
              l[1] = t / s,
              this
          }
          stopWarping() {
            const e = this._timeScaleInterpolant;
            return null !== e && (this._timeScaleInterpolant = null,
              this._mixer._takeBackControlInterpolant(e)),
              this
          }
          getMixer() {
            return this._mixer
          }
          getClip() {
            return this._clip
          }
          getRoot() {
            return this._localRoot || this._mixer._root
          }
          _update(e, t, i, n) {
            if (!this.enabled)
              return void this._updateWeight(e);
            const r = this._startTime;
            if (null !== r) {
              const n = (e - r) * i;
              if (n < 0 || 0 === i)
                return;
              this._startTime = null,
                t = i * n
            }
            t *= this._updateTimeScale(e);
            const s = this._updateTime(t)
              , a = this._updateWeight(e);
            if (a > 0) {
              const e = this._interpolants
                , t = this._propertyBindings;
              if (2501 === this.blendMode)
                for (let i = 0, n = e.length; i !== n; ++i)
                  e[i].evaluate(s),
                    t[i].accumulateAdditive(a);
              else
                for (let i = 0, r = e.length; i !== r; ++i)
                  e[i].evaluate(s),
                    t[i].accumulate(n, a)
            }
          }
          _updateWeight(e) {
            let t = 0;
            if (this.enabled) {
              t = this.weight;
              const i = this._weightInterpolant;
              if (null !== i) {
                const n = i.evaluate(e)[0];
                t *= n,
                e > i.parameterPositions[1] && (this.stopFading(),
                0 === n && (this.enabled = !1))
              }
            }
            return this._effectiveWeight = t,
              t
          }
          _updateTimeScale(e) {
            let t = 0;
            if (!this.paused) {
              t = this.timeScale;
              const i = this._timeScaleInterpolant;
              null !== i && (t *= i.evaluate(e)[0],
              e > i.parameterPositions[1] && (this.stopWarping(),
                0 === t ? this.paused = !0 : this.timeScale = t))
            }
            return this._effectiveTimeScale = t,
              t
          }
          _updateTime(e) {
            const t = this._clip.duration
              , i = this.loop;
            let n = this.time + e
              , r = this._loopCount;
            const s = 2202 === i;
            if (0 === e)
              return -1 === r ? n : s && 1 == (1 & r) ? t - n : n;
            if (2200 === i) {
              -1 === r && (this._loopCount = 0,
                this._setEndings(!0, !0, !1));
              e: {
                if (n >= t)
                  n = t;
                else {
                  if (!(n < 0)) {
                    this.time = n;
                    break e
                  }
                  n = 0
                }
                this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                  this.time = n,
                  this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: e < 0 ? -1 : 1
                  })
              }
            } else {
              if (-1 === r && (e >= 0 ? (r = 0,
                this._setEndings(!0, 0 === this.repetitions, s)) : this._setEndings(0 === this.repetitions, !0, s)),
              n >= t || n < 0) {
                const i = Math.floor(n / t);
                n -= t * i,
                  r += Math.abs(i);
                const a = this.repetitions - r;
                if (a <= 0)
                  this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                    n = e > 0 ? t : 0,
                    this.time = n,
                    this._mixer.dispatchEvent({
                      type: "finished",
                      action: this,
                      direction: e > 0 ? 1 : -1
                    });
                else {
                  if (1 === a) {
                    const t = e < 0;
                    this._setEndings(t, !t, s)
                  } else
                    this._setEndings(!1, !1, s);
                  this._loopCount = r,
                    this.time = n,
                    this._mixer.dispatchEvent({
                      type: "loop",
                      action: this,
                      loopDelta: i
                    })
                }
              } else
                this.time = n;
              if (s && 1 == (1 & r))
                return t - n
            }
            return n
          }
          _setEndings(e, t, i) {
            const n = this._interpolantSettings;
            i ? (n.endingStart = or,
              n.endingEnd = or) : (n.endingStart = e ? this.zeroSlopeAtStart ? or : ar : lr,
              n.endingEnd = t ? this.zeroSlopeAtEnd ? or : ar : lr)
          }
          _scheduleFading(e, t, i) {
            const n = this._mixer
              , r = n.time;
            let s = this._weightInterpolant;
            null === s && (s = n._lendControlInterpolant(),
              this._weightInterpolant = s);
            const a = s.parameterPositions
              , o = s.sampleValues;
            return a[0] = r,
              o[0] = t,
              a[1] = r + e,
              o[1] = i,
              this
          }
        }
        const $u = new Float32Array(1);
        class ed extends vr {
          constructor(e) {
            super(),
              this._root = e,
              this._initMemoryManager(),
              this._accuIndex = 0,
              this.time = 0,
              this.timeScale = 1
          }
          _bindAction(e, t) {
            const i = e._localRoot || this._root
              , n = e._clip.tracks
              , r = n.length
              , s = e._propertyBindings
              , a = e._interpolants
              , o = i.uuid
              , l = this._bindingsByRootAndName;
            let h = l[o];
            void 0 === h && (h = {},
              l[o] = h);
            for (let e = 0; e !== r; ++e) {
              const r = n[e]
                , l = r.name;
              let c = h[l];
              if (void 0 !== c)
                ++c.referenceCount,
                  s[e] = c;
              else {
                if (c = s[e],
                void 0 !== c) {
                  null === c._cacheIndex && (++c.referenceCount,
                    this._addInactiveBinding(c, o, l));
                  continue
                }
                const n = t && t._propertyBindings[e].binding.parsedPath;
                c = new Gu(Ju.create(i, l, n),r.ValueTypeName,r.getValueSize()),
                  ++c.referenceCount,
                  this._addInactiveBinding(c, o, l),
                  s[e] = c
              }
              a[e].resultBuffer = c.buffer
            }
          }
          _activateAction(e) {
            if (!this._isActiveAction(e)) {
              if (null === e._cacheIndex) {
                const t = (e._localRoot || this._root).uuid
                  , i = e._clip.uuid
                  , n = this._actionsByClip[i];
                this._bindAction(e, n && n.knownActions[0]),
                  this._addInactiveAction(e, i, t)
              }
              const t = e._propertyBindings;
              for (let e = 0, i = t.length; e !== i; ++e) {
                const i = t[e];
                0 == i.useCount++ && (this._lendBinding(i),
                  i.saveOriginalState())
              }
              this._lendAction(e)
            }
          }
          _deactivateAction(e) {
            if (this._isActiveAction(e)) {
              const t = e._propertyBindings;
              for (let e = 0, i = t.length; e !== i; ++e) {
                const i = t[e];
                0 == --i.useCount && (i.restoreOriginalState(),
                  this._takeBackBinding(i))
              }
              this._takeBackAction(e)
            }
          }
          _initMemoryManager() {
            this._actions = [],
              this._nActiveActions = 0,
              this._actionsByClip = {},
              this._bindings = [],
              this._nActiveBindings = 0,
              this._bindingsByRootAndName = {},
              this._controlInterpolants = [],
              this._nActiveControlInterpolants = 0;
            const e = this;
            this.stats = {
              actions: {
                get total() {
                  return e._actions.length
                },
                get inUse() {
                  return e._nActiveActions
                }
              },
              bindings: {
                get total() {
                  return e._bindings.length
                },
                get inUse() {
                  return e._nActiveBindings
                }
              },
              controlInterpolants: {
                get total() {
                  return e._controlInterpolants.length
                },
                get inUse() {
                  return e._nActiveControlInterpolants
                }
              }
            }
          }
          _isActiveAction(e) {
            const t = e._cacheIndex;
            return null !== t && t < this._nActiveActions
          }
          _addInactiveAction(e, t, i) {
            const n = this._actions
              , r = this._actionsByClip;
            let s = r[t];
            if (void 0 === s)
              s = {
                knownActions: [e],
                actionByRoot: {}
              },
                e._byClipCacheIndex = 0,
                r[t] = s;
            else {
              const t = s.knownActions;
              e._byClipCacheIndex = t.length,
                t.push(e)
            }
            e._cacheIndex = n.length,
              n.push(e),
              s.actionByRoot[i] = e
          }
          _removeInactiveAction(e) {
            const t = this._actions
              , i = t[t.length - 1]
              , n = e._cacheIndex;
            i._cacheIndex = n,
              t[n] = i,
              t.pop(),
              e._cacheIndex = null;
            const r = e._clip.uuid
              , s = this._actionsByClip
              , a = s[r]
              , o = a.knownActions
              , l = o[o.length - 1]
              , h = e._byClipCacheIndex;
            l._byClipCacheIndex = h,
              o[h] = l,
              o.pop(),
              e._byClipCacheIndex = null,
              delete a.actionByRoot[(e._localRoot || this._root).uuid],
            0 === o.length && delete s[r],
              this._removeInactiveBindingsForAction(e)
          }
          _removeInactiveBindingsForAction(e) {
            const t = e._propertyBindings;
            for (let e = 0, i = t.length; e !== i; ++e) {
              const i = t[e];
              0 == --i.referenceCount && this._removeInactiveBinding(i)
            }
          }
          _lendAction(e) {
            const t = this._actions
              , i = e._cacheIndex
              , n = this._nActiveActions++
              , r = t[n];
            e._cacheIndex = n,
              t[n] = e,
              r._cacheIndex = i,
              t[i] = r
          }
          _takeBackAction(e) {
            const t = this._actions
              , i = e._cacheIndex
              , n = --this._nActiveActions
              , r = t[n];
            e._cacheIndex = n,
              t[n] = e,
              r._cacheIndex = i,
              t[i] = r
          }
          _addInactiveBinding(e, t, i) {
            const n = this._bindingsByRootAndName
              , r = this._bindings;
            let s = n[t];
            void 0 === s && (s = {},
              n[t] = s),
              s[i] = e,
              e._cacheIndex = r.length,
              r.push(e)
          }
          _removeInactiveBinding(e) {
            const t = this._bindings
              , i = e.binding
              , n = i.rootNode.uuid
              , r = i.path
              , s = this._bindingsByRootAndName
              , a = s[n]
              , o = t[t.length - 1]
              , l = e._cacheIndex;
            o._cacheIndex = l,
              t[l] = o,
              t.pop(),
              delete a[r],
            0 === Object.keys(a).length && delete s[n]
          }
          _lendBinding(e) {
            const t = this._bindings
              , i = e._cacheIndex
              , n = this._nActiveBindings++
              , r = t[n];
            e._cacheIndex = n,
              t[n] = e,
              r._cacheIndex = i,
              t[i] = r
          }
          _takeBackBinding(e) {
            const t = this._bindings
              , i = e._cacheIndex
              , n = --this._nActiveBindings
              , r = t[n];
            e._cacheIndex = n,
              t[n] = e,
              r._cacheIndex = i,
              t[i] = r
          }
          _lendControlInterpolant() {
            const e = this._controlInterpolants
              , t = this._nActiveControlInterpolants++;
            let i = e[t];
            return void 0 === i && (i = new nu(new Float32Array(2),new Float32Array(2),1,$u),
              i.__cacheIndex = t,
              e[t] = i),
              i
          }
          _takeBackControlInterpolant(e) {
            const t = this._controlInterpolants
              , i = e.__cacheIndex
              , n = --this._nActiveControlInterpolants
              , r = t[n];
            e.__cacheIndex = n,
              t[n] = e,
              r.__cacheIndex = i,
              t[i] = r
          }
          clipAction(e, t, i) {
            const n = t || this._root
              , r = n.uuid;
            let s = "string" == typeof e ? pu.findByName(n, e) : e;
            const a = null !== s ? s.uuid : e
              , o = this._actionsByClip[a];
            let l = null;
            if (void 0 === i && (i = null !== s ? s.blendMode : 2500),
            void 0 !== o) {
              const e = o.actionByRoot[r];
              if (void 0 !== e && e.blendMode === i)
                return e;
              l = o.knownActions[0],
              null === s && (s = l._clip)
            }
            if (null === s)
              return null;
            const h = new Zu(this,s,t,i);
            return this._bindAction(h, l),
              this._addInactiveAction(h, a, r),
              h
          }
          existingAction(e, t) {
            const i = t || this._root
              , n = i.uuid
              , r = "string" == typeof e ? pu.findByName(i, e) : e
              , s = r ? r.uuid : e
              , a = this._actionsByClip[s];
            return void 0 !== a && a.actionByRoot[n] || null
          }
          stopAllAction() {
            const e = this._actions;
            for (let t = this._nActiveActions - 1; t >= 0; --t)
              e[t].stop();
            return this
          }
          update(e) {
            e *= this.timeScale;
            const t = this._actions
              , i = this._nActiveActions
              , n = this.time += e
              , r = Math.sign(e)
              , s = this._accuIndex ^= 1;
            for (let a = 0; a !== i; ++a)
              t[a]._update(n, e, r, s);
            const a = this._bindings
              , o = this._nActiveBindings;
            for (let e = 0; e !== o; ++e)
              a[e].apply(s);
            return this
          }
          setTime(e) {
            this.time = 0;
            for (let e = 0; e < this._actions.length; e++)
              this._actions[e].time = 0;
            return this.update(e)
          }
          getRoot() {
            return this._root
          }
          uncacheClip(e) {
            const t = this._actions
              , i = e.uuid
              , n = this._actionsByClip
              , r = n[i];
            if (void 0 !== r) {
              const e = r.knownActions;
              for (let i = 0, n = e.length; i !== n; ++i) {
                const n = e[i];
                this._deactivateAction(n);
                const r = n._cacheIndex
                  , s = t[t.length - 1];
                n._cacheIndex = null,
                  n._byClipCacheIndex = null,
                  s._cacheIndex = r,
                  t[r] = s,
                  t.pop(),
                  this._removeInactiveBindingsForAction(n)
              }
              delete n[i]
            }
          }
          uncacheRoot(e) {
            const t = e.uuid
              , i = this._actionsByClip;
            for (const e in i) {
              const n = i[e].actionByRoot[t];
              void 0 !== n && (this._deactivateAction(n),
                this._removeInactiveAction(n))
            }
            const n = this._bindingsByRootAndName[t];
            if (void 0 !== n)
              for (const e in n) {
                const t = n[e];
                t.restoreOriginalState(),
                  this._removeInactiveBinding(t)
              }
          }
          uncacheAction(e, t) {
            const i = this.existingAction(e, t);
            null !== i && (this._deactivateAction(i),
              this._removeInactiveAction(i))
          }
        }
        class td {
          constructor(e) {
            "string" == typeof e && (console.warn("THREE.Uniform: Type parameter is no longer needed."),
              e = arguments[1]),
              this.value = e
          }
          clone() {
            return new td(void 0 === this.value.clone ? this.value : this.value.clone())
          }
        }
        const id = new ArrayBuffer(4)
          , nd = (new Float32Array(id),
          new Uint32Array(id),
          new Uint32Array(512))
          , rd = new Uint32Array(512);
        for (let e = 0; e < 256; ++e) {
          const t = e - 127;
          t < -27 ? (nd[e] = 0,
            nd[256 | e] = 32768,
            rd[e] = 24,
            rd[256 | e] = 24) : t < -14 ? (nd[e] = 1024 >> -t - 14,
            nd[256 | e] = 1024 >> -t - 14 | 32768,
            rd[e] = -t - 1,
            rd[256 | e] = -t - 1) : t <= 15 ? (nd[e] = t + 15 << 10,
            nd[256 | e] = t + 15 << 10 | 32768,
            rd[e] = 13,
            rd[256 | e] = 13) : t < 128 ? (nd[e] = 31744,
            nd[256 | e] = 64512,
            rd[e] = 24,
            rd[256 | e] = 24) : (nd[e] = 31744,
            nd[256 | e] = 64512,
            rd[e] = 13,
            rd[256 | e] = 13)
        }
        const sd = new Uint32Array(2048)
          , ad = new Uint32Array(64)
          , od = new Uint32Array(64);
        for (let e = 1; e < 1024; ++e) {
          let t = e << 13
            , i = 0;
          for (; 0 == (8388608 & t); )
            t <<= 1,
              i -= 8388608;
          t &= -8388609,
            i += 947912704,
            sd[e] = t | i
        }
        for (let e = 1024; e < 2048; ++e)
          sd[e] = 939524096 + (e - 1024 << 13);
        for (let e = 1; e < 31; ++e)
          ad[e] = e << 23;
        ad[31] = 1199570944,
          ad[32] = 2147483648;
        for (let e = 33; e < 63; ++e)
          ad[e] = 2147483648 + (e - 32 << 23);
        ad[63] = 3347054592;
        for (let e = 1; e < 64; ++e)
          32 !== e && (od[e] = 1024);
        class ld extends Zr {
          constructor(e, t, i) {
            console.error('THREE.WebGLMultisampleRenderTarget has been removed. Use a normal render target and set the "samples" property to greater 0 to enable multisampling.'),
              super(e, t, i),
              this.samples = 4
          }
        }
        "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{
          detail: {
            revision: Rn
          }
        })),
        "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = Rn);
        class hd extends yu {
          constructor(e) {
            super(e),
              this.dracoLoader = null,
              this.ktx2Loader = null,
              this.meshoptDecoder = null,
              this.pluginCallbacks = [],
              this.register((function(e) {
                  return new md(e)
                }
              )),
              this.register((function(e) {
                  return new wd(e)
                }
              )),
              this.register((function(e) {
                  return new Ad(e)
                }
              )),
              this.register((function(e) {
                  return new vd(e)
                }
              )),
              this.register((function(e) {
                  return new yd(e)
                }
              )),
              this.register((function(e) {
                  return new xd(e)
                }
              )),
              this.register((function(e) {
                  return new _d(e)
                }
              )),
              this.register((function(e) {
                  return new fd(e)
                }
              )),
              this.register((function(e) {
                  return new bd(e)
                }
              )),
              this.register((function(e) {
                  return new gd(e)
                }
              )),
              this.register((function(e) {
                  return new dd(e)
                }
              )),
              this.register((function(e) {
                  return new Sd(e)
                }
              ))
          }
          load(e, t, i, n) {
            const r = this;
            let s;
            s = "" !== this.resourcePath ? this.resourcePath : "" !== this.path ? this.path : Nu.extractUrlBase(e),
              this.manager.itemStart(e);
            const a = function(t) {
              n ? n(t) : console.error(t),
                r.manager.itemError(e),
                r.manager.itemEnd(e)
            }
              , o = new _u(this.manager);
            o.setPath(this.path),
              o.setResponseType("arraybuffer"),
              o.setRequestHeader(this.requestHeader),
              o.setWithCredentials(this.withCredentials),
              o.load(e, (function(i) {
                  try {
                    r.parse(i, s, (function(i) {
                        t(i),
                          r.manager.itemEnd(e)
                      }
                    ), a)
                  } catch (e) {
                    a(e)
                  }
                }
              ), i, a)
          }
          setDRACOLoader(e) {
            return this.dracoLoader = e,
              this
          }
          setDDSLoader() {
            throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')
          }
          setKTX2Loader(e) {
            return this.ktx2Loader = e,
              this
          }
          setMeshoptDecoder(e) {
            return this.meshoptDecoder = e,
              this
          }
          register(e) {
            return -1 === this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.push(e),
              this
          }
          unregister(e) {
            return -1 !== this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
              this
          }
          parse(e, t, i, n) {
            let r;
            const s = {}
              , a = {};
            if ("string" == typeof e)
              r = e;
            else if (Nu.decodeText(new Uint8Array(e,0,4)) === Md) {
              try {
                s[ud.KHR_BINARY_GLTF] = new Td(e)
              } catch (e) {
                return void (n && n(e))
              }
              r = s[ud.KHR_BINARY_GLTF].content
            } else
              r = Nu.decodeText(new Uint8Array(e));
            const o = JSON.parse(r);
            if (void 0 === o.asset || o.asset.version[0] < 2)
              return void (n && n(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));
            const l = new qd(o,{
              path: t || this.resourcePath || "",
              crossOrigin: this.crossOrigin,
              requestHeader: this.requestHeader,
              manager: this.manager,
              ktx2Loader: this.ktx2Loader,
              meshoptDecoder: this.meshoptDecoder
            });
            l.fileLoader.setRequestHeader(this.requestHeader);
            for (let e = 0; e < this.pluginCallbacks.length; e++) {
              const t = this.pluginCallbacks[e](l);
              a[t.name] = t,
                s[t.name] = !0
            }
            if (o.extensionsUsed)
              for (let e = 0; e < o.extensionsUsed.length; ++e) {
                const t = o.extensionsUsed[e]
                  , i = o.extensionsRequired || [];
                switch (t) {
                  case ud.KHR_MATERIALS_UNLIT:
                    s[t] = new pd;
                    break;
                  case ud.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                    s[t] = new Dd;
                    break;
                  case ud.KHR_DRACO_MESH_COMPRESSION:
                    s[t] = new Ed(o,this.dracoLoader);
                    break;
                  case ud.KHR_TEXTURE_TRANSFORM:
                    s[t] = new Cd;
                    break;
                  case ud.KHR_MESH_QUANTIZATION:
                    s[t] = new Id;
                    break;
                  default:
                    i.indexOf(t) >= 0 && void 0 === a[t] && console.warn('THREE.GLTFLoader: Unknown extension "' + t + '".')
                }
              }
            l.setExtensions(s),
              l.setPlugins(a),
              l.parse(i, n)
          }
          parseAsync(e, t) {
            const i = this;
            return new Promise((function(n, r) {
                i.parse(e, t, n, r)
              }
            ))
          }
        }
        function cd() {
          let e = {};
          return {
            get: function(t) {
              return e[t]
            },
            add: function(t, i) {
              e[t] = i
            },
            remove: function(t) {
              delete e[t]
            },
            removeAll: function() {
              e = {}
            }
          }
        }
        const ud = {
          KHR_BINARY_GLTF: "KHR_binary_glTF",
          KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
          KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
          KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
          KHR_MATERIALS_IOR: "KHR_materials_ior",
          KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness",
          KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
          KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
          KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
          KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
          KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
          KHR_MATERIALS_VOLUME: "KHR_materials_volume",
          KHR_TEXTURE_BASISU: "KHR_texture_basisu",
          KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
          KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
          KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
          EXT_TEXTURE_WEBP: "EXT_texture_webp",
          EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression"
        };
        class dd {
          constructor(e) {
            this.parser = e,
              this.name = ud.KHR_LIGHTS_PUNCTUAL,
              this.cache = {
                refs: {},
                uses: {}
              }
          }
          _markDefs() {
            const e = this.parser
              , t = this.parser.json.nodes || [];
            for (let i = 0, n = t.length; i < n; i++) {
              const n = t[i];
              n.extensions && n.extensions[this.name] && void 0 !== n.extensions[this.name].light && e._addNodeRef(this.cache, n.extensions[this.name].light)
            }
          }
          _loadLight(e) {
            const t = this.parser
              , i = "light:" + e;
            let n = t.cache.get(i);
            if (n)
              return n;
            const r = t.json
              , s = ((r.extensions && r.extensions[this.name] || {}).lights || [])[e];
            let a;
            const o = new Wr(16777215);
            void 0 !== s.color && o.fromArray(s.color);
            const l = void 0 !== s.range ? s.range : 0;
            switch (s.type) {
              case "directional":
                a = new Ou(o),
                  a.target.position.set(0, 0, -1),
                  a.add(a.target);
                break;
              case "point":
                a = new Fu(o),
                  a.distance = l;
                break;
              case "spot":
                a = new Du(o),
                  a.distance = l,
                  s.spot = s.spot || {},
                  s.spot.innerConeAngle = void 0 !== s.spot.innerConeAngle ? s.spot.innerConeAngle : 0,
                  s.spot.outerConeAngle = void 0 !== s.spot.outerConeAngle ? s.spot.outerConeAngle : Math.PI / 4,
                  a.angle = s.spot.outerConeAngle,
                  a.penumbra = 1 - s.spot.innerConeAngle / s.spot.outerConeAngle,
                  a.target.position.set(0, 0, -1),
                  a.add(a.target);
                break;
              default:
                throw new Error("THREE.GLTFLoader: Unexpected light type: " + s.type)
            }
            return a.position.set(0, 0, 0),
              a.decay = 2,
            void 0 !== s.intensity && (a.intensity = s.intensity),
              a.name = t.createUniqueName(s.name || "light_" + e),
              n = Promise.resolve(a),
              t.cache.add(i, n),
              n
          }
          createNodeAttachment(e) {
            const t = this
              , i = this.parser
              , n = i.json.nodes[e]
              , r = (n.extensions && n.extensions[this.name] || {}).light;
            return void 0 === r ? null : this._loadLight(r).then((function(e) {
                return i._getNodeRef(t.cache, r, e)
              }
            ))
          }
        }
        class pd {
          constructor() {
            this.name = ud.KHR_MATERIALS_UNLIT
          }
          getMaterialType() {
            return va
          }
          extendParams(e, t, i) {
            const n = [];
            e.color = new Wr(1,1,1),
              e.opacity = 1;
            const r = t.pbrMetallicRoughness;
            if (r) {
              if (Array.isArray(r.baseColorFactor)) {
                const t = r.baseColorFactor;
                e.color.fromArray(t),
                  e.opacity = t[3]
              }
              void 0 !== r.baseColorTexture && n.push(i.assignTexture(e, "map", r.baseColorTexture, cr))
            }
            return Promise.all(n)
          }
        }
        class fd {
          constructor(e) {
            this.parser = e,
              this.name = ud.KHR_MATERIALS_EMISSIVE_STRENGTH
          }
          extendMaterialParams(e, t) {
            const i = this.parser.json.materials[e];
            if (!i.extensions || !i.extensions[this.name])
              return Promise.resolve();
            const n = i.extensions[this.name].emissiveStrength;
            return void 0 !== n && (t.emissiveIntensity = n),
              Promise.resolve()
          }
        }
        class md {
          constructor(e) {
            this.parser = e,
              this.name = ud.KHR_MATERIALS_CLEARCOAT
          }
          getMaterialType(e) {
            const t = this.parser.json.materials[e];
            return t.extensions && t.extensions[this.name] ? Jc : null
          }
          extendMaterialParams(e, t) {
            const i = this.parser
              , n = i.json.materials[e];
            if (!n.extensions || !n.extensions[this.name])
              return Promise.resolve();
            const r = []
              , s = n.extensions[this.name];
            if (void 0 !== s.clearcoatFactor && (t.clearcoat = s.clearcoatFactor),
            void 0 !== s.clearcoatTexture && r.push(i.assignTexture(t, "clearcoatMap", s.clearcoatTexture)),
            void 0 !== s.clearcoatRoughnessFactor && (t.clearcoatRoughness = s.clearcoatRoughnessFactor),
            void 0 !== s.clearcoatRoughnessTexture && r.push(i.assignTexture(t, "clearcoatRoughnessMap", s.clearcoatRoughnessTexture)),
            void 0 !== s.clearcoatNormalTexture && (r.push(i.assignTexture(t, "clearcoatNormalMap", s.clearcoatNormalTexture)),
            void 0 !== s.clearcoatNormalTexture.scale)) {
              const e = s.clearcoatNormalTexture.scale;
              t.clearcoatNormalScale = new Dr(e,e)
            }
            return Promise.all(r)
          }
        }
        class gd {
          constructor(e) {
            this.parser = e,
              this.name = ud.KHR_MATERIALS_IRIDESCENCE
          }
          getMaterialType(e) {
            const t = this.parser.json.materials[e];
            return t.extensions && t.extensions[this.name] ? Jc : null
          }
          extendMaterialParams(e, t) {
            const i = this.parser
              , n = i.json.materials[e];
            if (!n.extensions || !n.extensions[this.name])
              return Promise.resolve();
            const r = []
              , s = n.extensions[this.name];
            return void 0 !== s.iridescenceFactor && (t.iridescence = s.iridescenceFactor),
            void 0 !== s.iridescenceTexture && r.push(i.assignTexture(t, "iridescenceMap", s.iridescenceTexture)),
            void 0 !== s.iridescenceIor && (t.iridescenceIOR = s.iridescenceIor),
            void 0 === t.iridescenceThicknessRange && (t.iridescenceThicknessRange = [100, 400]),
            void 0 !== s.iridescenceThicknessMinimum && (t.iridescenceThicknessRange[0] = s.iridescenceThicknessMinimum),
            void 0 !== s.iridescenceThicknessMaximum && (t.iridescenceThicknessRange[1] = s.iridescenceThicknessMaximum),
            void 0 !== s.iridescenceThicknessTexture && r.push(i.assignTexture(t, "iridescenceThicknessMap", s.iridescenceThicknessTexture)),
              Promise.all(r)
          }
        }
        class vd {
          constructor(e) {
            this.parser = e,
              this.name = ud.KHR_MATERIALS_SHEEN
          }
          getMaterialType(e) {
            const t = this.parser.json.materials[e];
            return t.extensions && t.extensions[this.name] ? Jc : null
          }
          extendMaterialParams(e, t) {
            const i = this.parser
              , n = i.json.materials[e];
            if (!n.extensions || !n.extensions[this.name])
              return Promise.resolve();
            const r = [];
            t.sheenColor = new Wr(0,0,0),
              t.sheenRoughness = 0,
              t.sheen = 1;
            const s = n.extensions[this.name];
            return void 0 !== s.sheenColorFactor && t.sheenColor.fromArray(s.sheenColorFactor),
            void 0 !== s.sheenRoughnessFactor && (t.sheenRoughness = s.sheenRoughnessFactor),
            void 0 !== s.sheenColorTexture && r.push(i.assignTexture(t, "sheenColorMap", s.sheenColorTexture, cr)),
            void 0 !== s.sheenRoughnessTexture && r.push(i.assignTexture(t, "sheenRoughnessMap", s.sheenRoughnessTexture)),
              Promise.all(r)
          }
        }
        class yd {
          constructor(e) {
            this.parser = e,
              this.name = ud.KHR_MATERIALS_TRANSMISSION
          }
          getMaterialType(e) {
            const t = this.parser.json.materials[e];
            return t.extensions && t.extensions[this.name] ? Jc : null
          }
          extendMaterialParams(e, t) {
            const i = this.parser
              , n = i.json.materials[e];
            if (!n.extensions || !n.extensions[this.name])
              return Promise.resolve();
            const r = []
              , s = n.extensions[this.name];
            return void 0 !== s.transmissionFactor && (t.transmission = s.transmissionFactor),
            void 0 !== s.transmissionTexture && r.push(i.assignTexture(t, "transmissionMap", s.transmissionTexture)),
              Promise.all(r)
          }
        }
        class xd {
          constructor(e) {
            this.parser = e,
              this.name = ud.KHR_MATERIALS_VOLUME
          }
          getMaterialType(e) {
            const t = this.parser.json.materials[e];
            return t.extensions && t.extensions[this.name] ? Jc : null
          }
          extendMaterialParams(e, t) {
            const i = this.parser
              , n = i.json.materials[e];
            if (!n.extensions || !n.extensions[this.name])
              return Promise.resolve();
            const r = []
              , s = n.extensions[this.name];
            t.thickness = void 0 !== s.thicknessFactor ? s.thicknessFactor : 0,
            void 0 !== s.thicknessTexture && r.push(i.assignTexture(t, "thicknessMap", s.thicknessTexture)),
              t.attenuationDistance = s.attenuationDistance || 0;
            const a = s.attenuationColor || [1, 1, 1];
            return t.attenuationColor = new Wr(a[0],a[1],a[2]),
              Promise.all(r)
          }
        }
        class _d {
          constructor(e) {
            this.parser = e,
              this.name = ud.KHR_MATERIALS_IOR
          }
          getMaterialType(e) {
            const t = this.parser.json.materials[e];
            return t.extensions && t.extensions[this.name] ? Jc : null
          }
          extendMaterialParams(e, t) {
            const i = this.parser.json.materials[e];
            if (!i.extensions || !i.extensions[this.name])
              return Promise.resolve();
            const n = i.extensions[this.name];
            return t.ior = void 0 !== n.ior ? n.ior : 1.5,
              Promise.resolve()
          }
        }
        class bd {
          constructor(e) {
            this.parser = e,
              this.name = ud.KHR_MATERIALS_SPECULAR
          }
          getMaterialType(e) {
            const t = this.parser.json.materials[e];
            return t.extensions && t.extensions[this.name] ? Jc : null
          }
          extendMaterialParams(e, t) {
            const i = this.parser
              , n = i.json.materials[e];
            if (!n.extensions || !n.extensions[this.name])
              return Promise.resolve();
            const r = []
              , s = n.extensions[this.name];
            t.specularIntensity = void 0 !== s.specularFactor ? s.specularFactor : 1,
            void 0 !== s.specularTexture && r.push(i.assignTexture(t, "specularIntensityMap", s.specularTexture));
            const a = s.specularColorFactor || [1, 1, 1];
            return t.specularColor = new Wr(a[0],a[1],a[2]),
            void 0 !== s.specularColorTexture && r.push(i.assignTexture(t, "specularColorMap", s.specularColorTexture, cr)),
              Promise.all(r)
          }
        }
        class wd {
          constructor(e) {
            this.parser = e,
              this.name = ud.KHR_TEXTURE_BASISU
          }
          loadTexture(e) {
            const t = this.parser
              , i = t.json
              , n = i.textures[e];
            if (!n.extensions || !n.extensions[this.name])
              return null;
            const r = n.extensions[this.name]
              , s = t.options.ktx2Loader;
            if (!s) {
              if (i.extensionsRequired && i.extensionsRequired.indexOf(this.name) >= 0)
                throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
              return null
            }
            return t.loadTextureImage(e, r.source, s)
          }
        }
        class Ad {
          constructor(e) {
            this.parser = e,
              this.name = ud.EXT_TEXTURE_WEBP,
              this.isSupported = null
          }
          loadTexture(e) {
            const t = this.name
              , i = this.parser
              , n = i.json
              , r = n.textures[e];
            if (!r.extensions || !r.extensions[t])
              return null;
            const s = r.extensions[t]
              , a = n.images[s.source];
            let o = i.textureLoader;
            if (a.uri) {
              const e = i.options.manager.getHandler(a.uri);
              null !== e && (o = e)
            }
            return this.detectSupport().then((function(r) {
                if (r)
                  return i.loadTextureImage(e, s.source, o);
                if (n.extensionsRequired && n.extensionsRequired.indexOf(t) >= 0)
                  throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
                return i.loadTexture(e)
              }
            ))
          }
          detectSupport() {
            return this.isSupported || (this.isSupported = new Promise((function(e) {
                const t = new Image;
                t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",
                  t.onload = t.onerror = function() {
                    e(1 === t.height)
                  }
              }
            ))),
              this.isSupported
          }
        }
        class Sd {
          constructor(e) {
            this.name = ud.EXT_MESHOPT_COMPRESSION,
              this.parser = e
          }
          loadBufferView(e) {
            const t = this.parser.json
              , i = t.bufferViews[e];
            if (i.extensions && i.extensions[this.name]) {
              const e = i.extensions[this.name]
                , n = this.parser.getDependency("buffer", e.buffer)
                , r = this.parser.options.meshoptDecoder;
              if (!r || !r.supported) {
                if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0)
                  throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                return null
              }
              return Promise.all([n, r.ready]).then((function(t) {
                  const i = e.byteOffset || 0
                    , n = e.byteLength || 0
                    , s = e.count
                    , a = e.byteStride
                    , o = new ArrayBuffer(s * a)
                    , l = new Uint8Array(t[0],i,n);
                  return r.decodeGltfBuffer(new Uint8Array(o), s, a, l, e.mode, e.filter),
                    o
                }
              ))
            }
            return null
          }
        }
        const Md = "glTF";
        class Td {
          constructor(e) {
            this.name = ud.KHR_BINARY_GLTF,
              this.content = null,
              this.body = null;
            const t = new DataView(e,0,12);
            if (this.header = {
              magic: Nu.decodeText(new Uint8Array(e.slice(0, 4))),
              version: t.getUint32(4, !0),
              length: t.getUint32(8, !0)
            },
            this.header.magic !== Md)
              throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
            if (this.header.version < 2)
              throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
            const i = this.header.length - 12
              , n = new DataView(e,12);
            let r = 0;
            for (; r < i; ) {
              const t = n.getUint32(r, !0);
              r += 4;
              const i = n.getUint32(r, !0);
              if (r += 4,
              1313821514 === i) {
                const i = new Uint8Array(e,12 + r,t);
                this.content = Nu.decodeText(i)
              } else if (5130562 === i) {
                const i = 12 + r;
                this.body = e.slice(i, i + t)
              }
              r += t
            }
            if (null === this.content)
              throw new Error("THREE.GLTFLoader: JSON content not found.")
          }
        }
        class Ed {
          constructor(e, t) {
            if (!t)
              throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
            this.name = ud.KHR_DRACO_MESH_COMPRESSION,
              this.json = e,
              this.dracoLoader = t,
              this.dracoLoader.preload()
          }
          decodePrimitive(e, t) {
            const i = this.json
              , n = this.dracoLoader
              , r = e.extensions[this.name].bufferView
              , s = e.extensions[this.name].attributes
              , a = {}
              , o = {}
              , l = {};
            for (const e in s) {
              const t = zd[e] || e.toLowerCase();
              a[t] = s[e]
            }
            for (const t in e.attributes) {
              const n = zd[t] || t.toLowerCase();
              if (void 0 !== s[t]) {
                const r = i.accessors[e.attributes[t]]
                  , s = Fd[r.componentType];
                l[n] = s,
                  o[n] = !0 === r.normalized
              }
            }
            return t.getDependency("bufferView", r).then((function(e) {
                return new Promise((function(t) {
                    n.decodeDracoFile(e, (function(e) {
                        for (const t in e.attributes) {
                          const i = e.attributes[t]
                            , n = o[t];
                          void 0 !== n && (i.normalized = n)
                        }
                        t(e)
                      }
                    ), a, l)
                  }
                ))
              }
            ))
          }
        }
        class Cd {
          constructor() {
            this.name = ud.KHR_TEXTURE_TRANSFORM
          }
          extendTexture(e, t) {
            return void 0 !== t.texCoord && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'),
            void 0 === t.offset && void 0 === t.rotation && void 0 === t.scale || (e = e.clone(),
            void 0 !== t.offset && e.offset.fromArray(t.offset),
            void 0 !== t.rotation && (e.rotation = t.rotation),
            void 0 !== t.scale && e.repeat.fromArray(t.scale),
              e.needsUpdate = !0),
              e
          }
        }
        class Pd extends Kc {
          constructor(e) {
            super(),
              this.isGLTFSpecularGlossinessMaterial = !0;
            const t = ["#ifdef USE_SPECULARMAP", "\tuniform sampler2D specularMap;", "#endif"].join("\n")
              , i = ["#ifdef USE_GLOSSINESSMAP", "\tuniform sampler2D glossinessMap;", "#endif"].join("\n")
              , n = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "\tvec4 texelSpecular = texture2D( specularMap, vUv );", "\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tspecularFactor *= texelSpecular.rgb;", "#endif"].join("\n")
              , r = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );", "\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tglossinessFactor *= texelGlossiness.a;", "#endif"].join("\n")
              , s = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );", "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );", "material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.", "material.roughness += geometryRoughness;", "material.roughness = min( material.roughness, 1.0 );", "material.specularColor = specularFactor;"].join("\n")
              , a = {
              specular: {
                value: (new Wr).setHex(16777215)
              },
              glossiness: {
                value: 1
              },
              specularMap: {
                value: null
              },
              glossinessMap: {
                value: null
              }
            };
            this._extraUniforms = a,
              this.onBeforeCompile = function(e) {
                for (const t in a)
                  e.uniforms[t] = a[t];
                e.fragmentShader = e.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", t).replace("#include <metalnessmap_pars_fragment>", i).replace("#include <roughnessmap_fragment>", n).replace("#include <metalnessmap_fragment>", r).replace("#include <lights_physical_fragment>", s)
              }
              ,
              Object.defineProperties(this, {
                specular: {
                  get: function() {
                    return a.specular.value
                  },
                  set: function(e) {
                    a.specular.value = e
                  }
                },
                specularMap: {
                  get: function() {
                    return a.specularMap.value
                  },
                  set: function(e) {
                    a.specularMap.value = e,
                      e ? this.defines.USE_SPECULARMAP = "" : delete this.defines.USE_SPECULARMAP
                  }
                },
                glossiness: {
                  get: function() {
                    return a.glossiness.value
                  },
                  set: function(e) {
                    a.glossiness.value = e
                  }
                },
                glossinessMap: {
                  get: function() {
                    return a.glossinessMap.value
                  },
                  set: function(e) {
                    a.glossinessMap.value = e,
                      e ? (this.defines.USE_GLOSSINESSMAP = "",
                        this.defines.USE_UV = "") : (delete this.defines.USE_GLOSSINESSMAP,
                        delete this.defines.USE_UV)
                  }
                }
              }),
              delete this.metalness,
              delete this.roughness,
              delete this.metalnessMap,
              delete this.roughnessMap,
              this.setValues(e)
          }
          copy(e) {
            return super.copy(e),
              this.specularMap = e.specularMap,
              this.specular.copy(e.specular),
              this.glossinessMap = e.glossinessMap,
              this.glossiness = e.glossiness,
              delete this.metalness,
              delete this.roughness,
              delete this.metalnessMap,
              delete this.roughnessMap,
              this
          }
        }
        class Dd {
          constructor() {
            this.name = ud.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,
              this.specularGlossinessParams = ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity"]
          }
          getMaterialType() {
            return Pd
          }
          extendParams(e, t, i) {
            const n = t.extensions[this.name];
            e.color = new Wr(1,1,1),
              e.opacity = 1;
            const r = [];
            if (Array.isArray(n.diffuseFactor)) {
              const t = n.diffuseFactor;
              e.color.fromArray(t),
                e.opacity = t[3]
            }
            if (void 0 !== n.diffuseTexture && r.push(i.assignTexture(e, "map", n.diffuseTexture, cr)),
              e.emissive = new Wr(0,0,0),
              e.glossiness = void 0 !== n.glossinessFactor ? n.glossinessFactor : 1,
              e.specular = new Wr(1,1,1),
            Array.isArray(n.specularFactor) && e.specular.fromArray(n.specularFactor),
            void 0 !== n.specularGlossinessTexture) {
              const t = n.specularGlossinessTexture;
              r.push(i.assignTexture(e, "glossinessMap", t)),
                r.push(i.assignTexture(e, "specularMap", t, cr))
            }
            return Promise.all(r)
          }
          createMaterial(e) {
            const t = new Pd(e);
            return t.fog = !0,
              t.color = e.color,
              t.map = void 0 === e.map ? null : e.map,
              t.lightMap = null,
              t.lightMapIntensity = 1,
              t.aoMap = void 0 === e.aoMap ? null : e.aoMap,
              t.aoMapIntensity = 1,
              t.emissive = e.emissive,
              t.emissiveIntensity = void 0 === e.emissiveIntensity ? 1 : e.emissiveIntensity,
              t.emissiveMap = void 0 === e.emissiveMap ? null : e.emissiveMap,
              t.bumpMap = void 0 === e.bumpMap ? null : e.bumpMap,
              t.bumpScale = 1,
              t.normalMap = void 0 === e.normalMap ? null : e.normalMap,
              t.normalMapType = 0,
            e.normalScale && (t.normalScale = e.normalScale),
              t.displacementMap = null,
              t.displacementScale = 1,
              t.displacementBias = 0,
              t.specularMap = void 0 === e.specularMap ? null : e.specularMap,
              t.specular = e.specular,
              t.glossinessMap = void 0 === e.glossinessMap ? null : e.glossinessMap,
              t.glossiness = e.glossiness,
              t.alphaMap = null,
              t.envMap = void 0 === e.envMap ? null : e.envMap,
              t.envMapIntensity = 1,
              t
          }
        }
        class Id {
          constructor() {
            this.name = ud.KHR_MESH_QUANTIZATION
          }
        }
        class Rd extends tu {
          constructor(e, t, i, n) {
            super(e, t, i, n)
          }
          copySampleValue_(e) {
            const t = this.resultBuffer
              , i = this.sampleValues
              , n = this.valueSize
              , r = e * n * 3 + n;
            for (let e = 0; e !== n; e++)
              t[e] = i[r + e];
            return t
          }
        }
        Rd.prototype.interpolate_ = function(e, t, i, n) {
          const r = this.resultBuffer
            , s = this.sampleValues
            , a = this.valueSize
            , o = 2 * a
            , l = 3 * a
            , h = n - t
            , c = (i - t) / h
            , u = c * c
            , d = u * c
            , p = e * l
            , f = p - l
            , m = -2 * d + 3 * u
            , g = d - u
            , v = 1 - m
            , y = g - u + c;
          for (let e = 0; e !== a; e++) {
            const t = s[f + e + a]
              , i = s[f + e + o] * h
              , n = s[p + e + a]
              , l = s[p + e] * h;
            r[e] = v * t + y * i + m * n + g * l
          }
          return r
        }
        ;
        const Ld = new es;
        class kd extends Rd {
          interpolate_(e, t, i, n) {
            const r = super.interpolate_(e, t, i, n);
            return Ld.fromArray(r).normalize().toArray(r),
              r
          }
        }
        const Fd = {
          5120: Int8Array,
          5121: Uint8Array,
          5122: Int16Array,
          5123: Uint16Array,
          5125: Uint32Array,
          5126: Float32Array
        }
          , Bd = {
          9728: Un,
          9729: Hn,
          9984: Gn,
          9985: 1007,
          9986: Vn,
          9987: Wn
        }
          , Od = {
          33071: Nn,
          33648: zn,
          10497: On
        }
          , Nd = {
          SCALAR: 1,
          VEC2: 2,
          VEC3: 3,
          VEC4: 4,
          MAT2: 4,
          MAT3: 9,
          MAT4: 16
        }
          , zd = {
          POSITION: "position",
          NORMAL: "normal",
          TANGENT: "tangent",
          TEXCOORD_0: "uv",
          TEXCOORD_1: "uv2",
          COLOR_0: "color",
          WEIGHTS_0: "skinWeight",
          JOINTS_0: "skinIndex"
        }
          , Ud = {
          scale: "scale",
          translation: "position",
          rotation: "quaternion",
          weights: "morphTargetInfluences"
        }
          , Gd = {
          CUBICSPLINE: void 0,
          LINEAR: rr,
          STEP: nr
        };
        function Vd(e, t, i) {
          for (const n in i.extensions)
            void 0 === e[n] && (t.userData.gltfExtensions = t.userData.gltfExtensions || {},
              t.userData.gltfExtensions[n] = i.extensions[n])
        }
        function Hd(e, t) {
          void 0 !== t.extras && ("object" == typeof t.extras ? Object.assign(e.userData, t.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + t.extras))
        }
        function Wd(e, t) {
          if (e.updateMorphTargets(),
          void 0 !== t.weights)
            for (let i = 0, n = t.weights.length; i < n; i++)
              e.morphTargetInfluences[i] = t.weights[i];
          if (t.extras && Array.isArray(t.extras.targetNames)) {
            const i = t.extras.targetNames;
            if (e.morphTargetInfluences.length === i.length) {
              e.morphTargetDictionary = {};
              for (let t = 0, n = i.length; t < n; t++)
                e.morphTargetDictionary[i[t]] = t
            } else
              console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
          }
        }
        function jd(e) {
          const t = e.extensions && e.extensions[ud.KHR_DRACO_MESH_COMPRESSION];
          let i;
          return i = t ? "draco:" + t.bufferView + ":" + t.indices + ":" + Xd(t.attributes) : e.indices + ":" + Xd(e.attributes) + ":" + e.mode,
            i
        }
        function Xd(e) {
          let t = "";
          const i = Object.keys(e).sort();
          for (let n = 0, r = i.length; n < r; n++)
            t += i[n] + ":" + e[i[n]] + ";";
          return t
        }
        function Yd(e) {
          switch (e) {
            case Int8Array:
              return 1 / 127;
            case Uint8Array:
              return 1 / 255;
            case Int16Array:
              return 1 / 32767;
            case Uint16Array:
              return 1 / 65535;
            default:
              throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
          }
        }
        class qd {
          constructor(e={}, t={}) {
            this.json = e,
              this.extensions = {},
              this.plugins = {},
              this.options = t,
              this.cache = new cd,
              this.associations = new Map,
              this.primitiveCache = {},
              this.meshCache = {
                refs: {},
                uses: {}
              },
              this.cameraCache = {
                refs: {},
                uses: {}
              },
              this.lightCache = {
                refs: {},
                uses: {}
              },
              this.sourceCache = {},
              this.textureCache = {},
              this.nodeNamesUsed = {};
            const i = !0 === /^((?!chrome|android).)*safari/i.test(navigator.userAgent)
              , n = navigator.userAgent.indexOf("Firefox") > -1
              , r = n ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1;
            "undefined" == typeof createImageBitmap || i || n && r < 98 ? this.textureLoader = new wu(this.options.manager) : this.textureLoader = new Uu(this.options.manager),
              this.textureLoader.setCrossOrigin(this.options.crossOrigin),
              this.textureLoader.setRequestHeader(this.options.requestHeader),
              this.fileLoader = new _u(this.options.manager),
              this.fileLoader.setResponseType("arraybuffer"),
            "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0)
          }
          setExtensions(e) {
            this.extensions = e
          }
          setPlugins(e) {
            this.plugins = e
          }
          parse(e, t) {
            const i = this
              , n = this.json
              , r = this.extensions;
            this.cache.removeAll(),
              this._invokeAll((function(e) {
                  return e._markDefs && e._markDefs()
                }
              )),
              Promise.all(this._invokeAll((function(e) {
                  return e.beforeRoot && e.beforeRoot()
                }
              ))).then((function() {
                  return Promise.all([i.getDependencies("scene"), i.getDependencies("animation"), i.getDependencies("camera")])
                }
              )).then((function(t) {
                  const s = {
                    scene: t[0][n.scene || 0],
                    scenes: t[0],
                    animations: t[1],
                    cameras: t[2],
                    asset: n.asset,
                    parser: i,
                    userData: {}
                  };
                  Vd(r, s, n),
                    Hd(s, n),
                    Promise.all(i._invokeAll((function(e) {
                        return e.afterRoot && e.afterRoot(s)
                      }
                    ))).then((function() {
                        e(s)
                      }
                    ))
                }
              )).catch(t)
          }
          _markDefs() {
            const e = this.json.nodes || []
              , t = this.json.skins || []
              , i = this.json.meshes || [];
            for (let i = 0, n = t.length; i < n; i++) {
              const n = t[i].joints;
              for (let t = 0, i = n.length; t < i; t++)
                e[n[t]].isBone = !0
            }
            for (let t = 0, n = e.length; t < n; t++) {
              const n = e[t];
              void 0 !== n.mesh && (this._addNodeRef(this.meshCache, n.mesh),
              void 0 !== n.skin && (i[n.mesh].isSkinnedMesh = !0)),
              void 0 !== n.camera && this._addNodeRef(this.cameraCache, n.camera)
            }
          }
          _addNodeRef(e, t) {
            void 0 !== t && (void 0 === e.refs[t] && (e.refs[t] = e.uses[t] = 0),
              e.refs[t]++)
          }
          _getNodeRef(e, t, i) {
            if (e.refs[t] <= 1)
              return i;
            const n = i.clone()
              , r = (e,t)=>{
                const i = this.associations.get(e);
                null != i && this.associations.set(t, i);
                for (const [i,n] of e.children.entries())
                  r(n, t.children[i])
              }
            ;
            return r(i, n),
              n.name += "_instance_" + e.uses[t]++,
              n
          }
          _invokeOne(e) {
            const t = Object.values(this.plugins);
            t.push(this);
            for (let i = 0; i < t.length; i++) {
              const n = e(t[i]);
              if (n)
                return n
            }
            return null
          }
          _invokeAll(e) {
            const t = Object.values(this.plugins);
            t.unshift(this);
            const i = [];
            for (let n = 0; n < t.length; n++) {
              const r = e(t[n]);
              r && i.push(r)
            }
            return i
          }
          getDependency(e, t) {
            const i = e + ":" + t;
            let n = this.cache.get(i);
            if (!n) {
              switch (e) {
                case "scene":
                  n = this.loadScene(t);
                  break;
                case "node":
                  n = this.loadNode(t);
                  break;
                case "mesh":
                  n = this._invokeOne((function(e) {
                      return e.loadMesh && e.loadMesh(t)
                    }
                  ));
                  break;
                case "accessor":
                  n = this.loadAccessor(t);
                  break;
                case "bufferView":
                  n = this._invokeOne((function(e) {
                      return e.loadBufferView && e.loadBufferView(t)
                    }
                  ));
                  break;
                case "buffer":
                  n = this.loadBuffer(t);
                  break;
                case "material":
                  n = this._invokeOne((function(e) {
                      return e.loadMaterial && e.loadMaterial(t)
                    }
                  ));
                  break;
                case "texture":
                  n = this._invokeOne((function(e) {
                      return e.loadTexture && e.loadTexture(t)
                    }
                  ));
                  break;
                case "skin":
                  n = this.loadSkin(t);
                  break;
                case "animation":
                  n = this._invokeOne((function(e) {
                      return e.loadAnimation && e.loadAnimation(t)
                    }
                  ));
                  break;
                case "camera":
                  n = this.loadCamera(t);
                  break;
                default:
                  throw new Error("Unknown type: " + e)
              }
              this.cache.add(i, n)
            }
            return n
          }
          getDependencies(e) {
            let t = this.cache.get(e);
            if (!t) {
              const i = this
                , n = this.json[e + ("mesh" === e ? "es" : "s")] || [];
              t = Promise.all(n.map((function(t, n) {
                  return i.getDependency(e, n)
                }
              ))),
                this.cache.add(e, t)
            }
            return t
          }
          loadBuffer(e) {
            const t = this.json.buffers[e]
              , i = this.fileLoader;
            if (t.type && "arraybuffer" !== t.type)
              throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
            if (void 0 === t.uri && 0 === e)
              return Promise.resolve(this.extensions[ud.KHR_BINARY_GLTF].body);
            const n = this.options;
            return new Promise((function(e, r) {
                i.load(Nu.resolveURL(t.uri, n.path), e, void 0, (function() {
                    r(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'))
                  }
                ))
              }
            ))
          }
          loadBufferView(e) {
            const t = this.json.bufferViews[e];
            return this.getDependency("buffer", t.buffer).then((function(e) {
                const i = t.byteLength || 0
                  , n = t.byteOffset || 0;
                return e.slice(n, n + i)
              }
            ))
          }
          loadAccessor(e) {
            const t = this
              , i = this.json
              , n = this.json.accessors[e];
            if (void 0 === n.bufferView && void 0 === n.sparse)
              return Promise.resolve(null);
            const r = [];
            return void 0 !== n.bufferView ? r.push(this.getDependency("bufferView", n.bufferView)) : r.push(null),
            void 0 !== n.sparse && (r.push(this.getDependency("bufferView", n.sparse.indices.bufferView)),
              r.push(this.getDependency("bufferView", n.sparse.values.bufferView))),
              Promise.all(r).then((function(e) {
                  const r = e[0]
                    , s = Nd[n.type]
                    , a = Fd[n.componentType]
                    , o = a.BYTES_PER_ELEMENT
                    , l = o * s
                    , h = n.byteOffset || 0
                    , c = void 0 !== n.bufferView ? i.bufferViews[n.bufferView].byteStride : void 0
                    , u = !0 === n.normalized;
                  let d, p;
                  if (c && c !== l) {
                    const e = Math.floor(h / c)
                      , i = "InterleavedBuffer:" + n.bufferView + ":" + n.componentType + ":" + e + ":" + n.count;
                    let l = t.cache.get(i);
                    l || (d = new a(r,e * c,n.count * c / o),
                      l = new Qh(d,c / o),
                      t.cache.add(i, l)),
                      p = new Jh(l,s,h % c / o,u)
                  } else
                    d = null === r ? new a(n.count * s) : new a(r,h,n.count * s),
                      p = new _a(d,s,u);
                  if (void 0 !== n.sparse) {
                    const t = Nd.SCALAR
                      , i = Fd[n.sparse.indices.componentType]
                      , o = n.sparse.indices.byteOffset || 0
                      , l = n.sparse.values.byteOffset || 0
                      , h = new i(e[1],o,n.sparse.count * t)
                      , c = new a(e[2],l,n.sparse.count * s);
                    null !== r && (p = new _a(p.array.slice(),p.itemSize,p.normalized));
                    for (let e = 0, t = h.length; e < t; e++) {
                      const t = h[e];
                      if (p.setX(t, c[e * s]),
                      s >= 2 && p.setY(t, c[e * s + 1]),
                      s >= 3 && p.setZ(t, c[e * s + 2]),
                      s >= 4 && p.setW(t, c[e * s + 3]),
                      s >= 5)
                        throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
                    }
                  }
                  return p
                }
              ))
          }
          loadTexture(e) {
            const t = this.json
              , i = this.options
              , n = t.textures[e].source
              , r = t.images[n];
            let s = this.textureLoader;
            if (r.uri) {
              const e = i.manager.getHandler(r.uri);
              null !== e && (s = e)
            }
            return this.loadTextureImage(e, n, s)
          }
          loadTextureImage(e, t, i) {
            const n = this
              , r = this.json
              , s = r.textures[e]
              , a = r.images[t]
              , o = (a.uri || a.bufferView) + ":" + s.sampler;
            if (this.textureCache[o])
              return this.textureCache[o];
            const l = this.loadImageSource(t, i).then((function(t) {
                t.flipY = !1,
                s.name && (t.name = s.name);
                const i = (r.samplers || {})[s.sampler] || {};
                return t.magFilter = Bd[i.magFilter] || Hn,
                  t.minFilter = Bd[i.minFilter] || Wn,
                  t.wrapS = Od[i.wrapS] || On,
                  t.wrapT = Od[i.wrapT] || On,
                  n.associations.set(t, {
                    textures: e
                  }),
                  t
              }
            )).catch((function() {
                return null
              }
            ));
            return this.textureCache[o] = l,
              l
          }
          loadImageSource(e, t) {
            const i = this.json
              , n = this.options;
            if (void 0 !== this.sourceCache[e])
              return this.sourceCache[e].then((e=>e.clone()));
            const r = i.images[e]
              , s = self.URL || self.webkitURL;
            let a = r.uri || ""
              , o = !1;
            if (void 0 !== r.bufferView)
              a = this.getDependency("bufferView", r.bufferView).then((function(e) {
                  o = !0;
                  const t = new Blob([e],{
                    type: r.mimeType
                  });
                  return a = s.createObjectURL(t),
                    a
                }
              ));
            else if (void 0 === r.uri)
              throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
            const l = Promise.resolve(a).then((function(e) {
                return new Promise((function(i, r) {
                    let s = i;
                    !0 === t.isImageBitmapLoader && (s = function(e) {
                        const t = new Kr(e);
                        t.needsUpdate = !0,
                          i(t)
                      }
                    ),
                      t.load(Nu.resolveURL(e, n.path), s, void 0, r)
                  }
                ))
              }
            )).then((function(e) {
                var t;
                return !0 === o && s.revokeObjectURL(a),
                  e.userData.mimeType = r.mimeType || ((t = r.uri).search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/) ? "image/jpeg" : t.search(/\.webp($|\?)/i) > 0 || 0 === t.search(/^data\:image\/webp/) ? "image/webp" : "image/png"),
                  e
              }
            )).catch((function(e) {
                throw console.error("THREE.GLTFLoader: Couldn't load texture", a),
                  e
              }
            ));
            return this.sourceCache[e] = l,
              l
          }
          assignTexture(e, t, i, n) {
            const r = this;
            return this.getDependency("texture", i.index).then((function(s) {
                if (void 0 === i.texCoord || 0 == i.texCoord || "aoMap" === t && 1 == i.texCoord || console.warn("THREE.GLTFLoader: Custom UV set " + i.texCoord + " for texture " + t + " not yet supported."),
                  r.extensions[ud.KHR_TEXTURE_TRANSFORM]) {
                  const e = void 0 !== i.extensions ? i.extensions[ud.KHR_TEXTURE_TRANSFORM] : void 0;
                  if (e) {
                    const t = r.associations.get(s);
                    s = r.extensions[ud.KHR_TEXTURE_TRANSFORM].extendTexture(s, e),
                      r.associations.set(s, t)
                  }
                }
                return void 0 !== n && (s.encoding = n),
                  e[t] = s,
                  s
              }
            ))
          }
          assignFinalMaterial(e) {
            const t = e.geometry;
            let i = e.material;
            const n = void 0 === t.attributes.tangent
              , r = void 0 !== t.attributes.color
              , s = void 0 === t.attributes.normal;
            if (e.isPoints) {
              const e = "PointsMaterial:" + i.uuid;
              let t = this.cache.get(e);
              t || (t = new Tc,
                ga.prototype.copy.call(t, i),
                t.color.copy(i.color),
                t.map = i.map,
                t.sizeAttenuation = !1,
                this.cache.add(e, t)),
                i = t
            } else if (e.isLine) {
              const e = "LineBasicMaterial:" + i.uuid;
              let t = this.cache.get(e);
              t || (t = new mc,
                ga.prototype.copy.call(t, i),
                t.color.copy(i.color),
                this.cache.add(e, t)),
                i = t
            }
            if (n || r || s) {
              let e = "ClonedMaterial:" + i.uuid + ":";
              i.isGLTFSpecularGlossinessMaterial && (e += "specular-glossiness:"),
              n && (e += "derivative-tangents:"),
              r && (e += "vertex-colors:"),
              s && (e += "flat-shading:");
              let t = this.cache.get(e);
              t || (t = i.clone(),
              r && (t.vertexColors = !0),
              s && (t.flatShading = !0),
              n && (t.normalScale && (t.normalScale.y *= -1),
              t.clearcoatNormalScale && (t.clearcoatNormalScale.y *= -1)),
                this.cache.add(e, t),
                this.associations.set(t, this.associations.get(i))),
                i = t
            }
            i.aoMap && void 0 === t.attributes.uv2 && void 0 !== t.attributes.uv && t.setAttribute("uv2", t.attributes.uv),
              e.material = i
          }
          getMaterialType() {
            return Kc
          }
          loadMaterial(e) {
            const t = this
              , i = this.json
              , n = this.extensions
              , r = i.materials[e];
            let s;
            const a = {}
              , o = r.extensions || {}
              , l = [];
            if (o[ud.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
              const e = n[ud.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
              s = e.getMaterialType(),
                l.push(e.extendParams(a, r, t))
            } else if (o[ud.KHR_MATERIALS_UNLIT]) {
              const e = n[ud.KHR_MATERIALS_UNLIT];
              s = e.getMaterialType(),
                l.push(e.extendParams(a, r, t))
            } else {
              const i = r.pbrMetallicRoughness || {};
              if (a.color = new Wr(1,1,1),
                a.opacity = 1,
                Array.isArray(i.baseColorFactor)) {
                const e = i.baseColorFactor;
                a.color.fromArray(e),
                  a.opacity = e[3]
              }
              void 0 !== i.baseColorTexture && l.push(t.assignTexture(a, "map", i.baseColorTexture, cr)),
                a.metalness = void 0 !== i.metallicFactor ? i.metallicFactor : 1,
                a.roughness = void 0 !== i.roughnessFactor ? i.roughnessFactor : 1,
              void 0 !== i.metallicRoughnessTexture && (l.push(t.assignTexture(a, "metalnessMap", i.metallicRoughnessTexture)),
                l.push(t.assignTexture(a, "roughnessMap", i.metallicRoughnessTexture))),
                s = this._invokeOne((function(t) {
                    return t.getMaterialType && t.getMaterialType(e)
                  }
                )),
                l.push(Promise.all(this._invokeAll((function(t) {
                    return t.extendMaterialParams && t.extendMaterialParams(e, a)
                  }
                ))))
            }
            !0 === r.doubleSided && (a.side = 2);
            const h = r.alphaMode || "OPAQUE";
            if ("BLEND" === h ? (a.transparent = !0,
              a.depthWrite = !1) : (a.transparent = !1,
            "MASK" === h && (a.alphaTest = void 0 !== r.alphaCutoff ? r.alphaCutoff : .5)),
            void 0 !== r.normalTexture && s !== va && (l.push(t.assignTexture(a, "normalMap", r.normalTexture)),
              a.normalScale = new Dr(1,1),
            void 0 !== r.normalTexture.scale)) {
              const e = r.normalTexture.scale;
              a.normalScale.set(e, e)
            }
            return void 0 !== r.occlusionTexture && s !== va && (l.push(t.assignTexture(a, "aoMap", r.occlusionTexture)),
            void 0 !== r.occlusionTexture.strength && (a.aoMapIntensity = r.occlusionTexture.strength)),
            void 0 !== r.emissiveFactor && s !== va && (a.emissive = (new Wr).fromArray(r.emissiveFactor)),
            void 0 !== r.emissiveTexture && s !== va && l.push(t.assignTexture(a, "emissiveMap", r.emissiveTexture, cr)),
              Promise.all(l).then((function() {
                  let i;
                  return i = s === Pd ? n[ud.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(a) : new s(a),
                  r.name && (i.name = r.name),
                    Hd(i, r),
                    t.associations.set(i, {
                      materials: e
                    }),
                  r.extensions && Vd(n, i, r),
                    i
                }
              ))
          }
          createUniqueName(e) {
            const t = Ju.sanitizeNodeName(e || "");
            let i = t;
            for (let e = 1; this.nodeNamesUsed[i]; ++e)
              i = t + "_" + e;
            return this.nodeNamesUsed[i] = !0,
              i
          }
          loadGeometries(e) {
            const t = this
              , i = this.extensions
              , n = this.primitiveCache;
            function r(e) {
              return i[ud.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e, t).then((function(i) {
                  return Kd(i, e, t)
                }
              ))
            }
            const s = [];
            for (let i = 0, a = e.length; i < a; i++) {
              const a = e[i]
                , o = jd(a)
                , l = n[o];
              if (l)
                s.push(l.promise);
              else {
                let e;
                e = a.extensions && a.extensions[ud.KHR_DRACO_MESH_COMPRESSION] ? r(a) : Kd(new Ia, a, t),
                  n[o] = {
                    primitive: a,
                    promise: e
                  },
                  s.push(e)
              }
            }
            return Promise.all(s)
          }
          loadMesh(e) {
            const t = this
              , i = this.json
              , n = this.extensions
              , r = i.meshes[e]
              , s = r.primitives
              , a = [];
            for (let e = 0, t = s.length; e < t; e++) {
              const t = void 0 === s[e].material ? (void 0 === (o = this.cache).DefaultMaterial && (o.DefaultMaterial = new Kc({
                color: 16777215,
                emissive: 0,
                metalness: 1,
                roughness: 1,
                transparent: !1,
                depthTest: !0,
                side: 0
              })),
                o.DefaultMaterial) : this.getDependency("material", s[e].material);
              a.push(t)
            }
            var o;
            return a.push(t.loadGeometries(s)),
              Promise.all(a).then((function(i) {
                  const a = i.slice(0, i.length - 1)
                    , o = i[i.length - 1]
                    , l = [];
                  for (let i = 0, h = o.length; i < h; i++) {
                    const h = o[i]
                      , c = s[i];
                    let u;
                    const d = a[i];
                    if (4 === c.mode || 5 === c.mode || 6 === c.mode || void 0 === c.mode)
                      u = !0 === r.isSkinnedMesh ? new nc(h,d) : new Qa(h,d),
                      !0 !== u.isSkinnedMesh || u.geometry.attributes.skinWeight.normalized || u.normalizeSkinWeights(),
                        5 === c.mode ? u.geometry = Jd(u.geometry, 1) : 6 === c.mode && (u.geometry = Jd(u.geometry, 2));
                    else if (1 === c.mode)
                      u = new Sc(h,d);
                    else if (3 === c.mode)
                      u = new bc(h,d);
                    else if (2 === c.mode)
                      u = new Mc(h,d);
                    else {
                      if (0 !== c.mode)
                        throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + c.mode);
                      u = new Ic(h,d)
                    }
                    Object.keys(u.geometry.morphAttributes).length > 0 && Wd(u, r),
                      u.name = t.createUniqueName(r.name || "mesh_" + e),
                      Hd(u, r),
                    c.extensions && Vd(n, u, c),
                      t.assignFinalMaterial(u),
                      l.push(u)
                  }
                  for (let i = 0, n = l.length; i < n; i++)
                    t.associations.set(l[i], {
                      meshes: e,
                      primitives: i
                    });
                  if (1 === l.length)
                    return l[0];
                  const h = new Gh;
                  t.associations.set(h, {
                    meshes: e
                  });
                  for (let e = 0, t = l.length; e < t; e++)
                    h.add(l[e]);
                  return h
                }
              ))
          }
          loadCamera(e) {
            let t;
            const i = this.json.cameras[e]
              , n = i[i.type];
            if (n)
              return "perspective" === i.type ? t = new no(Pr.radToDeg(n.yfov),n.aspectRatio || 1,n.znear || 1,n.zfar || 2e6) : "orthographic" === i.type && (t = new Co(-n.xmag,n.xmag,n.ymag,-n.ymag,n.znear,n.zfar)),
              i.name && (t.name = this.createUniqueName(i.name)),
                Hd(t, i),
                Promise.resolve(t);
            console.warn("THREE.GLTFLoader: Missing camera parameters.")
          }
          loadSkin(e) {
            const t = this.json.skins[e]
              , i = {
              joints: t.joints
            };
            return void 0 === t.inverseBindMatrices ? Promise.resolve(i) : this.getDependency("accessor", t.inverseBindMatrices).then((function(e) {
                return i.inverseBindMatrices = e,
                  i
              }
            ))
          }
          loadAnimation(e) {
            const t = this.json.animations[e]
              , i = []
              , n = []
              , r = []
              , s = []
              , a = [];
            for (let e = 0, o = t.channels.length; e < o; e++) {
              const o = t.channels[e]
                , l = t.samplers[o.sampler]
                , h = o.target
                , c = void 0 !== h.node ? h.node : h.id
                , u = void 0 !== t.parameters ? t.parameters[l.input] : l.input
                , d = void 0 !== t.parameters ? t.parameters[l.output] : l.output;
              i.push(this.getDependency("node", c)),
                n.push(this.getDependency("accessor", u)),
                r.push(this.getDependency("accessor", d)),
                s.push(l),
                a.push(h)
            }
            return Promise.all([Promise.all(i), Promise.all(n), Promise.all(r), Promise.all(s), Promise.all(a)]).then((function(i) {
                const n = i[0]
                  , r = i[1]
                  , s = i[2]
                  , a = i[3]
                  , o = i[4]
                  , l = [];
                for (let e = 0, t = n.length; e < t; e++) {
                  const t = n[e]
                    , i = r[e]
                    , h = s[e]
                    , c = a[e]
                    , u = o[e];
                  if (void 0 === t)
                    continue;
                  let d;
                  switch (t.updateMatrix(),
                    t.matrixAutoUpdate = !0,
                    Ud[u.path]) {
                    case Ud.weights:
                      d = lu;
                      break;
                    case Ud.rotation:
                      d = cu;
                      break;
                    default:
                      d = du
                  }
                  const p = t.name ? t.name : t.uuid
                    , f = void 0 !== c.interpolation ? Gd[c.interpolation] : rr
                    , m = [];
                  Ud[u.path] === Ud.weights ? t.traverse((function(e) {
                      e.morphTargetInfluences && m.push(e.name ? e.name : e.uuid)
                    }
                  )) : m.push(p);
                  let g = h.array;
                  if (h.normalized) {
                    const e = Yd(g.constructor)
                      , t = new Float32Array(g.length);
                    for (let i = 0, n = g.length; i < n; i++)
                      t[i] = g[i] * e;
                    g = t
                  }
                  for (let e = 0, t = m.length; e < t; e++) {
                    const t = new d(m[e] + "." + Ud[u.path],i.array,g,f);
                    "CUBICSPLINE" === c.interpolation && (t.createInterpolant = function(e) {
                      return new (this instanceof cu ? kd : Rd)(this.times,this.values,this.getValueSize() / 3,e)
                    }
                      ,
                      t.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0),
                      l.push(t)
                  }
                }
                const h = t.name ? t.name : "animation_" + e;
                return new pu(h,void 0,l)
              }
            ))
          }
          createNodeMesh(e) {
            const t = this.json
              , i = this
              , n = t.nodes[e];
            return void 0 === n.mesh ? null : i.getDependency("mesh", n.mesh).then((function(e) {
                const t = i._getNodeRef(i.meshCache, n.mesh, e);
                return void 0 !== n.weights && t.traverse((function(e) {
                    if (e.isMesh)
                      for (let t = 0, i = n.weights.length; t < i; t++)
                        e.morphTargetInfluences[t] = n.weights[t]
                  }
                )),
                  t
              }
            ))
          }
          loadNode(e) {
            const t = this.json
              , i = this.extensions
              , n = this
              , r = t.nodes[e]
              , s = r.name ? n.createUniqueName(r.name) : "";
            return function() {
              const t = []
                , i = n._invokeOne((function(t) {
                  return t.createNodeMesh && t.createNodeMesh(e)
                }
              ));
              return i && t.push(i),
              void 0 !== r.camera && t.push(n.getDependency("camera", r.camera).then((function(e) {
                  return n._getNodeRef(n.cameraCache, r.camera, e)
                }
              ))),
                n._invokeAll((function(t) {
                    return t.createNodeAttachment && t.createNodeAttachment(e)
                  }
                )).forEach((function(e) {
                    t.push(e)
                  }
                )),
                Promise.all(t)
            }().then((function(t) {
                let a;
                if (a = !0 === r.isBone ? new rc : t.length > 1 ? new Gh : 1 === t.length ? t[0] : new na,
                a !== t[0])
                  for (let e = 0, i = t.length; e < i; e++)
                    a.add(t[e]);
                if (r.name && (a.userData.name = r.name,
                  a.name = s),
                  Hd(a, r),
                r.extensions && Vd(i, a, r),
                void 0 !== r.matrix) {
                  const e = new Rs;
                  e.fromArray(r.matrix),
                    a.applyMatrix4(e)
                } else
                  void 0 !== r.translation && a.position.fromArray(r.translation),
                  void 0 !== r.rotation && a.quaternion.fromArray(r.rotation),
                  void 0 !== r.scale && a.scale.fromArray(r.scale);
                return n.associations.has(a) || n.associations.set(a, {}),
                  n.associations.get(a).nodes = e,
                  a
              }
            ))
          }
          loadScene(e) {
            const t = this.json
              , i = this.extensions
              , n = this.json.scenes[e]
              , r = this
              , s = new Gh;
            n.name && (s.name = r.createUniqueName(n.name)),
              Hd(s, n),
            n.extensions && Vd(i, s, n);
            const a = n.nodes || []
              , o = [];
            for (let e = 0, i = a.length; e < i; e++)
              o.push(Qd(a[e], s, t, r));
            return Promise.all(o).then((function() {
                return r.associations = (e=>{
                    const t = new Map;
                    for (const [e,i] of r.associations)
                      (e instanceof ga || e instanceof Kr) && t.set(e, i);
                    return e.traverse((e=>{
                        const i = r.associations.get(e);
                        null != i && t.set(e, i)
                      }
                    )),
                      t
                  }
                )(s),
                  s
              }
            ))
          }
        }
        function Qd(e, t, i, n) {
          const r = i.nodes[e];
          return n.getDependency("node", e).then((function(e) {
              if (void 0 === r.skin)
                return e;
              let t;
              return n.getDependency("skin", r.skin).then((function(e) {
                  t = e;
                  const i = [];
                  for (let e = 0, r = t.joints.length; e < r; e++)
                    i.push(n.getDependency("node", t.joints[e]));
                  return Promise.all(i)
                }
              )).then((function(i) {
                  return e.traverse((function(e) {
                      if (!e.isMesh)
                        return;
                      const n = []
                        , r = [];
                      for (let e = 0, s = i.length; e < s; e++) {
                        const s = i[e];
                        if (s) {
                          n.push(s);
                          const i = new Rs;
                          void 0 !== t.inverseBindMatrices && i.fromArray(t.inverseBindMatrices.array, 16 * e),
                            r.push(i)
                        } else
                          console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[e])
                      }
                      e.bind(new lc(n,r), e.matrixWorld)
                    }
                  )),
                    e
                }
              ))
            }
          )).then((function(e) {
              t.add(e);
              const s = [];
              if (r.children) {
                const t = r.children;
                for (let r = 0, a = t.length; r < a; r++) {
                  const a = t[r];
                  s.push(Qd(a, e, i, n))
                }
              }
              return Promise.all(s)
            }
          ))
        }
        function Kd(e, t, i) {
          const n = t.attributes
            , r = [];
          function s(t, n) {
            return i.getDependency("accessor", t).then((function(t) {
                e.setAttribute(n, t)
              }
            ))
          }
          for (const t in n) {
            const i = zd[t] || t.toLowerCase();
            i in e.attributes || r.push(s(n[t], i))
          }
          if (void 0 !== t.indices && !e.index) {
            const n = i.getDependency("accessor", t.indices).then((function(t) {
                e.setIndex(t)
              }
            ));
            r.push(n)
          }
          return Hd(e, t),
            function(e, t, i) {
              const n = t.attributes
                , r = new rs;
              if (void 0 === n.POSITION)
                return;
              {
                const e = i.json.accessors[n.POSITION]
                  , t = e.min
                  , s = e.max;
                if (void 0 === t || void 0 === s)
                  return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
                if (r.set(new ts(t[0],t[1],t[2]), new ts(s[0],s[1],s[2])),
                  e.normalized) {
                  const t = Yd(Fd[e.componentType]);
                  r.min.multiplyScalar(t),
                    r.max.multiplyScalar(t)
                }
              }
              const s = t.targets;
              if (void 0 !== s) {
                const e = new ts
                  , t = new ts;
                for (let n = 0, r = s.length; n < r; n++) {
                  const r = s[n];
                  if (void 0 !== r.POSITION) {
                    const n = i.json.accessors[r.POSITION]
                      , s = n.min
                      , a = n.max;
                    if (void 0 !== s && void 0 !== a) {
                      if (t.setX(Math.max(Math.abs(s[0]), Math.abs(a[0]))),
                        t.setY(Math.max(Math.abs(s[1]), Math.abs(a[1]))),
                        t.setZ(Math.max(Math.abs(s[2]), Math.abs(a[2]))),
                        n.normalized) {
                        const e = Yd(Fd[n.componentType]);
                        t.multiplyScalar(e)
                      }
                      e.max(t)
                    } else
                      console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
                  }
                }
                r.expandByVector(e)
              }
              e.boundingBox = r;
              const a = new As;
              r.getCenter(a.center),
                a.radius = r.min.distanceTo(r.max) / 2,
                e.boundingSphere = a
            }(e, t, i),
            Promise.all(r).then((function() {
                return void 0 !== t.targets ? function(e, t, i) {
                  let n = !1
                    , r = !1
                    , s = !1;
                  for (let e = 0, i = t.length; e < i; e++) {
                    const i = t[e];
                    if (void 0 !== i.POSITION && (n = !0),
                    void 0 !== i.NORMAL && (r = !0),
                    void 0 !== i.COLOR_0 && (s = !0),
                    n && r && s)
                      break
                  }
                  if (!n && !r && !s)
                    return Promise.resolve(e);
                  const a = []
                    , o = []
                    , l = [];
                  for (let h = 0, c = t.length; h < c; h++) {
                    const c = t[h];
                    if (n) {
                      const t = void 0 !== c.POSITION ? i.getDependency("accessor", c.POSITION) : e.attributes.position;
                      a.push(t)
                    }
                    if (r) {
                      const t = void 0 !== c.NORMAL ? i.getDependency("accessor", c.NORMAL) : e.attributes.normal;
                      o.push(t)
                    }
                    if (s) {
                      const t = void 0 !== c.COLOR_0 ? i.getDependency("accessor", c.COLOR_0) : e.attributes.color;
                      l.push(t)
                    }
                  }
                  return Promise.all([Promise.all(a), Promise.all(o), Promise.all(l)]).then((function(t) {
                      const i = t[0]
                        , a = t[1]
                        , o = t[2];
                      return n && (e.morphAttributes.position = i),
                      r && (e.morphAttributes.normal = a),
                      s && (e.morphAttributes.color = o),
                        e.morphTargetsRelative = !0,
                        e
                    }
                  ))
                }(e, t.targets, i) : e
              }
            ))
        }
        function Jd(e, t) {
          let i = e.getIndex();
          if (null === i) {
            const t = []
              , n = e.getAttribute("position");
            if (void 0 === n)
              return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),
                e;
            for (let e = 0; e < n.count; e++)
              t.push(e);
            e.setIndex(t),
              i = e.getIndex()
          }
          const n = i.count - 2
            , r = [];
          if (2 === t)
            for (let e = 1; e <= n; e++)
              r.push(i.getX(0)),
                r.push(i.getX(e)),
                r.push(i.getX(e + 1));
          else
            for (let e = 0; e < n; e++)
              e % 2 == 0 ? (r.push(i.getX(e)),
                r.push(i.getX(e + 1)),
                r.push(i.getX(e + 2))) : (r.push(i.getX(e + 2)),
                r.push(i.getX(e + 1)),
                r.push(i.getX(e)));
          r.length / 3 !== n && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
          const s = e.clone();
          return s.setIndex(r),
            s
        }
        function Zd(e, t) {
          let i = "texel";
          if (null !== e) {
            const n = Number.parseInt(Rn);
            if (!(t && n >= 133 && 135 !== n && e.format === Kn && e.type === jn && e.encoding === cr))
              switch (e.encoding) {
                case cr:
                  i = "sRGBToLinear(texel)";
                  break;
                case hr:
                  i = "texel";
                  break;
                default:
                  throw new Error(`Unsupported encoding: ${e.encoding}`)
              }
          }
          return i
        }
        var $d = [new Float32Array([0, 0]), new Float32Array([0, 1, 1]), new Float32Array([0, 1, 1, 2]), new Float32Array([0, 1, 2, 2, 3]), new Float32Array([0, 1, 2, 3, 4, 4, 5]), new Float32Array([0, 1, 2, 3, 4, 5, 7, 8, 9, 10])]
          , ep = class extends to {
            constructor(e=new Jr) {
              super({
                name: "KawaseBlurMaterial",
                uniforms: {
                  inputBuffer: new td(null),
                  texelSize: new td(new Jr),
                  scale: new td(new Dr(1,1)),
                  kernel: new td(0)
                },
                blending: 0,
                depthWrite: !1,
                depthTest: !1,
                fragmentShader: "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nvarying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec4 sum=texture2D(inputBuffer,vUv0);sum+=texture2D(inputBuffer,vUv1);sum+=texture2D(inputBuffer,vUv2);sum+=texture2D(inputBuffer,vUv3);gl_FragColor=sum*0.25;\n#include <encodings_fragment>\n}",
                vertexShader: "uniform vec4 texelSize;uniform float kernel;uniform vec2 scale;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vec2 dUv=(texelSize.xy*vec2(kernel)+texelSize.zw)*scale.x*scale.y;vUv0=vec2(uv.x-dUv.x,uv.y+dUv.y);vUv1=vec2(uv.x+dUv.x,uv.y+dUv.y);vUv2=vec2(uv.x+dUv.x,uv.y-dUv.y);vUv3=vec2(uv.x-dUv.x,uv.y-dUv.y);gl_Position=vec4(position.xy,1.0,1.0);}"
              }),
                this.toneMapped = !1,
                this.setTexelSize(e.x, e.y),
                this.kernelSize = 2
            }
            set inputBuffer(e) {
              this.uniforms.inputBuffer.value = e
            }
            setInputBuffer(e) {
              this.inputBuffer = e
            }
            get kernelSequence() {
              return $d[this.kernelSize]
            }
            set resolutionScale(e) {
              this.uniforms.scale.value.x = e
            }
            get scale() {
              return this.uniforms.scale.value.y
            }
            set scale(e) {
              this.uniforms.scale.value.y = e
            }
            getScale() {
              return this.uniforms.scale.value
            }
            setScale(e) {
              this.uniforms.scale.value = e
            }
            getKernel() {
              return null
            }
            get kernel() {
              return this.uniforms.kernel.value
            }
            set kernel(e) {
              this.uniforms.kernel.value = e
            }
            setKernel(e) {
              this.kernel = e
            }
            setTexelSize(e, t) {
              this.uniforms.texelSize.value.set(e, t, .5 * e, .5 * t)
            }
            setSize(e, t) {
              const i = 1 / e
                , n = 1 / t;
              this.uniforms.texelSize.value.set(i, n, .5 * i, .5 * n)
            }
          }
          , tp = class extends to {
            constructor() {
              super({
                name: "CopyMaterial",
                uniforms: {
                  inputBuffer: new td(null),
                  opacity: new td(1)
                },
                blending: 0,
                depthWrite: !1,
                depthTest: !1,
                fragmentShader: "#include <common>\n#include <dithering_pars_fragment>\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nuniform float opacity;varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=opacity*texel;\n#include <encodings_fragment>\n#include <dithering_fragment>\n}",
                vertexShader: "varying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}"
              }),
                this.toneMapped = !1
            }
            set inputBuffer(e) {
              this.uniforms.inputBuffer.value = e
            }
            setInputBuffer(e) {
              this.uniforms.inputBuffer.value = e
            }
            getOpacity(e) {
              return this.uniforms.opacity.value
            }
            setOpacity(e) {
              this.uniforms.opacity.value = e
            }
          }
          , ip = class extends to {
            constructor(e=new Dr, t=2) {
              super({
                name: "EdgeDetectionMaterial",
                defines: {
                  LOCAL_CONTRAST_ADAPTATION_FACTOR: "2.0",
                  EDGE_THRESHOLD: "0.1",
                  DEPTH_THRESHOLD: "0.01",
                  PREDICATION_MODE: "0",
                  PREDICATION_THRESHOLD: "0.01",
                  PREDICATION_SCALE: "2.0",
                  PREDICATION_STRENGTH: "1.0",
                  DEPTH_PACKING: "0"
                },
                uniforms: {
                  inputBuffer: new td(null),
                  depthBuffer: new td(null),
                  predicationBuffer: new td(null),
                  texelSize: new td(e)
                },
                blending: 0,
                depthWrite: !1,
                depthTest: !1,
                fragmentShader: "varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;\n#if EDGE_DETECTION_MODE != 0\nvarying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;\n#endif\n#if EDGE_DETECTION_MODE == 1\n#include <common>\n#endif\n#if EDGE_DETECTION_MODE == 0 || PREDICATION_MODE == 1\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nfloat readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}vec3 gatherNeighbors(){float p=readDepth(vUv);float pLeft=readDepth(vUv0);float pTop=readDepth(vUv1);return vec3(p,pLeft,pTop);}\n#elif PREDICATION_MODE == 2\nuniform sampler2D predicationBuffer;vec3 gatherNeighbors(){float p=texture2D(predicationBuffer,vUv).r;float pLeft=texture2D(predicationBuffer,vUv0).r;float pTop=texture2D(predicationBuffer,vUv1).r;return vec3(p,pLeft,pTop);}\n#endif\n#if PREDICATION_MODE != 0\nvec2 calculatePredicatedThreshold(){vec3 neighbours=gatherNeighbors();vec2 delta=abs(neighbours.xx-neighbours.yz);vec2 edges=step(PREDICATION_THRESHOLD,delta);return PREDICATION_SCALE*EDGE_THRESHOLD*(1.0-PREDICATION_STRENGTH*edges);}\n#endif\n#if EDGE_DETECTION_MODE != 0\nuniform sampler2D inputBuffer;\n#endif\nvoid main(){\n#if EDGE_DETECTION_MODE == 0\nconst vec2 threshold=vec2(DEPTH_THRESHOLD);\n#elif PREDICATION_MODE != 0\nvec2 threshold=calculatePredicatedThreshold();\n#else\nconst vec2 threshold=vec2(EDGE_THRESHOLD);\n#endif\n#if EDGE_DETECTION_MODE == 0\nvec3 neighbors=gatherNeighbors();vec2 delta=abs(neighbors.xx-vec2(neighbors.y,neighbors.z));vec2 edges=step(threshold,delta);if(dot(edges,vec2(1.0))==0.0){discard;}gl_FragColor=vec4(edges,0.0,1.0);\n#elif EDGE_DETECTION_MODE == 1\nfloat l=linearToRelativeLuminance(texture2D(inputBuffer,vUv).rgb);float lLeft=linearToRelativeLuminance(texture2D(inputBuffer,vUv0).rgb);float lTop=linearToRelativeLuminance(texture2D(inputBuffer,vUv1).rgb);vec4 delta;delta.xy=abs(l-vec2(lLeft,lTop));vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}float lRight=linearToRelativeLuminance(texture2D(inputBuffer,vUv2).rgb);float lBottom=linearToRelativeLuminance(texture2D(inputBuffer,vUv3).rgb);delta.zw=abs(l-vec2(lRight,lBottom));vec2 maxDelta=max(delta.xy,delta.zw);float lLeftLeft=linearToRelativeLuminance(texture2D(inputBuffer,vUv4).rgb);float lTopTop=linearToRelativeLuminance(texture2D(inputBuffer,vUv5).rgb);delta.zw=abs(vec2(lLeft,lTop)-vec2(lLeftLeft,lTopTop));maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges.xy*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);\n#elif EDGE_DETECTION_MODE == 2\nvec4 delta;vec3 c=texture2D(inputBuffer,vUv).rgb;vec3 cLeft=texture2D(inputBuffer,vUv0).rgb;vec3 t=abs(c-cLeft);delta.x=max(max(t.r,t.g),t.b);vec3 cTop=texture2D(inputBuffer,vUv1).rgb;t=abs(c-cTop);delta.y=max(max(t.r,t.g),t.b);vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}vec3 cRight=texture2D(inputBuffer,vUv2).rgb;t=abs(c-cRight);delta.z=max(max(t.r,t.g),t.b);vec3 cBottom=texture2D(inputBuffer,vUv3).rgb;t=abs(c-cBottom);delta.w=max(max(t.r,t.g),t.b);vec2 maxDelta=max(delta.xy,delta.zw);vec3 cLeftLeft=texture2D(inputBuffer,vUv4).rgb;t=abs(c-cLeftLeft);delta.z=max(max(t.r,t.g),t.b);vec3 cTopTop=texture2D(inputBuffer,vUv5).rgb;t=abs(c-cTopTop);delta.w=max(max(t.r,t.g),t.b);maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);\n#endif\n}",
                vertexShader: "uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;\n#if EDGE_DETECTION_MODE != 0\nvarying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;\n#endif\nvoid main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,0.0);vUv1=vUv+texelSize*vec2(0.0,-1.0);\n#if EDGE_DETECTION_MODE != 0\nvUv2=vUv+texelSize*vec2(1.0,0.0);vUv3=vUv+texelSize*vec2(0.0,1.0);vUv4=vUv+texelSize*vec2(-2.0,0.0);vUv5=vUv+texelSize*vec2(0.0,-2.0);\n#endif\ngl_Position=vec4(position.xy,1.0,1.0);}"
              }),
                this.toneMapped = !1,
                this.edgeDetectionMode = t
            }
            set depthBuffer(e) {
              this.uniforms.depthBuffer.value = e
            }
            set depthPacking(e) {
              this.defines.DEPTH_PACKING = e.toFixed(0),
                this.needsUpdate = !0
            }
            setDepthBuffer(e, t=3200) {
              this.depthBuffer = e,
                this.depthPacking = t
            }
            get edgeDetectionMode() {
              return Number(this.defines.EDGE_DETECTION_MODE)
            }
            set edgeDetectionMode(e) {
              this.defines.EDGE_DETECTION_MODE = e.toFixed(0),
                this.needsUpdate = !0
            }
            getEdgeDetectionMode() {
              return this.edgeDetectionMode
            }
            setEdgeDetectionMode(e) {
              this.edgeDetectionMode = e
            }
            get localContrastAdaptationFactor() {
              return Number(this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR)
            }
            set localContrastAdaptationFactor(e) {
              this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR = e.toFixed("6"),
                this.needsUpdate = !0
            }
            getLocalContrastAdaptationFactor() {
              return this.localContrastAdaptationFactor
            }
            setLocalContrastAdaptationFactor(e) {
              this.localContrastAdaptationFactor = e
            }
            get edgeDetectionThreshold() {
              return Number(this.defines.EDGE_THRESHOLD)
            }
            set edgeDetectionThreshold(e) {
              this.defines.EDGE_THRESHOLD = e.toFixed("6"),
                this.defines.DEPTH_THRESHOLD = (.1 * e).toFixed("6"),
                this.needsUpdate = !0
            }
            getEdgeDetectionThreshold() {
              return this.edgeDetectionThreshold
            }
            setEdgeDetectionThreshold(e) {
              this.edgeDetectionThreshold = e
            }
            get predicationMode() {
              return Number(this.defines.PREDICATION_MODE)
            }
            set predicationMode(e) {
              this.defines.PREDICATION_MODE = e.toFixed(0),
                this.needsUpdate = !0
            }
            getPredicationMode() {
              return this.predicationMode
            }
            setPredicationMode(e) {
              this.predicationMode = e
            }
            set predicationBuffer(e) {
              this.uniforms.predicationBuffer.value = e
            }
            setPredicationBuffer(e) {
              this.uniforms.predicationBuffer.value = e
            }
            get predicationThreshold() {
              return Number(this.defines.PREDICATION_THRESHOLD)
            }
            set predicationThreshold(e) {
              this.defines.PREDICATION_THRESHOLD = e.toFixed("6"),
                this.needsUpdate = !0
            }
            getPredicationThreshold() {
              return this.predicationThreshold
            }
            setPredicationThreshold(e) {
              this.predicationThreshold = e
            }
            get predicationScale() {
              return Number(this.defines.PREDICATION_SCALE)
            }
            set predicationScale(e) {
              this.defines.PREDICATION_SCALE = e.toFixed("6"),
                this.needsUpdate = !0
            }
            getPredicationScale() {
              return this.predicationScale
            }
            setPredicationScale(e) {
              this.predicationScale = e
            }
            get predicationStrength() {
              return Number(this.defines.PREDICATION_STRENGTH)
            }
            set predicationStrength(e) {
              this.defines.PREDICATION_STRENGTH = e.toFixed("6"),
                this.needsUpdate = !0
            }
            getPredicationStrength() {
              return this.predicationStrength
            }
            setPredicationStrength(e) {
              this.predicationStrength = e
            }
            setSize(e, t) {
              this.uniforms.texelSize.value.set(1 / e, 1 / t)
            }
          }
          , np = {
            FRAGMENT_HEAD: "FRAGMENT_HEAD",
            FRAGMENT_MAIN_UV: "FRAGMENT_MAIN_UV",
            FRAGMENT_MAIN_IMAGE: "FRAGMENT_MAIN_IMAGE",
            VERTEX_HEAD: "VERTEX_HEAD",
            VERTEX_MAIN_SUPPORT: "VERTEX_MAIN_SUPPORT"
          }
          , rp = class extends to {
            constructor(e, t, i, n, r=!1) {
              super({
                name: "EffectMaterial",
                defines: {
                  THREE_REVISION: Rn.replace(/\D+/g, ""),
                  DEPTH_PACKING: "0",
                  ENCODE_OUTPUT: "1"
                },
                uniforms: {
                  inputBuffer: new td(null),
                  depthBuffer: new td(null),
                  resolution: new td(new Dr),
                  texelSize: new td(new Dr),
                  cameraNear: new td(.3),
                  cameraFar: new td(1e3),
                  aspect: new td(1),
                  time: new td(0)
                },
                blending: 0,
                depthWrite: !1,
                depthTest: !1,
                dithering: r
              }),
                this.toneMapped = !1,
              e && this.setShaderParts(e),
              t && this.setDefines(t),
              i && this.setUniforms(i),
                this.adoptCameraSettings(n)
            }
            set inputBuffer(e) {
              this.uniforms.inputBuffer.value = e
            }
            setInputBuffer(e) {
              this.uniforms.inputBuffer.value = e
            }
            get depthBuffer() {
              return this.uniforms.depthBuffer.value
            }
            set depthBuffer(e) {
              this.uniforms.depthBuffer.value = e
            }
            get depthPacking() {
              return Number(this.defines.DEPTH_PACKING)
            }
            set depthPacking(e) {
              this.defines.DEPTH_PACKING = e.toFixed(0),
                this.needsUpdate = !0
            }
            setDepthBuffer(e, t=3200) {
              this.depthBuffer = e,
                this.depthPacking = t
            }
            setShaderParts(e) {
              return this.fragmentShader = "#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#define packFloatToRGBA(v) packDepthToRGBA(v)\n#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nuniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;\n#if THREE_REVISION >= 137\nvec4 sRGBToLinear(const in vec4 value){return vec4(mix(pow(value.rgb*0.9478672986+vec3(0.0521327014),vec3(2.4)),value.rgb*0.0773993808,vec3(lessThanEqual(value.rgb,vec3(0.04045)))),value.a);}\n#endif\nfloat readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}float getViewZ(const in float depth){\n#ifdef PERSPECTIVE_CAMERA\nreturn perspectiveDepthToViewZ(depth,cameraNear,cameraFar);\n#else\nreturn orthographicDepthToViewZ(depth,cameraNear,cameraFar);\n#endif\n}FRAGMENT_HEADvoid main(){FRAGMENT_MAIN_UVvec4 color0=texture2D(inputBuffer,UV);vec4 color1=vec4(0.0);FRAGMENT_MAIN_IMAGEgl_FragColor=color0;\n#ifdef ENCODE_OUTPUT\n#include <encodings_fragment>\n#endif\n#include <dithering_fragment>\n}".replace(np.FRAGMENT_HEAD, e.get(np.FRAGMENT_HEAD)).replace(np.FRAGMENT_MAIN_UV, e.get(np.FRAGMENT_MAIN_UV)).replace(np.FRAGMENT_MAIN_IMAGE, e.get(np.FRAGMENT_MAIN_IMAGE)),
                this.vertexShader = "uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;VERTEX_HEADvoid main(){vUv=position.xy*0.5+0.5;VERTEX_MAIN_SUPPORTgl_Position=vec4(position.xy,1.0,1.0);}".replace(np.VERTEX_HEAD, e.get(np.VERTEX_HEAD)).replace(np.VERTEX_MAIN_SUPPORT, e.get(np.VERTEX_MAIN_SUPPORT)),
                this.needsUpdate = !0,
                this
            }
            setDefines(e) {
              for (const t of e.entries())
                this.defines[t[0]] = t[1];
              return this.needsUpdate = !0,
                this
            }
            setUniforms(e) {
              for (const t of e.entries())
                this.uniforms[t[0]] = t[1];
              return this
            }
            setExtensions(e) {
              this.extensions = {};
              for (const t of e)
                this.extensions[t] = !0;
              return this
            }
            get encodeOutput() {
              return void 0 !== this.defines.ENCODE_OUTPUT
            }
            set encodeOutput(e) {
              this.encodeOutput !== e && (e ? this.defines.ENCODE_OUTPUT = "1" : delete this.defines.ENCODE_OUTPUT,
                this.needsUpdate = !0)
            }
            isOutputEncodingEnabled(e) {
              return this.encodeOutput
            }
            setOutputEncodingEnabled(e) {
              this.encodeOutput = e
            }
            get time() {
              return this.uniforms.time.value
            }
            set time(e) {
              this.uniforms.time.value = e
            }
            setDeltaTime(e) {
              this.uniforms.time.value += e
            }
            adoptCameraSettings(e) {
              e && (this.uniforms.cameraNear.value = e.near,
                this.uniforms.cameraFar.value = e.far,
                e instanceof no ? this.defines.PERSPECTIVE_CAMERA = "1" : delete this.defines.PERSPECTIVE_CAMERA,
                this.needsUpdate = !0)
            }
            setSize(e, t) {
              const i = this.uniforms;
              i.resolution.value.set(e, t),
                i.texelSize.value.set(1 / e, 1 / t),
                i.aspect.value = e / t
            }
            static get Section() {
              return np
            }
          }
          , sp = class extends to {
            constructor(e=new Dr, t=new Dr) {
              super({
                name: "SMAAWeightsMaterial",
                defines: {
                  MAX_SEARCH_STEPS_INT: "16",
                  MAX_SEARCH_STEPS_FLOAT: "16.0",
                  MAX_SEARCH_STEPS_DIAG_INT: "8",
                  MAX_SEARCH_STEPS_DIAG_FLOAT: "8.0",
                  CORNER_ROUNDING: "25",
                  CORNER_ROUNDING_NORM: "0.25",
                  AREATEX_MAX_DISTANCE: "16.0",
                  AREATEX_MAX_DISTANCE_DIAG: "20.0",
                  AREATEX_PIXEL_SIZE: "(1.0 / vec2(160.0, 560.0))",
                  AREATEX_SUBTEX_SIZE: "(1.0 / 7.0)",
                  SEARCHTEX_SIZE: "vec2(66.0, 33.0)",
                  SEARCHTEX_PACKED_SIZE: "vec2(64.0, 16.0)"
                },
                uniforms: {
                  inputBuffer: new td(null),
                  searchTexture: new td(null),
                  areaTexture: new td(null),
                  resolution: new td(t),
                  texelSize: new td(e)
                },
                blending: 0,
                depthWrite: !1,
                depthTest: !1,
                fragmentShader: "#define sampleLevelZeroOffset(t, coord, offset) texture2D(t, coord + offset * texelSize)\n#if __VERSION__ < 300\n#define round(v) floor(v + 0.5)\n#endif\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nuniform lowp sampler2D areaTexture;uniform lowp sampler2D searchTexture;uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}vec2 decodeDiagBilinearAccess(in vec2 e){e.r=e.r*abs(5.0*e.r-5.0*0.75);return round(e);}vec4 decodeDiagBilinearAccess(in vec4 e){e.rb=e.rb*abs(5.0*e.rb-5.0*0.75);return round(e);}vec2 searchDiag1(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 searchDiag2(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);coord.x+=0.25*texelSize.x;vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;e=decodeDiagBilinearAccess(e);coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 areaDiag(const in vec2 dist,const in vec2 e,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE_DIAG,AREATEX_MAX_DISTANCE_DIAG)*e+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.x+=0.5;texCoord.y+=AREATEX_SUBTEX_SIZE*offset;return texture2D(areaTexture,texCoord).rg;}vec2 calculateDiagWeights(const in vec2 texCoord,const in vec2 e,const in vec4 subsampleIndices){vec2 weights=vec2(0.0);vec4 d;vec2 end;if(e.r>0.0){d.xz=searchDiag1(texCoord,vec2(-1.0,1.0),end);d.x+=float(end.y>0.9);}else{d.xz=vec2(0.0);}d.yw=searchDiag1(texCoord,vec2(1.0,-1.0),end);if(d.x+d.y>2.0){vec4 coords=vec4(-d.x+0.25,d.x,d.y,-d.y-0.25)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.xy=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).rg;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).rg;c.yxwz=decodeDiagBilinearAccess(c.xyzw);vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.z);}d.xz=searchDiag2(texCoord,vec2(-1.0,-1.0),end);if(sampleLevelZeroOffset(inputBuffer,texCoord,vec2(1,0)).r>0.0){d.yw=searchDiag2(texCoord,vec2(1.0),end);d.y+=float(end.y>0.9);}else{d.yw=vec2(0.0);}if(d.x+d.y>2.0){vec4 coords=vec4(-d.x,-d.x,d.y,d.y)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.x=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).g;c.y=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(0,-1)).r;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).gr;vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.w).gr;}return weights;}float searchLength(const in vec2 e,const in float offset){vec2 scale=SEARCHTEX_SIZE*vec2(0.5,-1.0);vec2 bias=SEARCHTEX_SIZE*vec2(offset,1.0);scale+=vec2(-1.0,1.0);bias+=vec2(0.5,-0.5);scale*=1.0/SEARCHTEX_PACKED_SIZE;bias*=1.0/SEARCHTEX_PACKED_SIZE;return texture2D(searchTexture,scale*e+bias).r;}float searchXLeft(in vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x>end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(-2.0,0.0)*texelSize+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.0)+3.25;return texelSize.x*offset+texCoord.x;}float searchXRight(vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x<end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(2.0,0.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.5)+3.25;return-texelSize.x*offset+texCoord.x;}float searchYUp(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.y>end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=-vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.0)+3.25;return texelSize.y*offset+texCoord.y;}float searchYDown(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;i++){if(!(texCoord.y<end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.5)+3.25;return-texelSize.y*offset+texCoord.y;}vec2 area(const in vec2 dist,const in float e1,const in float e2,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE)*round(4.0*vec2(e1,e2))+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.y=AREATEX_SUBTEX_SIZE*offset+texCoord.y;return texture2D(areaTexture,texCoord).rg;}void detectHorizontalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){\n#if !defined(DISABLE_CORNER_DETECTION)\nvec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,1)).r;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).r;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,-2)).r;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,-2)).r;weights*=clamp(factor,0.0,1.0);\n#endif\n}void detectVerticalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){\n#if !defined(DISABLE_CORNER_DETECTION)\nvec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(1,0)).g;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).g;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(-2,0)).g;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(-2,1)).g;weights*=clamp(factor,0.0,1.0);\n#endif\n}void main(){vec4 weights=vec4(0.0);vec4 subsampleIndices=vec4(0.0);vec2 e=texture2D(inputBuffer,vUv).rg;if(e.g>0.0){\n#if !defined(DISABLE_DIAG_DETECTION)\nweights.rg=calculateDiagWeights(vUv,e,subsampleIndices);if(weights.r==-weights.g){\n#endif\nvec2 d;vec3 coords;coords.x=searchXLeft(vOffset[0].xy,vOffset[2].x);coords.y=vOffset[1].y;d.x=coords.x;float e1=texture2D(inputBuffer,coords.xy).r;coords.z=searchXRight(vOffset[0].zw,vOffset[2].y);d.y=coords.z;d=round(resolution.xx*d+-vPixCoord.xx);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.zy,vec2(1,0)).r;weights.rg=area(sqrtD,e1,e2,subsampleIndices.y);coords.y=vUv.y;detectHorizontalCornerPattern(weights.rg,coords.xyzy,d);\n#if !defined(DISABLE_DIAG_DETECTION)\n}else{e.r=0.0;}\n#endif\n}if(e.r>0.0){vec2 d;vec3 coords;coords.y=searchYUp(vOffset[1].xy,vOffset[2].z);coords.x=vOffset[0].x;d.x=coords.y;float e1=texture2D(inputBuffer,coords.xy).g;coords.z=searchYDown(vOffset[1].zw,vOffset[2].w);d.y=coords.z;d=round(resolution.yy*d-vPixCoord.yy);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.xz,vec2(0,1)).g;weights.ba=area(sqrtD,e1,e2,subsampleIndices.x);coords.x=vUv.x;detectVerticalCornerPattern(weights.ba,coords.xyxz,d);}gl_FragColor=weights;}",
                vertexShader: "uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void main(){vUv=position.xy*0.5+0.5;vPixCoord=vUv*resolution;vOffset[0]=vUv.xyxy+texelSize.xyxy*vec4(-0.25,-0.125,1.25,-0.125);vOffset[1]=vUv.xyxy+texelSize.xyxy*vec4(-0.125,-0.25,-0.125,1.25);vOffset[2]=vec4(vOffset[0].xz,vOffset[1].yw)+vec4(-2.0,2.0,-2.0,2.0)*texelSize.xxyy*MAX_SEARCH_STEPS_FLOAT;gl_Position=vec4(position.xy,1.0,1.0);}"
              }),
                this.toneMapped = !1
            }
            set inputBuffer(e) {
              this.uniforms.inputBuffer.value = e
            }
            setInputBuffer(e) {
              this.uniforms.inputBuffer.value = e
            }
            get searchTexture() {
              return this.uniforms.searchTexture.value
            }
            set searchTexture(e) {
              this.uniforms.searchTexture.value = e
            }
            get areaTexture() {
              return this.uniforms.areaTexture.value
            }
            set areaTexture(e) {
              this.uniforms.areaTexture.value = e
            }
            setLookupTextures(e, t) {
              this.searchTexture = e,
                this.areaTexture = t
            }
            get orthogonalSearchSteps() {
              return Number(this.defines.MAX_SEARCH_STEPS_INT)
            }
            set orthogonalSearchSteps(e) {
              const t = Math.min(Math.max(e, 0), 112);
              this.defines.MAX_SEARCH_STEPS_INT = t.toFixed("0"),
                this.defines.MAX_SEARCH_STEPS_FLOAT = t.toFixed("1"),
                this.needsUpdate = !0
            }
            setOrthogonalSearchSteps(e) {
              this.orthogonalSearchSteps = e
            }
            get diagonalSearchSteps() {
              return Number(this.defines.MAX_SEARCH_STEPS_DIAG_INT)
            }
            set diagonalSearchSteps(e) {
              const t = Math.min(Math.max(e, 0), 20);
              this.defines.MAX_SEARCH_STEPS_DIAG_INT = t.toFixed("0"),
                this.defines.MAX_SEARCH_STEPS_DIAG_FLOAT = t.toFixed("1"),
                this.needsUpdate = !0
            }
            setDiagonalSearchSteps(e) {
              this.diagonalSearchSteps = e
            }
            get diagonalDetection() {
              return void 0 === this.defines.DISABLE_DIAG_DETECTION
            }
            set diagonalDetection(e) {
              e ? delete this.defines.DISABLE_DIAG_DETECTION : this.defines.DISABLE_DIAG_DETECTION = "1",
                this.needsUpdate = !0
            }
            isDiagonalDetectionEnabled() {
              return this.diagonalDetection
            }
            setDiagonalDetectionEnabled(e) {
              this.diagonalDetection = e
            }
            get cornerRounding() {
              return Number(this.defines.CORNER_ROUNDING)
            }
            set cornerRounding(e) {
              const t = Math.min(Math.max(e, 0), 100);
              this.defines.CORNER_ROUNDING = t.toFixed("4"),
                this.defines.CORNER_ROUNDING_NORM = (t / 100).toFixed("4"),
                this.needsUpdate = !0
            }
            setCornerRounding(e) {
              this.cornerRounding = e
            }
            get cornerDetection() {
              return void 0 === this.defines.DISABLE_CORNER_DETECTION
            }
            set cornerDetection(e) {
              e ? delete this.defines.DISABLE_CORNER_DETECTION : this.defines.DISABLE_CORNER_DETECTION = "1",
                this.needsUpdate = !0
            }
            isCornerRoundingEnabled() {
              return this.cornerDetection
            }
            setCornerRoundingEnabled(e) {
              this.cornerDetection = e
            }
            setSize(e, t) {
              const i = this.uniforms;
              i.texelSize.value.set(1 / e, 1 / t),
                i.resolution.value.set(e, t)
            }
          }
          , ap = new io
          , op = null
          , lp = class {
            constructor(e="Pass", t=new qh, i=ap) {
              this.name = e,
                this.renderer = null,
                this.scene = t,
                this.camera = i,
                this.screen = null,
                this.rtt = !0,
                this.needsSwap = !0,
                this.needsDepthTexture = !1,
                this.enabled = !0
            }
            get renderToScreen() {
              return !this.rtt
            }
            set renderToScreen(e) {
              if (this.rtt === e) {
                const t = this.getFullscreenMaterial();
                null !== t && (t.needsUpdate = !0),
                  this.rtt = !e
              }
            }
            setRenderer(e) {
              this.renderer = e
            }
            isEnabled() {
              return this.enabled
            }
            setEnabled(e) {
              this.enabled = e
            }
            get fullscreenMaterial() {
              return null !== this.screen ? this.screen.material : null
            }
            set fullscreenMaterial(e) {
              let t = this.screen;
              null !== t ? t.material = e : (t = new Qa(function() {
                if (null === op) {
                  const e = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0])
                    , t = new Float32Array([0, 0, 2, 0, 0, 2]);
                  void 0 !== (op = new Ia).setAttribute ? (op.setAttribute("position", new _a(e,3)),
                    op.setAttribute("uv", new _a(t,2))) : (op.addAttribute("position", new _a(e,3)),
                    op.addAttribute("uv", new _a(t,2)))
                }
                return op
              }(),e),
                t.frustumCulled = !1,
              null === this.scene && (this.scene = new qh),
                this.scene.add(t),
                this.screen = t)
            }
            getFullscreenMaterial() {
              return this.fullscreenMaterial
            }
            setFullscreenMaterial(e) {
              this.fullscreenMaterial = e
            }
            getDepthTexture() {
              return null
            }
            setDepthTexture(e, t=3200) {}
            render(e, t, i, n, r) {
              throw new Error("Render method not implemented!")
            }
            setSize(e, t) {}
            initialize(e, t, i) {}
            dispose() {
              for (const e of Object.keys(this)) {
                const t = this[e];
                if (null !== t && "function" == typeof t.dispose) {
                  if (t instanceof qh || t === this.renderer)
                    continue;
                  this[e].dispose()
                }
              }
            }
          }
          , hp = class extends lp {
            constructor(e, t=!0) {
              super("CopyPass"),
                this.fullscreenMaterial = new tp,
                this.needsSwap = !1,
                this.renderTarget = e,
              void 0 === e && (this.renderTarget = new Zr(1,1,{
                minFilter: Hn,
                magFilter: Hn,
                stencilBuffer: !1,
                depthBuffer: !1
              }),
                this.renderTarget.texture.name = "CopyPass.Target"),
                this.autoResize = t
            }
            get resize() {
              return this.autoResize
            }
            set resize(e) {
              this.autoResize = e
            }
            get texture() {
              return this.renderTarget.texture
            }
            getTexture() {
              return this.renderTarget.texture
            }
            setAutoResizeEnabled(e) {
              this.autoResize = e
            }
            render(e, t, i, n, r) {
              this.fullscreenMaterial.inputBuffer = t.texture,
                e.setRenderTarget(this.renderToScreen ? null : this.renderTarget),
                e.render(this.scene, this.camera)
            }
            setSize(e, t) {
              this.autoResize && this.renderTarget.setSize(e, t)
            }
            initialize(e, t, i) {
              void 0 !== i && (this.renderTarget.texture.type = i,
                i !== jn ? this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1" : e.outputEncoding === cr && (this.renderTarget.texture.encoding = cr))
            }
          }
          , cp = class extends lp {
            constructor() {
              super("ClearMaskPass", null, null),
                this.needsSwap = !1
            }
            render(e, t, i, n, r) {
              const s = e.state.buffers.stencil;
              s.setLocked(!1),
                s.setTest(!1)
            }
          }
          , up = new Wr
          , dp = class extends lp {
            constructor(e=!0, t=!0, i=!1) {
              super("ClearPass", null, null),
                this.needsSwap = !1,
                this.color = e,
                this.depth = t,
                this.stencil = i,
                this.overrideClearColor = null,
                this.overrideClearAlpha = -1
            }
            setClearFlags(e, t, i) {
              this.color = e,
                this.depth = t,
                this.stencil = i
            }
            getOverrideClearColor() {
              return this.overrideClearColor
            }
            setOverrideClearColor(e) {
              this.overrideClearColor = e
            }
            getOverrideClearAlpha() {
              return this.overrideClearAlpha
            }
            setOverrideClearAlpha(e) {
              this.overrideClearAlpha = e
            }
            render(e, t, i, n, r) {
              const s = this.overrideClearColor
                , a = this.overrideClearAlpha
                , o = e.getClearAlpha()
                , l = null !== s
                , h = a >= 0;
              l ? (up.copy(e.getClearColor(up)),
                e.setClearColor(s, h ? a : o)) : h && e.setClearAlpha(a),
                e.setRenderTarget(this.renderToScreen ? null : t),
                e.clear(this.color, this.depth, this.stencil),
                l ? e.setClearColor(up, o) : h && e.setClearAlpha(o)
            }
          }
          , pp = -1
          , fp = class extends vr {
            constructor(e, t=-1, i=-1, n=1) {
              super(),
                this.resizable = e,
                this.base = new Dr(1,1),
                this.preferred = new Dr(t,i),
                this.target = this.preferred,
                this.s = n
            }
            get width() {
              const {base: e, preferred: t, scale: i} = this;
              let n;
              return n = t.width !== pp ? t.width : t.height !== pp ? Math.round(t.height * (e.width / Math.max(e.height, 1))) : Math.round(e.width * i),
                n
            }
            set width(e) {
              this.preferredWidth = e
            }
            get height() {
              const {base: e, preferred: t, scale: i} = this;
              let n;
              return n = t.height !== pp ? t.height : t.width !== pp ? Math.round(t.width / Math.max(e.width / Math.max(e.height, 1), 1)) : Math.round(e.height * i),
                n
            }
            set height(e) {
              this.preferredHeight = e
            }
            getWidth() {
              return this.width
            }
            getHeight() {
              return this.height
            }
            get scale() {
              return this.s
            }
            set scale(e) {
              this.s !== e && (this.s = e,
                this.preferred.setScalar(pp),
                this.dispatchEvent({
                  type: "change"
                }),
                this.resizable.setSize(this.base.width, this.base.height))
            }
            getScale() {
              return this.scale
            }
            setScale(e) {
              this.scale = e
            }
            get baseWidth() {
              return this.base.width
            }
            set baseWidth(e) {
              this.base.width !== e && (this.base.width = e,
                this.dispatchEvent({
                  type: "change"
                }),
                this.resizable.setSize(this.base.width, this.base.height))
            }
            getBaseWidth() {
              return this.base.width
            }
            setBaseWidth(e) {
              this.base.width !== e && (this.base.width = e,
                this.dispatchEvent({
                  type: "change"
                }),
                this.resizable.setSize(this.base.width, this.base.height))
            }
            get baseHeight() {
              return this.base.height
            }
            set baseHeight(e) {
              this.base.height !== e && (this.base.height = e,
                this.dispatchEvent({
                  type: "change"
                }),
                this.resizable.setSize(this.base.width, this.base.height))
            }
            getBaseHeight() {
              return this.baseHeight
            }
            setBaseHeight(e) {
              this.baseHeight = e
            }
            setBaseSize(e, t) {
              this.base.width === e && this.base.height === t || (this.base.set(e, t),
                this.dispatchEvent({
                  type: "change"
                }),
                this.resizable.setSize(this.base.width, this.base.height))
            }
            get preferredWidth() {
              return this.preferred.width
            }
            set preferredWidth(e) {
              this.preferred.width !== e && (this.preferred.width = e,
                this.dispatchEvent({
                  type: "change"
                }),
                this.resizable.setSize(this.base.width, this.base.height))
            }
            getPreferredWidth() {
              return this.preferredWidth
            }
            setPreferredWidth(e) {
              this.preferredWidth = e
            }
            get preferredHeight() {
              return this.preferred.height
            }
            set preferredHeight(e) {
              this.preferred.height !== e && (this.preferred.height = e,
                this.dispatchEvent({
                  type: "change"
                }),
                this.resizable.setSize(this.base.width, this.base.height))
            }
            getPreferredHeight() {
              return this.preferredHeight
            }
            setPreferredHeight(e) {
              this.preferredHeight = e
            }
            setPreferredSize(e, t) {
              this.preferred.width === e && this.preferred.height === t || (this.preferred.set(e, t),
                this.dispatchEvent({
                  type: "change"
                }),
                this.resizable.setSize(this.base.width, this.base.height))
            }
            copy(e) {
              this.base.set(e.getBaseWidth(), e.getBaseHeight()),
                this.preferred.set(e.getPreferredWidth(), e.getPreferredHeight()),
                this.dispatchEvent({
                  type: "change"
                }),
                this.resizable.setSize(this.base.width, this.base.height)
            }
            static get AUTO_SIZE() {
              return pp
            }
          }
          , mp = !1
          , gp = class {
            constructor(e=null) {
              this.originalMaterials = new Map,
                this.material = null,
                this.materials = null,
                this.materialsBackSide = null,
                this.materialsDoubleSide = null,
                this.materialsFlatShaded = null,
                this.materialsFlatShadedBackSide = null,
                this.materialsFlatShadedDoubleSide = null,
                this.setMaterial(e),
                this.meshCount = 0,
                this.replaceMaterial = e=>{
                  if (e.isMesh) {
                    let t;
                    if (e.material.flatShading)
                      switch (e.material.side) {
                        case 2:
                          t = this.materialsFlatShadedDoubleSide;
                          break;
                        case 1:
                          t = this.materialsFlatShadedBackSide;
                          break;
                        default:
                          t = this.materialsFlatShaded
                      }
                    else
                      switch (e.material.side) {
                        case 2:
                          t = this.materialsDoubleSide;
                          break;
                        case 1:
                          t = this.materialsBackSide;
                          break;
                        default:
                          t = this.materials
                      }
                    this.originalMaterials.set(e, e.material),
                      e.isSkinnedMesh ? e.material = t[2] : e.isInstancedMesh ? e.material = t[1] : e.material = t[0],
                      ++this.meshCount
                  }
                }
            }
            setMaterial(e) {
              if (this.disposeMaterials(),
                this.material = e,
              null !== e) {
                const t = this.materials = [e.clone(), e.clone(), e.clone()];
                for (const i of t)
                  i.uniforms = Object.assign({}, e.uniforms),
                    i.side = 0;
                t[2].skinning = !0,
                  this.materialsBackSide = t.map((t=>{
                      const i = t.clone();
                      return i.uniforms = Object.assign({}, e.uniforms),
                        i.side = 1,
                        i
                    }
                  )),
                  this.materialsDoubleSide = t.map((t=>{
                      const i = t.clone();
                      return i.uniforms = Object.assign({}, e.uniforms),
                        i.side = 2,
                        i
                    }
                  )),
                  this.materialsFlatShaded = t.map((t=>{
                      const i = t.clone();
                      return i.uniforms = Object.assign({}, e.uniforms),
                        i.flatShading = !0,
                        i
                    }
                  )),
                  this.materialsFlatShadedBackSide = t.map((t=>{
                      const i = t.clone();
                      return i.uniforms = Object.assign({}, e.uniforms),
                        i.flatShading = !0,
                        i.side = 1,
                        i
                    }
                  )),
                  this.materialsFlatShadedDoubleSide = t.map((t=>{
                      const i = t.clone();
                      return i.uniforms = Object.assign({}, e.uniforms),
                        i.flatShading = !0,
                        i.side = 2,
                        i
                    }
                  ))
              }
            }
            render(e, t, i) {
              const n = e.shadowMap.enabled;
              if (e.shadowMap.enabled = !1,
                mp) {
                const n = this.originalMaterials;
                this.meshCount = 0,
                  t.traverse(this.replaceMaterial),
                  e.render(t, i);
                for (const e of n)
                  e[0].material = e[1];
                this.meshCount !== n.size && n.clear()
              } else {
                const n = t.overrideMaterial;
                t.overrideMaterial = this.material,
                  e.render(t, i),
                  t.overrideMaterial = n
              }
              e.shadowMap.enabled = n
            }
            disposeMaterials() {
              if (null !== this.material) {
                const e = this.materials.concat(this.materialsBackSide).concat(this.materialsDoubleSide).concat(this.materialsFlatShaded).concat(this.materialsFlatShadedBackSide).concat(this.materialsFlatShadedDoubleSide);
                for (const t of e)
                  t.dispose()
              }
            }
            dispose() {
              this.originalMaterials.clear(),
                this.disposeMaterials()
            }
            static get workaroundEnabled() {
              return mp
            }
            static set workaroundEnabled(e) {
              mp = e
            }
          }
          , vp = class extends lp {
            constructor(e, t, i=null) {
              super("RenderPass", e, t),
                this.needsSwap = !1,
                this.clearPass = new dp,
                this.overrideMaterialManager = null === i ? null : new gp(i),
                this.ignoreBackground = !1,
                this.skipShadowMapUpdate = !1,
                this.selection = null
            }
            get renderToScreen() {
              return super.renderToScreen
            }
            set renderToScreen(e) {
              super.renderToScreen = e,
                this.clearPass.renderToScreen = e
            }
            get overrideMaterial() {
              const e = this.overrideMaterialManager;
              return null !== e ? e.material : null
            }
            set overrideMaterial(e) {
              const t = this.overrideMaterialManager;
              null !== e ? null !== t ? t.setMaterial(e) : this.overrideMaterialManager = new gp(e) : null !== t && (t.dispose(),
                this.overrideMaterialManager = null)
            }
            getOverrideMaterial() {
              return this.overrideMaterial
            }
            setOverrideMaterial(e) {
              this.overrideMaterial = e
            }
            get clear() {
              return this.clearPass.enabled
            }
            set clear(e) {
              this.clearPass.enabled = e
            }
            getSelection() {
              return this.selection
            }
            setSelection(e) {
              this.selection = e
            }
            isBackgroundDisabled() {
              return this.ignoreBackground
            }
            setBackgroundDisabled(e) {
              this.ignoreBackground = e
            }
            isShadowMapDisabled() {
              return this.skipShadowMapUpdate
            }
            setShadowMapDisabled(e) {
              this.skipShadowMapUpdate = e
            }
            getClearPass() {
              return this.clearPass
            }
            render(e, t, i, n, r) {
              const s = this.scene
                , a = this.camera
                , o = this.selection
                , l = a.layers.mask
                , h = s.background
                , c = e.shadowMap.autoUpdate
                , u = this.renderToScreen ? null : t;
              null !== o && a.layers.set(o.getLayer()),
              this.skipShadowMapUpdate && (e.shadowMap.autoUpdate = !1),
              (this.ignoreBackground || null !== this.clearPass.overrideClearColor) && (s.background = null),
              this.clearPass.enabled && this.clearPass.render(e, t),
                e.setRenderTarget(u),
                null !== this.overrideMaterialManager ? this.overrideMaterialManager.render(e, s, a) : e.render(s, a),
                a.layers.mask = l,
                s.background = h,
                e.shadowMap.autoUpdate = c
            }
          }
        ;
        function yp(e, t, i) {
          for (const n of t) {
            const t = "$1" + e + n.charAt(0).toUpperCase() + n.slice(1)
              , r = new RegExp("([^\\.])(\\b" + n + "\\b)","g");
            for (const e of i.entries())
              null !== e[1] && i.set(e[0], e[1].replace(r, t))
          }
        }
        function xp(e, t, i, n, r, s, a) {
          const o = new Map([["fragment", t.getFragmentShader()], ["vertex", t.getVertexShader()]])
            , l = void 0 !== o.get("fragment") && /mainImage/.test(o.get("fragment"))
            , h = void 0 !== o.get("fragment") && /mainUv/.test(o.get("fragment"));
          let c = []
            , u = []
            , d = !1
            , p = !1;
          if (void 0 === o.get("fragment"))
            console.error("Missing fragment shader", t);
          else if (h && 0 != (2 & a))
            console.error("Effects that transform UV coordinates are incompatible with convolution effects", t);
          else if (l || h) {
            const f = /(?:\w+\s+(\w+)\([\w\s,]*\)\s*{[^}]+})/g
              , m = rp.Section;
            if (h) {
              const t = `\t${e}MainUv(UV);\n`;
              i.set(m.FRAGMENT_MAIN_UV, i.get(m.FRAGMENT_MAIN_UV) + t),
                d = !0
            }
            if (null !== o.get("vertex") && /mainSupport/.test(o.get("vertex"))) {
              let t = `\t${e}MainSupport(`;
              t += /mainSupport *\([\w\s]*?uv\s*?\)/.test(o.get("vertex")) ? "vUv);\n" : ");\n",
                i.set(m.VERTEX_MAIN_SUPPORT, i.get(m.VERTEX_MAIN_SUPPORT) + t),
                c = c.concat([...o.get("vertex").matchAll(/(?:varying\s+\w+\s+(\w*))/g)].map((e=>e[1]))),
                u = u.concat(c).concat([...o.get("vertex").matchAll(f)].map((e=>e[1])))
            }
            u = u.concat([...o.get("fragment").matchAll(f)].map((e=>e[1]))),
              u = u.concat([...t.defines.keys()].map((e=>e.replace(/\([\w\s,]*\)/g, "")))),
              u = u.concat([...t.uniforms.keys()]),
              t.uniforms.forEach(((t,i)=>s.set(e + i.charAt(0).toUpperCase() + i.slice(1), t))),
              t.defines.forEach(((t,i)=>r.set(e + i.charAt(0).toUpperCase() + i.slice(1), t))),
              yp(e, u, r),
              yp(e, u, o);
            const g = t.blendMode;
            if (n.set(g.blendFunction, g),
              l) {
              const t = /MainImage *\([\w\s,]*?depth[\w\s,]*?\)/;
              let n = `${e}MainImage(color0, UV, `;
              0 != (1 & a) && t.test(o.get("fragment")) && (n += "depth, ",
                p = !0),
                n += "color1);\n\t";
              const r = e + "BlendOpacity";
              s.set(r, g.opacity),
                n += `color0 = blend${g.blendFunction}(color0, color1, ${r});\n\n\t`,
                i.set(m.FRAGMENT_MAIN_IMAGE, i.get(m.FRAGMENT_MAIN_IMAGE) + n),
                n = `uniform float ${r};\n\n`,
                i.set(m.FRAGMENT_HEAD, i.get(m.FRAGMENT_HEAD) + n)
            }
            i.set(m.FRAGMENT_HEAD, i.get(m.FRAGMENT_HEAD) + o.get("fragment") + "\n"),
            null !== o.get("vertex") && i.set(m.VERTEX_HEAD, i.get(m.VERTEX_HEAD) + o.get("vertex") + "\n")
          } else
            console.error("The fragment shader contains neither a mainImage nor a mainUv function", t);
          return {
            varyings: c,
            transformedUv: d,
            readDepth: p
          }
        }
        new Float32Array([255 / 256 / 256 ** 3, 255 / 256 / 65536, 255 / 256 / 256, 255 / 256]);
        var _p = class extends lp {
          constructor(e, ...t) {
            super("EffectPass"),
              this.fullscreenMaterial = new rp(null,null,null,e),
              this.listener = e=>this.handleEvent(e),
              this.effects = [],
              this.setEffects(t),
              this.skipRendering = !1,
              this.uniformCount = 0,
              this.varyingCount = 0,
              this.minTime = 1,
              this.maxTime = Number.POSITIVE_INFINITY
          }
          get encodeOutput() {
            return this.fullscreenMaterial.encodeOutput
          }
          set encodeOutput(e) {
            this.fullscreenMaterial.encodeOutput = e
          }
          get dithering() {
            return this.fullscreenMaterial.dithering
          }
          set dithering(e) {
            const t = this.fullscreenMaterial;
            t.dithering = e,
              t.needsUpdate = !0
          }
          setEffects(e) {
            for (const e of this.effects)
              e.removeEventListener("change", this.listener);
            this.effects = e.sort(((e,t)=>t.attributes - e.attributes));
            for (const e of this.effects)
              e.addEventListener("change", this.listener)
          }
          verifyResources() {
            if (null !== this.renderer) {
              const e = this.renderer.capabilities;
              let t = Math.min(e.maxFragmentUniforms, e.maxVertexUniforms);
              this.uniformCount > t && console.warn("The current rendering context doesn't support more than " + t + " uniforms, but " + this.uniformCount + " were defined"),
                t = e.maxVaryings,
              this.varyingCount > t && console.warn("The current rendering context doesn't support more than " + t + " varyings, but " + this.varyingCount + " were defined")
            }
          }
          updateMaterial() {
            const e = rp.Section
              , t = new Map([[e.FRAGMENT_HEAD, ""], [e.FRAGMENT_MAIN_UV, ""], [e.FRAGMENT_MAIN_IMAGE, ""], [e.VERTEX_HEAD, ""], [e.VERTEX_MAIN_SUPPORT, ""]])
              , i = new Map
              , n = new Map
              , r = new Map
              , s = new Set;
            let a = 0
              , o = 0
              , l = 0
              , h = !1
              , c = !1;
            for (const e of this.effects)
              if (0 === e.blendMode.blendFunction)
                l |= 1 & e.getAttributes();
              else if (0 != (l & e.getAttributes() & 2))
                console.error("Convolution effects cannot be merged", e);
              else {
                l |= e.getAttributes();
                const u = xp("e" + a++, e, t, i, n, r, l);
                if (o += u.varyings.length,
                  h = h || u.transformedUv,
                  c = c || u.readDepth,
                null !== e.extensions)
                  for (const t of e.extensions)
                    s.add(t)
              }
            const u = /\bblend\b/g;
            for (const n of i.values()) {
              const i = n.getShaderCode().replace(u, `blend${n.blendFunction}`);
              t.set(e.FRAGMENT_HEAD, t.get(e.FRAGMENT_HEAD) + i + "\n")
            }
            if (0 != (1 & l)) {
              if (c) {
                const i = "float depth = readDepth(UV);\n\n\t";
                t.set(e.FRAGMENT_MAIN_IMAGE, i + t.get(e.FRAGMENT_MAIN_IMAGE))
              }
              this.needsDepthTexture = null === this.getDepthTexture()
            } else
              this.needsDepthTexture = !1;
            if (h) {
              const i = "vec2 transformedUv = vUv;\n";
              t.set(e.FRAGMENT_MAIN_UV, i + t.get(e.FRAGMENT_MAIN_UV)),
                n.set("UV", "transformedUv")
            } else
              n.set("UV", "vUv");
            t.forEach(((e,t,i)=>i.set(t, e.trim().replace(/^#/, "\n#")))),
              this.uniformCount = r.size,
              this.varyingCount = o,
              this.skipRendering = 0 === a,
              this.needsSwap = !this.skipRendering,
              this.fullscreenMaterial.setShaderParts(t).setExtensions(s).setUniforms(r).setDefines(n)
          }
          recompile() {
            this.updateMaterial(),
              this.verifyResources()
          }
          getDepthTexture() {
            return this.fullscreenMaterial.depthBuffer
          }
          setDepthTexture(e, t=3200) {
            this.fullscreenMaterial.depthBuffer = e,
              this.fullscreenMaterial.depthPacking = t;
            for (const i of this.effects)
              i.setDepthTexture(e, t)
          }
          render(e, t, i, n, r) {
            for (const i of this.effects)
              i.update(e, t, n);
            if (!this.skipRendering || this.renderToScreen) {
              const r = this.fullscreenMaterial;
              r.inputBuffer = t.texture,
                r.time += n,
                e.setRenderTarget(this.renderToScreen ? null : i),
                e.render(this.scene, this.camera)
            }
          }
          setSize(e, t) {
            this.fullscreenMaterial.setSize(e, t);
            for (const i of this.effects)
              i.setSize(e, t)
          }
          initialize(e, t, i) {
            this.renderer = e;
            for (const n of this.effects)
              n.initialize(e, t, i);
            this.updateMaterial(),
              this.verifyResources(),
            void 0 !== i && i !== jn && (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1")
          }
          dispose() {
            super.dispose();
            for (const e of this.effects)
              e.removeEventListener("change", this.listener),
                e.dispose()
          }
          handleEvent(e) {
            "change" === e.type && this.recompile()
          }
        }
          , bp = class extends lp {
          constructor({kernelSize: e=2, resolutionScale: t=.5, width: i=fp.AUTO_SIZE, height: n=fp.AUTO_SIZE, resolutionX: r=i, resolutionY: s=n}={}) {
            super("KawaseBlurPass"),
              this.renderTargetA = new Zr(1,1,{
                minFilter: Hn,
                magFilter: Hn,
                stencilBuffer: !1,
                depthBuffer: !1
              }),
              this.renderTargetA.texture.name = "Blur.Target.A",
              this.renderTargetB = this.renderTargetA.clone(),
              this.renderTargetB.texture.name = "Blur.Target.B";
            const a = this.resolution = new fp(this,r,s,t);
            a.addEventListener("change", (e=>this.setSize(a.baseWidth, a.baseHeight))),
              this.blurMaterial = new ep,
              this.copyMaterial = new tp
          }
          getResolution() {
            return this.resolution
          }
          get dithering() {
            return this.copyMaterial.dithering
          }
          set dithering(e) {
            this.copyMaterial.dithering = e
          }
          get kernelSize() {
            return this.blurMaterial.kernelSize
          }
          set kernelSize(e) {
            this.blurMaterial.kernelSize = e
          }
          get width() {
            return this.resolution.width
          }
          set width(e) {
            this.resolution.preferredWidth = e
          }
          get height() {
            return this.resolution.height
          }
          set height(e) {
            this.resolution.preferredHeight = e
          }
          get scale() {
            return this.blurMaterial.scale
          }
          set scale(e) {
            this.blurMaterial.scale = e
          }
          getScale() {
            return this.blurMaterial.scale
          }
          setScale(e) {
            this.blurMaterial.scale = e
          }
          getKernelSize() {
            return this.kernelSize
          }
          setKernelSize(e) {
            this.kernelSize = e
          }
          getResolutionScale() {
            return this.resolution.scale
          }
          setResolutionScale(e) {
            this.resolution.scale = e
          }
          render(e, t, i, n, r) {
            const s = this.scene
              , a = this.camera
              , o = this.renderTargetA
              , l = this.renderTargetB
              , h = this.blurMaterial
              , c = h.kernelSequence;
            let u = t;
            this.fullscreenMaterial = h;
            for (let t = 0, i = c.length; t < i; ++t) {
              const i = 0 == (1 & t) ? o : l;
              h.kernel = c[t],
                h.inputBuffer = u.texture,
                e.setRenderTarget(i),
                e.render(s, a),
                u = i
            }
            this.fullscreenMaterial = this.copyMaterial,
              this.copyMaterial.inputBuffer = u.texture,
              e.setRenderTarget(this.renderToScreen ? null : i),
              e.render(s, a)
          }
          setSize(e, t) {
            const i = this.resolution;
            i.setBaseSize(e, t);
            const n = i.width
              , r = i.height;
            this.renderTargetA.setSize(n, r),
              this.renderTargetB.setSize(n, r),
              this.blurMaterial.setSize(n, r),
              this.blurMaterial.resolutionScale = i.scale
          }
          initialize(e, t, i) {
            void 0 !== i && (this.renderTargetA.texture.type = i,
              this.renderTargetB.texture.type = i,
              i !== jn ? this.blurMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1" : e.outputEncoding === cr && (this.renderTargetA.texture.encoding = cr,
                this.renderTargetB.texture.encoding = cr))
          }
          static get AUTO_SIZE() {
            return fp.AUTO_SIZE
          }
        }
          , wp = class extends lp {
          constructor(e, t) {
            super("MaskPass", e, t),
              this.needsSwap = !1,
              this.clearPass = new dp(!1,!1,!0),
              this.inverse = !1
          }
          get inverted() {
            return this.inverse
          }
          set inverted(e) {
            this.inverse = e
          }
          get clear() {
            return this.clearPass.enabled
          }
          set clear(e) {
            this.clearPass.enabled = e
          }
          getClearPass() {
            return this.clearPass
          }
          isInverted() {
            return this.inverted
          }
          setInverted(e) {
            this.inverted = e
          }
          render(e, t, i, n, r) {
            const s = e.getContext()
              , a = e.state.buffers
              , o = this.scene
              , l = this.camera
              , h = this.clearPass
              , c = this.inverted ? 0 : 1
              , u = 1 - c;
            a.color.setMask(!1),
              a.depth.setMask(!1),
              a.color.setLocked(!0),
              a.depth.setLocked(!0),
              a.stencil.setTest(!0),
              a.stencil.setOp(s.REPLACE, s.REPLACE, s.REPLACE),
              a.stencil.setFunc(s.ALWAYS, c, 4294967295),
              a.stencil.setClear(u),
              a.stencil.setLocked(!0),
            this.clearPass.enabled && (this.renderToScreen ? h.render(e, null) : (h.render(e, t),
              h.render(e, i))),
              this.renderToScreen ? (e.setRenderTarget(null),
                e.render(o, l)) : (e.setRenderTarget(t),
                e.render(o, l),
                e.setRenderTarget(i),
                e.render(o, l)),
              a.color.setLocked(!1),
              a.depth.setLocked(!1),
              a.stencil.setLocked(!1),
              a.stencil.setFunc(s.EQUAL, 1, 4294967295),
              a.stencil.setOp(s.KEEP, s.KEEP, s.KEEP),
              a.stencil.setLocked(!0)
          }
        }
          , Ap = class extends lp {
          constructor(e, t="inputBuffer") {
            super("ShaderPass"),
              this.fullscreenMaterial = e,
              this.inputBufferUniform = null,
              this.setInput(t)
          }
          setInput(e) {
            if (this.inputBufferUniform = null,
            null !== this.fullscreenMaterial) {
              const t = this.fullscreenMaterial.uniforms;
              void 0 !== t && void 0 !== t[e] && (this.inputBufferUniform = t[e])
            }
          }
          render(e, t, i, n, r) {
            null !== this.inputBufferUniform && null !== t && (this.inputBufferUniform.value = t.texture),
              e.setRenderTarget(this.renderToScreen ? null : i),
              e.render(this.scene, this.camera)
          }
          initialize(e, t, i) {
            void 0 !== i && i !== jn && (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1")
          }
        }
          , Sp = .001;
        Set;
        var Mp = new Map([[0, null], [1, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y,opacity);}"], [2, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,min(y.a,opacity));}"], [3, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y)*0.5,opacity);}"], [4, "float blend(const in float x,const in float y){return(y==0.0)?0.0:max(1.0-(1.0-x)/y,0.0);}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return mix(x,z,opacity);}"], [5, "float blend(const in float x,const in float y){return(y>=1.0)?y:min(x/max(1.0-y,1e-9),1.0);}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return mix(x,z,opacity);}"], [6, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x,y),opacity);}"], [7, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,abs(x-y),opacity);}"], [8, "float blend(const in float x,const in float y){return(y>0.0)?x/y:1e12;}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return mix(x,z,opacity);}"], [9, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y-2.0*x*y),opacity);}"], [10, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x,y),opacity);}"], [11, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x*y,opacity);}"], [12, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-abs(1.0-x-y),opacity);}"], [13, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,opacity);}"], [14, "float blend(const in float x,const in float y){return(x<0.5)?(2.0*x*y):(1.0-2.0*(1.0-x)*(1.0-y));}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return mix(x,z,opacity);}"], [15, "float blend(const in float x,const in float y){return(y>=1.0)?y:min(x*x/max(1.0-y,1e-9),1.0);}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return mix(x,z,opacity);}"], [17, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return y;}"], [16, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-(1.0-x)*(1.0-y),opacity);}"], [18, "float blend(const in float x,const in float y){return(y<0.5)?(2.0*x*y+x*x*(1.0-2.0*y)):(sqrt(x)*(2.0*y-1.0)+2.0*x*(1.0-y));}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return mix(x,z,opacity);}"], [19, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x+y-1.0,0.0),opacity);}"]])
          , Tp = class extends vr {
            constructor(e, t=1) {
              super(),
                this.f = e,
                this.opacity = new td(t)
            }
            getOpacity() {
              return this.opacity.value
            }
            setOpacity(e) {
              this.opacity.value = e
            }
            get blendFunction() {
              return this.f
            }
            set blendFunction(e) {
              this.f = e,
                this.dispatchEvent({
                  type: "change"
                })
            }
            getBlendFunction() {
              return this.blendFunction
            }
            setBlendFunction(e) {
              this.blendFunction = e
            }
            getShaderCode() {
              return Mp.get(this.blendFunction)
            }
          }
          , Ep = class extends vr {
            constructor(e, t, {attributes: i=0, blendFunction: n=13, defines: r=new Map, uniforms: s=new Map, extensions: a=null, vertexShader: o=null}={}) {
              super(),
                this.name = e,
                this.renderer = null,
                this.attributes = i,
                this.fragmentShader = t,
                this.vertexShader = o,
                this.defines = r,
                this.uniforms = s,
                this.extensions = a,
                this.blendMode = new Tp(n),
                this.blendMode.addEventListener("change", (e=>this.setChanged())),
                this.inputColorSpace = null,
                this.outputColorSpace = null
            }
            getName() {
              return this.name
            }
            setRenderer(e) {
              this.renderer = e
            }
            getDefines() {
              return this.defines
            }
            getUniforms() {
              return this.uniforms
            }
            getExtensions() {
              return this.extensions
            }
            getBlendMode() {
              return this.blendMode
            }
            getAttributes() {
              return this.attributes
            }
            setAttributes(e) {
              this.attributes = e,
                this.setChanged()
            }
            getFragmentShader() {
              return this.fragmentShader
            }
            setFragmentShader(e) {
              this.fragmentShader = e,
                this.setChanged()
            }
            getVertexShader() {
              return this.vertexShader
            }
            setVertexShader(e) {
              this.vertexShader = e,
                this.setChanged()
            }
            setChanged() {
              this.dispatchEvent({
                type: "change"
              })
            }
            setDepthTexture(e, t=3200) {}
            update(e, t, i) {}
            setSize(e, t) {}
            initialize(e, t, i) {}
            dispose() {
              for (const e of Object.keys(this)) {
                const t = this[e];
                if (null !== t && "function" == typeof t.dispose) {
                  if (t instanceof qh || t === this.renderer)
                    continue;
                  this[e].dispose()
                }
              }
            }
          }
        ;
        function Cp(e, t, i) {
          return e + (t - e) * i
        }
        function Pp(e, t, i, n) {
          const r = Cp(e, t, .75)
            , s = Cp(i, n, .75);
          return Cp(r, s, .875)
        }
        new ts,
          new Rs,
          new Wr,
          new Float32Array(3),
          new Float32Array(3),
          new Float32Array(3),
          new Float32Array(3),
          new Float32Array(3),
          new Float32Array(3),
          new Float32Array([0, 0, 0]),
          new Float32Array([1, 0, 0]),
          new Float32Array([1, 1, 0]),
          new Float32Array([1, 1, 1]),
          new Float32Array([0, 0, 0]),
          new Float32Array([1, 0, 0]),
          new Float32Array([1, 0, 1]),
          new Float32Array([1, 1, 1]),
          new Float32Array([0, 0, 0]),
          new Float32Array([0, 0, 1]),
          new Float32Array([1, 0, 1]),
          new Float32Array([1, 1, 1]),
          new Float32Array([0, 0, 0]),
          new Float32Array([0, 1, 0]),
          new Float32Array([1, 1, 0]),
          new Float32Array([1, 1, 1]),
          new Float32Array([0, 0, 0]),
          new Float32Array([0, 1, 0]),
          new Float32Array([0, 1, 1]),
          new Float32Array([1, 1, 1]),
          new Float32Array([0, 0, 0]),
          new Float32Array([0, 0, 1]),
          new Float32Array([0, 1, 1]),
          new Float32Array([1, 1, 1]),
          new Float32Array(2),
          new Float32Array(2),
          new Float32Array([0, -.25, .25, -.125, .125, -.375, .375]),
          new Float32Array([0, 0]),
          new Float32Array([.25, -.25]),
          new Float32Array([-.25, .25]),
          new Float32Array([.125, -.125]),
          new Float32Array([-.125, .125]),
          new Uint8Array([0, 0]),
          new Uint8Array([3, 0]),
          new Uint8Array([0, 3]),
          new Uint8Array([3, 3]),
          new Uint8Array([1, 0]),
          new Uint8Array([4, 0]),
          new Uint8Array([1, 3]),
          new Uint8Array([4, 3]),
          new Uint8Array([0, 1]),
          new Uint8Array([3, 1]),
          new Uint8Array([0, 4]),
          new Uint8Array([3, 4]),
          new Uint8Array([1, 1]),
          new Uint8Array([4, 1]),
          new Uint8Array([1, 4]),
          new Uint8Array([4, 4]),
          new Uint8Array([0, 0]),
          new Uint8Array([1, 0]),
          new Uint8Array([0, 2]),
          new Uint8Array([1, 2]),
          new Uint8Array([2, 0]),
          new Uint8Array([3, 0]),
          new Uint8Array([2, 2]),
          new Uint8Array([3, 2]),
          new Uint8Array([0, 1]),
          new Uint8Array([1, 1]),
          new Uint8Array([0, 3]),
          new Uint8Array([1, 3]),
          new Uint8Array([2, 1]),
          new Uint8Array([3, 1]),
          new Uint8Array([2, 3]),
          new Uint8Array([3, 3]),
          Pp(0, 0, 0, 0),
          new Float32Array([0, 0, 0, 0]),
          Pp(0, 0, 0, 1),
          new Float32Array([0, 0, 0, 1]),
          Pp(0, 0, 1, 0),
          new Float32Array([0, 0, 1, 0]),
          Pp(0, 0, 1, 1),
          new Float32Array([0, 0, 1, 1]),
          Pp(0, 1, 0, 0),
          new Float32Array([0, 1, 0, 0]),
          Pp(0, 1, 0, 1),
          new Float32Array([0, 1, 0, 1]),
          Pp(0, 1, 1, 0),
          new Float32Array([0, 1, 1, 0]),
          Pp(0, 1, 1, 1),
          new Float32Array([0, 1, 1, 1]),
          Pp(1, 0, 0, 0),
          new Float32Array([1, 0, 0, 0]),
          Pp(1, 0, 0, 1),
          new Float32Array([1, 0, 0, 1]),
          Pp(1, 0, 1, 0),
          new Float32Array([1, 0, 1, 0]),
          Pp(1, 0, 1, 1),
          new Float32Array([1, 0, 1, 1]),
          Pp(1, 1, 0, 0),
          new Float32Array([1, 1, 0, 0]),
          Pp(1, 1, 0, 1),
          new Float32Array([1, 1, 0, 1]),
        Pp(1, 1, 1, 0),
        new Float32Array([1, 1, 1, 0]),
        Pp(1, 1, 1, 1),
        new Float32Array([1, 1, 1, 1]),
        Math.PI,
        new ts,
        new ts;
        var Dp = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAAQCAYAAACm53kpAAAAeElEQVRYR+2XSwqAMAxEJ168ePEqwRSKhIIiuHjJqiU0gWE+1CQdApcVAMUAuARaMGCX1MIL/Ow13++9lW2s3mW9MWvsnWc/2fvGygwPAN4E8QzAA4CXAB6AHjG4JTHYI1ey3pcx6FHnEfhLDOIBKAmUBK6/ANUDTlROXAHd9EC1AAAAAElFTkSuQmCC"
          , Ip = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKAAAAIwCAYAAAABNmBHAAAgAElEQVR4Xuy9CbhlV1ktOvbpq09DkiIkUBI6kxASIH0DlAQiIK1wRfSJTx+i4JX7vKIigs8HXpXvqVcvrcC9agQ7IDTSSWgqCQQliDRBJKkkhDSkqVPNqVOnP+8b//rH3P+eZ+199tlznVTlvVrft7+1T7OaueZY42/m37QALKNk2wHg1pITlB17mC+Pp11W3X/LHyT32vhg48/5SOv+PnwpsHA70JoGlueB1iKApeqzvOzn44GatTB76Xzhd7suBR7+WWADgDEAwwCG/L54b/poDLrHuvvm70Z2Avhsc+PVcxscBU8F8C8ADg5+ipIjD/PlGwfgju8B924E5seARUfLsiNmqQW0IjL8+7L2NYD/7COBzfcCm+aB8SVgdAkYIRCXKyDax4EdAanL5PuNPllNvXDlAHwFgP8AcC2AhRIoDXbsYb48dl5WkVFTE3LGDcC9m4CZCWBuFFgeAZaGAYJQQCRqDHT+McJrVb8zwATUXH02MHYfMHEIGFsAxgjApQqACYQORjtd/B7Axt/z79sC0+cMPgjjlwPwVwHcA+DfAHzTxcVgWBroqMN8+cYBeM71wH0TwKExYHYUWCIAHYRLTlkCYgcIBcAgU/n3qy8GRu4HRgnAOWBkERhddPAJhGJDBxkvw7cqimr+zFM/ZLnZF64cgL8BYD+AWwB8x/dlWuWagHiYL984AJ/0RWBy1AE4AizyM1yxYAcTigW55xMbAkxEiwEdkJ/ZCQxPAiOHgBECcKEC4TBZcKkSv+mTieNcNPNC26mLNsj45QD8LQDTAO4GcJt/7iw2bfoG4WG+vAGwm9ExiEg69zpg/wgwPQLMjgALzn4E4aIzoJjQ9g4024uygkj+pyuAoX0VAIfngOH5NgCHMhAm8Sv2y3XDZeBhNIp8OzJE8OsBzAKYBHAXgDt8/4O+MVT0j4f58o0D8Pxrgf3DwMwIMEPQEYRkNwfgsuuDZLskip0No0gWMD/9HGDoADAkAC4Aw/wsAgZAgs2Z0ABI0GU6IVmKv+f28KDnHxkA/G0A8y6G73N9kOCjXnh/Ebb6OvgwX75xAF5wLTA1VIHPADgMLDj4yIA5AAm6aCUnv4oz46eeDwxNAUMzwJAz4BABSNDFTwSfg7DDKHE23MG5PqIY8A1u/dINs9dBdy8AgnGPM2NfUBrsnw7z5RsH4IXXAAcJviFgluAbygBINnSLWOAjGxJ4pgOKDV0v/OSLKp8iGXBovhLBBOCQM2ACoTOhnYrAdItYbCij5JFzRyIAqRccAnDAQUjg6UNQ7hsMXP0cRQAexss3DsCLCECCLwCQzMcPwUi2MwAScAKbfnY/YRLFQ8DHX+IAJAMSfDkAF13kLvleIjhjQQHxUVS3jjgGpKeeNzYVQEjgUS8k+PghONdhIwAP4+XXBYCHKIJbwJyDTgaIAdCBJx3Q2M8tYAHP9m4df/ylQOsQ0JqtRLCx30K1wtLBggScQOgsKBGcWHAJeOwRC0BSM1mQIKRbhh+Bj98JQP6t4U0APEyXXxcAEnxkQAFwoVUxID9kvQg+c1C7vidRbIDkc24B//hTQGumDcCWA5DgMxASdNIFBUI5pCML8v8API5zfEQx4BudgqiczviSnJhQwCP4BMCGl+wO8+U7AJi/W4O4YS6+pmK/2ciADsAOBhTIIiAJnPB7AvNjP+0AnANaYkAHX2JBAc+tYaJXOqBZv24Vc386XW5dtkHGW+4HFAJonpOe+YYQZAShgKjv3PNvPQaxVoI8zJdfFwASfPzMUwS3Kt1v0UFIlos6oDFdAGFcliMAP/ryAEAGNwQRnDOgLbdlIEwrIs6AZ/QgkMMHQF6ZAKQcJAsSYPwIeAIk9wJgoPK1gi7+PwF4GC/fOAAvIQPSs0URTPBJ/Pp3GSEGRHfBCIQ0xowBtUbcAj7ys5X4Jfu1HIAGQrIgQRXEsAFQIORDFhiDY/rMHmrU4QUgR08AkgUjCAW6CD6CkwBsAIQC4GG6fPMA3OXiNzCg2I9gNCMksmAAoemDzoimFwL48M85AKkiuQVMAAp8CYRRDAt8GQiJ67N6GJODAXAHlsGguscA2AJg1IPGYmxOpBxFWkRN9LsATgIwXnNs/v/5z/9XCf8BO3YAtxbc/46/KDt+5+ea1Yku2VUxHz/z0v24FwMGK1gWsK2OUUxHHdCBeRUB6OxHABr4ZICIBd0QWSF+XRdMTAjgCdTrG9cBNwE4F8CpDkICyYLGsuhFt6zs+gISwUen8zEAjgMw4cfx2H6O/90yAFo84Cbg4ID3/9TfLTt+5+ebnRABkODjx0SwPi5ec/FrYpmqSAxM8Dn60CsqAFI6GfhqAMiDE/gokmvEr0C4PgDkBQm40wE8zMFEUDKEVoxIMLl/KS73mE7H9d+vcKHQQcjwW0Yu9nP8m8sAmOIBuWY6wP2/4s0ezjjg8TuvaR6ABJ70vxUApGrm7EbGE+i472BAB+WHfqHS/eoAaEwY2E9+wLSXTqhI7CXgnB6LCoOJ4BiST+hTnG0HcCwAglCx3ARoZEVFXnBPp/O/A/hXACc7CPs9/i1lAOyIB+RDX+P9/+pbQjjjAMfv/PL6AFDs1wFAgs/9fgKfgdE/ZEpuiQlbwAde6QAMBgiRmsSwA9BY0JfjovGRDBMH4TlcXGhcBOc6HkF0gjPhZgchxTLZMAci/04W/B6Ab3t09EPXcPyflgFwRTwgJ2MN9/8bf5qFM67x+B/aW4XQz42FeL0YrRyikztUFw0704mf9kXgxhOAqc3AAsPyRxxQCs/PdXOFY0W1KHy3QIUGtx+6vdnx1vsB+dsTncm2AogglFgVEAlUWrOMB2RyEmMCGQ/Y7/HvKns6tfGAnJQ+r/9b76oJZ1zD8WdyQjYBh8aBhVEHjELouQ8ukQ7VRSCJAALwkr+sALhnGzDD3JAJYJHg9uhoi4bx8ytkWUtvHT/7+Zc4dw1uZ3612fH2dkQf7yxIEEockwkJQn4IQoq8unhAhmPRKKFx0uv4K8ueTs94wD7u//VX9ghn7OP4c+4G7h8HpseB+dF2AKlFLwuAIZ8jD6NPrOhAffmfA9/ZBuzZCkyRWSeqBCWyoYGQ5yQrBpDbum/ME1HoPo0XEkSD2zlfbna8q6+EUJcTCxKEtHL5EQjP6BEPyIgYAZBvYt3xHyx7OqvGA65y/7/9wVXCGVc5/sl7qxD66dEqiYgRzAqhN1A4CBNAAlDyAFI+iZ9/N3DLJuC+jcDUBmCWyUnOrmTYCMIOkNclLg0B8/RsNLg9+UvNjnd1APLmmQpFHyEBROuWACQT8nN+H/GAvY7/VNnT6SsesMf13/CpahGnZzhjj+PPmwX2MYdDIfQexWyBAwEUOQDrRDN/98p3A7dvAO6fAA5sqHJDBEAyoUVGkwEd6HR12XU4kwzfl6fCXTZzjy57vvnR513X7Hj7AyDvggAUi9EyFgiZqNxPQF6345nOWbD1HQ/Y5fpvuLa/2+82/vNHgAPDFQDnhoF5j2C2qBWCI8bw1eRw5CL5l94L3DEOTI4DB8Y9OWmsEu/zBJ3rgsaybqBob/7A4C7jtWcooRrczr+u2fH2D0AOQgAUCxKEP7aGgLy64+m6KdjWFA9Yc/03/Osa4glrjr+AupqHz1sEs0cxG0BC9HIePLoit9eNkVf9L+DuUWByDJgaq4ybGYLPAWgiXmLedUE7dwC7saL7CqfPKXi4NYdaykCD410bAHlDEsNiwZ9wAPYbkJcfz6T2gm3N8YDZ9d/wHxUA+739fPwXPrSKYGb+BuP3jAFDElFH9HIWwbzCIGkBr/or4J4RYO8oMOW6ZVcAuvi1Cgoha04BCwT5gfMKHm7NoRde2+x41w5A3hQZkADk5+cGiAeMx3+/7AENFA8Yrv/G71cAXFM4Yzj+otOAaQLQA0gZxaIIZtMDFTigKJV8H9Iq6aZ59ZXAvSPAvpEKgBTtBODcSCWCZeRYtpzrmLyeGNCAyFl1v+Hei8qeb370Rdc2O97BAMi7EgB/2QG41nhAHU9LuWAbOB7Qr//GPRUA13r7Gv9FZwIMoVcEswEwfDoimEP0shKKtIphaZQAXv1+YM+wA3DEdcvRKkGJADQQEsQuhi1Tjt95vBsh5nx2IO59SsHDrTmUOStNjndwAAqEry0IyCMICkOyiuIBNwBvPFQQT7gBuPjc9oRYAIHyOEL4vIFEYVNaOou5vCGE/tV/A0wOVcnpzI47NOri3QFIBpSeaSDUdYLOSWvYImSGgftpJDa4MWJbAGxivGUA5MAOc0Be6eVLj7/4Mk+hzCOYPYpZDBiNkLh+G/M3yFyv/ltgL3W3YQfgcFUhgRY2PwY+Z7/EhAR1SFyXCOb57r28QfQBsJQBMn5D4y0HYLPje9Cd7RIC0PM3EiMofF4gVCBp1P840ix/gyz56r+vAMjk9Gl375iB4+CzveuZdLkkEPJ8ZEfX/6R73vOjzT5Si9hucLxHAVg4PwJgRwh9CKOXK8YA4ZEqKZXSQWh5P+5AftXfA/uGKvYjCKn72cctbFrZNECka5L5CPwIPtMH3TVz17MLB5gdLgA2Nd6jACycHwLQxFEUSR5ASvARDB0h9AQb9bXIgCGk6lUfAPYTgEPAITKgg1BObk58srTJgG58WMkWMaAbQQT1nc8rHGANAJsc71EAFs4PAagQestgC1lsBJ4BMCSOK6dDUcwqqaFiQr/0QeAAAdjy+jBiQQeeMSBZT3nCPUDIa9z+/MIB1gCwyfEeBWDh/BCAeQSzgkjFfGLBBD5nxQ4DxN0wv3hVxX5TBGDwL5obxvVA5YqYL5BeMLd66YYxJpRB0gK+96LCAdYAsMnxHgVg4fwIgMrhUPKQ2C+Bz0PmBTqBMQehAbDlIjj4F80KJguSVZ0FuXpjoCOgXawLjALhbT9eOMAuAGxqvEcBWDg/l1IE05Ed0ygZnyHdz0VwCqEPIfNyx0QQvvLDFQCp+8nfZk5und8tXwIgWcHSNX0N2CJmnAl3v6RwgNnhl17T7HiPArBwfghAS7mV/hey2JS9FvM3BLpUUi1YwDRMXvkRYJoAlAh2l0dcZ04s6JUTDIjyBcrl4yDc/dLCAdYAsMnxHgVg4fxwKVwJgGEJNmWtxpQMpX9on2eRhVA+O56AjMfnP+e3Xvf3NwG4xIPTleiY55bpGh6UbafNU0l0z0p+5Jh5HqYJ6b51nP6XP8cx12XNHQVgIQB/bFPVg2OC7Q+WgVFWng/FvtWLI06uWh5oguKEcXVS/9sEAF//VGD7t4ETDgJbF4CNi8CGZWBs2fPL/H6Vwp2KEtVk4fJ+v/EIYPN9wKa5qu+IncfPwXHVZe/aOL3EbwS7xv8A1rQvnO0j8PArTgTGZ4BxFv9mIxhOCGsv+0OPYDRghcLfkWkEuq0+G00x4OtfDGz+d2DbHmDLjL8si8AYP/7CGIAiEEMTG92zXqSbH+d9R2aA0XnvO+JjthiIrOVDHHPOkBrzUQAWAPsZp3oPDpa/Xag6EVkLBK+5rAnJC3/nYk/APD704WiEAV8OTHwX2LQH2DgFbJgFNrBhjd8r79deGoEwsllgNBOzy8CdjweG9wBj08AIAci2D6HafmyAk4/Z7SJ72hGYRwFYAMDLTwOGp4FRFgD3HhzqRGQiyeurqOdG6r0Rm8IEZjzRlkiqCWoEgK8Axm4BJu4HJhyAbFhDxmbDGnZO4j0SgLGDkpibgEq66TJw/1nA0F5gdLpq+zDqFfd5LMeWqu5HNST0uJOIllg+qgMWgI+HPv0xwLA3gWHpW2sC441gCECbmKziaGrnUdMO4aHeh6MxAP4SMHI7ML4HGD8AjHvHJGNAgpDgY/ck3stipRemvVhc+uASMPUEYGh/9dIRgGx8Y+MNbR/00uVtH0wEx94j/v0oAxaA8Ed+GBieAYZZg5kADC0QWGOFzGJlcGPzl1BxNLXD8sk4xftwNAbA/wwM3wGMUmxOOQBnHXzetIYvibonmSiuYTNjriVg7glAiwBk0fNZH6+PmX9P6kfNmCXGpftJ7TgKwBIAnln14BAAYxMYm5C6RjCyCoOyr0qkD/c+HI0B8DXA8N3AyCQwesD1VQKH7EcASm1Q+y4CkN9pUKiVF5nLvy+fBbTUd8QBaH1HvNBROiZvfsNnrF4kcvPwpdsBLBeU18Nf7AB23Dp4ecHC8oBgUlJJecLS+7+WOpE3gbE+HKw+yoevCYkMGKqPJrdEKARutaFYRs1fiEZ0wP8CDN8LDO8FRqYq3W10pgKgfYLaYCzootgA6KXaTA90y374TKB1sBozy77xHFZ536utRgAmEaw6g5kUSFZwSXnA330qsOlfgHMPDlZesLA8IOjoLypPWHj/11EnCiVwkz7kAExtsGraYUWdSDX5TmsagL8KDBGA7Bd30JsW0oWivnEOQNP7yGTSBR101AlZSUtGyfgZDkCWY1HnJdcBVe6325hTvelg2CQjZNDygG/2An0j1wKnL6y9vGBheUC8prQ8YeH9X39OVQSc7Mc6fCaKvAeHdCIVf4yMYCynTpX+nb97NJmlSQb8r8DQHm9YOFUZTKOzoXGhs6AxF0HIexcLBvWBuiHN8s2ne98R3qc6L4Vyb2oBVjfm9MIFHbjDCh6kPOBbQoG+oW8CO5bWVl6wsDwgfr20PGHh/X/1iaEIuDcCTIW/1Q4rFv8OnYiW3c+W2iKwUjKbyjQNwL1uuR6sAEgDgq1brXOmV81PxhNB6DUDBSYzQJwFtz623XcktX1Q1VWKaTF/zZhVazBVYA1tX5MazsGvobwe/jQr0Ne6BTh5uf/ygoXlAfG60vKEhff/rSe1i4DnTWDUACY1guFTDqLYdCBvf6DJYSMYATBfOx1kLfj1v1axH10nQ3Sd0GUkBnTfpemtBJgseIKQAHLQcVxa2TnuMW0Aqui5es8xBIegVdVVE8VhzHnLh65WMB9An+X18K6aAn2tO4ETl6vqbKuVFywsDwhevqg8YeH93/Rk70JE90nowxZbIJjvS3WYNSGUwGHJTpPxwwcbBuBrgRYBeKACn7VtpdUu/c0NJxO9BIxcKu4TTODzbkonPLoaL0vyUQRb2y8HsL1ckfWzMeuFi40Qezqi+yiPhyt7FOjr6/gCFwgP7Xb5vssTFt7/nQRg6MGRWmDRoeyTlpgw68GRTwgZgo1gGmXAX6/8dtaylSKY/koyID9BhzML3q1gAos2AcOrZYSoq/pJp1VtODRm9Z3LS/7WjVkvXOzEtOpKyGrlAT+4SoG+VY8vBGCvy/dVnrDw/vee65NBJiAjBIVcAJQjOm+DkCZEeiGAMw6sAwDZsJrAdhFM9rPGhd4904Co5oVuCZPV6kD40Ec6+9W8dBTBsfdc3nkpvnB82fp2RPcs79dHgb51LA9ofsDV6vut5/3PnxcAmLVBiDqgevDaJLkYrpuQxzcNwN8AWgIgRbB8loEBzXDwl4cGiDGft58SCOWGedgjvOJ+bPvgRkiuA+ZjzhnQQOiFNVbloa7l/fos0LdO5QENgEXlCfs8Qbf7HyMA3QVjYihYhLENgjX9y/qwxQmRU/asfd0ZcLU2CHVGyusJQLKfVi98CS12T5f7iECkHpsMkAhCF8+nshWH2I/jXsOYO144GV/9ApAIrS3vt4YCfetQHtAA2G+/4PW4/2PPbzMgmUMi2NoeSCRxIt2/FvuxWURIWCXg357gfTjEDNIHnTRXRCpH5ugKwGl3HpMBXQc0v6WLYVm/5limj04rG762K2uYY9jBkr9+rI03NL5ZbczS/dJ+LQyoga4o77fGAn0NlwdMAOy3vl/T938KAcj121z8Bn+Y9eWQJRz8Y6kNagDh2ey5EvxjxQD8TWdAuneCCO4An1vw5vdzQMmdktwq7pLZQR+dM34+ZumAxvY1Y04uqOAJ6FsExzeto7zfAAX6GiwPaLWR1lrfr8n7f/Rl3QGzmsis+/uO71V9OFgP2gpPhgr7TGRqRUT6dyvr4aIs/pm/2zVUNbBSv6G8e5pEv0Cvec7Po7+bTtjlBRlkvAMBkDeQyvsNWKCvofKACYBrre/X1P0/oWEAnnFD1YdjhtXxR73mX10FfCHHE9pVWcGAI/S0gKsfA2y+twrFZw6Hxf/F0Pk8Ri/kpGSnMuDx5T0iACgQHioo0NdAecBUHW6QdsV2/cL7v/Cyqr5gnc42CCOcfX1VIZ/V8We9IDmTzVXwPDJiXuKXPxtDBma8+lzP4WAgKkPxCUAPE4v5GzEuMX0PYJPLhB6FJsc7MAMmkVxaYC/K9gG+F1++8AQ7Gwbgk78I7GFpXgIwFiRXOwaJZPUbiR0yCUDRk+cHf+YpwMj9HgfI8ClGPyvsSiH0WSKRuYlitLb/zHM/JOSs5C/YIC9cMQDZr/dwxgOW9gtGYUBi0wA8l304vDQvAchilFbpIBQhZ7Ejq6ZQ0/Yhil8y4j89Axie9DAsD6FX9HOK3QtROTFkviN83kG4felIY8DCeLrSeMDSfsEovAECUFsTjHD+tcB+tkFgcXKvBRir7qtFl9owmO4Xy/1G3bAFfPrZHorFNWBFwHjQAFctIghj2kBarw06If/+MM9ZqTN6DgsDojCerjQesLRfMApvoGkAWh8Ob/tgAPSKWCp8ngNQtadjmTdltvNvn3peFYhgQQgh+iUmEaUAUoXM1yRLmWuFLaE9Z+XIAWBhPF1pPGBpv2AU3kDTALzwmqo6qtVh9kJErAudABia38TC5wJgS2xIhAwBn3yhByL4EhzXfRXxYsDTJ4IvrNN2JFMxZcBzVo4cABbG05XGA5b2C0bhDTQNQLZBYH1AVsQSAAU+imI1obHyblnjG/kJk3U8BHz8xVUQAhnQIl5CyNgKAGp5LKSSCoAySh5Jj79vTagcxUaIBeRNe79g9gq+DXig4wGzy+PONfT7RWFA4noAkGXZVAhcBckJQgNgrLiaNb3paIDo1vHHX+oA9LQBi4DxJcOUPJUnTgU2NJUyROs8irGARxQAC+PpCtsFd40H/AEf0gMQkLgeACT41PiGoLOKqyrJq3K/Ya9mNyr5FusN/uPLPIeDa8Bc+w3rtyl4VFHaMZc3i9RWBM9jjzgAFsbTFbYLRmm/YBTeQNMAtD4cBKDXBTQGdAB2MGBo8SCLmEuS1AFVAJ3A/NhPt0PoCcA8bSDG76XI7aySg6JYuGfKwJHFgH0E5B3ueMCe/Y4L+xVHAOZ+9EHcEgQgwbeiEYx6jwTdz4qfu7EhEJqxGqruf/RnHIAEnxgwBM0aC8aUAYWNBRCmoIll4HTqO122QcZbrgMWxtMVtgvuOx6wa7/jwhtoGoDWh4MBJ16WN4lfr8AqI0TVV1O1fa9BbQzovkAy4Ed+NgCQUSxZCFWvCOaOFREXyUwZOPIA2GdA3uGOB6wPaOz+QPv5S+MA3OXiN9aclghW+d3IgupBF2pPqxcxGenDPxfSRh2ASiKKiVP2PaZScvAKoA0VDc6cOlIB2GdA3uGOB1zR77iwX/F6AFB9ONSOQW0frA50sILVcckWJyIDSgwPAVcJgFbYuZ3FJvAlEHbJ3IsgJLGedeBIA+AAAXmHOx6wo99xYb/i9QKg2iAIfDJEJHqj4SExbEty0gkdhB/6P9oZbBZIGiKYVb9GKaN50lRHBLOvhDxh/5EKwDUG5B3ueMB2QGM/grb7/6wHAPNGMAY+GSGUjC52VX2f2CD4+HO0gqkZfegXKgBaHkcWtS0AWii9xG1ImrLlN5XR8L8fmQD05BVrmEENmpYSP9QX+KHiqj2/82+HqqDWwnbBRfGATdzAegGwru2DpRq7Mzq2fpAf0Nq0Rl2wBXzglZ4yUAPAmDSVWDBPHQjLcgTqOZ6zUvdKHh4ruDCerox/Dnu7YqwXAC1NI/QcEQuK6WK/kdgCTGC0PYAP/KIDMBgglq+hIkrOfsaCviLSofcJgJ5AdM7kkSaCj/HqQKVIGvD4swF8bcBjmzjsaQ2H5D/6acBd9wALB4DFWWB5AVherMp4GKIYEOp7+26UF0aSfT/xYuDG7wDjrIpAERytXf2vajj7ueryQXSFl10K/ON3gIWDwCLvjfGB8Z54O+Ee4ve6513uB2R1yzsqC+twbC8HcNVhfAeaBuDP/TvwtS3A/ePAIfYFVlPq2HHTuyulZCTlhbjhETF5yxTQGgPGhoHhIWC4VSXGD3n0tLkMHXHxu+YyB+MlPwDuZs5K6FlsbCzdVO9DuKfkHM8AEkP7B8fOkwDcD+B7np42+JkGOvKdAL4E4K8P0zvQdET0b14D3DgB3D0B7B8HZka9WzrD88N6sFm+YcUjrn7E1ZDvMtF9DBgeAYaHgSGB0PNHCD4BLwLRsByAyX/ij0/dDUxuqlIG5hix7eFhvLcOVUAtyPSydAFmOQNe6EYGV/9ZESiKgIEgtbaD/gHALQC4ovY5r5KwtjOU/XfTAHzzLuCmIeDuMWDvKHBwpMoN0WQzNtAaYSs0K4ZlOSAjGG9kPjCBRwZ0ABKEBJexYAZEAU3A7Oi1BeDym4EDnjQ1TwCGWMW8MXcKks0YOyZNlQOQjcgYIUHllEzYQ0ktm+r6oz8G4F4AXwXwRd8/kO9A0wB8y65KmPxgGJgcqYJTKYpTv2CCzyddQJRDOjKivn+Deh8BF8BnwBtaCUA+YYEyAU8h+c6Az9gNHHRmrgOgmDA3jHQ+iWupCeUAvNSrA9HNwqx+muk9nJVNg/CTfrmbAPwbgK8D+PcHkIibjob5o13A3XypWsAkG1cPA9PDFQDZM1id0i1KxsWfOrKnAFXlifCFFMMRcASigOcs2MGAIfE9iWXplS6On7UbmPaUUTXQrgsVMzcRj5Folg2V5ayUA5BWYKwOxKUafnosWjcJwk+7W5F2EKvlE3xcXaNYfiCYsGkA/smuqug6hcleAnAImPbO6YwRpMgjCAVAm/yQmKTv5hNsAf/i7SyNBSl2a8Qv/4/M1yF+BZSYlNQCnnVrpbC+mToAACAASURBVJcaI7sOSEY2NpaDXLqpR+vE/OVksDgImgGgghHoYJbTWc7oJtFWc65/cg2AYvh2ALsB3AzgVv95nS/f4QdsIkT9T3cBrGtITWZfC5hqtQHInsEGQn3UDDvEDEY/ICf7SxMOrAg8T+c00JGkvHGd2DABUYZIAONzCUDppCFhSukCBsLQrFtZe/IixYQpSyEoJoqnuPWrVRAubQh83HNlZB23z7j1ywmj6CIIqUPxw2Xeu9bx2jx10wz4Z7sqTYZaDD8EIDuoE3hMVEphWg66JIp90k0sBxBcy+iPIIaT1RtEsHS/yIAqw+VSNPWQfe5tlVEk8auXgVa5BUsEJuT5uoliAbE5AGotmIAjCPnR9xDG3TQernYAUupTdBGEFMf83OkApHG+XlvTAPwfuyrgSZOhas3u6cwTsUBVn2gTwyFMi8wjHZAA1M9fYGHDULJD1m8Cpa8fRxDad+l+Ykf/3XNvd11U+qiL39SxXevSsshdDFvgbI1O2AwAtRZMZzTBRuDFjxe1Xg8QEIB8yyj5yYIUxfQIkfkIRnmHCM712JoG4FsdgHHp3ACoMH2G6jM4lWzoQarSvwQ6MSB/vporVaFkh+mCLlpVR8Z+dqDZLoDOpHSiQeAFDkBjPrlgCHgCUaFifg67H/9uYjn4Ai1vpTERTAASBaoQJBAKeNqHlL6mwPDZYAOROag/EYRkPX34MwHIvzW9rQcA+TLpI22G7EcQKlJGsYIJhC6ClUMiXfBTbFUQAej6nPS/OuAl9pOOqIc2BLzg++3VmWgIEUz82cRuCAtLIHQQm0gO52uOAb22sC3JEWgRfPpZf2sQBQIgLydPEIFGwPEj8MlF2bSbsulghLftqsCXq9HGgHysznrGgi5qzTUTFH8FLhAUn3hIJwCN0HLncw37qaF2zoYvuKNivmQIuUNc7GvWt6sHNs26twA6vhyq8NEMAHlyntFrDCcQehyaPTl+FwAbXDcmAKMRThakEk8Q8kPg8SPL0qzLBl+A9QCgR6uZGs3vfHz8TtBZvkgGQrEPBVAUg2Sij50QAOjiVKI3saADJRm7dSLYWfSFDkCem/dhZeMy9pPY5QvSDYQyUJoDIK8qMezh3wY6fSL49PcGgCAA8pScJLIgAUYQEmz8RPA17StvGoBv39W24eREiBoNQSgWNI1HBkdgxJSw1AI+dFIbgOYmkjimQ1r6XXC3rAbCHycAgytohf8vsB/r2KRaRq7zpZ+D37HMX0s3DDcCUGLYaw53MJ4YUODzusqlGCQAOQCejuxA8UULUkxIwAmMAp8Wa3qkN/R9W+sBwOhIEPjk5SLr8HeKFbTQfb77csPIMHGl/4MPbReslPhNe4+MiTpi9AFGV4nI7MfvagNQLh/pfrYnDAS8aJQ42A2w4em2cAyWQUuJVQTGWLs1uL7DG9J1RjhA+jvYk4t3KXeMqijpzrud4At9z3XtP16yGfjKZmCGooYh1tZzvv8xXPFl4PoJYC97k9FlwZWD+Azi/deMZWeP13eQCGEyoERudChIjbb3mJYwH7V0QIKuCwj/gfMj0asn2I0FXRSHXfL/iRkNgLyeVj8ccMY//J1fyxzTAXT2+xoQViKYD/1hDqLxPiYxTgSvQrphphG97tz4Slqafnj7uk1kIQDZrvWTw8B3jwEW+RLxPgSiCERdPwPR7+wCPg/gulFgfruDkOMQkFc5x84e708JAMmCuRNBXi4TIg5CGRzGiBGE/D4E/C2r2vcAYJoify62i0aJSMhB+2IHoNwu0fkcjQ85pu3ack5nIBREqneYFyWLkAXIJHESe00Cyx5QyeL6F/tyEcDcrOW2n7fX8df0mME+/vQ/PQjhoy3gzo3AISYf80MQaQx1peH9wb7v2mrtmCBkIMMejp3jIJD1MsaxaMZ8v5N/67INAsB3BAYU4JL4DSo1J15AFPAEwuQHZJzkKfUAtOHLJSOQRWndBYQvCQA01cfnNopfsaCJaD2baBn79QjSTiOEP1EcawIpkq2kegBTNgHWEpOKF8Uwq2NRFPM4AqCf46/rA2U9/uVDvurB01zvAJpiiwOl3fEeciCGF+Ij11f+QkbSfMPfIzqw57mEFZ9Dl3Ps5HXWAYByHJAJKV7N+s0cCQQhwSlfm4lGZ0KB8C/rABgZUS6ZHITBSEhCowUYAAksF7cStWREyxRwtuPpOlgw+5s9sq6OaIJIIlUgEhA1edoTgHxa9HVw5jibZNF+j/9yGQA/7pbujZ4bwv2+cWB6tFo0NzYnkxFA+cvEAo43VBoEo2e+48EMXEOmD9F6xhCE8RwZEJ80VblKvDlmzwicfqy93/o+8K8TwB2jVSgW138FrJQTXBNlnJgmrjZwanow9CBP/rL9wF0jwAGWDtFyoN9PHutnIHT05mPXz93dMGQAPniJsjiBXiTbxDZFMF9NLUPQxKR5qezz1Y6/YZDH0D6GkdAkYJIvRalAdHAMmPZoYhb6NhDWvEyf/ma737CXN7R1ZC7hUbPgcFgqt/ZZjADnM1xqEVhYBpb4CUk5UsL7jQvj///5buDrLeCOEeD+YQchYwG9VIfyg1NaZszFiCH6DkRGLze5/dgk8IMWcMCjdCiCzR8od1B8OTwvJM8JEShFut1fzMhi+eRJr6LI7hYP2M/xVLwKNoZjUTwRMAQQmYyhWGQxsSADOflZ4kukj7PhZ75bETjBpkAGahMkcrGgwhsXeCyBHBj1wmOBQwvAwqKzoFeRV8ZaerjKYAuirmPY/o9X7q5Cyr7fAvYMAftCPGAEoYlBiVtFwLjtp2U4irj7yOANbi+crHyrfCbTquJV44O0F1FrwQGIMZFqdQDyP/gGSZ8TC0ZRRsOlVzzgasd/u+zpMByLehAfCgMQCDyGZJHFCCgLZ2f8mgI5qauEcVx9e5vACTgCTwEMWr5TdIpWKJb5MvrnoocDswvAPAG4VLGg6UKeqmi4iuDz4er30oX0FP7u5moMvIf7W8B+jwlUNAzFnlZCIhvGFRCeWzrgXSSIBreXTFZSgVLHAp4UHOFuociEEsn2PJwl/XEk0dzfSojeerFg1IOo5BKAveIBex1P67lgUzgWQaJwLAKRH04i14ItgDKEtGsRnWx49b2Vkk9wUefTGrKCF7R0JxZMqxN8cmPAxWcAcxGABKEAKPA5u9lEaAbCmKMI+sDN1X3z+ro24wEZFc0VEE64ABgT180PF9ZdBcDb6JpqcPtPk+1ACbmKjJnllwyuILunEAWjZHkBsrsRUnfD0qEiC5IJfyisgMhzWhcP2O14Ro4WbASgAMQJ48SJwchmBCDFa8qpyBbSP7OvU4PQ0p2W7+LSnSJUFOrI4V7w5IoBTQQTfJ6oTSYk2mQcpGRyH2syGjIF6EM3V/fM++C1CfwUExhCsmzCaQT43lZC3e1hBpEHh36XEqrB7Scmq5dV0XZxmV8WuDFzAF9iwhow9seAGoBcGtKjqAc+1l9rLb/1igesO55ysmCrC8ei6IxRMAKTWNBi6Xw98xNTFUi0jEcmpYgRAPhddpVi9OIEPP5cYD4CcLkCooHPwaW9kV+iwWrQHT8uA1fd3F7DFvgUHUP2k8jTiogAqLoxFpDgbMj9jXSuN7i9dLIdaxzBp5XVBMIMgFEnFAPKT9qPd6A9BIGI7MfPmf4U+40HzI8nWgq2PBxL4FEkjKJixGRRFyQQPzzd1iAUzCAQas1YOmAEoFjwkecDC/PAwhKw6CxIkCXwOdVJLxTobMjBdyIgfvimNvNJ7Evf4jWtdnRYD1YNGVuG93VWuWs4Jf+mlZCCZxwP/cnJ6mXVKk2+tK8lQQVHRTGc64SDAZB3Ey3JcxyACkToJx4wHl+YwqloGDICmYmTFgMQFBET8yyYzyAG/AfWX8mCGQg0BTRoHwt9KVaPE/HQ890AIfgWK+CRAaMRYnVdxHbhdY8Wslw1V93UDsmPIj9GxgiAioRRMIJNvoti+SW/Ikd0gwAU8+XxJcbGITJPDvI6XdCFREFSknTB83xka40H1PGF9dnycCxFwygkK0bASJQSVAbAYeD98xUAe5U3jKIwBosSgNsuABYogl3/IwgFPrOIg1Xc4ZrpAsSrvruykl2ucykapkMMh4CExD5DwJfWAYAxwk4MKPAJgOIjGSEGwuCakRhemw6Yv0UUwRf7L00L9pnsNx6Qx4feY4O8pDEcixOjsoTKKpMYjSFYYjOC8Eq3Wnnr0YYS+0Tmi2HysrPGLqwASNYzBnT2Mz2QD91laxLB0gs12GAh81cf/o/OcHyJ+qj0S/zxnhUZbSyYWaL8+Rq2S29wowiWkJPan4MvgrDDGAlRe7KIywDIgR3meEDWg9HbJgApNTkXo8o0i7oVgxnEgFr8F7jEdnU5GvqfJQKQKyEOPlsNIQvyvupAGHS/Okv4qv9oh+PHxMLk8ggBCRxvAmEN+AiEzz2iQfQBeNmkh4K52hJBKOaNe/FSLobLRXCz43rQnu2yi9oMSMDxs2jo8303ERz1wsCGZECF4kd3DwEYYwJjhoNlQrgIjlYodbBPrwMAZfEmyzcIv27gs6XDzC/IR1DOgA9a6DRz4wZAsZ+LYXvQYsHoD4ziOFklna6YD3+nnU6dZ7bGDAcBUImIAmEUw/zbJ1i/scGNDJiLXmle3RhQ+l/aq57gUQCWzwwBKPeLsZ/LFrGg/ShRXAe64Ajkv30kALAjF8R11Dy3K7KRwJcsUTaqWScARou3w/INVnCH+A36n8RvM3nB5XP4oD6DATBYwGb5ajlOLOh6X8JaBKRG77+7ygGYp1bn+V25/01AzBnwQ1ypanD7KWfA1QDYC3zJIj7KgOUzc9nFbetX/r+O5biwNhyX5uSEDr5o0xsJwLp8/m4A7GaJUv/j3/5+HQFYJ3oFPPkho/hNeqBcMkcB2BAA6XrxmMBkfFAci/m0JpwzXw0TXvXtzrz+PKc/Ml/ugzM9MDqCAbz/keVjjGcQA/YLvjoguo1mRslRI6RwfsiA5nqhL5D6nscF8gfTdfxpS+/hLzvWfzMQCoB1Fq/8b3VWaPIDZqsRV64DALsZHVHs1gEvsqFAeBSApQC8pHK90Oql4UEAyvCwNeGcBXNLOPMLftgZsI75ouUr9ousp2TEyIJ/sU4AzC1e+WIFshyAHPZREVwItrrD3wGAhibTYBhxVpe/xePyrNBuWaoNp3DgFwC81O+RAepK/a5Lfe51jxr7JwA83nPXYgq1asl0yX5N48+f4VEGLATlK1vAo5YB1gBSRmsM+NFE57lcfPD5pPFWCJImtyvGgGfOAacBYO59zFglgHgPefZsXV6/gPXBYeC0RVgyJNOGYuJjPka9eHWgjL9bWzhWk0/n/wPn+k8bgFNmgYcsVflZnBRmIShtJM/m7JGibGBoOIIez9wKPP4AcNpylfbNlGfdI+9NjBjz8JVzppckZuJ+dBw4aQ44drk6j1LIY9JkPD7P4s2lwVEGLHwJnncscNIh4Nh5YMsSsHm5ndOu1BGFThJ8/K6JrZtoslST2+XHA6ftB05ZAE5crgAups5TfaL6EF+UyIif3gAcOwtsXep82eIYY9JkXpMgMp/AeZQBC2b8OduBYw8C2+aALQvARgJwGZhY7swEzbNa88IRvAVO1qkF91J36DNOBE7eD2yfB45fqphLnevzdGeBKBfL8UX5/CZgyyyweRHYsFwxYHzRNK6oetSBMDLjUQAWTPqPngpsnQK2zgKbCMAlYMMSME4ALrcnR6JYQIwsoUnjpDRstOLy7cBJB4CHUGwuAtuW2nUDVH1EFUhycSwWjGD64mZg0xywcaECoI0z5P3X5P6nWlHdgHgUgAUAfOYOYMtBYNMssHEe2LgITBCADkIzSJZXpCOnIg25uPrhgnupO/TyhwLHHwSOmwW2LVSik2pCrDsQskzNIBGIpBdGI+VfNgMb5oENCxX4yPRjPj4xaJ0+WGeEHRXBDUz2Mx4FbDoIbJypADixUAFwzAFI8KUJChMV2SUaAGc1cE/xFJef3FYRti64nkqWDrqqEhbrsm5zvZCdPCd8nHzJOLZuABRz9hTHZwPL7LnLnoNMIY2VyaKcjtZLHOAbNgNPngKe4BacfGF1pnydD+hphQ/8XV5UiEueLGnDN1tWXj/3/4cTwAUzwGPcRcFJiDpPt3FLmf5vjwE2HAQ2zPrEzDv7OQg5OSM+ScYQy5Xbo8465u/ZfLTJ7fKHAdumKxVh8wKwealSE6inEoSy2MWCdbUHIghv3AqMzwHji9VLZuDzD8cXxxWZs5c7apmW0fMBnIHKn5X7d6I5npvRz94O7LgXuGIReJSb+Xl1tzqflybwRwqf9i97BQRWomWJQ7oZVFtJoqDX/b/oGODsvcBTATB9gsfGqmzdjtVz+G+PAyamgYmZCoDjFE2anCVg1CeJwOMnTRB/DmUINVkkgia3y08BtkwDW+YqAFJFMD1VAAw6XG61R31O9/fdrcDYPDDmY0zjc1UjivBuAMx1QdMB+WAYXU8dhEU16dOSkppbcHFSrng8MHwnsGMPcN5ypURHp2xMIa7zDz2z8Gn/kVe0YomO0wEwBYKujL7v/zHA6C3AxfOVh58g5AsZxx4fZM7sf3h6BcDxWWeGBZ+cMEFiwGEHHRnDzun7ONHs/djkRgBunql0VDOSHIDU3cxSD4aEajhFXS4H4S1bgVGN0V8we7E0Fh9jVDG6Obr1LJMRwn+kOCaTEYT0dsfqZHXl/p7PrLi9wIY7gO0H2yAgCAWCWCowKrYE8nMLn/a7PQn9X7zIJPPkCcK+758y7x7guNsB6l98gZjLLYet3Ay5n0sv4R+fCYxPA2MOwLEAQLIDPyP8uBg2cRYmzFweAYilKkn+OC8/Fdh0CNhEA4nGA40kd6FES13WLO8v1qHKAfh9B+DoYjU2Ak/js/8NAIwg7OUb7LCC+WAfB4CpBJoIiTRNRmS1l13kqWh3Adv2A8cdqqp1MB+aIOSxWv6pq5D2kkIAvt8rF7BLJksN/jMqfa7v+7/Ak4B3A6ceqpasKMq5akAmlLWY37t8ZW97PDB2qALg2BxgAFwANEGcnI5JcrDZRPlkaXL4u1KJUAfAjbTQ59x6dSvdLPXAgGYshZWR6JIRaXB/NwFI8C1WwLMXzMeSwLfcXuKrA2G+wrLCDcN/IIg4ERRn0qvyySAQX6mG1XuA4fuAbTOVwktRRr2MLCoQyvEZ/UY/WwjAj3jtFJZkU79g1ghkgEBf98+0Umb/3A2M3lkBl/fOcdMok2EjkZyv8773LAfgHDDKjwNwxEUw9yailpwdxBAEYhBbAuGzG3aKkQEJwAkCkOCjlb7Y6SYyf2UwlAS+vKYnAXjfNmDEX7DEfA5CjUcsnzvbu1nDtUMmCDkRZEEyGdlAk6G6lQTSa6m0MP6HuY73AxNTlcJLZ6WOJYC5/CNxLpHMgdKIKNl69Qvu6/75AjHOiTU87gKOOViJb748BKCWrnK/maTA+58AjM0Ao7PA6Lx/xBAupoYDC9okBRAmPdBZ47lNA/DhwMRsxX7mPgl+SrmK5EaRNRslXFQ9CKB9DkADn79cZtkHFkysJ103eBbqlh97DpmTQTYgk9VNxu+xYbXKU3lhFoJPOgdFGY+lPkgQxokkgF9Xgj4AvfoFs84eX4Ke9x9fIC+tRfDxvvniif358sSir2LCj5wNjBKAc8CIi2AxxLCzIAGY9L7AhGIKgpATw4l8wToB0JjPrfTkp+SLQbHrOqm5jNyajS6VCMIpApDAWwQ4LrGgXqzIfnq5cv0vN0ZXHTInME5GBNLb1DGdOYQsI7AfGKFjlgqve8wJwG4T+fuFAFytXzCLb+VgWnH/fIGYfc46Hs7iHC8ZkPcdXx4VfVXJw8+cA4wIgM6AHSLKWZCTESfLfg7WsIyRF3ckiRQ+HACXkwHptyP4KHrpJvKVGnOhRF9eBF9wE0mUEogz2wC+WGI/vVxiQQIxAs9+rmHA6E1YFYB8DJwQMZl0OrLZ++i7sfT8zroYHLS9df4RACWKxSZvLXzG/fQLZqk2gqn2/vUCUQ9UZaM9wDaPeSPrC4A5C1KV+NITKwCS/SiCR/jRBDlLmP7nHynsxno1IPwJSyRpbiMADXzuPDYfZfBTEoAmcuVQdiaW0zwXwQsCYDYmMaDA1wG8TBSvaoR0G77EcGSET6hjOvVApfRPAUN0zjr45JzVcSqiTxD+VeGzXku/4Nr7JwDJOkxFIwt6j6+RqUrlkO4bXzp1gCAAv04AzgLDDsBhKugLFUvQUhTwCEKbnKCw14HwJ9cDgGQ9WegRgDI8XEcVEDvAl7lVlglAgi+I4CR+Zf1mLGgMmDFhBGFfDCicRJFERviSABjLS7FC0MFKMU+07wOPE0kGvaoQgGvtF9z1/iODkwn3VWoEXxres5ib9xx1wZufBAwLgAQexbAD0JiQwJOuJBA68/H3Zhk6+3CifqqwWNMKN8wjKgbk6gWJgC+FMaBb5vJVmsUbV2vCqo3cRWZcCIACoax53+ulkqNd7iqOcU1WcC9cxEm5kQBUdZ+sTnSL/jEtTWngi21jhJNJBivZBukXvOL+yYBkcOqxKjJ4AGgxzMrBVwdAMmHrZOAYF2l6y/mwV6xD17zmWo6MbRyeWtOHwxJ91IIhr6rqZS70DPPLXDVUrfBwzHKr1EUp6/h0T/6L/GcCqslt4IhoTcwdAqDSs7I60WQH6R329pHuFyuXDJmEjuOSbdB+wSvuP5bGUjmsA5XoUvcvBXKKAQnApUdXwah0b8jXR2YzJTsC0ZHB33FL+2yiX3h/1YeD1fFZGT81g/H6yqkVa9YEpqMhTADle8erHA6t7Mh6j4ZBXdBGjFyO4CSIm9wGBiBvgqxwIAJQlXIyEJLyI/i0SkAG/FbhaEr6BXfcv+5dLKhCg4z1C1HEBJ8+BODQGZXfk/quAZC6ketAZEQCTWAU8PIJt0fgwHzZvVWNaKqi7JLOmtDWFy42g1FxH/XfqGkII0C+a0tnDkfsGxQjn3VPsk7tXmuy+Xp0JhtoJosAaFcUAJUYKiYJxcqHqKAH9rPlG2cMrmCUbMX9guMLpGTcCMKDlZGhMK8IPnPIn1X5PA2AwegwEEYmDGBMjOI5whGQP3NPBT7VJlRNaKvF4t2IWHbDErtDlSk1p4lJ7/zd246tglGZryIfrFhQ7pU8WCAX0ZENG+57U14Z4YrCeLrSxXdev6TfLwrbxT7znMrfKQXfHLQCnyvmRIv0Q3430ezMmL98P393G3wqz6am1NYzzoGn+svqRmTAU2citctqAX/2EI8F9ACEmLHXLZGoFxtSl2xyK2bAYwrj6Xr12+1noL/jUTCD9vvFrn6u0v1/nvGkaoVBAQi0eummMAuXQHMWJAA7gCixG8U0gFfcXdlBKk4Z6zELgAJfZEKrxpC1xOIl/+Sk7jkcdYlSco90y9+gK6vJrRiADD0piad7RuFo3udNCgft94vCdrGXn+tujgV3QAcHLcFnroelivHkchEL8ue0uQ74S3eubAITS3IQhKkMRjBMokgWG3L//2z3VSnP4VDgQWxUEEUxAZFHL0eR3HDfm3IRbDHkBfF0zy4EIKNhSvr9goGEBdvTz/MIYQLQdVsTwRTFDj5jQmdArRDYJQNDSs961R3tPhx5NXoVgoxleHnarjohgLec3D2HI492yQNvIwvqO9fJm9zKGbAwnu6FhaP5pFuMg/b7tTbpBdvTz68cz/zI8azVj8iAHTqgmFHXDUB89R2dtaC7tUGw4kDOgFb0R2wYRDGZ8g9O8aU4XwPOczhiwGlMjqqLWiFYGu570wADFsbTvaxg8nkow7E8nM/atfKzln6/1mS4YHv6BQ4+Z0BbqHcd0NwwYbVD3+1yWhXJxPBrbq8AqE/XApSqAxiBV2MZ/54DMOZwKE00rnDUWcR5KiV/brjtSAMALIyn+/mCyeehjIYp6fdrvVELth8RAClyHXxmhPi6r1m8FM0ucgk8+y4RHC1kAK/5XgW+2hZYofafWcPq1B5AqDqEYsQ3nepR2gqhV2yiol1COkD0C+aOaoGx4aL7DQCwMJ7uVwomn4fm7VrX2u/XAlELth+5sHPtN+l/Ap6sX2dCsZ/phZkIJgv9l++1wbcq+2WFv2NXIjNKAPzuw7MUAV8DTuynFIEsQy83RgTAhiv+NgBABaQOGE/3mwWTLwAqHnaQfr9GnwUbARgDNBUlkpzQboyYCyYDYdILdf0l4NduW9kGoa4geNdazLElKoA3Prx7DofiETtC6XvE7hGEzJlpcis3Qgrj6d5UOJoYDcMglrX2+y0NPtl5UZUjkfx/Hqbecoe0OZzdF1gHQrln9Bhee4s3f3Zxm4MvAk9VSFdUIw0i+Q2PaBtISiBSSFgCYMjMW00MP7pwvvLDmwFgQTzdHxcOSGvBg/b7ZRZByWYAlOERluKM3Ra9CKWc0q73dTBhMFT4ZwIw9l5Lrpes+HjeBiGCUOKXeuBvPcKTiEIOR0f+RhDBMYi0Lhea4GTaa5NbOQAVDzhgPB1La5RssV3rIP1+7yy5OAADoAchEHBkFbKfGRpiweAPtMs5IFNokyOGk/7rAYC9OhBFwNXVY1at5tftCBHaWVS2AJdEcEinrDNC+Lumiyc1B8AB4+muLARAXTDCWvr93lR4/Z0Xt6ODFQkj8WtumEwHTKDLQejAfN3uds/dfjoQdatGLxb8jQBAYz6/boxiFgAVudzNIc2/s3xLk1szAORoB4yn+2DhaATAGJCtbpkCYq9+v4V+aBgAQ4i66XtaC85YkDog/zdZvzUgfN1N7a633Xqv6fe9msDIHfNaB6Ay2JRE1AHAEDIfI5nzZCLeN4Nbm9yaA+CA8XSsul6yqV0rJ2WQfr+splCyCYBR/HJyKX4phs0PKBZ0lqOYTpvniAiUAmAd+HKjo1cvDjHgr+3wPJQsVCymUZrPMuRsRBDG4AQCsunyJtFGHwAAIABJREFUcc0BUJlxQoH62q8ST8cggpKNAFRGwCD9fkuvbwAkyGgJE3C+Nz1P1q9/T3F1EZBxvZh50s6AEYC5yyUHXt5/Q8zI5/KrAmAIkkipkyGPYwXz1aRT8v5ZO6jJrRyAvKOvNXlLazsXs9bo/ztc29Pohgotp5J49Rcj/pzfIwGS//3OM4CNd1dpntQpFUmjEH4LYIgnyn/OLjL8FeDGhwJbNgFjI8DIEDA8BAy1PFK7FSKf43cNKrvHx+8C/vmxwMgmYHgEaA35J0StpvvzL/nP8RbLAfhyT207TChgDRiu/ZL9DsfWNABvYzbhCDBKoBAk/pEobGWTqp819hzQ1/0k0PoaMDEJbJjxVZFgDad0SaUO5LksWVj+XScDmw5UEUDJ6U4d0nVbC91S3ovfVHp5al64cgC+k7mZAP768KCA0WD3A/ieLz090CDceVmlAuhBljLgrfcAw6PAyDAwPFwBkCAbItM4a/FiNtERjBl76W9ffD2AbwJDdwFj+6syImRXrd5Y2FjIYcnzWPLEqnsfC0zsr6qBMQmfIDR/pyJ6xMhKyMrSDiKD2xja6TADTt0/AGAs1KcAUCFrOLF6tbtiRVFavT/wuMCa7MfVTlH098YBeBcwNAIMEYAUlS4uBULOmK3LCnwOPANlEIOSoF9+C4DvVoWXhvdWZVOYqWgi3vOXDUQhgieB0EElViMYJ08HxqeqnG8D4IIDkAzo51DKQQJvBKUmKACzbM4+5hUivwrgiwC4LzvjmgCh6nBcgiMTcv9Abo0D8E6g5eCjfpUA6AxoQIzgi8ALmWwC4z//DxcPPwBak8DQFDB8yJPpPZHeGCyC0KN5DFCByfh9/+OAsekKgEzCTwD047X0SCPM1IYQjCv2E/MJoGVwUUQoPboq0MdqkWVn7RtDDMahB4g+P6qhXFpjVtkDtRGA2nKjos7IyOyHFUbIrXe0FXsTuzIYfNb4O2M3ATGIYQOmPn6hG6gi3eUkQQAeAIYOAUOzALMVh2pAlESqGFBAXAYOMQVjxll03iO/yYKRAT0FQXkwZkjp1pz51LO2XAT3KtD3AIAwj4Wg05kfiuUHYlsXAJLVnP0INLM0OYFx78AzcRySeTsw2AJueI+Dj2Fne4EWKz5MA0MzDkCCkAByUWqsJzarEanzj2zXwjEGFHuGY+pYsMojzZL1G9EBexXou339IRBrC3lJGmNDuSHX+w7WC4Cm6wWxm8DngLTImgC8pBcGBuTXf/1fXnyTugnFwxTQOgi0CECyIFlsvvJfEnh0mhsYI/s5uxFYi1xZof7oOqSAawwYjRGBzYGXbtWXaCIrlvHUagX6SP/ruMVYCEbEqECXAMjfree2HgA0ESur1/0vtnNwGSsG0RsZME20/+/XWH6Mugk/yngPAGy5GDYALjiIHIgRUIrsZjM7Ax+BSx1S4pfffQVIep8dL7dMDsTGjJB+CvQxTHmdtrw4l0CovFruC2NOe975egDQsCXRK/eK634JhBK90q2C7I1i+Gt0jxF40k1cPJAB7UP2m3MGJAAFQrGei9iUTH9yBUDTHfU3B5+BOIKQ43BWtNtPcWIOzEZE8FoK9K0DCGNxLi3FqaKA9gTgeoFwPQAoI0OulWT11oEwiFz7cwbErzNxWtEYBB+VY76Vh4DWrH8IOoGQ7Ocg1CqMRLPltmxvs1/SHaP4dcAJePYyyUCRIzrTB8tE8FoL9DUMwl61kQQ87Rmy2PS2rgB0a1ci18RudEJH57OsY02y/+83/sZdBKr4FXQTApBvprGgQCg9UEAM+h9F6ugJDkC3gJPBEvRGrYoYCBX9IxEcS5K4i6cZAHIw8oXQ4mLBb35YH5d7OekadtTV1UZSjaEIPH4nQzYNwgjAHNwDuWGYpZc7lzPfX1cQur5oBorfzDf+zi0yVTuSkuxBI2Q+PhQDIUEnMLo1TBCZLufGw/ixbQa0KB8CTODjPohdY78IQmfDjmW7Yo/doAX6GqIiAtDHaYswSmeMubV81kp11L6hy2PdAcgblfslOKC1IiKRmyRxZgV/8++DS8BFrxXi5Hd/U6MeSKdqEsEKhpBRsgRMbAtuG4KU/+9ry5brzP/lPVMv1EPOQegharrVcgZUhVHFxNPcp9VFtlOWkL437C0WABWypFRGsV0sb5Hn2zYBwvUGoKl10v1knDgo0y7XA8Pfv0UACnjaK33Co9gJQAOe64FkNvtZAHQdjz9v2Nz2GSa3jYej2W3KGuZ9ixGdIVSoKT13B2s5AHkGheST6qn0erHv5AIgAAU+LVfw/wq3CEAV7clBKDDGZG9/5oVXx/oyYARczcqH5GyH8eFplTawFvAtrtXLGpNrQDGbejupB3omlIHQGc/ErzOcGSRs8zrhAbbuL1Tco/JfbLlNwHOmi2kIcs3owbdwNpYtynDQhsFcgvuG9/YapGFvYX22zZcAU0/GwA2LJ/4AmGF9mwEbBu98Y3cMF+uAGQCj2HVp3BbPuo3IlqxAy5wHAq4OfARmEBXGfNIBa0BIsG0ecwC67merHgRpZLwocrWaovuTxew/V0txJQ2DWeae3WAGbdhb2DB4+wRw7w5g8Qpv88liyGtoWHzMi4C9fAEHbBi8kwUKu2xNAdBxaGBLbJdZux1LwAGECYAEm6wyfpelJrEgFnRDxESwgyUxIUsVMwjVy5AYO0bG89Auu1/5BF38KqjBHlUAYXsteNCGwTeWNuwtk4JMkrlzGNizA1hm69g1Nix+zDOBW0aBeRZZGqBh8M4emfWNADDT+zqMjQyESdQFHfDbZECCLRgdHeCTe8CBaKJY1rDnBRCIAuGW4TYAZeFG8ZuMkGiQ1IEwGCJtHZBmy1obBsvVMnDD3jIAerti3LEBOMjGcOpa3WfD4ic9t6oveDtLfw7QMHjnH6wPAybW6yaG4+8D4HIQfvtDIVtLejpBFsVvUI7NIBHw3DUjRzL3rDVtsYPOkAScuX3coNDynT2VYJCkn+PjqvUD8hVbS8NgjphGxcANe8sAGNoVY/824BCBtIaGxRe8pLKZdpMkTvXiJ2toGHzSNHDPScAyq3er4qPyGaNc7JCRXWLT2TjwGmCOeQashq6+qSpZmp8vojQpheF58ncdZVjLnjWPHr4VWKTKxrHGUqq97qXu3jp0wPy+eEC/DYNZsZAO6IEb9pY9lNCuGPcNV830ZmkM9dmw+OKfbdcXvJMPdY0Ng0/7GnDXKcDMccBS7MwdKz8KCAKQIgY0MWGCtr4TOHAasMwOkTqf6unyuLykfd254nkb7qsw/iVg7jhgmSX31Vpd9yRHeLx+zRhjEGRbB6wDYT8NdymyubzDzCCGfpMJWfSRYfr9HP/aMgBm7YoxNQHMbQHm+ID6aFh8yS93tAvGQb7da2gYfPoXgbtPAqaPA+a3AEubgGU1RM6B060fgkRoCzj+TcD+04CFE4BldZdRc4/YxlxgjJMewSiwN1zWfsOngdljq3EmY08vm5i/7j5yIMqpvupKyGoNg9lngYosl9wY/0dZdrMzYl8Ne8sAWNOu2MA3zw/F2CoNiy99XbvftrcLriz6PhsGn3U9cM9xMODObQYWCMANwPJ49UliuW6SaqqBn/gGYP8pwPyJwNIxwDK76ahDeN6uXYCuYyABkEza4LbpY5WEWdSLxjF26/dQB0SJ6r4ByAN6NQxmkWcqrnQ00x1DEDJFjR8CcNWGvWVPp6ZdMQ6OVOCb3wAscPJ6NCy+7PerkP5Q3tBY1PrT9tEw+JwbgPu2AlNbgVkCcCOwtAFYcgAuiwWlM/XqDjMEbP9t4MB2YO54YJFMo/5gHIcALV1TRZ17FXOhPtvgtvkqf9H4kvHDlyKK4l6VzvVSBF22uwjOb7pbw+CfcwBSkyeFEHAUx/yw9JTyEbo27C17Ol3aFWNuAlgIn9QxO2tYfNlbK6MvaxeMRYquvL9rTcPgJ30TuH8LcHAzMOugX3QALo21WXBZLEHwRF1OgHS2eOgbgIPHA7PHAezNu7QFWFZ7JnXJ5rnqxHEulvlzwyVNN3+wern5Yovl7SXLGwvn4riLWO4fgMRJXcPd/+pmOymELEhRzBxJAo9gVL4kwVnbsLccgHEpWi3epocCAMeBRU5eTcPiy/6qtl0wpvhA+2gYfO7NwOQm4OBGYGaDs+5ExYDGgqP+ccAkINaVpB8GTv4d4OBxwNw2YGFrxYCmV0YxLNYheCXau7EhV3ga3Lb8g4+R45uoGLADgHWqhsBXA8K1AZADyRvuvtkBSArh+i9DsQhCOtf0UUgW/7aiYW/Z0+nRrhizoxXwFhyAi5y4rGHxU66qAFhT3rDSIVdpGHzencDejcDBDcDsBDBP1uX1CMJRwFiQIBzxieL3KIY1YW5MPOxNwLRb8gs0aghAss1GZ1O+SFHsdRPt0i/PLHu++dFb/x4mXfhcbWxhfCtYMFr/uWvKxfDaAcg7ipPCvFOVpuo3HrCjYW/ZA+rRrti6TS6MVQ+L4NPH2nx698GnXF0BsKa8Iab4dFZpGHz+JLBvApieqAA4J8CPOQuOBBAOV0CUYbIskRkAecrvAdNbXc/aDCxSpyT4CEIyTgRgneiLIp3nP6fs+a4A4N8B8/48CUC+ZGJA29fpuLmxJW+5h5kNFg2jiWHSi0r0Uv4pCoZsxw8DUfnhd4Vk0XGdGvaWPaBV2hVjdjgA0BlpkQ/K9bmn/HOVqtClvKEBqlfD4AtmgP3jDsBxB6DA7tdbcvYzJvQJkii2n4NOeMpbgJktbYPGACiF3wFoEx1ZMNe/4jnPLXu+KwD4t/5SO/iMBcXuesHylyACMBPDgzGg7opM8mEHIGdwrfGA1rC37AH10a64Yr4APvvOSdwEPOVbKxu+K2pdKRTmdI3dqkPPVgbSTBGAY8AsATjWniBdx0QxJylOFCcr6HBiw1P/CDgU3EgEIMW52M8YkLolQRddIN1AyKWiBretf9MJQN6HsaCPxe4rvgDdHOcOxDIAcmDFDXvLnk4f7Yqt63gEIB/Yoj+4p9xaAbBHeUPM8qF2aRh84QQwNQYcGgdmx4C50WqCFngNsgSvQ+Dxu4MuiawhwIAXVk1O+e/A7CZgThY1dcno1nHL2oDIyZULpBsAFTBZ9pjT0QQgn2V6ufRicS8QRgbs5ZYpEsENDejBfpoLrwAOjgIzZMBRZ0AHoUC+SOA56xJwNlEyTFw5FxBPeWvlzpnbANCdQ1eSGTRybMuydgMggVBsKmtYoC6Mt8znZxsZMLzAxoAOvsh+ydDqtXx4FIDl8L/omQ7A0QqA82S/ERdTI22mNfaTuBIIxR4BhKe+y61punQC+MytI/Zz/c9EuvyBeetLAfGZ5WOMZ9j2/gqABB1fMLsHAVBqhfTcyH5d9MByEdzs+B50Z7voGZX+NzNSsd8cwUcG5ASRKYbdHRNYwhhDIHRgGmO0gFP+HJh15jOXjnyKblVT5Cbfoq+yJOszF8P8+VnNPlICkMAzds/YLxlYznrJwIpO6egTPMqA5ZNDAB6iCCYAyYBcBqTRQ0e4630SxZyQJQIvMJ8mSeLrYe+p/GzGfnTpEIBy6US/out+K1wg+brs88rHmDOgAVCMnrEfxxMte1Mt6j7u9zzKgIXzczEBOJIB0BnCJoqgIfDEhM58SWzJEPGJe9hfVH42un/Mfxl9bgSiBySIBWnAJBDGEDAB8QWFA8wO3/a+wH4+rg4RLPYLul8tCI8CsJmJMQAOuwFC9qMI9g9Z0CxhZz65K0wfFBPqu7PEyVdWAOTHVlTcpxhXHZLz1w0ZA6EDLhkCskRf0sw4dRYC0PQ/vVSRAYPo7QCdj7GqVOSMeBSAzUzMxZcDMwLgcKX/zbv45SQlHXDIgagJc+bjZBqAWhUoH/Y+B2D0J7rFa6LYDRmzomsAaOeKqxEvbWacHQB08JkRIteSXiSBLYJOLB+X4xrzAzY7vgfd2S4RAKkDDgPzNEAIxMASSWF38WsgkuXLyXTRSRCe/DduSZMBMwe6ObTd8JBj24Aot07uDObPP9XsIzUGFPs5+JJ/M6oT4buxHv9X7BeY8KgOWDg/Z58GTC9Xq5FxTXOw9c3Cm6k5fPcjgbHbgAlvVG2tH1T3Oavoq6BlniZ+12n5u/2sDbOvasqoFg8x2Lnbcd1GdhSAhXN+7qMrAC4sA8sORJ6yHwD28z+Ft4fdv8UyqUDrDmCEBcpZ39kLS6aq9l4D2rLb/KYsFTPWdfbvh86vQu2s1K/K+zIjTsXIVQ9a59Egs4Y6sZfIA/EcSp/jEXv8BWcAhxaA+SVgSQAkGAMICcwVlNLlqTc9Gbv/HAA7MrL4+f1VlXwrUq7SvCoyGcrrWpGhuur2fNGYwM8YT67hT3s1LaZvqn5MLM0bzmHMmIFSgdFNj/mIBct63NhFZwEzDsBFgpDPeanNgATfCtGsX9TIKwNrg9tuVkhlng7TI/YArX1VkXKrEe1l2SynN1RCsFJsqnQv3UIMxhwIRjU5AGN9QUteVz3BUAvahuNgjC3HxLAND7nBp/cgONXF5wCz8xUDGgCjKPbvevlzcKUHH2ag6cnYzepYBB9Zi2FxDJdjoXJv1WDFiLJ6MKqKZUzoQFTfj2HmwTKcTpVWvcxHKm6kKgoORAEvVclPD6NdzLXpMT8IYNPcLV7yJGB2AVhYrAC4SNA5AxKM9ryDPE5fs6eeVKWGZ2M3S3MQfEyJUKV8L1ZpJXpVJ9pLilmlAxWkVJHKwIhjjD9TtVXVm1HdOy/pJiaMFRWM+bo0rWl4yM1N7oPhTJecC8wRgAttBjQWdBBGESwgSiV0Pb9DRgu0TY19N+M1mRKh8niqFx3rRDsLqjgl9yaGXT80vcL1wnE252PAZCzAHQCoiqoW3yYWFIt664fUpKaREr1NPakH6XkuOQ+YDwy4FMSwgU8GSRSz0UJx3Vx/5vFNbrs/EiLRY+v4ACITww6iJEodQKwBIyBRv9vwhKzUW6z66TUGEwhDS3ezqusAyNxnJn8xa1KRPSFts9YfFB/QDZcAm78CnDBT5U8rCqjfc3yh8Gn/hGd/MsKf1+QzYJ4891Jye13iy1cAE9cDJ+6FpYrEkidxDN3OtXR+FwBGMezoMmxJLOumAuD4J4rxJrfdH/XCoLGFVKiUbw+LAPQqWWaMMLrd6/+JycSIm85w9lOpt1j1MwAwFTiqAWEUxeYH5ENn/jInUVHeMXQ/f/jRePvCa4DhTwLHfBc4frGqqaNJzLPw6iZxV+HTplFGvZrXZT45N39+HW3TujlZv8D6fp8HRq8Dts9XIOR5YtakgBgdrrrt5Qsq8Ssd0BhQ4HMwmVitAWHAY/LbLDQNQDaTVJ8Q6W4qVB51OOqDZDPVB3TLOBepW5jmqaLbec3jGgBGMSxvvemDYkQ9GoKF1ShUCSKCqBeQrvmfVZPC1keBjXcCmw911tTJ8q5XgOLaQgA+x/OdWA2EGZ98gbjleTHdQHQN+2iwls3nK3/Zhj3VeQhovYzdxmArSwQgDRA3QiSCJUrTnjfl4KozRCSCCeYmt90EoJJbVCk/1+FiCwFZxLk4dRfLFia6x8LbYkD9v9cXtLG6+O4AYQRfrgPygVIcqyhTXcWFOJH8fh3rz7EKwnUArq8mcGwK2MCC1i7WY7Zenh56feHT/jE3yliE4TZncd636gPFCKWavGhcRx2J+cvs9MlSw0Ty3cCm+c7n0G0MExdW4BMIbTXE9UCynvyCCX+Ovm4gbByA/xisVgJPpXrzLj4EoRJjJIZrWHArS9iprK+KcefgiyB0XVKGjOmCmW9xhRVMUSyRFnNeFGEdI2q+/HFXclkp9WsAbgTG9wGj08CI64WxRk/OTDcUAvBHXSLQxcVCDMQSWbzv+1e7WVbz+k5w2tJtsbcCYV6WJY7hmAsDA7r1Sz3OgOgoM+KTOJbcjSI5yGIaNE1uuwlAAU/MF+tF5/0sIghVLdVdM2S0bSzHx2Mi+FTxXf8X925NC4BycK8QwfmgVX1LlcFiykEMcL2BndJJ7aQfijKfxLGDwAhByM7aC5U4qwPzNwufNnNuOH4VZaCPlPo2AahqFqoPVFc14ga2m+WEEL0cAz9kdPrOmMu8r1o/rTsXz7f9oswFs+jO6LAqkvC3Ggg5Fg6mwW03CUI6X12h8lyfcz3QHqr3DIl64DbqaQKc9mI87QXACD6vpJqY0EVxz2CEyCI5eMSGX2e7VtI5J4yTRyZhscrvt1nQuivOAaNLlYESwcySgiVbr37Bfd0/u31yEgg2FVaiPCeVOguqAfGov0iR0R9JABJ0bnwk9nMxw+fOh55EbgRhzozrBUA1polN9CLwok5HEEUQBjFMQB7D+j656PW+IrJ8O/bBCo4sGFdGejqiyYCx3mKe9/JtTiBvmI5OFiTisg9LtJFF7gZGDrUbHKs79+hyu5hSaUvh1foFr3r/6vZJCiXgCDwVVFJ7MVmRLsrGltuFCc68yFdACMDAflwR4QM3HPoKgIExt4gz42SuaQb8hBOE2oZmlu+KFlKR3QSssMJxDPWbbjpfLoJrxG8CYT8MKGZSVTCxYFTIb84nkCxCIPLDiby30gXFghaF4c2ReR466Uu2fvoFr3r/fKAEFxvpqMcd9yonIrkuK5LLV7MVCM+/uDJCyIC2J8a0z1iwqyESgMl15Sa33QKgmtPEBnp11mwuXgO70Ud4DHWzfgDYC3zBEOk7HlA6XKyHQzb8HgGoCSQLqsxorIy1Bxie7Wx0rFaf+wr9Xv32C+56/7HbJ5VHtRYT+GJrsehHcya57PyKAQk6+vBkBZPpjPEExlwU59awg3C24W6KBsC6tqHR+MidyVG3i3rdAnAsH2T093XT+zLr197MTA80h3SfsZP2UqpCrPQ46oF317VrpeiKXTJ9MhMLkgGdCacKG/mupV9w1/vnwyGgCDCKWzJe3lqsyzLWZWe6/kc/oKzgKH4jC7oolhdC4jiuzM0WPo+cPQ2AsX1obFCTO5Jzn566PwbReiwnfTWjI4KvDoh1juh+aT+WKSYD3i8Aql2rJk+VsVQly5kkddv2FvHT61icqO7Fr71/IkLNXOi0FQjV0046oBy6wZ922Q95ICqDEaL4XWw3COcf9Mw73DFB9AqE6wZAAS8XuzGQIDKf+oVkqxt00ttAc+YT0PJ9qRFSB8xoye5Xu1ZVeCSgCLbYLVNswoncHxoeLwCzBGjBNki/4BX3z9lXgUCyIIGmhova83cRgO5Te9yLgP3MfmsBS8xs8/U67ePQOqy9umBUruDchqo8sHSd3PMfT5ifo+ack8eFHI6QEcnT5GvdOnVdXof+ptJ+BVPWceiaRHA8Us/nkACo8mzqlqmWrbFDppT5A5UIZm7CPA2Vgm3QfsEd909kKIqB1qJAKCBG8ZstZz3xHOAAiwmpDIdng1maZQAkZzsHZ537YfQrwNyxoQ+HakrnS0h1mUA1C96TdJTmORyhC3oeqdwROi+GDhkFI6bYNrcNDEDeAkXwQizPRpmnIs3OdqZPSaRFUcbchHlgie6agq2kX7Dd/+d8lUJVXuUzk8ERmS+2vfd4uvN2VOV5rSwb0y3JhgIh9wJeN3YMQCIgR78Q+nDEVYBYZUrUpbXFnM7COSdf7N4IPvtDnT2BY/h8Chh10MXQeYGS+7GGjaQiABpuNIFiECnzdWJMIUHcazLptC7YivsF8/7FgLFMqpiQL5TuNbKfA/DC46rqqAbAwIKWK+timRUBEiNGsOQsyQm+Gpjd4n046hbT84KPuYjOmHHyp92gcgDS2OoIuVIeh/xyUkaVwyEWdLrewHE3uBUDcKIwnq40HpDXL+n3CzbaKdguel5VnFJl2awaghLQBTzteZ0cjLq2A2n0M6EPh2pC57Wg41poLzZsAZNso0Hw6eVR/J8bF9YjWGmVCpGKwQLBRCcrbiSxNLgVAxCF8XSl8YDHHFPW7xeFBRwv/rGqOKUBkODzqgdWPYAM53vTASMQu4Bx9J+69OHIF+N71F1O1gUB+AsBfFqKC+4Wi4BWX+CYgOTAU36wdMVNVKka3MoBWBhPxyiuko3xkSX9fvGMkqsDlzzHC1N6SQ4DoINOe7KelWWTheziObeKCdARApD1AdVnRH048gKUAmAEYi6Oh4DJV4VoGDWqjq4XLbO5o1jBoimEPhPJmwu9FvnTLgdgYTwd2wyXbMyRKen3i2eXXB245FlVYUpVxUpGiLtmGBlrTEhVUwV8dEkVKAq3MHJ1uzRbRx+OOgDWFX6MsXJU/36lJoEoA2AKvw8+uwTEDIBbStdOs8ddDsDCeDom7ZdszBIs6fcL9ror2C75US9IxJJsEsHdGFBil4yYuUwknofJgF4XcEUfjrz+X7fKo4EJJ//PkMORO6FrVjQMeL5kJhZMMXzLwNZCt1nzDFgYT8cQwpLt4hDON0i/X7ys5OrAJVe0S/ISgFY7j9ZvnQ7I3+lyqpYaL98CWp/N+nDkZdhi6bW8An1kP3fRTLKVWlwF6RZCH2L4zDDR0k1IqeTNb2OQSYNbOQMWxtMxeqtkY6I+ny9VEz6btfb7xc+XXB249AoXv85+tIBVgJJ6n4lf6oV+mfjdDJNMH0wAVFX90GMk1f5TxlS3Fggh92DyN0IORy5665KIfCktsl+K3VsGtpVOWOMiuDCerlSnjQ2rB+n3C+pIBdulz8wqonrNPLKgwKaC5B3s53qhXVq6oDNg6sOhqvqhEr3V2VNLBjmnSSNdrOLJ1zkAu6VPRjFcFz4fXDJ8i45hG94Gt3IGjOFYA8TTlQZ/qGH1oP1+8ZtlT1MAtHK8mQg25zOZUSCLIliWcbw8wfW5Ln04ssqnHX04euiCk6/3de66MPpuAQVZAEFkw2MKFw6a1wEL4+lSBvmAOMhD8vkOkFX77feLNw14YT/ssmc4A6oOdHBEkwXlgjH2k4Nal6wB4fIuX9LzZjAmorNeHMo5Tc0OewHwDTUh9HXxfGJsYkAbAAAgAElEQVS/uvCpoAcew6zBBrdyBlQwwoDxdLZWXLDFkHyF8xGE/fb7xR8XXByAAVC1oB18HQYIT+8uGfP75SCUs1o64he8v4j6cIQ+IqkPhxrBCHjdjBH6AblQkAeY1ondukSiELmsUPpjbyp7XuvDgAXxdNZVvWCLIfmKg6Bbhrjup98v3lVwcQLw8gqA5v9zC9jErutltg8gMxDWWMBaMVkmANWFyEV6R0uH2I1IzW7ypbkQOTP5f2ch9KsFkwp0kQlDAOmxzHpscGuGAQvi6VD4RgmAg/b7xZVlT5MATNXwqQc6KGwf2U2uGV2uzg3D4ua7fDnPwZcKgIdq9GaIBPZb0YdD7hgyIFWMXiH0eQ5vXS5HcMkc++9lz2t9GLAgns7KxxZsCkgdtN8vWD+vYDMAUpcja7lOR9eLVcIP4tcuob/3AOHCdW02VTX62ApB4Mv1v24gnPy9HiH03fJ366KYHYTHsgBBg1s5AxbG0+HLZaOp65i+ln6/YM5EwdYBwGj1cmUkE7+8THLNdAHhwrUOXtcrO/pwhF4cct2oN68BMDCfmsJM/n6PEPoYPp8bH3kCkbtjji2tJJA962YAWBBPZ0WBCrbYsFoOf9pDAiENk179fkuvf9nTXewKcBSjsn7ldonWbgQpx+26otaLIwAlfi2QQSJY3Yjy5i9dmsFM/oEDMM/Z7Uf0RiYUA7J+ToNbOQC3e0WBBm9qLad6HICG1ZK1XB5PoxnuOOIcxSXe/Of8xHV/P+FpwN47gKUpYHmuSve0pKZgCKSq5wqniWE1WZz/xouBm74KTMwBI17lVBXwtWSs+8/vL45Ff3vhpcAnvwos8d48DZX3M2hx9XIAnu0IIO0chu35AOgLL0yuG/jOmwbg028G/mNz1YWdETbm4I5BrFlov+EtD2wIo7l+Atg8D2xY7iw3V5diEqO54mnj6XdMAYcU+6gon7A3NSO2qFjlyZYDkAX6uD5Iam44YaUfVNDNxaJcLIPXcGGpfi6PnZdVD1wPspQBX/wl4OaNwN6Jqg+xwrxslcVFuYJblehkcYYZGPS3L20BxueBcS8nwg5H5kZkx6TQSbXFZcCQKadx5Cz5mPurAFxrRaa17pAR2PFC+ElSHKQ/0QjQcgCyGyM9v3SnsDBRJgL6msWCf6IfWeUJac8UFlpY8500DcCfvgb43hiwZwyYVhd2D/VSrKGAmIDnBkiafEcN9cprHgKMzgNjS1V7rRjRlceyrqif6KAkMgXIM+6tAnDl+zSL36O9+U8p9jGHQo285/2XA/AnXeNnKAorDXH/AILwbSvLEz6Ql2+cAf/3XcCdw8DkKHBwpOpFbE2wadzIdyh3jjNQirYWEwYq+/zJwMh8pf+xKNSwM6DZMmzNRRbM2K+2Ii6TlFrAWfd5V3i/F7IgT2LBF5LbIdkqxLPWvtzlAGQ3RpU3Y7AiixMxLOUB2t7pKQ8M0qCTnp8HkojJgNqaMEJesQv4AR3Iw8DB4QqAs+6SWRiqgJgY0HVDAdBA4Ba4xN7ndlSFAAjAYX4IPO5dBDMAdS2i+Jx7XTf1eEdTDfgAQnR34p/wQkRmjNAoByDT/ugFphXAmjAEn8qaPQAgZCs0lSckCNmVigEbFMsPBBE3DcBX7gLuawH7hoAD7EM8DMw48AhATrjtQwiXoqkTEwWd7LOneXNCbz6Tiq/TInb2M8ZzIFrTQbGiy92oGz7pXl/7jvdAJnb2470IbB3T77Sai+hyAP5voTqW6sKwFAc/TAdc5+3dvcsTrvPVYSK4SQb8xV3+6IaAqSHg0FDVh3iOIFTIFxtit9orL5Z/LD1Q4s+B8OnHVuXwhhdd5DoLGsgCCJ04q66X/Ju/vSaeAxDPvbdtmdtKDV90gVEPIl/xySkviOhmAEjrlzSkwj40SlQZYZ39I+8JBMx8mZryhOsKwqYB+KpdVSDFvhYwPVR9BD7uyX4SwRS59nNI+bRck/DzJ05v12M0nY8fAk8iWL5BB5qASPGRCi8EVjzv3mqpkC9ACrrwhKukB67GhpqRRowQMqCiYbj8oOoHeUWpdYIBAUj8c8WjrjyhNIJ1unzjDPjqXdUjJAAP8TMEzLYq9uOHICQALe/EwWe+QgddAqCzzD8+vgIgg0qp+5nYjaDzCgjmnCYone0klqP4JSgvvK+6LoFPoFMlkPGh+0rPWta4RHTNJJQz4M8EAGoNTPVU8opS64CC9zoAWTFChcq7lCdch6s3L4J/2QFIEBKA1P9mHIBmhPh3Ai354RyAAmWsR/PRs6vOR8Z8FMPS97yxtIlYgVB/I7jC0rIKSfLXF1EEB+BFFjQ3jCLA49OWsRTTEPzvzQEwry7VrZ5KwzAQAPssT9jw1dcHgCrORQCS/bgn+1HsCYQSveaHkzvGv1scgU/6R55Y1YIxhvOm1EZekQWl8wVDxJgwc88QiJc6AKX/meHDawX9z16M/Em7bO8Q08GBP/jEkAEVjMBoAFWXUjRA3KtNwOBXW3EkAZhrALktpC6lKtTV4OU7RHB+3kHWgv/zrnYZl2kCkF4uF8MGQGc+MqEYUCA0n1tkwxbw4ScHAHr71Q7W4++c8czwcBAmHVB/c7Bcek9b3FuwbdD/kjGWgzJjQ3thGmVA3jhfOyU+RxB6FamOFp8NrhsTgLy8Cpzm5QlVptAU+6CiNgXCaIQ0BcDYV8b0P4pi30vfIxD5+w72C9aliegW8MHzqrmh/meuFhYi0pKbs6D9fsh/n1XFMrYMbPgUByCZz6J+uEknDA9AornWFRb01WZEsACoHhOqyC7wdetT0QAK2KqOb5MCUvPyhLE0oQxzqaYNXL5xBvyVXe12vByLADjXAvgxBvSPGFGMIjCmJbEW8HfntxtQmxT0cmxp9UPAdKAZ1upA6EB7qgDo6oCUxXRtPVSpAwJpnUhuxAqWCCYK1MBExZljY5S8SYr+pxAFAuBayhNG26jw8usCQLX0SAAkwwcAEngyQizaXoziIli+Oe7/9kJvNk1LmBMe9ECO3XRB7aPeF0EYHNVPdT8gj016YBcWtBfBVYJuz7mF7VgGY/pO8f5WdQ1/7U67nIKNS7j0wIbDPFZsyNHHY7od/xdlEHj8CcC3TgCWHgGAPSxiSdt4312u/8SPAl8/Dlh4pDeZW2PD4J1c9+uyDaIDkgEJQKnTfG/N8nUAmu5HUnMW5ARbPfEuIHy/ACjRK7FL5pOR4RaxgTHofKl8r/S1ZWBnAGDKefbn3AFIPRPXB7sFiVQimKVgGdl5ooNwLQ1/1U+DQGSXQ9r5Evy1q9rZbP1lGQDZsPpzI8APHgXgod7qUx11YtBbFzC+/C+BL7SAWwhgdoLkONSLqy5oLogYft3ZI1F7EAC+phsAnekokhP4HIzml/PvthQWmPB9LJ7jxkcSr14jWj4/0wFlgJD5eoDw6fe4DzAYPHokWhHJZ3TFSkn4h7YOSOBwEtiMTv1aY0uktFYTmI2/43EMQmCuAJmUE0gmVD8EFdPpdnxhVhqzDr8F4NMtYM9Jfg98EVTeNu9Q2OFZBX7vr9vtgm/lcezczZ61ZNN8DCvilYCdPXqNDQpAlfGTKm0M6AA0PTAyoMSx64cRfPQHXsniOTI+fEWDFGp+Qb9BeySRBV2kpl0QxxGAlHDmkI56X6z+EP7UDYSdRgh/IouwIZ36lHabBE0GJ0r10Rgb/xA/tt/j/6aMAf+7R4CxzuBXWRGULwBfIrY6UNfpvLae7n0I+LO/reoLMqiVMbW38oUhkNkQIzZO7tIweGePcmWlAFTjAYHPVGwXxWoLYblEDkLuTT8MDPhXLJ4jALpaJB+ggU6xfgJknT7IKXIQXh4Y0FZCog+wxiUTwSkXUbSMV1rB/A31OXWuFpPUda/mRHKi1e6U+hA7Zq7l+A+UAfDtHg/LrptkQpZ727cRWOL9542Pa3rOvuOqagUltgtmJM08j4/PILbIDKz6w5PAHsbraTnMGdZWIwIzxIfeK0rn578J3LAVuH8CODRahV/FFQ/1IumIvXP1QudNfyNT8oVqcHviPcBd48A0g2RDuoDqHdb2SalZAdG9dnfDkAE0gXnH5ijWCDbKCq5/MRiV0QD8HgHQ63jG0hdsLGxA3x9Bw1Asli7hO3BwApgng/Gjvq01IHrXJ7q3Cz7E++YziF2rs1ZLZ+8H9jJsSoECWXj6igmR87aLgfbGq4GvbgLu2gjsHwdmCEIPSI1h+SkCRjpfUC3iNWcpoRrcnrYbuGsUOMBo7QBCxSTG/igxVcBIVGPWM1h1JYQPnyKNExGZMDIJ9b66eEBGxPDY1Y5nv+GCjfGAxD+DDpiawphABWZPjwNzNLAEIH4XCH0M7/5c93bBfI8Yk2cgVAdvdT10ifDkBWC/r9lGH51NhIsnsWHOfPmEUKT94WeAG8eAO8aAfWPAwVEHISNQlKQUglJjJExqC+H6Nq93kOpUg9szbwLuHa66QzFWkaFieXxi6hgVHOMCYGRuJ+5V4jYJIDKI9KlsAvFDq8QDrnb8NWVPh9EwdFkQ79TlSMIsN0Mi5s9MoOGno4U6f3YAvefL7Y7rvdoFLxOANSA8f7xSgWmd0kCQbmZ6mTLEnJ0UqWLhUkxlrBn6n3wWuGkYuGukCsufGq2iojnRFpafsU7MDxErJuZhYCsJosHtWTcBe1oeq+hxigJgXBrMmTBPnJKLrr+VED54ibHYvZos8sO+DNcrHrDX8YVVyglAKud0LtMjFPtNMz6QLDY7VomLJd671AEH4Xu+3g7nWq28ISvX58/hguOBg8vtFQvV/hEzxfqOevuTfpjri8vAWz8L3NYCfjBc6ZYHmBcitnFd06pxyb8W4gPlgonBqffTtdTg9pybqiVNBssyUsdUD7eGO9amnf3sXtxQipl7Wg/sD4A8AwHIyZMYky50Tp/xgN2OL8y051qw2hXzwRCEdT2nmck1RxHG+w5jeO9NFQBpR6ldMIMXlFWgVndqF2dVFsJzuOgRwMElB6DcI6rznemD0RnbwQiSRS3g7Z+tVIl7PC9kahiYZm6IizuLigliT/VoUog+p8P9l3wJ7qGEanB77k3VczroUToWLCsABud4ypaLCUoxf9i/9w9ADiICULrQRWuIB6w7nuZrwaZwLBGwClSqSyz3AhHbaRGEFGOmC44D72UVgjW2C2Z4lIF4ArjodODQcqUGqAxfcpG4mJVuVqcL5tbs2z/veV0tYK/nhTAqesYNHdO5PCJZos+WuzxHJIViuXFyJxupNLg976ZK2lizUKodilGUgzyGhokF8yw5Mf+qRkjdjfuDtwkkm7DTkNaBaQ2ox1q3eMD8+B6O3H6em8Kx1Ccx9ptWl9iYIUAAWrI3I3nHgPdOtsO5eOuxXXBdj0V1vOL/so3Cxef60tlSpYwveKf0pAu6ohfdJ8k4CUqgvr5jV6VGTBKALeCAh+VbZLTnh5gu6D44A6H8cVlkNK95O1WkBrfn31R5HSy+JCwPplAxRegE/2T+AloGncNmbQyogUQx/KwB4gHj8YWNTwRAOW0FIIIndoqNkTAxz/bd09XDGLBdMM6/pLKi5whAX60gCK2ujxzEAqGL2pQ1Jis5AJEAFHvTujYAKjRf+SEugm1d2COQLU/DAwQ44caEw8AtZzSIPgAvuKkdrWMM6M7xCMBoiBn4YpCE2NCfxWAA5MEuwvCCEICwlnhAHV+YORfDsWJGgPpMKwg1b9QpFnzHbD2BK2JGul9s8KkYW17vLALQRTCBpzXZpS4gtCXXMAkduuAy8E7PijPWprXJ5CR38ygw1fJDohh2BlRAgq2OeN7uTWc1D0AFNtmL54ESBsCaJcLkDajxj5ZXRiCIGA0waDwgjy8sk5+HY+X9ppUbJSCp6TnFCMXwny1WAFQ8rUAc2wUrRL6mXTAefWnFfnz3FpbagQKLAqAzoZjAKkkpXkNO5GCEvOMLFXOnnC4xIKOjnQGNdWSM+GqHQGd7JSsxUf+JzQLwhTdV4je1nQvr1MkPGtlf9yP2Dy+gAqZ6rQytfvdHSDxgLwBF8AmAYjHWluEDiKGMiqOVvtejXTBOuRSYJwDJAARgZAGWL9Nk+IM3SzgTydE4eec1nZHbtDaNAf1Dpd/SMx2END6kD0oXtFhBXmcY+OY6AFChnKnzl7NfdMR3qCAae2B+VVMYXASvDs3/X/zHJZcB84vuiqABEo0QPnhnwqQLyRURmZBPytnwHde0M1vN2lR6picoKULaxHDIEdHkW2iWg4/7b5zb7DSQAVd0/griV2JYojfpwRGEYsGBrOBmx/OgP5sAKANkcbFzNWTRnX/GSGImMYH/LYlk+gGvdT+bW+SWH+Ig1GqL5QeTtR2EYj5LVHfjw/ZDwL8yJ6TB7UU3VVoTjTYxYDK+Ivv7dzNAZIxpZSiU8jjKgIWTcykZkBawDBBnQdMr5QeTKI5iWCB09AmEb7+ucnOQ/aTPWn6wuzyS4u+R0Ob6CUGqJpIDA97AdqINbgRgBJ69CG4Jp6q/ckjXqB/RKla4WpkO2ODgHoynigA0JiLwaNiEt95YQKJ4FRC+7brKzRH9jZbN6iJYuSHm9I5iOAOhHNJfZkh+gxsBKPbLu3+JgaWDdojhMO5kkDWSlNTg4B6MpyIAjf3IggJgMD4MCARjFMU9QCgAykhSKnUCYHB9JB0wy5aTRUxmup4h+Q1uAmDs+hpXgFLnB6ULONOn5xACNJqxghsc3IPxVBGAiQG9aLeilWUJW1FvVXEN0TKp1C6At19TMSCBpz1dHtT/JH7N9yaxp6QkF73KBxYIr10nAMproB44qQGTj6sjUrtOFPtLeFQHLES9AdDFrq1E6M13MaxVCTNAXNFThIylLcor40zxtgDAPKuVwDMrOKw+SBTbtR2MND7sZwC7Qvm4wqHa4T/uIrhb+7n0EgbQdTijoyg+agWXT8llDsAFWr/B8qP1K7bT0pvtVwHhW6+t2C/m8svvZlawi2CKe37nhFtapkDnILRqBQA+v04AjMyn79EIkXO/DnzyCBwVweX4wxs9B4rRZgyPVFqykgDd+5JSpBU5r0vHyHz+jsc3ub0KABsZMCyQgeExKyFPVIz3lmcM6OfPAGCADYPE67Jfs6h7G0o+xvi7oyK4cLZfOgpsXwC2Lq9MwuuVERonKn4nSJrcXnQKcM7dwMMXgYcsVxkSebJgzOWPqdB1ad2f3gpsnwK2LXWeR9m3danUIV1lBSCPArBwtp+7DThuBti6UDWDmWA/DvXk8LRptfPtNUlihYZTOPCi04GH3wFsnwGOW6iAs5n3GeJJ+KLoE+9VDClQ8R6vOQHYegDYwuY3S6H/iJ8jb11ck0q9Qhoc9QMWgPBZJwFbpoFN88DGRWBiqQIgWyJY3lPozaGJ1KTEPh36zpTkJrcXPRE44S7g+Cng2DlgyyKwaclfFoIwvCwx9Zn3Q1DmIPx/2/sSaMuusszvjfXq1ZRUElJkKsBEGQyYhJCBSkUqAW1tsBdpuxEVaBzowXZqe1g90G2LotjQdmMjKqtBxQERdAWUAkUlZNBGkQRNyIAEMAkxpFKpqjfUG3t9//m/c/+737njPq9uVeqcte66b7jnnn32/s6///3v//++Tz0dmD0KzC4DM6vAFpd/0L3Gh6yTDgnvLwKzAWDGiH/ThcC2OWDrErB1pRgQisIQhAa+AED+HEEY6uNLyrRnZLSl6tSbrgLOeBQ44yiw8ziwfaV4UGbdegmA5QMTLFlqsfn7XecDW+eAmePAltXiXnkuZSBkRcm4UGXtU2uo3xsAZgz6y54JzMwDWzkgBOAqMMVBCSAUObh8QuN/CiTgcWAuyWhL1amvvBbY+VgxbW477paa7gIBqCnUrbUBiQuhAKDUot13IbBlDtiyBEyvtO5VDxvvVfxW/JkWNFrCeK8NAGsY7BsvKQC4hQCkJNaKy2LRIsg6SJ3IQSe1onKKC2CsOYMeN+0Dtj0ObDsGbFsEZmWp5S74g2Ir2uA22BScAJGA+dJFwPQ8ML0ETAUAkgDTPq9zdK/+sMWpPF19NxYwA4g3PtsHxAE4SQC6FdSgmGWRRIJLZJll8EGKjHiX1jwaN10HzD4BbD0GzC4WrsKMW2pNobZoCu6CLCDfCTqzgg6sr+wFphaAKQfgZHKvpRSYg7HN5XCL2AbAZwPrZGaj6ippXhgn0kqmU1woxnHedg5AATuWHig2FE1uVRwoxoX+Wcbg89S3AqCKPONcCi8oPtVP+9++G3j+oSK2xRBFDElUxbTS+3nvc4FpDsjxllXQoJg8FgdCQoGJJTTicLcQ6vPL6wbg9cDM4cJv27oAzFA5ky9/UOSvmg8oP86n0dICBn25JwjARWDSAUgBHN6vfdbv10AbARh8X91vDM2ss+NvAECKPVLCsHoyUgRqrlbnRwB933OBc+4DXrIC0IEmiLnE75di8HsyAcjzWUVGUi6uICMpVwwJVMXdeOk3XAxc+Hng+vV2esAYw+sWoP31r3eLcLwQBeQUrEHh4Jo2h4vDmJPuAyMLGAeEn7uqbgB+I7DlSWBGCwe31Gb9aL20kGDb/EGRxY6WTz8f2wtM8l4pgL1SgM8esHCvsuylME4nn9cfQLtldg6TZ0kUKorAfij23vAPCmqp3fcCl60XFINid1PlZrf41/dnApB6wSQjutUfIDJR8CGIQOwWEH7DywpKrWc8CFzqRLHkVYrB2jS2FQH5vkuBycXCAlIUUAAkCM2iRBA6+ARCe7DjYmQduLYTleiQ/XTTS4DpI+6nLhZW2nzVCEBaMLd+soIGqjD1ampdugiYWCpeBKA9bBJC9ActAk8LES26SqsftInLZ44dQif4Igdhym5WLrPDyuYH/7HTCNwDnPko8LXrBccjQaioe6BiKad3+QY/MGTH6rS3OBvCnQDuAIyqhiDkQ9RX+29yE3on8IwjxQPI8zkTiApGU3oVkD/4fGDieAuAdMw5MFQjEgg1DYsUku+a3uI0TGBfV7PotwHwaOEmbHEATvuDIutni6UAQoFRIFRYhfe/dhEw7tbe9Of0Si1g8HkrwRcevDajz07gIJ7n05rYyWIpb4ya/7vv8PRdFpj/LXDmkQLAnA4jCCOlTBRN/rFMAJKgkkVHpGUjySSBSFeg7/azqk8EgbSEq8UDRACLKDXSyaQ7Br//DcA4LSCtwnKhTEkQcmAIQhtM+Uaajl0uS9NatITXWzpzfcdNB4DpY+6nBgDaCtanYLN6fCj4u1ay0QIqtML/EYC61wSA9tAJeP6eWsAoDysFpg1eB0HIQRCIIkVeCqQf/05P3WCB+UPA+CPAzvmCaFWDKEuYcl1yMN+Y2dckqGTeHPEvvWDSNhOAfbefX0A6rS8CUw8X9066bFIfdqMHJID++DJgLACQumyc3gyAEYRRKFCLD1eu5ODLF6QvXedx0w3A1BwwxdAJLTXjd8seQnGrZ9bPFxLyA7WIKON63tYtCQBN/sv9QPm6BkLp0vl9t/m6ietR6fbyBA4gnXtORwRRpNnTtPpW6gWLH83lKqcOFTEnDiKtoHwy8RNFhrefyeztbnrBfbWfgttsP+kIyO32ELD1cHHvInrlvWs6TsnB7qAUlg/suFtAWkE55zYQ0QpqcALoNCXTEt7A3KoaDwGQfqoAOEUBa7fUbKctltwCajVbxvSiyvoasM0BaBKwwdKb9fN7NfcqBWGiSWykWXER0umeacUEonQgCKRfIgDFjya5yq8Wfsfs8dYgiuMxgpAg/vnMzu6mF0z6Zj5APdvPQec0TEosnvQosGOhaLuIYvnwEYSithE52F1XFAA0p5yigD4otCqygFKnpHUpLYP0OcKURYv6Mj4MNR433QhM0gL6QongawOg+6rl9CswKoSkEIxPyTsuAPigCYBmAXVfYcVf+n0SRYw6dP1YwNgHsgSajiJP429RrpWOM6cxDiJB6NINM4w7LbUGMQUwB/M9mZ3dSy+YVG0EoBiDBST5ddZ+PkCsAiIlQZDa3LVatJ0WXG2PbL98AB+4omB3oP/HgTUhmGgBfRqWf2TTrUSjExDSP/qWzQDgfAFAWyzR8rkFtDAKX75jo6nUguZxZ8NByHbvvqBQ36T1swcsBaBAGGRg40Ir+rt9WUDhQ5ZAU7Es2e9LLzglqHRxNkbeuW+oQRRls5jaMjnK0a9ecNf2R4LAwO829kQB3LTtEYQPUwzQAWgW0AGo8AQH0ljp/V17pm0KRcEifGuNOnocO1rACQbKPXhs8TtNwVr5uh+n6Zf3wDgu29g2FdMtOc8B6PdpFj08ZFrplw+ZA5FTvAQQ0/BT36FPDkRqBT9Jag7xYlQItY0f88j78sZzCcKPZlrAQfSCK9uvB4h577SCotUiEJ8opq8IQFl/PUBPEoBLxbRE62LSqG4dFB8r5bHcOtiOQSqT5T7RKzYDgJx+BUCCTxZQCwhaQc9oKcEnEBKknj5FsJ1LAPo9xoWWPWDy+6IIoqbeaO0VA+zHB0zxIQDKkn1GgtXiRxMIAx0Vn0Db+lkuFjLRCt5WEwD71Qvu2H5OfekD5FaciQay/GIbFgBXriwAyGmJADR1ck3DwTE3TQ4B0LetzBJErTYAr2BBSI3HTS8tLKBZPo/fWQDZp197Z3scjGb5BDp/L3+njMweB6B83Gj9wj3atOsPWin9WgXCFlVO/3ctf4iD8XkBkH5USlAZlNPZAQqARr5vxu1yjmH0givbX0UQKI63o0Wun/xHuR8E4VnPK5JQLd4VNttTBvK2uoiKOUf/f+GjwMNBh0NMV6J0c0NpcRv7mrYv3kh8/uHxYp+bVpwLp3R7sts2YzouSq3KGa+q7+x7Co4nazAerRKsVlV1QitF59dyyFZaYY0HMu9mWL3gtvZXMbymBIFMZ1ov2h0B+LTLisxgW+Eq5uU92iZ72ud9vvR+4JFp4NjkRh2ONi0OB1/UBCkvEYRhfuNs4OmhhiPKnFQlx6aAjMnSXJUAACAASURBVPjmz1w41nnwO4cCIBvBwZgTAOUHRq3gyDExD4zRGVYEnpm5LqmQc0M5esFt7acFl0SlHiBxuTkYxxdaihUC4QVXFu5FCUD5QtJl85sjGA0ziQxqeu/fem+hw0F2fLLQGxFlYMRvo7v1WmIVtpt1DFkXvOR7LwJ2HSkyoZmEypoVVe8p7b6qEMnidGG/Vl/L2aPOIwuA1pAIQE3DAmFa4j9f7CPaFpCHKujr5xzZesGdHqAqKz5X+FLRAl58le+jui+kTBALMcgZ73CDBkpN2/7+bfcWOhwUyCEAjQTcAVhKdjkPc2RajewKyu/n1//qJcA2uhBMRGXQOcn9U6JIOjXHQqSYOsVoQp1HNgAvz8yny80H5PVz9H6RqVd849WtXQ/zA0Ow2ayGLJ474L0G79vvbulwkJi8BGCg4S01SKqofoNvSIC+5zkhFUupV8rUTpJN06KpaBkFQm5M1HlkA3AyM5/u9Zl38zrk6f0iU6/4hmscgK5ISUtCTowyDqb7UxwsqFJW3fo/vbuIBJEZ1YRgyHwQKNi0KEl1OKTCZJdxtPDn//v8ooaDaVgqFyiTD2IKfcjZS4Fo+7g+HXOPv84jG4DIzKfLzQf8KVfI/FNKrQ6h94tfz+vOA9cGAAbrpylY2SDlVTTt+uCnV3/V3a7DQQAysJAwobZJgUXi78Qayhd812WeiOAZzEyUiAkHMeu5BF5FwZQAWLPwknkLQy9CrPMy8+lIHZFzvN3T+YbV+8X7c64OHHix74V6zIxB+RJ0wQ+UU992tYoFy3fcXcTDxQkoPsCUhFIczKVCegSg5B8A/PILN9ZwxBSxtiKiUAOi7JW0dLTustF8AGbm0/1o3vjjnSGdj+lYlGwdRO8XN+c1wABIoHk6k61yuSCJITq3jDY9Vx0BqK++uwAfX6JkI/hME0SC1EGguiQ+isqcQRLrF6/0jO2w+6FMnZhyZYsQ1W50qOHgPX1NXndtODsfgMwHzMin+0+ZN0S9YOllMzWfLwKQSS396P3iY3kNOLDPM1y065H4gOW3p4uTDkB8zWdb7FgbdDhEgJkCUDRvogTmd/vPv3BVAUBuvylNzAAYi4hisVQnEHoIqWblrxqm4Mx8ujfljT+YjsWBYgIOc0oJPsq1slCpH71fKybJOEoAuuVTRSCnYlmU6P/Z4iSJEcbLv+Yu9/1EAh7JKEXDKxq4ChUiKymRbwjgHdcUWTARgLYXHSr2LOU+BV7MVwzxwOfkOWybYAGZD5iRT0edjpxD6VhcOQ6j94tP51wdOHBdMeXa9OqWRcmWXA1XLUIUH6zyCwlAs3z+YBkfs1u+VIejJEF3ckrjI9T0y/aMA2+/tgAg08VURKT8vbKMUgAMIGzzAcOi5HknHQAz8+l+MW/829KxhtH7tTz+jIMAJPCYMULAWd6fvi+EY9ouoZBM/Kx/4LUBgFLgNC5o16FrE8JJVJgkiFhaQQBv3+dVbMrWVsC8UxFRkjjaVsW2DtRdOJ/vAyohVYK7A+bTvTdj8HlqTMcaRu/XxHkzjgNkIOWuDr8jnYYDKDutgpUhra0uAlAyCCUAK8BXcjBXgLCk/h0D/hcByDxFAdAzoFUqUBYRJTUcMWdPP7ONL6i5bLQeALJRQ+bT/W7G4AuAOXq/lsGdcRgAY+glLkYclJVTsa6ptCX3uQjAKINQstFrAZKIwWxQIhIJuovB/Nx+r2LzFCwlj8Y0evl/MYk0kieVtcvrwGUnHQCVjjVkPl3mItQsIPuElx9G79dOzDgMgGkAWlNyBJn8xKprBRC+zgEo4LWRgcdVcOCjjlNvmx84DrzNAahaFZWLygKWxUNibIhTcPD9BMLLa65bzreAMSGVoXvJ/Cgh1WUfO+XTZS5CDYDs9GH1fnOrIDcAkABTTDCCLYK0Cwi/586WcKJUiEpC8CCBYDsiiSplqUIUmOjf+o2tIiKVUJbgU5uSWl4DWwX4+PcXnrQATBNS+8yny1yEopdcay+930y5YhgAg+9n2OoUeI5TdQer+32fdhmGoOBZanBo+g1yEKU4dYgFSvqB//vZBIBt9RshkTbW8ZZZ2hUgvDL3iU3uux4LSBM0ZD7dPRnTH08VAIfV+2XAOucQAMuVcKfFSD/+IAABsEoGwYAoHZIKEEYxRIHwLS8pUuhjFVs6/ZZhIVWyxVKBBIRXnbQATBNS+8ynI4tBzkEACv+chlUVIKE/5cRGsWmlKfIzudc3APLQSlg3E2OCyVRc1kpU3DgBmKoQsWtlBcswjPu+nfTYtBL+GQdgOf16GCZW6pXlBCqWSgqJypoOAFfXXDifbwFJLvi5HAjlnUsiIe6AjOp4iQNQHRlT2PlgJCUbbc2s+v/hFwFb/q7gm6HlYpBbmTV2sscQyy/qFBj2v0/cAdz/HGD7NDA1AUyOOU+1CwWOewNjKj6/O03F1/WuugW4/XJgfBoYmwDGdH7IxB5kLPIB+I8AfNwZgga5ck2fJbEm8V9zNWPfrasbgMuPAcuseJ8Exsb9FdBhA+7gaQNKB6TfcgCYug+YJT+g89aoBDMmIMScP12uTKj13uDv8zsKig/uJ1uQOsnojm3qB5P5ACRBH3OhPuzzRN9DV88HqQLEWPJnvTy5nm/t/1s4BcuSpRZtGAu4fi+wtBVYEyccrYwn6hF8/FkJp9bKxAKVFsn/d8urgbHPA9NPOEOWl4+2cfoFHhfVrJTZPKHSj5daOtup6JyCpPx8rHWRVQ7WOlrYCMx8AHIzlxkALPD9c0VB+x/A3E/+E2fUYHXdF7KTGwdvTd0AHP9r4PgWYG0KWBdfsBdsMPfPrKKsoL9XAVLAvO2fFylCE4cKliyrDVZNcGS1CqEYhWFiAZV+XntaURdTLmpCEbpchTYLqi6NrkMCzLzt5Xc4HwyJmmkJ+Z73jQOh4NWeDUZiK1K08f0EXt7CMHVawIk7gaVpYJUA9LI1Ao8bzKX1cytoFtFfpdCIWz7rgzHgth8u0oPGDwETc8CEMySUzFaikgtlpW1Ta8JqNba7lVljSRgW+Q6ZP/57WQvj6fydBjXfAjKbgEvMLwWCvhNoipgNpnQshlS4IGFWzIk6ylWwAz93ETLxGWB5ClidLABoIOS7pmGfG+33YAG5mND0G8F4678vkiPJczNOAC4UyQm2N8w94kirFlfIAl7i402d6dbPWWAtrsjOFiuCvAJZOQE0pHTFsckHYDeCvhNgipQNxoAz8/8IPr5nbvH2jd+6AThJAE4AqwTdZKEBLDoDgU4+YVkPHIBoPwareOt/BkDexsMFAFnbzNJYm0IDnVwbt4uyur1kwL7Tp+iZM/08WT9Rc7DHUmuYTr/x+6o4ovvu9fjBbgR9JyA+omwwxvZI5ULg6ZW7y9FPf9QNwKm/CgCcKABovh8ByVy/UCtJq2f+X1yYJPGU27lIZLbuEWDsWBHesZeDz4iURLUWa1TE47LqK12fZmd3OXidFctqm92KatVs1jAEsNv6sdymaa2g8+xUL4I+Pn2beCgbLGWHI/h8G3oTr45iK86POlbBU9yKI/AcfLR+ouQwH9BfmmbLlTHboOnZ/T9+5vaf8FUaAThXsFOQ45mUcgZCWTAxe0UQ+urYMO1/37GtxQmoLCBtRSp30LrDp2SFdzYMgk/R+VNwvwR9mwQDsaspGSfJgYDYNTbp8psCQFJxEIBkQjDrxt8dXCUIY+COH5MVFPi8SOn2n/QYLZ9Gp0cxANIP5IvAkzVzxivRydnKNzBa8fddM84b6AFyAriMF2pajk9kYIeoClXmA3AQgr5NQEHMBqMVFMNaIOayNRL/vhlH3RZwmhbQQUcAasrVVGz4EtjCu/3dfb/ID3PbT7uKAZ/MhcIC0vqRTo4W0IBIEAmEtFwCYqjW03bcmdwBYeoWgetUbrR8snrloiR2drpACf+rD4D9EvTVjIJu7HBV+781X752Czj9lwUZkTEgcPoNPp5Nv4oBRhCG6dd+1DkMz1JIhR1BAHJ7zwqO3fIRRM5tmDK5CoQKsSgOeBYBKFZULTqcB9r6Ni5KYmd3WKDUA0BlhNLM8EbT1QBXBU72aI5ZjUcVOxz7WLkQ8d37vsart/uA6RcPsxNSAtAXHDYNC1AEpf9s01kKwuBwGU7HgVt/1jtD1e60fgQigSe/j5bQp+KYpGB+H62jT7P8/ZypBIC8Dhcx8eY9wF015abhmnoAyJ5WSrKeNgKO9SHxnT/LSasJBim5lRjWBEIVeROInKL1qunybRawLgASdEy74qjaNNzJCgqEEYzBGvK0297mAFSHEIB6ebKDgc8J1ksmV8t29f1en6L5v6cxIK5iK6Xne/5jCTiFcTqVn/r/tWDPWwXnEPTVgIKUHU7ljASawKefIwDpMdRxRB+wFgD+RREDJABpwSzz2c0LfxczVjkVKwaYgtBBezu3SvX08d39P5uO3QKahXMQciourZRAGKZWar/YZ1xXRPe8wQr2AUK7TvbOVTZBXx4MBECRnConUBSFEXT6mf/TK+/qmzAF/0UBOPqBZYF52HrTFCw2LH5G8UCzJEko5nZqmRnPh/uCXmpnVpDTsIPPwKApOaSA2QLDLSHf97iPx0tpISLfz7bl4iFfsUsnj+HZWEeOYDCDnDmCvZkEgedcCjxGseIhBYt3vx049HwMLRh8gA9gh2MoH9ABqKJzxf0McO7XlSAU4HzhYYFq+5D7hwBu/98OQLlIBCKnW39SlXNY+nqeiq2dkQg+gnGPb9/ZpT0lq6MV5D96gLCwgDmCwbdnCvZmCgY/dxy47xxg5SWuUjigYPHFbwA+fyGwfr2rXrMvPB+vp3L3GHCgi9JOHQCkRVPppeUBigXLFymyejYTB4YsgfA20ofRAlYB0FfAlvQqP0/TsX5PLOB5DNu471cmIwiBaRww/F01J+mz2pqChxUMZvpJlmBv3iTocsW4dzewfhkGFix+2febXDAeJO/YEILBB7pU1g8LQFo98QASVGYNQ6DZfEG3fnEqrgLhbf/HV15anbkFNCvohWSl9XPQ2XTM/2s3I4DwPIZwBEDfgitH0Ek6N6x+u/iD7T4g/YdBBYPpWHEaHlqwNw+AQa4Yj54JrJO+aQDB4pt+oCAyYvOPEIQDCgYfeF/9U3AbAMX7ItAlVtAspKZdz5SOlvA2pstxjES3wJ+92NgAGK2gwi78QoVfEhBeQACqNNP1RdoA18kKdgDhxkUI/zKIYDCnqyzB3jwAJnLFOEIW7QEEi1/1Y21ywVglCAcQDD5/Efj7M4CVrZ5AKlkhxeQUaxBI4nvFzxf8IfCVC4HV7cC6ZEX5nen3VX1vAGLZq8ysrvHY+QBwbGfI2E6JpLvdX+ksthpUvQrmX/sVDGZVUJZgb17vJHLFeGQcmCdVb5+Cxd/5xjZ6QzzMLOQBBIOfTV2Ps4HFHQ7CLQUQmUrV0rgKJMsCjsxGAqTn/hzw0EXA4tnAyg5gbTYBorKkUyLnkB9YVhTxu+kT13iccwtwdBewPAus+b2ar9xJAafqfgMQO4dh+J9+BHe5gqZZZzYok1JJUcpaR6bp93P+W/N6p0KuGIemgEWKgPQhWPxdP7NBLhiHKYHUp2DwpZ8rLOD8tmJQVplOLxAqmbRKC6EDYC7/CeCRPcCx3cDSrsISrs04CPm9ArZk55UvKAspYLqPaPdR4/H0g8DRHcDyVr/X6VabLHk2PhjpPVZY7d5xwF6CwS9y/4LbbVyQsEKIufGiKe0p2JvXOx3kinF0GjhOQY+oNRtljji9TQPf/fOV9IZY4Gq4D8Hgy/4W+Oo2YG5bUUy04vUcLCqSJVRWszJbNgxSmMau+q/Ao2cBR88EjtOqbgNWWaTkIFz3YiWrF4nAjtN0nBZrJnU+/8PA3CxwfMYB6LUra3oglL0tps6wlVha5rLiqd9AdDfB4Je6U0s/0BXTDYh80Sr2FOzNA2AXuWIszABL1JaKWq1R+nwGeM17OsoFY5XTVw/B4Cv+Djg0C8xvLYqJCECzgsxmZlq9T8e0XGUyaUizavPtxoFr/zvw2BnA0Z3A8e2FVV3x6c4sqwObckeyhiXAowUSADhD1XhceDMwx37lvU4XxVN2n3rJIocygkr/Vbs7fe+EdBLcfaXXQ3IPWIrpBB6XlnwpR76jYG9e7/SQKzarxM7qJFj8mg8UarMV9IZ4gvNDD8HgKx8HDs8A8zMFAFnPYQPDl0Co2g4fpDZLqKCxT0/7fhJ4fCdwbFvhRiwRgJruCOwUgCpeCvUjZmEFxhfk9W969kW/B8xvKQqnVgg+B6CB0MsI7P70AHgmd2n1NQ0rv7FvALIlVYK73MnQCDLThSGZoDpuP7uCeuX5n8zroB5yxThGnQ0CgyBMxY63Aq/5aBHG6EBviDlOLV0Eg1+0AByZLgbl+HRxnZXJoqqttA4ODovlJZVuSjTQFtq+NwNPbHMAzramdVpVs6wEoPtdNg37wJfvsYiJP9NFqvHY+7vAwjSwxAeNxVO8T6aNVRRRlT6hHrJ0Ovaw0WDJCKng7g86APvNB9wg2JvXO33IFWOBgn8EIf2nRLD4tbe1+AU7yAWbZeskGHwVdd2mgAUCcNKnJgLQrZ/V9/Jnn5JUYmnAE3hCmv3+t8AWQfSzyPK/POOgJgDdsgqA5nfJAvLdLV+bz0kK4RqPZ3wQWJxyAPqDVhZQyQr7gyaXI9axWCFVAGLvRUhV46PgLnUWBs0HbBPszeudPuWKsTRZAJDTo8l8ui/42juL5veQC7ZpsEow+OrZQlqVVuH4FLA8WVyDAOTAmHUQCAWQkOlsQAwDt/9/AE8SgPQpNa07+AhAA6HLXbb5Xr4IaAMfv/eGvP5NzyYA7UGjBWTWjh40v9fSyscHLtaxhJWxFVsNNAXH1khw983+DYPmA5aCvXkdNIBccemfceooAfhAAcA+6A2xLuAGucxrzgKOMexDfV9OwbS2BB/BEoqLSrBoYGgJ3E8qLcIEsP/ngCPuUy7S13L3wb6PU56/m/Xj4Ps0TKCXQA6AXuNeZY3HMz5QANAeND1kwcKXlj6wOZQ+b7R+Pi0PD0DeFAfk590CKg8qncfoFzIRVWVqfFfBhgn25vXOAHLFWCDbvPstBsJZ4LUPt+jdesgFg+qVptWq11bg2gtgfuLiRAAgQeg+oEmsOujsXb5SsAoCIN/3vx04OlNM6Yv0tdx1MKvK7/TFjVmeCD4HQQQhf159eV7/pmc/kwCcKABoeYvR0oept7SEoZQ0Tr1lPuPQFlAtO0nyAcWhpzw/FSjFzGjLx+RGvxzoSeC1hwsA9klvaFN5FAy+9mJgnhaQ0qqagglADo4c9AhCDpJPl5ZommQ8738HcGw6AJBW1VecZv0cePwOY0/wl1lAD/WUCx0mMlDLr8bjmb+Dwp3x4nkDYbD0thIO5aNtfmDi/xGEeRawxhs7Vb/q2huABQJwAlhyy2cC0xoggjAAUCWWAkksOiIY978TmOOqeqqwqAx3WGhHK06n7TDwOcAV/iipPAKjwgrZm2o8nkUA0gKmAHTrp+o9MTrEYvq44o9pZIOtgmu8mafCV72YAKT/RwAy5OPOuVlAAk9Oule6xQRTWUKlWtkU/IvAHAHti5oIwDK841ZPFtCmdr0U8PaC9hVultd4CIC8P2Ztt/m5/qC11TJXlJDGGpfGAmYODgFoCxACkLpuWh3KCgqE8gNVZK4KtxgjJAB/2X1Krao1rfN7CWZf3LSBT4uAEIyWBVpipL7GgwA0AW25GbGENBTRx3rm1M2w39mmrFVwjTd1Kn+VAZALEE5LtIDyMWUBvbLNLGHgd5H/V07BDp7r3uU+Jadgn3ptxekA5MBri0/Wp4wzBjDbCnkMWMqVpE8GJwLQqvfc0pqbkVj5aNk7gbCxgJno30cAjntowtXNaZ1suvSKNhsYTcVKmw9F5xGE+94dfEoP+JYhD/8OC8eIPUsUHokVVKB78XszbzAF4Pvd//PCKVGIpOAr78mn4DZOm8YC1jco+w6EFTDDPJqeCEBZBa5GffVbhmQ8DtZW5TYOvPhXip0GTuu22lTMLSw+aAVl9QhEWjurI/aQiLJkTMLsX9R3r/ymZ73fp1+37OU9hunXSkdl7T3QrhKCtlCM59k2i5CMMSIAGdqxEIwrmptzTsCEut5yilKoJLAcxCq3fe8tLCDBFwO+tKjyuxSCMdYEXoeDrHcHvu0tTwLzmwHA4N/Gh6zNCqqeOSxC2lb8tQSiMwbuqXIqAcjFh2JjBKGJyShQG6ygVbfJegULWBYcMR3rvb6oCRaQwFPgl1M5rR7/JtBZOIZWx/0+s4QeY5z/1/X2tFnAxPpFELaVkdLN8MWGVr4pCBsfMHN8bmTKfCjZ0Ncp456/x58zLzfw6Qf3ABd8pUgEYmqk5bGyek06IQl1bkXScnlN/u8L24Gdx1qVq91KQvrpgwaAAw9p+wnXPw1YjyWMGtDo2ASOFGMU7SIEUzdYD34vMPmXwLbHgdkFYAtlGiim6DpxJtvq9LtlVr/aWKEB8pUXAOOPAFPzwBTZ9r04vdQ9Ts4pAZ3cd+yHxgfMAOH+vcA69/9Uxijmz/AerYpdar1lNSMYzV+vWY/34I8DY58Gph8Bpo8A04vAFEFIknIHohGVR62QhFRSYjQE6qFri2z3iaPAhHNNlxKwArI0Q1IAxwfReacbC5gBPp66/5ICgLKCtqnsrKKlrFZUFPKOr7osMTtdsxzqQRZ93Q1MPARMPllohUxRqkEK6gShOP0S+dY2hlRv99y+ovRi7IiTnTvLqmg6xDPYpqAUgRgsoR7MxgJmgHD/c4E1FXu7FRRbvEgd7evXWlbPpp9EgUjiJpwe6zwOMlvpAWCMVusJYPIYMOlSDZRpoGiNxKzbdIQlXONMWJbGtw4svdgz3El47nzTRvPrrKptAJT6ZrzfintvAJgx4vsvdQvIXK5VYF3sUZxmJUvgA1FOvwF8spKyBtM1y6EepI4LqVMedbEaTp0EIKdPKh5FqYYqSxgo2jgFr13j6XXHnOiSZOeBVSvyC8qC2r05FVvVw9cAMAOA178AWPMp2LJaaekiCPXExwHw660n1oB/niGQazwOkkSepbJ/72I1x4CJ+cJ6lYI1riccrVicUuVSmIW82pkwnHHVOKbFsOozQGkFkwewnBES37ABYMaAX39ZAUCCb82nIlo+40p2gNnvsoKunxH1xGwA/LOzdQOQJPIuHzV2GBg7Cow7AI0l33XfjOsv6oVodes6ISbBsAZMX+kJxU56KY7pkmFVhOciuvTzSt05v0+ryuT/9gDrZNe4wPMsI7VJP3GcP7gUOOdvgL1rRYJ0ZI5IV3hV4/wrGYPPU3/AiRhYusy2K7mU999P+z90ObD7LuBZK0Xdkeq9NSX2+o4HLwfWlopFCC0fgciBMtAFC8CGrYXVoVjnU2G7rTXrzh4kfRzLY1kyGwBoeiGcPiXb5eAzdXWnazPCSScb4j3xfmav8Cx2p50lAMW0VXINitCogl2r9H2dcctWwQxQsn6ZTBbMNtcgdKIbiZj51VcBk38CXPxoQcfCUg8pjcYgZScw/momACnXyr4leBhs5QaBTHpf7X8dMPYJYO8XgAv9e8QJlAZZq8D4xSuANYKPJQn0AR2AHKy1MACKe9nfFI6IEqduEWoHIJ9wlsVKLekoMCa9EAegSTYQeM4TXco2SEMkAHEbBZoj4bbYtdyCVrFqGXgTSxgXYTZeHLi9AMjEQRCVUXP/n4KUaaT8vVTi+Rtg7GPAuYcAWlMCgUVkQfJ2Q12yBvPXMwHImhDWwf81imsTiLSEvHZkr+jY/p9CQRD4p8DOBwteItai05qn31FFdfLlFxYWgCDUIkRkj/TxbCEi/89jfPZ3X2VqYSJQbmUNQY3HQT7hbv2sLoerVwKQHNEEoCsm8R4MhPRjXUGzVEIKIoY7yaEYuY4dgGb5RXruoSgtSCLLarkICQ9f6QNykGjFdjsIBaI4kGlt8W+Rg5g0HJ8qAp47nihAzFpuWtPIMBZJlASILvR6fQ0DCVbJCkJOJCqnk4pGpb99tZ8MopyiKDX7WWDiwYKXiEQOehCrgKh+eJQ+EQHo1Lby/zRlyf8TIbf9XS5ftIb8I92YugH4ay2pLusorl7dAoonWtMwQSTdOFuQSLTGHyIC8kxSIQuA4hwU2WUAoO4/grBcDbsfWElSzg+JCoYDoEGM1ixSkHzgF/wG7y8sIa3J7JPAGWuFJSQIaU01iJHUiYP4e33BrPOHmG/JMaOfTZVYRhwGav87vWKPJ9/rSH4IOGO5sITqg/ggxXs4TOaBAECbeoOsgfl+DrQShFqcEIhyyt0MbMusEkx76iAZXKM8BvXiZAGlF+KaIbaadYpem4aDgpJZQz6YJABV5VcHAJZ0v4FxX6KG5UpYs0KnqjhRuagEVgPglYAl9ciHf8mdUrJh0Qx9vkDBzBywfbkYQIGwahA/kglATsHsDzKA0BATiPyZ4NEDwIeoa/uFYKKXL2f24nQoIgd9R3yQCMTFqwIAfdBWI7+yB5ZLECYLETd85YJl+2YAUNosLIel/xYlu4Jsl6bhNhD6it4WJCvA2Zc4Gxo73RcgJeOqFmGR6rcChLYACyGojmEYdj59KnZ+tIQRhH9IvWA2hiREjDeRI9Cly7fMF3EtWRFawhQIf5IJwE56wdTIYdt7tp9ys1K8JnoJvod9Wn682PNkP4hUy1ndWgstAtBDMLYN5/6PAc5DGNoF4SrZfN+4+IhT8jqwg2Cp8ThIJ5vfSWBXAVCrWN9SMxDK+skaOvhoAc8me654pmUB3f0wyt+E8FyRAGmPlOEoiSD2qgvmAKoOm52fAuiTDHSyIRxx+lI0QxxADubfF5vffMmSajrWlP7nmZ3dSy+4r/ZzAUEHnQ8R70HsXlK+PgJsW68G4XYGZj0EY2EYATCAT6tAhmE0DXcC4faapcwMgAIfLb0kuzT9Qmw5uwAAIABJREFUSi+EfeALkSrpBovbrQDnkm8wAo8/E3i+CCsZ98NCpAp8cUekZyBavI4ET/TnaAk/RQCyAXy6uNSPA0i+wMeB6ePA5HFgZq2wpNGK3FUDAHmv3fSCe7afX8CB4UNEEOolVi/3obastNwJ9cO5BOBKEQMsAcifHWzRAigWWAlCn5K2bQYAOe1KMjTIR2kRUhKVS7IrLia0v+3xwHMZMCbYNP0KfG79zAqK5DxOvyEuWu6VD5KSHy2YAEQAfpaRdl5UkuUctIpBnCIIl4psD03FtIIP1ADAlBuJM47EqqUX3LX9kSBQcuuyftK78xUkHyQ+RLqHZ3Fv1KcgLj5kAQ1s0Qo6IA1nHhNLQzA8ZxvBXuNx8DcS5UYpNnoYxsCnUIqvZo0F3wPTMa7Hv53HOJVbS/l+5bumX7d+5WLE44hxIRJB2NMCqj9ixwuE90svWCaIA6bAp959EKeWChAyA0PTOV2unGMQveCO7bfqHbcS4rJR7Ewqnw5AWhLuImg2uFQAXAVs8RGmntW4+g2hB3P79L/EJ9zGvqrxOPibiVihAOgrWQOf/EBfBcsPNBBqW9Hv6zzGqFzmoXz3B9AePgXiq6bgiv4YOB9QHS8AfpkAFMMjrWAcQA0iO9XJiQyAnos2vV7ESHOOQfWCO7Zf7F40mZFQScRKAYBaSU6vAVcTgN7xXHiUFpDTMK2dFh56912BTiDcvpkATIXzCL4g3WXTZ4jpGfjoF/oihL+fx+0yWUABLwIwtYKKIabgCzHQvi2ggBKn0McEQDaKT5cGkIOo6SuyYzEfjQB0EM5nZgAPoxe8of3sgSqCQM3jkdFLvpRvR13+7UVRuhUFSavNO6otwp88ZZ3+t4M6HLtch6OT9AG/q9cmtf//gV1JDYcnQ2zY6/YakfSrU+Pg1M45NqPt3IEtoM7WFHokyrWKkooglCMWLYjiUXMtK3g8Uzd1WL3gDe3vRRCoUEYCwGtYFxxqgA2E/jI20F5hhmQod98BHNnlxOTig1aGiDanO21yV4DygWuB8YeB6fnC9WEtiKVVKeE0ZGiXWczeJoWMIig5a9V5DA1ANoKDeDylZ9NSXxyAsiKawrQqmCv2HVf5e8aRoxfc1n7xs+khItAUvojvyWryxVcWJZksVSyZoQRA3dcAoHzax4Gj2wtu6FVKM7gMgti02jbV476oUJJs1j/AbA1mQ3Pm8eTRsoZDtR+xZKCiEKmMXTIeXHPGdhYArX8FwG4DGMEnAHIK4yvT58nWC2b73cexaZgWWaEKgU1gjNbPP7PvOYGsUSBkv3hBtmRWNzxjTk9RWktvxp6POj0vARjY9sWkFel8RWxegjIF4RjwAOnZWMPBTGjqvHmszxJOBUD3xyznL2bqROvoP3N3q84jG4C7M/PpcvMBef0cvV9k6hXv+2Yno5QfGArRbaCC0mWv2YtF3ecerNDhkNZIIsXQRv5dlTtGADJSz2gEE1EJQM//026HdIEZLC8B6A0tk0g1Ja8DuzJdphS82QBEZj5dbj7gxZN5er/IZI+67pscgE7QaDOUMyC0Wb8+gXjuR4F5J6YsaXnFhBoAGEVvUhb60jISgCQnoh/OLBgvIrL8v7DdFkEYM5dtNg97tvz5zJqzdfIBmJlPl5sP+DJP5xtW7xffnzeh7H+Z+3+RpkyWT1YxuURJYVtx6T0fCTocouQV85VkHRIGegEuEv/YKpkA/JceVmL8kv6t5/9pu62tfiPWcFQVEa0DZ9WcLJEPwMx8uvfnjT9IgZyj94t/ldeA/S9tMaGa9SNdmsIxbvVscVJ1GScoMt4UPwhAsmMZ0aXzQBsvdGRBjQz0FUpEJRAJQOq4KAnBdz+sfiPJ3bOYn8fsykyVWMfiN3BOzckS+QDMzKe7OW/88aqQzsfE5kH1fvGjeQ0wADodmVGwOeiMsUqHrGOnS4UFy9P/wAEojkEnI+IqOIJQNLgpCXhcmLAtD/D+kgQE235L93tj+YBqgTX9BiCeW/NedT4AmQ+YkU/3sbzxBymQuZhm8g1T+QbV+wWFdjKO/Te2mEFNlCb6gPF708VJ1TXHgKd91GnZpDfi1k/gM2vqU3DUnCuBmNQe3P9vw6pe229KOvB0K1k+ZS+rnrfM2AlA3JMZtah/EZKZT3drxuDz1O/yxAwu9JgJxr3lQfR+8aa8Buy/wdWQZAVl+ZzCrG3q9c/YrkmHy3IRYryAAqAkEBIlopJxNNUbER+fA/H+/+AAdP9PmS9dazicJybm7mlB8nR2dI1HvgVkOlZGPt2nM29GCamcGZjAwlQ+vvrV+8X/zGsAAUiLVPp/wd+zaTMFWw+/kAA0GQQnpCw5mDsAMIrcRB5mC/+MAffTwgfwKY2KfmCZ6ZIkUShrxXxBX4yYaV8Hzmcn13jUA8CMfDqWYeQcSkhVOl8U6uxH7xekrsg49h8oiCENgC5TUG5vKxxT8f2aRtOtcAKQ1s8soPuOVUIwpchNlEEIOyNSIrrvv3hwnckWIZPZsnbcDyzTpvg3lU8mpZQqozyfK74aj3wAKh1LgrsD5tMxiz/nkGD1sHq/YNFOxkEAcuW7oqmXlisuQOT7VV2jwi/kTgj1RkoZhBje8Z83SCAEEJZW0C3gff8tADCt4VASaWIBK0HI9q8BF5yUAMzIp8tNx5Jg9bB6v/jdDPSRns0BWIZeUitIo9IhHmhXTvzCPQddccnZ76U1V/IvC4SBCFyg26DFNg7c++Mhhb6qiCikT7WVUmr6lYn2nRKyrdZ51GMBlZIc07GUBdMjny6XCiUmpA6j94vMZbgBMFo552pu27PXAqXTyAUQcitOQjAm9xX0N9pIwIPmSCmH5QuPqER0L4kDYgp9zOUL6fYxkbZcFceyAreAF3GlV+NRDwAz8uksnT3jiILVSmpWNlhMze+k94vMZfgGAPJeHDjpCrgM01Tdry9OzvmYAzAqLVWIwEShwzbRwwSEn+MqP6bQK5tZlWyhjCCCsC19Xv7gOnBRbgp7cu/5AOyVjqVMmA75dJZ9nHF0yohWNlhMxKnS+0XmMtwAmFq4imnYbrEqNJPc+9kfd62RKh0On8qV9hXZ9askEPgAfI56ziocUgVbzGT28lEtRMoKtg7lBHtznfZNA+CQ+XQWM8k4uglWK/NLYKzS+8U9GReXD0g/Tyvh4Ne17Yb4Zbr6g6y7/aNWcoPpjKRTsJIags5IJwkEAv6en05S6GUBfRWsUExZyVZVQCQwrgN7Wfdd41GPBczIp8ODeXfTSbBa6YYxlY8/p3q/udc3C+jTbtvqt2oadnB2m4oNgMn0W0p+hYWHWbwg9yU/0Kb9EIy+5y2hiCit4UgKyTeAkN8Valk4Le/ldlONRz4AWWBRM6fdIPfHstw/G+SE5rMnVQ/kA5AkLHS0ak7V7reXfhgACaBqDtD3e/nmc5k9kA/A80JReq+U38zGVp3ObJo/BvAOD3dtwiWar9zEHsgHIGlFubqSx7+Jja36anLLcDvvgwA+NDpDfILv+qlzuXwAXuSjrkKemlO2e3U1uWUYnL8dwB/5e2apca9LNv+vsQfyAUheX4VguB+mzIsaG9ntqxhF4Xbe3QD+n7/uHLAW9wQ1tblMRQ/UA0CaHC7plXEh+q4T0OWcfhleYTSHBK0EH/mi+fcRuKQn4I6fWpeoB4AevCz3HOOm9yb3F5mBlZBNclYCj1aRfyfrbgPCTR6AzK+vD4CyglX7jpmN7HY66d1E0ctdIrEEE4wEIMlam+Pk7YF6AMj7EwAVbU82vTerCwhAXopJN9zVI+AYrOeULLZgErY2x8nZA/kAJGWr0naUWdFpy2cT+oCWjpdjLFxE5UzYIBBpEUX5nLnlvAktb76SPVAfAOUHpiAMm96bsVtCAMaKALICMyxDq6cXfycA+b/mOLl6oF4AiqBRIEzBp7/X2Af0+fi1XIioMIlAI+AIPIGPmeROWV3j1Zuvyu2B+gHoFfZiDS2lC0LiY52WUADkQoTTMH1BFSYRdHoRfKSu5v9qrizMHYPT+vx6ARhSuDcAzzmDo5ZGHT1PAKYMwQxME2jiSo/gEwBrrq+u41ZOy++oD4BaCcsXTPiSI3ey8s4KGoG8QwCMFM+0ggQhLR0BF19SXuD/ayakz7uR0/TsMcxg3SjfqWNA0hsrga/ojaq/8WPcC+YIk4Ke4CMSuB2XVht1Oj8zIfXlU8BtU8DhmYRXWdfrdF1fgr3+S8At48CD04DVjXQSDO70PTUnaJ5uOCwsIIFHSSFy1pKPWCDsZxCpw8UVgKSPxLXM937OzxxAljzcPAbcswU4Qh4V3UN8mKoeKm/bu78IfKJQa8VD48CylHQiL3O3/qg5Rf30BKACMtJXjXKQcfBSK8Dfqc3KVCwuN2VFGRnm/yKZtq4Re5ifyQQgM2A+BeB3GHaZBo5MAIue0l7Kt3cC4xhw+5eL7TuCkJk1jBtyerbUfYG5ExjZ/pqrxE5fAOrOq5SmowVIrRp1IyT2R6+fg0bgVYG4CsyZe2UsaiOGKXr4Sfp9k8CxCYAFSKyvXeY1o1BxQux91yMtfsHPutgnnyUuUvhc0ZsgUXib+nVkq6+ZKaABIHsgVZnuwD9sVo66rrR4ImdhLGSQ8zPL/JgBQxeU1ouWkO9PTgDzbgmXxrzMkatl3keivfG5x4r4IRcz5BfkO5vEZ0kgpIfBZ8yKjlL17syy0tMNcOn9dl4Fy6dLFabj1Mpvow9Ify+I4Nlo9Xt+ZqU9VdJpqZh4QDDyxUyYOYJwHDg+DhgI/WUVZl7aSEt93+GO9Ia2iuZKOfA7lhp9JpvAVy61w2mOwO5hmCgMHC1H9O24gu6UD9jP+ZmbtLRaSsei9SL4XDPbAEh/kGQ/pSUcc0lbApFWb67lQUhpVnLBsoKqqZclFMmUtrxPcwxl3X7vOCAtYLSCcugFQmqhdssH7HU+RznjiOlYXA8wqkOfkItTAom+oKygca4ES8jY+N3z7fSG4hfUtp3ihUHruVSsFy1iRvNP+1N7A5BdJACmVpAgZPhGOyCigEjlPLudn7kvFtOxuB4g6OjD8UWLRkCZFRwrLCEXJQQhp2K+37lQeBCRX1A7KPQto1prFEmSYn2mB9EAsO+kYfk8KQhZF8yjVz5gp/MztyOUjiW9bCUhEBhKRCCgSis45uQ/PhX/xfFWMgOnWu2gxB0TF/o0kEZ/kCDM1Ts+3RHYnwVUL6XhDFrAswfIB6w6P1MrTulY0sum1VICglKwCEACqvQFCUK3gHcsFQCM/ILayqP1k9JshVqrncMalOYYvgcGAyCvIwuod8YBJQmZpmGJeyRwkGw4n8jJOJQNw3idLFhMRNB0SgASTJyKoy/4ieXCeFfJBUeV2SoAclFyR0bbm1OHTUiN0/DTAwD7zQeM52dqj8VsGEkVE2jKetG7AEhQ0frJAv6RC0trC1skl+IWlNinGLbSaZg7Mc0xfA8MbgF1LQV1z08A2G8+oM7PVF9Ms2GUE0gQyp+Lwu2yagLgR9ZaYpkSypQ6a6Q2DCqzpkvietXIFdoZfuieGmcOD0DeP0HEbBhNwYPmA/L8zJQsATAKnguEqS+XTqkE4YfWWwCUFZTksYAYwZfIBeN9Tw0cjOwu8gDIZqsoSSvhEeQDiiGYFoyWiSDRypWgi69UP5sc5fIcquSCNeXqe2X9ZAHfM7Khe2pcOB+AT41+aO5iRD3QAHBEHd9ctuiBBoANEkbaAw0AR9r9zcUbADYYGGkPNAAcafc3F28A2GBgpD3QAHCk3d9cvAFgg4GR9kADwJF2f3PxBoANBkbaAw0AR9r9zcUbADYYGGkPNAAcafc3F28A2GBgpD3QAHCk3d9cfOxqYJ2au9RdPtdp/khoEOlglDYT39V1PzQFXLsMXAlgt9PCxJKPbufyf8/KHIPfBPAZABf79Xc5XQ0ZQ1Q7360NbxoHrlsDvs5ZRsgo0une06by6X1mZvtP99PNAp4F4LsBXA5gjw8EGTeqaGF4QhzQF80CX7cAvGIdeDYAfhdZ2sTKUcVrpE7nd31N5gj8e2dIo2osk7NZpMdK0Z19tv+bJ4F9K8D1ACj8yfNSikHeg+5Z969m57Y/8/ZP+dPLKZhP/rcA+AYAF7g1oRUhEMUzFMt6eSJfX78b2DkPfM0i8GIAX+uWlAMppreUUErn8p2gzTl+2flg/sDbTkvIOik+CP20//mzwAXzwDcCuNTPJeFXpEpM6QEjIHm/zTF8D7T5gATYNQCe69aAloRTGulfBESBSYNyxR5g/Bhw7hKwZwl4vk9LnM5JmsBzUyDGAX3B8G23Mz/g9BuUa/0IiutfMkj7zwKmngAuXSvOpUvAWYBtF4BTnspIj/O8zPaf7qdvWITw6eZA0JLQEhKEGgxZhUj/dz3NzSKwbR44exnYvVKcy+mM5Km0JhxInUtrGkmzCPicg3W5LMGkQiZZTm9xS9Z3+4m2o8C5c4X15pTKW2Lb+fCx7WLtjYxzqiql29Icw/dA5SqYf6RTTilg+lYCIXmICKQ4IK9wxfSJY8AZK8CuFWDnanEua9ZTAMsaCog3Dt92O/MvnRGBtGwkqKRmMEkqCaa+2k+0LQDTh4rP88UHj74kF1WaATo9QHQ7mmP4HugYhtEKj4PB6ZQ+FS0hQahpldPya1kXTOqNY8DscgG+HavAttUCvBxInitrkgL4lcO33c7spBdM3kAuSnq2nx9gQfAh4JyVwvrxwel2z3p4aMlzH6DM2z/lT+8aB+Q/OT4EEqckWQSBkGD6EQKQnDCLwBSnYgcf32fXioGUFawC4esyu7CXXnDP9tOCsyD4KLB1rmgvX7zfbu2WG/Jtme0/3U/vKxBNAMoi0KcjkATCN3HOEr3UAjDrwOP71rXixYEkeKMFlSX8ocwR6KUXTJ7AaNE2tF8WfA4Ye7Kw1mwvX/yZn+eKnvcrfzC6IK/ObP/pfnpfAGQnySoISBqUXyAASS1AK0JfagWYcRDOrAF66TxZQU7jBOEbM0egH71gcgXSFZAV54NQtj9YcNIpbONCyh8Ygi8CVospApDuB63g92W2/3Q/vW8AsqM4gLIKBBIH8bcJwMCNMX68BTqBb8s6sGWtsIA6jwDk662ZI9CvXjA5A6NVa2t/IAicnC/aGV+8T74IQPm/AmGuBc+8/VP+9IEAyLslAKMV/LgAyIUInfnjwPQqMOOgI/DstQ5Mr7UAqMF8V2YXDqoXXNl+EQQ6N9v29aKdesUpWJZbAPyPme0/3U8fGIDssDid/pUASCvCaXgJmFguAEfgEXT27gDkuwaUg/nbmSMwjF7whvbLhSDL5TwwvdRqo9oqHzACkCB8U2b7T/fThwIgO01T1IMCoAZxGRhbKoAXQUcQTjkI+a4B5e5FzjGsXvCG9gdqrLGFYrpVG/UuHzBOw2/LaXxzbh43DKeoJwlAHqLndSs4udoCoIBHQE45EPk3DuitmYOQoxdctp8+rFwIWsGFYiFFoLGNchcEQC6e+OJC5J2Z7T/dTx/aApYdJ37AyJK/DIwvFxYvWr0IwEn/H1Opco5sveDUhSAAF4HJpQJkWixp6k2n4IYfMGf0amDHev2I8+l4/UbvNw8Eozw72wJePOJ8und7EkKj9ztKGA1/7WwATo44n45pWI3e7/AAGPWZ2QBkYHCU+XTMfGGQmYIxjd7vqOE0+PXzATjifDrKtTZ6v4MP/MlyRj4AR5xPF+VaqZLJF1UzKdPV6P2eLDDr3I58AI44n07ZMARbo/d78gMubWE+AEecT8e9YOn2Uheu0fs9tUCYD8AR59MpG6bR+z21gKfW1gNAz4geRT5dTEZo9H5PPRDmAzBmRM8BJzqfLiYjSKKr0fs9dYBYDwBHmE9XtRfMsIz04aQZ1+j9npygrA+Akqs8wfl0BCCTWRq935MTYL1aVQ8Ao1zlAnAi8+kEQGZTNXq/vYb75Pt/fQAcUT5dBGCj93vyAaxXi+oDoFLyT3A+3Rcavd9eY3xS/z8fgCQX/LPR3SOzkon55jg1eyAfgD8M4NcAPD6aDmBtB1e4NMDNcer1QD4AbwbwxwDe4UvRE9wHZG1gNSXDLlwLNcep1QP5APxzzwj9IIAPnXhT5ORc5EYCA9HNcWr1QD4AmRH6FQBMTSZZH98ZmD5Bh5g1FopiNns1x6nTA/kAvAfAEwDudnI+EvQxPfkEzYfaCXRSBluQMB7YHKdGD+QDsBNBH/9+AkAobqTADGK7Inw1x8nfA/kA7EXQt8kgrGAGMfBxZ5Cv5ji5eyAfgL0I+r68uR0QmUFoBQU8vfNvzXHy9kA9AORoMw7CdGQCjoUZDwL4kv/+8OZ1gJhBIjGDgMh3vTavBc035/RAPgD7JegjODfhiMwgoqeJwNPPTaB6Ezq/hq+sB4AcXeXEP+ZhGVo9vRimIQD5v5oPAZCupgDI9wg8/qz/1Xz55usyeyAfgMMQ9GU2Op4eAchpOIJQQEz/VuPlm6/K7IH6AMjgGzdl6QtyX5jWjpQFevF3lq3xf6yhrOlIAUgQCojR8gmE+l9Nl2++JrMH6gEgR5UA5KYsc+AZmCbQCDi+IvgEQMob1XBEAHIajgBMLV+0kCdws6aGu3zqfkV9AGTwjftg3JRVVRAtHQEXX/wbAcoXP5d5CID8GoJKvqDAloKOoIz/y7x8c3pmD4zhaqwjRzCYyQg5gr2ZgsFTLweWr8XQgsXjbwLWrnNtMlKgNoLBmZAa7PTCAuYIBlMvlWQswwr2UlUw45jdDSx8HbD+Ctd+HVCwePKbgJV9aASDM8Yg59TWFDysYPBtmYK91IbNOHaPA/M7gUXKXA4hWDz79cA8+W0aweCMURj+1HYfcBjBYO54MMY3tGDv8I3nmWSHOzYOLJ0LLPGXAQWLz3oB8MQUsEa16kYwOG8whjh74yJkUMFgbsNlCfYO0epwissVY34bsHw2sEIRkAEEi/dcU0SP5qhF1ggG5w3GEGdXr4L5134Fg4kAjuDQgr1DtDqcUmZETwArZwAru4BVqsv0KVh8/o3F4v0QXZBGMDhvMIY4u3MYhv95Zh+Cu1xBcxuOU/HfeDIq5cv7FuwdotXhlCBXjOXZAnyrO4BV6in0IVh8wStLuWCsUAyvEQzOG5ABz+4eB+R/ewnu/kOP/3G/l4kJTERlljQtIot2e53/IwO2OPl4FLtcnCqAp9cahT56CBZf+LpSLhhz1N5qBIPzBmTAs/sLRHcTDKbiNHdBGGymOC/3hglEvgjAnoK9A7Y4+XgiV4zVWYDAs/etxaubYPFFP1QkLtCIP8neaASD8wZkwLP7AyC/tJNg8L/xLNBu+YBdBXsHbHEFAINcMVamgdWZAoRrfPdXm8KitLdmgYveWAq+2y7iMqfuRjA4b1AGOLt/APJLqwSD3+y5T1yI0AoSbAxMMzGV1o8/My2ro2DvAK2t+GgiV4zj4+3AIwDXtwBrVJeuECze+9aW4Dut4PxkIhYsdetGMDhvoDqcPRgA+SWp4O4veQ5Uv/mAGwR78+6rQq4Yq9PAOi2fA4/vBkKudKVU7VZw77uKvWFuZbtcMNb5v0YwOG9g+jx7cADyi6Pg7gccgIxlcA5TKhaD01yYKBmVFpBZMfx/m2Bvny3t8LGqoqTliZbVI+gMgHwnMAnCIFi897cLAAZ6QyzFzzSCwXkD1OPs4QDIL5XgLmk5JHk/SD5gKdibd38VcsVYGmuBTaAzEHLHgyCcaokB7/1IkUET5IKxwF5pBIPzBqbPs4cHIC/AaeqvPL9pmHxAE+zts6VdLCD/lcgVY3UyWD0Bj1ZwqgCggXA7sPfWAoAJvaEtZBrB4Lyx6efsPADyCtmCvf00s/NnOsgVY3m8BTRZPZuGBUACdArY+5lWDqGmYbIrLHEx0ggG5w1OH2fnA7CPizQfaXqgUw80AGywMdIeaAA40u5vLt4AsMHASHugAeBIu7+5eAPABgMj7YEGgCPt/ubiDQAbDIy0BxoAjrT7m4s3AGwwMNIeaAA40u5vLt4AsMHASHugAeBIu7+5eAPABgMj7YEGgCPt/ubiDQAbDIy0B8ZYNMbkX+ZekpuIiOQrPar+xs889HJg6jZg5jAwvVZ8B+ll9PlO5/Fc/o+ECjnHfi8zYfkvM5ulmp4qJXVqx5deD4zfAkw/CGxdAZgoHfuh131QkaI5hu8Bs4Ds8B0AWLnIRGCBsFfn87JffDMwdjOw5R5g8giwZa34jnQQUwDo99wBfJ4TM7COiNdlaj2rA/jeV/vfDeATAP4UGH8I2Lrc6gc+SHqY4oMZ74VSKM0xfA+UUzB/oBUUCKMl6zSQ/PsXqZD5KQC/A0w/DEwcAcYXgYnVwppwADuBkefnCim90FmBWXwnK87Uen53BI8sbuwqaz9p5UgnQhBS+ZN1zE8Ak0utviCwq8DI8/nx5hi+Bzb4gJzKZE1SEFZZgS9/2pWR/gTAJ4HJQ8DEMWB8ARhfBsaWCwDquwQKvvNgHXvOcYVbPFJPkw+dDxC/W1Y4tWDpw/Rlgo4lo1T4/KxTihDNpJwj3/UiMLXemprjffC7eWpzDN8DlYsQDiKtVxzEqoHkyX9HRizW+nIgaQnvAiaeBCbmC0s4tgSMu2rMePAR9X252jXklaTFU108K0MHav/nvJ6ZxVVk9OI7GR2IZoGQNc/HgbHgIwqILIVujuF7oOMqWFawCoRxkfEIB5CWgkREBCNf9wMTc8A4QciBWyoGz16rwNgaML5eWKpctYZL3N+TWLX0gvtuP0HHk2n16JDyxXmVhfU0qywbJbr5GSuXKxA/sV5Y9UYWdnjwyS3qKKgarWA69Wg6fjQOIK0HadnIjPVFB+AiME4AuiUkCFnESyCSkmAuU7Cjm15wX+2X2ifBRn9A8mKcW2UFjULVQcgVDl80u40SYh763FfvquhLCxitoBYUsoJfjXKttByMq9CKcHn4sPuCbgXNJwyWkECcz5Q376UX3LNncZyQAAADEklEQVT9fFgIJs6lBBwtn3Tt6FpIz4RWnuQxPh2XIGzm4CwQ9hWIFgBTK0gQHiIAJddKq0ELQh+KL1qUR4MvSEsoENIKrgALHNiMox+94K7tl9qnnMio8MSf6SNwGpYVjCDk/Ju7isq496fCqX0BkDeqlWwKwic1gAQSpzGREnFgREz01eALLvvq2Kfi45m6cf3qBXdsfxRbJMho8dimqOhEK8cXQRr9QVpvPoDNMXQP9A3ACELFxPh+jACkP0fLIKFCCRRqKuPUdqjlC9o07JZwKVNHeBC94DQcZO0XAAkmgotAk9QYrR9f/BvByYfMSATDVMzwTXMM3QMDAVAgVHCZ7/MaQK4QZUHiNCbBQlqUw74YCb7gcmYkelC9YFlwvVv7RRAorTuBkECU9asCID9/x9B935zYzyKkqpfiNHxcA0gLQgvBAaPVkCqm3h2AtC5m/RyEqzw/4xhGL3hD++MmslgqCbgUfLKAcRrmTlBzDN0DA1tAXUlWcDm1IOIIJAjlT/Fd05lbFQFwjdtgGcewesFt7Rc/Gx8iWjUCjGCT1YvWT1MwgUqrf3NG45tTbcu0aximWx9xENcEQHGbcYAEwtSXSqY0gnCdgeuMI0cvuGx/FUGgFhwEYrR80QckWN+X0fjm1DwAWv8RgJFilJZBznz0pQg+AZAAlVWh1GvGka0XzB0cCQi30aSGVa9AF62fLOB7MhrfnJoPwPER59Px+o3e76mL5Kwp2G57xPl0kxc3er+nLvyKtLmhfUC78RHn081ONnq/pzcAR5xPR9mRRu/31IVgvgUccT4dNaobvd/TGYAjzqejumqj93s6A3DE+XRUg2VSCjdaGr3fUw+I+VPwiPPpqJjO8J1Nw43e7ymHwHoAKMFd7QErAeEE5NNJMb3R+z3lsGcNzgfgiPPpomJ6o/d76oGwPgCOKJ8uKqY3er+nKwBHmE+noqRG7/fUA199U/AI8+kEwEbv93QHoEhZTnA+nYqSGr3fBoAtaiqBUImdm5hPJwA2er+nKwBHnE+X1gUzSbnR+z11wPj/AeCpPDD3t7rvAAAAAElFTkSuQmCC"
          , Rp = class extends Ep {
            constructor({blendFunction: e=17, preset: t=1, edgeDetectionMode: i=2, predicationMode: n=0}={}) {
              let r, s;
              super("SMAAEffect", "uniform sampler2D weightMap;varying vec2 vOffset0;varying vec2 vOffset1;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 a;a.x=texture2D(weightMap,vOffset0).a;a.y=texture2D(weightMap,vOffset1).g;a.wz=texture2D(weightMap,uv).rb;vec4 color=inputColor;if(dot(a,vec4(1.0))>=1e-5){bool h=max(a.x,a.z)>max(a.y,a.w);vec4 blendingOffset=vec4(0.0,a.y,0.0,a.w);vec2 blendingWeight=a.yw;movec(bvec4(h),blendingOffset,vec4(a.x,0.0,a.z,0.0));movec(bvec2(h),blendingWeight,a.xz);blendingWeight/=dot(blendingWeight,vec2(1.0));vec4 blendingCoord=blendingOffset*vec4(texelSize,-texelSize)+uv.xyxy;color=blendingWeight.x*texture2D(inputBuffer,blendingCoord.xy);color+=blendingWeight.y*texture2D(inputBuffer,blendingCoord.zw);}outputColor=color;}", {
                vertexShader: "varying vec2 vOffset0;varying vec2 vOffset1;void mainSupport(const in vec2 uv){vOffset0=uv+texelSize*vec2(1.0,0.0);vOffset1=uv+texelSize*vec2(0.0,1.0);}",
                blendFunction: e,
                attributes: 3,
                uniforms: new Map([["weightMap", new td(null)]])
              }),
              arguments.length > 1 && (r = arguments[0],
                s = arguments[1],
              arguments.length > 2 && (t = arguments[2]),
              arguments.length > 3 && (i = arguments[3])),
                this.renderTargetEdges = new Zr(1,1,{
                  minFilter: Hn,
                  stencilBuffer: !1,
                  depthBuffer: !1
                }),
                this.renderTargetEdges.texture.name = "SMAA.Edges",
                this.renderTargetWeights = this.renderTargetEdges.clone(),
                this.renderTargetWeights.texture.name = "SMAA.Weights",
                this.uniforms.get("weightMap").value = this.renderTargetWeights.texture,
                this.clearPass = new dp(!0,!1,!1),
                this.clearPass.overrideClearColor = new Wr(0),
                this.clearPass.overrideClearAlpha = 1,
                this.edgeDetectionPass = new Ap(new ip),
                this.edgeDetectionMaterial.edgeDetectionMode = i,
                this.edgeDetectionMaterial.predicationMode = n,
                this.weightsPass = new Ap(new sp);
              const a = new gu;
              a.onLoad = ()=>{
                const e = new Kr(r);
                e.name = "SMAA.Search",
                  e.magFilter = Un,
                  e.minFilter = Un,
                  e.generateMipmaps = !1,
                  e.needsUpdate = !0,
                  e.flipY = !0,
                  this.weightsMaterial.searchTexture = e;
                const t = new Kr(s);
                t.name = "SMAA.Area",
                  t.magFilter = Hn,
                  t.minFilter = Hn,
                  t.generateMipmaps = !1,
                  t.needsUpdate = !0,
                  t.flipY = !1,
                  this.weightsMaterial.areaTexture = t,
                  this.dispatchEvent({
                    type: "load"
                  })
              }
                ,
                a.itemStart("search"),
                a.itemStart("area"),
                void 0 !== r && void 0 !== s ? (a.itemEnd("search"),
                  a.itemEnd("area")) : "undefined" != typeof Image && (r = new Image,
                  s = new Image,
                  r.addEventListener("load", (()=>a.itemEnd("search"))),
                  s.addEventListener("load", (()=>a.itemEnd("area"))),
                  r.src = Dp,
                  s.src = Ip),
                this.applyPreset(t)
            }
            get edgesTexture() {
              return this.renderTargetEdges.texture
            }
            getEdgesTexture() {
              return this.edgesTexture
            }
            get weightsTexture() {
              return this.renderTargetWeights.texture
            }
            getWeightsTexture() {
              return this.weightsTexture
            }
            get edgeDetectionMaterial() {
              return this.edgeDetectionPass.fullscreenMaterial
            }
            get colorEdgesMaterial() {
              return this.edgeDetectionMaterial
            }
            getEdgeDetectionMaterial() {
              return this.edgeDetectionMaterial
            }
            get weightsMaterial() {
              return this.weightsPass.fullscreenMaterial
            }
            getWeightsMaterial() {
              return this.weightsMaterial
            }
            setEdgeDetectionThreshold(e) {
              this.edgeDetectionMaterial.edgeDetectionThreshold = e
            }
            setOrthogonalSearchSteps(e) {
              this.weightsMaterial.orthogonalSearchSteps = e
            }
            applyPreset(e) {
              const t = this.edgeDetectionMaterial
                , i = this.weightsMaterial;
              switch (e) {
                case 0:
                  t.edgeDetectionThreshold = .15,
                    i.orthogonalSearchSteps = 4,
                    i.diagonalDetection = !1,
                    i.cornerDetection = !1;
                  break;
                case 1:
                  t.edgeDetectionThreshold = .1,
                    i.orthogonalSearchSteps = 8,
                    i.diagonalDetection = !1,
                    i.cornerDetection = !1;
                  break;
                case 2:
                  t.edgeDetectionThreshold = .1,
                    i.orthogonalSearchSteps = 16,
                    i.diagonalSearchSteps = 8,
                    i.cornerRounding = 25,
                    i.diagonalDetection = !0,
                    i.cornerDetection = !0;
                  break;
                case 3:
                  t.edgeDetectionThreshold = .05,
                    i.orthogonalSearchSteps = 32,
                    i.diagonalSearchSteps = 16,
                    i.cornerRounding = 25,
                    i.diagonalDetection = !0,
                    i.cornerDetection = !0
              }
            }
            setDepthTexture(e, t=3200) {
              this.edgeDetectionMaterial.depthBuffer = e,
                this.edgeDetectionMaterial.depthPacking = t
            }
            update(e, t, i) {
              this.clearPass.render(e, this.renderTargetEdges),
                this.edgeDetectionPass.render(e, t, this.renderTargetEdges),
                this.weightsPass.render(e, this.renderTargetEdges, this.renderTargetWeights)
            }
            setSize(e, t) {
              this.edgeDetectionMaterial.setSize(e, t),
                this.weightsMaterial.setSize(e, t),
                this.renderTargetEdges.setSize(e, t),
                this.renderTargetWeights.setSize(e, t)
            }
            dispose() {
              const {searchTexture: e, areaTexture: t} = this.weightsMaterial;
              null !== e && null !== t && (e.dispose(),
                t.dispose()),
                super.dispose()
            }
            static get searchImageDataURL() {
              return Dp
            }
            static get areaImageDataURL() {
              return Ip
            }
          }
          , Lp = class extends Ep {
            constructor({blendFunction: e, texture: t=null, aspectCorrection: i=!1}={}) {
              super("TextureEffect", "#ifdef TEXTURE_PRECISION_HIGH\nuniform mediump sampler2D map;\n#else\nuniform lowp sampler2D map;\n#endif\nvarying vec2 vUv2;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){\n#ifdef UV_TRANSFORM\nvec4 texel=texelToLinear(texture2D(map,vUv2));\n#else\nvec4 texel=texelToLinear(texture2D(map,uv));\n#endif\noutputColor=TEXEL;}", {
                blendFunction: e,
                defines: new Map([["TEXEL", "texel"]]),
                uniforms: new Map([["map", new td(null)], ["scale", new td(1)], ["uvTransform", new td(null)]])
              }),
                this.texture = t,
                this.aspectCorrection = i
            }
            get texture() {
              return this.uniforms.get("map").value
            }
            set texture(e) {
              const t = this.texture
                , i = this.uniforms
                , n = this.defines;
              if (t !== e) {
                if (i.get("map").value = e,
                  i.get("uvTransform").value = e.matrix,
                  n.delete("TEXTURE_PRECISION_HIGH"),
                null !== this.renderer) {
                  const t = Zd(e, this.renderer.capabilities.isWebGL2);
                  n.set("texelToLinear(texel)", t)
                }
                null !== e && (e.matrixAutoUpdate ? (n.set("UV_TRANSFORM", "1"),
                  this.setVertexShader("#ifdef ASPECT_CORRECTION\nuniform float scale;\n#else\nuniform mat3 uvTransform;\n#endif\nvarying vec2 vUv2;void mainSupport(const in vec2 uv){\n#ifdef ASPECT_CORRECTION\nvUv2=uv*vec2(aspect,1.0)*scale;\n#else\nvUv2=(uvTransform*vec3(uv,1.0)).xy;\n#endif\n}")) : (n.delete("UV_TRANSFORM"),
                  this.setVertexShader(null)),
                e.type !== jn && n.set("TEXTURE_PRECISION_HIGH", "1"),
                null !== t && t.type === e.type && t.encoding === e.encoding || this.setChanged())
              }
            }
            getTexture() {
              return this.texture
            }
            setTexture(e) {
              this.texture = e
            }
            get aspectCorrection() {
              return this.defines.has("ASPECT_CORRECTION")
            }
            set aspectCorrection(e) {
              this.aspectCorrection !== e && (e ? this.defines.set("ASPECT_CORRECTION", "1") : this.defines.delete("ASPECT_CORRECTION"),
                this.setChanged())
            }
            get uvTransform() {
              const e = this.texture;
              return null !== e && e.matrixAutoUpdate
            }
            set uvTransform(e) {
              const t = this.texture;
              null !== t && (t.matrixAutoUpdate = e)
            }
            setTextureSwizzleRGBA(e, t=e, i=e, n=e) {
              const r = "rgba";
              let s = "";
              0 === e && 1 === t && 2 === i && 3 === n || (s = [".", r[e], r[t], r[i], r[n]].join("")),
                this.defines.set("TEXEL", "texel" + s),
                this.setChanged()
            }
            update(e, t, i) {
              this.texture.matrixAutoUpdate && this.texture.updateMatrix()
            }
            initialize(e, t, i) {
              const n = Zd(this.texture, e.capabilities.isWebGL2);
              this.defines.set("texelToLinear(texel)", n),
                this.renderer = e
            }
          }
          , kp = class extends yu {
            load(e=(()=>{}
            ), t=null) {
              4 === arguments.length ? (e = arguments[1],
                t = arguments[3]) : 3 !== arguments.length && "function" == typeof arguments[0] || (e = arguments[1],
                t = null);
              const i = this.manager
                , n = new gu;
              return new Promise(((r,s)=>{
                  const a = new Image
                    , o = new Image;
                  n.onError = e=>{
                    i.itemError(e),
                      null !== t ? (t(`Failed to load ${e}`),
                        r()) : s(`Failed to load ${e}`)
                  }
                    ,
                    n.onLoad = ()=>{
                      const t = [a, o];
                      e(t),
                        r(t)
                    }
                    ,
                    a.addEventListener("error", (e=>{
                        n.itemError("smaa-search")
                      }
                    )),
                    o.addEventListener("error", (e=>{
                        n.itemError("smaa-area")
                      }
                    )),
                    a.addEventListener("load", (()=>{
                        i.itemEnd("smaa-search"),
                          n.itemEnd("smaa-search")
                      }
                    )),
                    o.addEventListener("load", (()=>{
                        i.itemEnd("smaa-area"),
                          n.itemEnd("smaa-area")
                      }
                    )),
                    i.itemStart("smaa-search"),
                    i.itemStart("smaa-area"),
                    n.itemStart("smaa-search"),
                    n.itemStart("smaa-area"),
                    a.src = Dp,
                    o.src = Ip
                }
              ))
            }
          }
        ;
        const Fp = class {
          constructor(e={}) {
            if (this.logs = "boolean" == typeof e.logs && e.logs,
              this.progressBar = "boolean" != typeof e.progressBar || e.progressBar,
              this.texturesFlipY = "boolean" == typeof e.texturesFlipY && e.texturesFlipY,
              this.progress = 0,
              this.onProgress = !1,
              this.init = !1,
              this.domElements = {},
              this.loadingManager = new gu,
              this.handleLoadingManager(),
              this.smaaImageLoader = new kp,
              this.textureLoader = new wu(this.loadingManager),
              this.gltfLoader = new hd(this.loadingManager),
            e.cubeTextureLoader && (this.cubeTextureLoader = new e.cubeTextureLoader(this.loadingManager)),
              e.basisLoader) {
              if (!e.renderer)
                throw new Error("[MultiLoader] A renderer must be provided to enable basis texture loading. https://www.npmjs.com/package/@thibka/three-multiloader");
              let t = e.basisTranscoderPath || "node_modules/three/examples/js/libs/basis/";
              this.basisLoader = new e.basisLoader(this.loadingManager),
                this.basisLoader.detectSupport(e.renderer),
                this.basisLoader.setTranscoderPath(t)
            }
            if (e.dracoLoader) {
              let t = e.dracoDecoderPath || "node_modules/three/examples/js/libs/draco/";
              this.dracoLoader = new e.dracoLoader(this.loadingManager),
                this.dracoLoader.setDecoderPath(t),
                this.dracoLoader.setDecoderConfig({
                  type: "js"
                })
            }
            this.images = [],
              this.textures = [],
              this.cubeTextures = [],
              this.models = [],
              this.videos = [],
              this.onloadCallbacks = [],
              this.loaded = !1,
              this.forceLoadIntervals = [],
              this.onLoaded = {
                add: this._onLoadedAdd.bind(this)
              }
          }
          handleLoadingManager() {
            this.loadingManager.onProgress = (e,t,i)=>{
              if (this.logs && console.log("Loading file: " + e + ".\nLoaded " + t + " of " + i + " files."),
                this.progress = t / i,
              this.progressBar && this.init) {
                let e = 100 - 100 * this.progress;
                this.domElements.loaderCompletion.style.transform = "translateX(-" + e + "%)"
              }
              "function" == typeof this.onProgress && this.onProgress(this.progress)
            }
              ,
              this.loadingManager.onError = function(e) {
                console.warn("There was an error loading " + String(e))
              }
              ,
              this.loadingManager.onLoad = ()=>{
                this.smaaImageLoader.load((([e,t])=>{}
                )).then((([e,t])=>{
                    this.images["smaa-search"] = e,
                      this.images["smaa-area"] = t,
                    this.progressBar && (this.domElements.loaderBar.style.opacity = 0,
                      setTimeout((()=>{
                          this.domElements.loader.style.opacity = 0,
                            setTimeout((()=>{
                                this.domElements.loader.style.display = "none"
                              }
                            ), 600)
                        }
                      ), 1e3)),
                      this.onloadCallbacks.forEach((e=>{
                          e()
                        }
                      )),
                      this.loaded = !0
                  }
                ))
              }
          }
          _onLoadedAdd(e) {
            if ("function" != typeof e)
              throw new Error("[MultiLoader] onLoaded() parameter must be a function.");
            this.loaded ? e() : this.onloadCallbacks.push(e)
          }
          createProgressBar() {
            let e = document.createElement("style");
            e.id = "three-multiloader-progressbar",
              e.innerHTML = "\n            .loader {\n                position: absolute;\n                z-index: 1000;\n                top: 0;\n                left: 0;\n                width: 100%;\n                height: 100%;\n                background: black;\n                display: flex;\n                justify-content: center;\n                align-items: center;\n                transition: opacity .5s linear;\n            }\n            \n            .loader__bar {\n                width: 75%;\n                height: 2px;\n                background: #333333;\n                overflow: hidden;\n                transition: opacity .5s linear;\n            }\n            \n            .loader__completion {\n                width: 100%;\n                height: 100%;\n                background: white;\n                transform: translateX(-100%);\n                transition: transform .2s ease;\n            }\n        ",
              document.head.appendChild(e);
            var t = document.createElement("div");
            t.id = "loader",
              t.classList.add("loader"),
              document.body.appendChild(t);
            var i = document.createElement("div");
            i.id = "loader__bar",
              i.classList.add("loader__bar"),
              t.appendChild(i);
            var n = document.createElement("div");
            n.id = "loader__completion",
              n.classList.add("loader__completion"),
              i.appendChild(n),
              this.domElements = {
                loader: t,
                loaderBar: i,
                loaderCompletion: n
              }
          }
          load(e) {
            this.init = !0,
            this.progressBar && this.createProgressBar(),
            e && 0 != e.length || (this.loadingManager.itemStart(),
              this.loadingManager.itemEnd()),
              e.forEach((e=>{
                  var t = e.alias;
                  if (e.alias)
                    t = e.alias;
                  else {
                    if ("string" != typeof e.path)
                      throw new Error("[MultiLoader] An alias must be provided for this asset: " + e.path);
                    t = e.path
                  }
                  if ("texture" == e.type) {
                    if ("basis" == e.path.split(".").pop()) {
                      if (!this.basisLoader)
                        throw new Error("[MultiLoader] BasisTextureLoader is not defined. https://www.npmjs.com/package/@thibka/three-multiloader");
                      this.loadingManager.itemStart(e.path),
                        this.basisLoader.load(e.path, (i=>{
                            this.textures[t] = i,
                              this.loadingManager.itemEnd(e.path)
                          }
                        ), (()=>{}
                        ), (e=>{
                            console.error(e)
                          }
                        ))
                    } else
                      this.textures[t] = this.textureLoader.load(e.path);
                    this.textures[t].flipY = this.texturesFlipY
                  } else if ("image" == e.type) {
                    let i = new Image;
                    this.loadingManager.itemStart(e.path),
                      i.onload = ()=>{
                        this.images[t] = i,
                          this.loadingManager.itemEnd(e.path)
                      }
                      ,
                      i.src = e.path
                  } else if ("cube-texture" == e.type) {
                    if ("object" != typeof e.path)
                      throw new Error("[MultiLoader] cube-texture paths must be arrays");
                    if (!this.cubeTextureLoader)
                      throw new Error("[MultiLoader] CubeTextureLoader is not defined. https://www.npmjs.com/package/@thibka/three-multiloader");
                    this.cubeTextures[t] = this.cubeTextureLoader.load(e.path)
                  } else if ("gltf" == e.type || "gltf-draco" == e.type)
                    "gltf-draco" != e.type || this.gltf_draco_loader_set || (this.gltfLoader.setDRACOLoader(this.dracoLoader),
                      this.gltf_draco_loader_set = !0),
                      this.gltfLoader.load(e.path, (e=>{
                          this.models[t] = e
                        }
                      ), (e=>{}
                      ), (t=>{
                          console.log(e),
                            console.error(t)
                        }
                      ));
                  else if ("draco" == e.type || "drc" == e.type) {
                    if (!this.dracoLoader)
                      throw new Error("[MultiLoader] dracoLoader is not defined. https://www.npmjs.com/package/@thibka/three-multiloader");
                    this.loadingManager.itemStart(e.path),
                      this.dracoLoader.load(e.path, (i=>{
                          i.computeVertexNormals(),
                            this.models[t] = i,
                            this.dracoLoader.dispose(),
                            this.loadingManager.itemEnd(e.path)
                        }
                      ), (e=>{}
                      ), (t=>{
                          console.log(e),
                            console.error(t)
                        }
                      ))
                  } else if ("video" == e.type) {
                    this.loadingManager.itemStart(e.path),
                      this.videos.length += 1;
                    let i = document.createElement("video")
                      , n = null != e.loadEvent ? e.loadEvent : "loadedmetadata";
                    i.setAttribute("data-load-event", n),
                      i.setAttribute("data-alias", t),
                      i.addEventListener(n, this.handleLoadedVideo.bind(this)),
                      i.muted = !0,
                      i.loop = !0,
                      i.src = e.path,
                      i.load(),
                      this.forceLoadIntervals[i.src] = setInterval((()=>{
                          i.load()
                        }
                      ), 500)
                  }
                }
              ))
          }
          handleLoadedVideo(e) {
            let t;
            t = null != e.path && e.path[0] ? e.path[0] : e.target;
            let i = t.dataset.loadEvent
              , n = t.dataset.alias;
            t.removeEventListener(i, this.handleLoadedVideo.bind(this)),
              clearInterval(this.forceLoadIntervals[t.src]),
              this.videos[n] = t,
              this.loadingManager.itemEnd(t.src)
          }
        }
          , Bp = new WeakMap;
        class Op extends yu {
          constructor(e) {
            super(e),
              this.decoderPath = "",
              this.decoderConfig = {},
              this.decoderBinary = null,
              this.decoderPending = null,
              this.workerLimit = 4,
              this.workerPool = [],
              this.workerNextTaskID = 1,
              this.workerSourceURL = "",
              this.defaultAttributeIDs = {
                position: "POSITION",
                normal: "NORMAL",
                color: "COLOR",
                uv: "TEX_COORD"
              },
              this.defaultAttributeTypes = {
                position: "Float32Array",
                normal: "Float32Array",
                color: "Float32Array",
                uv: "Float32Array"
              }
          }
          setDecoderPath(e) {
            return this.decoderPath = e,
              this
          }
          setDecoderConfig(e) {
            return this.decoderConfig = e,
              this
          }
          setWorkerLimit(e) {
            return this.workerLimit = e,
              this
          }
          load(e, t, i, n) {
            const r = new _u(this.manager);
            r.setPath(this.path),
              r.setResponseType("arraybuffer"),
              r.setRequestHeader(this.requestHeader),
              r.setWithCredentials(this.withCredentials),
              r.load(e, (e=>{
                  const i = {
                    attributeIDs: this.defaultAttributeIDs,
                    attributeTypes: this.defaultAttributeTypes,
                    useUniqueIDs: !1
                  };
                  this.decodeGeometry(e, i).then(t).catch(n)
                }
              ), i, n)
          }
          decodeDracoFile(e, t, i, n) {
            const r = {
              attributeIDs: i || this.defaultAttributeIDs,
              attributeTypes: n || this.defaultAttributeTypes,
              useUniqueIDs: !!i
            };
            this.decodeGeometry(e, r).then(t)
          }
          decodeGeometry(e, t) {
            for (const e in t.attributeTypes) {
              const i = t.attributeTypes[e];
              void 0 !== i.BYTES_PER_ELEMENT && (t.attributeTypes[e] = i.name)
            }
            const i = JSON.stringify(t);
            if (Bp.has(e)) {
              const t = Bp.get(e);
              if (t.key === i)
                return t.promise;
              if (0 === e.byteLength)
                throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")
            }
            let n;
            const r = this.workerNextTaskID++
              , s = e.byteLength
              , a = this._getWorker(r, s).then((i=>(n = i,
              new Promise(((i,s)=>{
                  n._callbacks[r] = {
                    resolve: i,
                    reject: s
                  },
                    n.postMessage({
                      type: "decode",
                      id: r,
                      taskConfig: t,
                      buffer: e
                    }, [e])
                }
              ))))).then((e=>this._createGeometry(e.geometry)));
            return a.catch((()=>!0)).then((()=>{
                n && r && this._releaseTask(n, r)
              }
            )),
              Bp.set(e, {
                key: i,
                promise: a
              }),
              a
          }
          _createGeometry(e) {
            const t = new Ia;
            e.index && t.setIndex(new _a(e.index.array,1));
            for (let i = 0; i < e.attributes.length; i++) {
              const n = e.attributes[i]
                , r = n.name
                , s = n.array
                , a = n.itemSize;
              t.setAttribute(r, new _a(s,a))
            }
            return t
          }
          _loadLibrary(e, t) {
            const i = new _u(this.manager);
            return i.setPath(this.decoderPath),
              i.setResponseType(t),
              i.setWithCredentials(this.withCredentials),
              new Promise(((t,n)=>{
                  i.load(e, t, void 0, n)
                }
              ))
          }
          preload() {
            return this._initDecoder(),
              this
          }
          _initDecoder() {
            if (this.decoderPending)
              return this.decoderPending;
            const e = "object" != typeof WebAssembly || "js" === this.decoderConfig.type
              , t = [];
            return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")),
              t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))),
              this.decoderPending = Promise.all(t).then((t=>{
                  const i = t[0];
                  e || (this.decoderConfig.wasmBinary = t[1]);
                  const n = Np.toString()
                    , r = ["/* draco decoder */", i, "", "/* worker */", n.substring(n.indexOf("{") + 1, n.lastIndexOf("}"))].join("\n");
                  this.workerSourceURL = URL.createObjectURL(new Blob([r]))
                }
              )),
              this.decoderPending
          }
          _getWorker(e, t) {
            return this._initDecoder().then((()=>{
                if (this.workerPool.length < this.workerLimit) {
                  const e = new Worker(this.workerSourceURL);
                  e._callbacks = {},
                    e._taskCosts = {},
                    e._taskLoad = 0,
                    e.postMessage({
                      type: "init",
                      decoderConfig: this.decoderConfig
                    }),
                    e.onmessage = function(t) {
                      const i = t.data;
                      switch (i.type) {
                        case "decode":
                          e._callbacks[i.id].resolve(i);
                          break;
                        case "error":
                          e._callbacks[i.id].reject(i);
                          break;
                        default:
                          console.error('THREE.DRACOLoader: Unexpected message, "' + i.type + '"')
                      }
                    }
                    ,
                    this.workerPool.push(e)
                } else
                  this.workerPool.sort((function(e, t) {
                      return e._taskLoad > t._taskLoad ? -1 : 1
                    }
                  ));
                const i = this.workerPool[this.workerPool.length - 1];
                return i._taskCosts[e] = t,
                  i._taskLoad += t,
                  i
              }
            ))
          }
          _releaseTask(e, t) {
            e._taskLoad -= e._taskCosts[t],
              delete e._callbacks[t],
              delete e._taskCosts[t]
          }
          debug() {
            console.log("Task load: ", this.workerPool.map((e=>e._taskLoad)))
          }
          dispose() {
            for (let e = 0; e < this.workerPool.length; ++e)
              this.workerPool[e].terminate();
            return this.workerPool.length = 0,
              this
          }
        }
        function Np() {
          let e, t;
          function i(e, t, i, n, r, s) {
            const a = s.num_components()
              , o = i.num_points() * a
              , l = o * r.BYTES_PER_ELEMENT
              , h = function(e, t) {
              switch (t) {
                case Float32Array:
                  return e.DT_FLOAT32;
                case Int8Array:
                  return e.DT_INT8;
                case Int16Array:
                  return e.DT_INT16;
                case Int32Array:
                  return e.DT_INT32;
                case Uint8Array:
                  return e.DT_UINT8;
                case Uint16Array:
                  return e.DT_UINT16;
                case Uint32Array:
                  return e.DT_UINT32
              }
            }(e, r)
              , c = e._malloc(l);
            t.GetAttributeDataArrayForAllPoints(i, s, h, l, c);
            const u = new r(e.HEAPF32.buffer,c,o).slice();
            return e._free(c),
              {
                name: n,
                array: u,
                itemSize: a
              }
          }
          onmessage = function(n) {
            const r = n.data;
            switch (r.type) {
              case "init":
                e = r.decoderConfig,
                  t = new Promise((function(t) {
                      e.onModuleLoaded = function(e) {
                        t({
                          draco: e
                        })
                      }
                        ,
                        DracoDecoderModule(e)
                    }
                  ));
                break;
              case "decode":
                const n = r.buffer
                  , s = r.taskConfig;
                t.then((e=>{
                    const t = e.draco
                      , a = new t.Decoder
                      , o = new t.DecoderBuffer;
                    o.Init(new Int8Array(n), n.byteLength);
                    try {
                      const e = function(e, t, n, r) {
                        const s = r.attributeIDs
                          , a = r.attributeTypes;
                        let o, l;
                        const h = t.GetEncodedGeometryType(n);
                        if (h === e.TRIANGULAR_MESH)
                          o = new e.Mesh,
                            l = t.DecodeBufferToMesh(n, o);
                        else {
                          if (h !== e.POINT_CLOUD)
                            throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
                          o = new e.PointCloud,
                            l = t.DecodeBufferToPointCloud(n, o)
                        }
                        if (!l.ok() || 0 === o.ptr)
                          throw new Error("THREE.DRACOLoader: Decoding failed: " + l.error_msg());
                        const c = {
                          index: null,
                          attributes: []
                        };
                        for (const n in s) {
                          const l = self[a[n]];
                          let h, u;
                          if (r.useUniqueIDs)
                            u = s[n],
                              h = t.GetAttributeByUniqueId(o, u);
                          else {
                            if (u = t.GetAttributeId(o, e[s[n]]),
                            -1 === u)
                              continue;
                            h = t.GetAttribute(o, u)
                          }
                          c.attributes.push(i(e, t, o, n, l, h))
                        }
                        return h === e.TRIANGULAR_MESH && (c.index = function(e, t, i) {
                          const n = 3 * i.num_faces()
                            , r = 4 * n
                            , s = e._malloc(r);
                          t.GetTrianglesUInt32Array(i, r, s);
                          const a = new Uint32Array(e.HEAPF32.buffer,s,n).slice();
                          return e._free(s),
                            {
                              array: a,
                              itemSize: 1
                            }
                        }(e, t, o)),
                          e.destroy(o),
                          c
                      }(t, a, o, s)
                        , n = e.attributes.map((e=>e.array.buffer));
                      e.index && n.push(e.index.array.buffer),
                        self.postMessage({
                          type: "decode",
                          id: r.id,
                          geometry: e
                        }, n)
                    } catch (e) {
                      console.error(e),
                        self.postMessage({
                          type: "error",
                          id: r.id,
                          error: e.message
                        })
                    } finally {
                      t.destroy(o),
                        t.destroy(a)
                    }
                  }
                ))
            }
          }
        }
        const zp = new Fp({
          progressBar: !1,
          dracoLoader: Op,
          dracoDecoderPath: "draco/"
        });
        zp.onLoaded.add((()=>{
            setTimeout((()=>{
                document.querySelector(".no-fouc").classList.add("no-fouc--in")
              }
            ), 50)
          }
        )),
          zp.assets = [{
            alias: "radial-gradient",
            type: "texture",
            path: "textures/radial-gradient.png"
          }, {
            alias: "cloud-1",
            type: "gltf-draco",
            path: "models/cloud_11.glb"
          }, {
            alias: "cloud-2",
            type: "gltf-draco",
            path: "models/cloud_22.glb"
          }, {
            alias: "plane",
            type: "gltf",
            path: "models/planeur.glb"
          }];
        const Up = zp;
        function Gp() {
          const e = navigator.userAgent;
          return /(tablet|ipad|playbook|silk)|(android(?!.*mobi))/i.test(e) || e.includes("Mac") && "ontouchend"in document ? "tablet" : /Mobile|Android|iP(hone|od)|IEMobile|BlackBerry|Kindle|Silk-Accelerated|(hpw|web)OS|Opera M(obi|ini)/.test(e) ? "mobile" : "desktop"
        }
        let Vp = null;
        const Hp = "\n    uniform sampler2D uTexture1;\n    uniform sampler2D uTexture2;\n    uniform float uProgress;\n\n    void mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\n        vec4 textureColor1 = texture2D(uTexture1, uv);\n        vec4 textureColor2 = texture2D(uTexture2, uv);\n\n        vec4 color = mix(textureColor1, textureColor2, uProgress);\n\n        outputColor = color;\n    }\n"
          , Wp = "\n    uniform sampler2D uTexture1;\n    uniform sampler2D uTexture2;\n    uniform float uProgress;\n    uniform float uSeed;\n    uniform float uDirection;\n\n    vec4 permute(vec4 x)\n    {\n        return mod(((x*34.0)+1.0)*x, 289.0);\n    }\n\n    //  Classic Perlin 2D Noise \n    //  by Stefan Gustavson\n    //\n    vec2 fade(vec2 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\n    float cnoise(vec2 P){\n        vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n        vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n        Pi = mod(Pi, 289.0); // To avoid truncation effects in permutation\n        vec4 ix = Pi.xzxz;\n        vec4 iy = Pi.yyww;\n        vec4 fx = Pf.xzxz;\n        vec4 fy = Pf.yyww;\n        vec4 i = permute(permute(ix) + iy);\n        vec4 gx = 2.0 * fract(i * 0.0243902439) - 1.0; // 1/41 = 0.024...\n        vec4 gy = abs(gx) - 0.5;\n        vec4 tx = floor(gx + 0.5);\n        gx = gx - tx;\n        vec2 g00 = vec2(gx.x,gy.x);\n        vec2 g10 = vec2(gx.y,gy.y);\n        vec2 g01 = vec2(gx.z,gy.z);\n        vec2 g11 = vec2(gx.w,gy.w);\n        vec4 norm = 1.79284291400159 - 0.85373472095314 * vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));\n        g00 *= norm.x;\n        g01 *= norm.y;\n        g10 *= norm.z;\n        g11 *= norm.w;\n        float n00 = dot(g00, vec2(fx.x, fy.x));\n        float n10 = dot(g10, vec2(fx.y, fy.y));\n        float n01 = dot(g01, vec2(fx.z, fy.z));\n        float n11 = dot(g11, vec2(fx.w, fy.w));\n        vec2 fade_xy = fade(Pf.xy);\n        vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n        float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n        return 2.3 * n_xy;\n    }\n\n    // https://www.desmos.com/calculator/frgjchu3nl\n    float easeInOutParabola(float x) {\n        return 0.5 + (cos(PI + x * 2.0 * PI)) / 2.0;\n    }\n\n    void mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\n        vec4 textureColor1 = texture2D(uTexture1, uv);\n        vec4 textureColor2 = texture2D(uTexture2, uv);\n        \n        float noise = cnoise(vec2(uv.x, uv.y) * 3. + uSeed) * uProgress;\n        float offScreenOffset = (-0.5 * uProgress);\n        //float mixer = step(uv.y + noise + offScreenOffset, uProgress);\n        float _step = abs(uv.x + uDirection) + noise + offScreenOffset;\n        float mixer = smoothstep(_step - .1, _step + .1, uProgress);\n\n        // smoothing transition with global a fade-in-out to fix issues\n        mixer *= pow(uProgress, .5); // fade-in (with ease-in)\n        mixer = mix(mixer, 1., pow(uProgress, 2.)); // fade-out (with ease-out)\n\n        vec4 color = mix(textureColor1, textureColor2, mixer);\n\n        outputColor = color;\n    }\n"
          , jp = "\n    uniform sampler2D uTexture1;\n    uniform sampler2D uTexture2;\n    uniform float uProgress;\n\n    void mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\n        vec4 textureColor1 = texture2D(uTexture1, uv);\n        vec4 textureColor2 = texture2D(uTexture2, uv);\n        \n        float gradientSize = 0.3;\n        float mixer = smoothstep((1. - uv.x) - gradientSize / 2.0, (1. - uv.x) + gradientSize / 2.0, uProgress * (1. + gradientSize*2.) - gradientSize);\n        vec4 color = mix(textureColor1, textureColor2, mixer);\n\n        outputColor = color;\n    }\n"
          , Xp = "\n    uniform sampler2D uTexture1;\n    uniform sampler2D uTexture2;\n    uniform float uProgress;\n\n    float strength = 0.08;\n\n    void mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\n        \n        vec4 textureColor1 = texture2D(uTexture1, uv);\n        vec4 textureColor2 = texture2D(uTexture2, uv);\n\n        vec2 oa = (((textureColor1.rg+textureColor1.b)*0.5)*2.0-1.0);\n        vec2 ob = (((textureColor2.rg+textureColor2.b)*0.5)*2.0-1.0);\n        vec2 oc = mix(oa,ob,0.5)*strength;\n\n        float w0 = uProgress;\n        float w1 = 1.0-uProgress;\n\n        vec4 expr1 = texture2D(uTexture1, uv+oc*w0);//getFromColor(p+oc*w0);\n        vec4 expr2 = texture2D(uTexture2, uv-oc*w1);//getToColor(p-oc*w1);\n        \n        outputColor = mix(expr1, expr2, uProgress);\n    }\n"
          , Yp = "\n    uniform sampler2D uTexture1;\n    uniform sampler2D uTexture2;\n    uniform float uProgress;\n\n    void mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\n        float x = uProgress;\n        \n        x = smoothstep(.0, 1.0, (x * 2.0 + uv.x - 1.0));\n        \n        outputColor = mix(texture2D(uTexture1, (uv - .5) * (1.-x) + .5), texture2D(uTexture2, (uv - .5) * x + .5), x);\n    }\n"
          , qp = "\n    uniform sampler2D uTexture1;\n    uniform sampler2D uTexture2;\n    uniform float uProgress;\n\n    vec2 zoom(vec2 uv, float amount) {\n        return 0.5 + ((uv - 0.5) * amount); \n    }\n\n    void mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\n        // TODO: some timing are hardcoded but should be one or many parameters\n        // TODO: should also be able to configure how much circles\n        // TODO: if() branching should be avoided when possible, prefer use of step() & other functions\n        vec2 ratio2 = vec2(1.0, 1.0 / aspect);\n        vec2 _uv = uv;\n        vec2 r = 2.0 * ((vec2(_uv.xy) - 0.5) * ratio2);\n        float pro = uProgress / 0.8;\n        float z = pro * 0.2;\n        float t = 0.0;\n        if (pro > 1.0) {\n            z = 0.2 + (pro - 1.0) * 5.;\n            t = clamp((uProgress - 0.8) / 0.07, 0.0, 1.0);\n        }\n        if (length(r) < 0.5+z) {\n            // _uv = zoom(_uv, 0.9 - 0.1 * pro);\n        }\n        else if (length(r) < 0.8+z*1.5) {\n            _uv = zoom(_uv, 1.0 - 0.15 * pro);\n            t = t * 0.5;\n        }\n        else if (length(r) < 1.2+z*2.5) {\n            _uv = zoom(_uv, 1.0 - 0.2 * pro);\n            t = t * 0.2;\n        }\n        else {\n            _uv = zoom(_uv, 1.0 - 0.25 * pro);\n        }\n\n        outputColor = mix(texture2D(uTexture1, _uv), texture2D(uTexture2, _uv), uProgress);\n    }\n"
          , Qp = "\n    uniform sampler2D uTexture1;\n    uniform sampler2D uTexture2;\n    uniform float uProgress;\n\n    float parabola( float x, float k )\n    {\n        return pow( 4.0*x*(1.0-x), k );\n    }\n\n    void mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\n        vec4 textureColor1 = texture2D(uTexture1, uv);\n        vec4 textureColor2 = texture2D(uTexture2, uv);\n        \n        float skewAmount = .1;\n        float skew = uv.y * skewAmount * parabola( uProgress, 2.0 );\n        float mixer = step(uv.x, uProgress + skew);\n        vec4 color = mix(textureColor1, textureColor2, mixer);\n\n        outputColor = color;\n    }\n"
          , Kp = "\n    uniform sampler2D uTexture1;\n    uniform sampler2D uTexture2;\n    uniform sampler2D uDepthTexture;\n    uniform float uProgress;\n\n    void mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\n        vec4 textureColor1 = texture2D(uTexture1, uv);\n        vec4 textureColor2 = texture2D(uTexture2, uv);\n        vec4 depthTextureColor = texture2D(uDepthTexture, uv);\n\n        float smoothSize = .01;\n        float mixer = smoothstep(depthTextureColor.x - smoothSize, depthTextureColor.x + smoothSize, uProgress);\n        vec4 color = mix(textureColor1, textureColor2, mixer);\n\n        outputColor = color;\n    }\n"
          , Jp = "\n    uniform sampler2D uTexture1;\n    uniform sampler2D uTexture2;\n    uniform float uProgress;\n\n    float count = 10.; // = 10.0\n    float smoothness = .5; // = 0.5\n\n    void mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\n        vec4 textureColor1 = texture2D(uTexture1, uv);\n        vec4 textureColor2 = texture2D(uTexture2, uv);\n        \n        \n\n        float pr = smoothstep(-smoothness, 0.0, uv.x - uProgress * (1.0 + smoothness));\n        float mixer = step(pr, fract(count * uv.x));\n        vec4 color = mix(textureColor1, textureColor2, mixer);\n\n        outputColor = color;\n    }\n"
          , Zp = "\n    uniform sampler2D uTexture1;\n    uniform sampler2D uTexture2;\n    uniform float uProgress;\n\n    float intensity = .04; // 0.1\n    int passes = 8; // 6\n\n    void mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\n        vec4 c1 = vec4(0.0);\n        vec4 c2 = vec4(0.0);\n\n        float disp = intensity*(0.5-distance(0.5, uProgress));\n        for (int xi=0; xi<passes; xi++)\n        {\n            float x = float(xi) / float(passes) - 0.5;\n            for (int yi=0; yi<passes; yi++)\n            {\n                float y = float(yi) / float(passes) - 0.5;\n                vec2 v = vec2(x,y);\n                float d = disp;\n                c1 += texture(uTexture1, uv + d*v);\n                c2 += texture(uTexture2, uv + d*v);\n            }\n        }\n        c1 /= float(passes*passes);\n        c2 /= float(passes*passes);\n\n        outputColor = mix(c1, c2, uProgress);\n    }\n";
        function $p(t, i, n={}) {
          let r = n.transition || "waveclip"
            , s = "boolean" != typeof n.endWithPasses2 || n.endWithPasses2
            , a = "boolean" != typeof n.pingpong || n.pingpong;
          this.savePass1 = new hp,
            this.texturePass1 = new _p(this.camera,new Lp({
              texture: this.savePass1.renderTarget.texture
            })),
            this.savePass2 = new hp,
            this.texturePass2 = new _p(this.camera,new Lp({
              texture: this.savePass2.renderTarget.texture
            })),
            this.transitionEffect = new Ep("transition",e[r],{
              blendFunction: 13,
              uniforms: new Map([["uTexture1", new td(this.savePass1.renderTarget.texture)], ["uTexture2", new td(this.savePass2.renderTarget.texture)], ["uProgress", new td(0)], ["uSeed", new td(10 * Math.random())], ["uDirection", new td(n.direction ?? -1)]])
            }),
            this.transitionPass = new _p(this.camera,this.transitionEffect),
          this.composeTransition || (this.composeTransition = ef),
            this.composeTransition(t, i, a),
            _n.to(this.transitionEffect.uniforms.get("uProgress"), {
              value: 1,
              duration: n.duration ?? 2,
              delay: n.delay || 0,
              ease: n.ease || "power2.inOut",
              onUpdate: ()=>{
                !0 === a ? a = 1 : 1 === a ? a = 2 : 2 === a && (a = 1),
                  this.composeTransition(t, i, a)
              }
              ,
              onComplete: ()=>{
                s && this.compose(i),
                n.onComplete && n.onComplete()
              }
            })
        }
        function ef(e, t, i) {
          this.composer.removeAllPasses(),
            2 !== i ? (e.forEach((e=>{
                this.composer.addPass(e)
              }
            )),
              this.composer.addPass(this.savePass1)) : this.composer.addPass(this.texturePass1),
            1 !== i ? (t.forEach((e=>{
                this.composer.addPass(e)
              }
            )),
              this.composer.addPass(this.savePass2)) : this.composer.addPass(this.texturePass2),
            this.composer.addPass(this.transitionPass)
        }
        class tf {
          static init(e, t) {
            this.transition = $p,
              this.canvas = bn.canvas,
              this.scene = new qh,
              this.scene_about = new qh,
              this.camera = new no(60,this.canvas.offsetWidth / this.canvas.offsetHeight,.1,50),
              this.renderer = Vp,
              this.composer = new class {
                constructor(e=null, {depthBuffer: t=!0, stencilBuffer: i=!1, multisampling: n=0, frameBufferType: r}={}) {
                  this.renderer = null,
                    this.inputBuffer = this.createBuffer(t, i, r, n),
                    this.outputBuffer = this.inputBuffer.clone(),
                    this.copyPass = new hp,
                    this.depthTexture = null,
                    this.passes = [],
                    this.timer = new class {
                      constructor() {
                        this.previousTime = 0,
                          this.currentTime = 0,
                          this.delta = 0,
                          this.fixedDelta = 1e3 / 60,
                          this.elapsed = 0,
                          this.timescale = 1,
                          this.fixedDeltaEnabled = !1,
                          this.autoReset = !1
                      }
                      setFixedDeltaEnabled(e) {
                        return this.fixedDeltaEnabled = e,
                          this
                      }
                      isAutoResetEnabled(e) {
                        return this.autoReset
                      }
                      setAutoResetEnabled(e) {
                        return "undefined" != typeof document && void 0 !== document.hidden && (e ? document.addEventListener("visibilitychange", this) : document.removeEventListener("visibilitychange", this),
                          this.autoReset = e),
                          this
                      }
                      getDelta() {
                        return this.delta * Sp
                      }
                      getFixedDelta() {
                        return this.fixedDelta * Sp
                      }
                      setFixedDelta(e) {
                        return this.fixedDelta = 1e3 * e,
                          this
                      }
                      getElapsed() {
                        return this.elapsed * Sp
                      }
                      getTimescale() {
                        return this.timescale
                      }
                      setTimescale(e) {
                        return this.timescale = e,
                          this
                      }
                      update(e) {
                        return this.fixedDeltaEnabled ? this.delta = this.fixedDelta : (this.previousTime = this.currentTime,
                          this.currentTime = void 0 !== e ? e : performance.now(),
                          this.delta = this.currentTime - this.previousTime),
                          this.delta *= this.timescale,
                          this.elapsed += this.delta,
                          this
                      }
                      reset() {
                        return this.delta = 0,
                          this.elapsed = 0,
                          this.currentTime = performance.now(),
                          this
                      }
                      handleEvent(e) {
                        document.hidden || (this.currentTime = performance.now())
                      }
                      dispose() {
                        this.setAutoResetEnabled(!1)
                      }
                    }
                    ,
                    this.autoRenderToScreen = !0,
                    this.setRenderer(e)
                }
                get multisampling() {
                  return this.inputBuffer.samples || 0
                }
                set multisampling(e) {
                  const t = this.inputBuffer
                    , i = this.multisampling;
                  i > 0 && e > 0 ? (this.inputBuffer.samples = e,
                    this.outputBuffer.samples = e,
                    this.inputBuffer.dispose(),
                    this.outputBuffer.dispose()) : i !== e && (this.inputBuffer.dispose(),
                    this.outputBuffer.dispose(),
                    this.inputBuffer = this.createBuffer(t.depthBuffer, t.stencilBuffer, t.texture.type, e),
                    this.inputBuffer.depthTexture = this.depthTexture,
                    this.outputBuffer = this.inputBuffer.clone())
                }
                getTimer() {
                  return this.timer
                }
                getRenderer() {
                  return this.renderer
                }
                setRenderer(e) {
                  if (this.renderer = e,
                  null !== e) {
                    const t = e.getSize(new Dr)
                      , i = e.getContext().getContextAttributes().alpha
                      , n = this.inputBuffer.texture.type;
                    n === jn && e.outputEncoding === cr && (this.inputBuffer.texture.encoding = cr,
                      this.outputBuffer.texture.encoding = cr,
                      this.inputBuffer.dispose(),
                      this.outputBuffer.dispose()),
                      e.autoClear = !1,
                      this.setSize(t.width, t.height);
                    for (const t of this.passes)
                      t.initialize(e, i, n)
                  }
                }
                replaceRenderer(e, t=!0) {
                  const i = this.renderer
                    , n = i.domElement.parentNode;
                  return this.setRenderer(e),
                  t && null !== n && (n.removeChild(i.domElement),
                    n.appendChild(e.domElement)),
                    i
                }
                createDepthTexture() {
                  const e = this.depthTexture = new Wh;
                  return this.inputBuffer.depthTexture = e,
                    this.inputBuffer.dispose(),
                    this.inputBuffer.stencilBuffer ? (e.format = Zn,
                      e.type = Qn) : e.type = Xn,
                    e
                }
                deleteDepthTexture() {
                  if (null !== this.depthTexture) {
                    this.depthTexture.dispose(),
                      this.depthTexture = null,
                      this.inputBuffer.depthTexture = null,
                      this.inputBuffer.dispose();
                    for (const e of this.passes)
                      e.setDepthTexture(null)
                  }
                }
                createBuffer(e, t, i, n) {
                  const r = this.renderer
                    , s = null === r ? new Dr : r.getDrawingBufferSize(new Dr)
                    , a = {
                    minFilter: Hn,
                    magFilter: Hn,
                    stencilBuffer: t,
                    depthBuffer: e,
                    type: i
                  };
                  let o;
                  return n > 0 ? (o = Number(Rn.replace(/\D+/g, "")) < 138 ? new ld(s.width,s.height,a) : new Zr(s.width,s.height,a),
                    o.ignoreDepthForMultisampleCopy = !1,
                    o.samples = n) : o = new Zr(s.width,s.height,a),
                  i === jn && null !== r && r.outputEncoding === cr && (o.texture.encoding = cr),
                    o.texture.name = "EffectComposer.Buffer",
                    o.texture.generateMipmaps = !1,
                    o
                }
                addPass(e, t) {
                  const i = this.passes
                    , n = this.renderer
                    , r = n.getDrawingBufferSize(new Dr)
                    , s = n.getContext().getContextAttributes().alpha
                    , a = this.inputBuffer.texture.type;
                  if (e.setRenderer(n),
                    e.setSize(r.width, r.height),
                    e.initialize(n, s, a),
                  this.autoRenderToScreen && (i.length > 0 && (i[i.length - 1].renderToScreen = !1),
                  e.renderToScreen && (this.autoRenderToScreen = !1)),
                    void 0 !== t ? i.splice(t, 0, e) : i.push(e),
                  this.autoRenderToScreen && (i[i.length - 1].renderToScreen = !0),
                  e.needsDepthTexture || null !== this.depthTexture)
                    if (null === this.depthTexture) {
                      const t = this.createDepthTexture();
                      for (e of i)
                        e.setDepthTexture(t)
                    } else
                      e.setDepthTexture(this.depthTexture)
                }
                removePass(e) {
                  const t = this.passes
                    , i = t.indexOf(e);
                  if (-1 !== i && t.splice(i, 1).length > 0) {
                    if (null !== this.depthTexture) {
                      const i = (e,t)=>e || t.needsDepthTexture;
                      t.reduce(i, !1) || (e.getDepthTexture() === this.depthTexture && e.setDepthTexture(null),
                        this.deleteDepthTexture())
                    }
                    this.autoRenderToScreen && i === t.length && (e.renderToScreen = !1,
                    t.length > 0 && (t[t.length - 1].renderToScreen = !0))
                  }
                }
                removeAllPasses() {
                  const e = this.passes;
                  this.deleteDepthTexture(),
                  e.length > 0 && (this.autoRenderToScreen && (e[e.length - 1].renderToScreen = !1),
                    this.passes = [])
                }
                render(e) {
                  const t = this.renderer
                    , i = this.copyPass;
                  let n, r, s, a = this.inputBuffer, o = this.outputBuffer, l = !1;
                  void 0 === e && (e = this.timer.update().getDelta());
                  for (const h of this.passes)
                    h.enabled && (h.render(t, a, o, e, l),
                    h.needsSwap && (l && (i.renderToScreen = h.renderToScreen,
                      n = t.getContext(),
                      r = t.state.buffers.stencil,
                      r.setFunc(n.NOTEQUAL, 1, 4294967295),
                      i.render(t, a, o, e, l),
                      r.setFunc(n.EQUAL, 1, 4294967295)),
                      s = a,
                      a = o,
                      o = s),
                      h instanceof wp ? l = !0 : h instanceof cp && (l = !1))
                }
                setSize(e, t, i) {
                  const n = this.renderer;
                  if (void 0 === e || void 0 === t) {
                    const i = n.getSize(new Dr);
                    e = i.width,
                      t = i.height
                  }
                  n.setSize(e, t, i);
                  const r = n.getDrawingBufferSize(new Dr);
                  this.inputBuffer.setSize(r.width, r.height),
                    this.outputBuffer.setSize(r.width, r.height);
                  for (const e of this.passes)
                    e.setSize(r.width, r.height)
                }
                reset() {
                  const e = this.timer.isAutoResetEnabled();
                  this.dispose(),
                    this.autoRenderToScreen = !0,
                    this.timer.setAutoResetEnabled(e)
                }
                dispose() {
                  for (const e of this.passes)
                    e.dispose();
                  this.passes = [],
                  null !== this.inputBuffer && this.inputBuffer.dispose(),
                  null !== this.outputBuffer && this.outputBuffer.dispose(),
                    this.deleteDepthTexture(),
                    this.copyPass.dispose(),
                    this.timer.dispose()
                }
              }
              (this.renderer,{
                stencilBuffer: !0
              }),
              this.config = {
                supersampling: 1,
                smaaPreset: (()=>{
                    let e = 0;
                    return 2 == bn.gpuTier && (e = 1),
                    bn.gpuTier >= 3 && (e = 2),
                      e
                  }
                )()
              },
              this.renderPass = new vp(this.scene,this.camera),
              this.renderPassAbout = new vp(this.scene_about,this.camera),
              this.pixelSize = window.devicePixelRatio,
              this.xCount = new td(window.innerWidth / this.pixelSize),
              this.yCount = new td(window.innerHeight / this.pixelSize),
              this.grainEffect = new Ep("grain","#define GLSLIFY 1\nuniform float uXCount;\nuniform float uYCount;\n\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\nfloat speed = 12.;\nfloat intensity = .065;\n\nfloat random2d(vec2 coord){\n    return fract(sin(dot(coord.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\n    float gridX = floor(uv.x * uXCount) / uXCount;\n    float gridY = 1.0 - floor(uv.y * uYCount) / uYCount;\n    float t = mod(time, 10.);\n    //float timeSpeed = time * speed; // -> fluide\n    float timeSpeed = floor(t * speed); // -> saccadé\n    float light = (inputColor.r + inputColor.g + inputColor.b) / 3.;\n    float grain = random2d(vec2(gridX + timeSpeed + light / 100000., gridY)) * intensity;\n    \n    grain -= grain / 2.;\n\n    outputColor = vec4(inputColor.rgb + vec3(grain), 1.0);\n}",{
                blendFunction: 13,
                uniforms: new Map([["uXCount", this.xCount], ["uYCount", this.yCount]])
              }),
              this.blurPass = new bp({
                kernelSize: 2
              }),
              this.renderSavePass = new hp,
              this.depthSavePass = new hp,
              this.blurSavePass = new hp,
              this.effectPass = new _p(this.camera,new Rp(e,t,this.config.smaaPreset),this.grainEffect),
              this.textureMixEffect = new Ep("transition","\n        uniform sampler2D uTexture1;\n        uniform sampler2D uTexture2;\n        uniform sampler2D uTexture3;\n        uniform float uMixerAmp;\n\n        void mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\n            vec4 textureColor1 = texture2D(uTexture1, uv);\n            vec4 textureColor2 = texture2D(uTexture2, uv);\n            vec4 textureColor3 = texture2D(uTexture3, uv);\n\n            float mixer = pow(textureColor1.x, 2.);\n\n            vec4 color = mix(textureColor3, textureColor2, mixer * uMixerAmp);\n\n            outputColor = color;\n        }\n        ",{
                blendFunction: 13,
                uniforms: new Map([["uTexture1", new td(Up.textures["radial-gradient"])], ["uTexture2", new td(this.blurSavePass.renderTarget.texture)], ["uTexture3", new td(this.renderSavePass.renderTarget.texture)], ["uMixerAmp", new td(1)]])
              }),
              this.transitionPass = new _p(this.camera,this.textureMixEffect),
              this.setSizeTimeout = null,
              window.addEventListener("resize", this.setSize.bind(this)),
              this.setSize()
          }
          static compose(e) {
            this.composer.removeAllPasses(),
              e.forEach((e=>{
                  this.composer.addPass(e)
                }
              ))
          }
          static setSize() {
            let e = this.canvas.offsetWidth * this.config.supersampling
              , t = this.canvas.offsetHeight * this.config.supersampling;
            this.composer.setSize(e, t),
              this.camera.aspect = e / t;
            let i = Pr.mapLinear(this.camera.aspect, 1.6, .6, 60, 90);
            i = Pr.clamp(i, 60, 90),
              this.camera.fov = i,
              this.camera.updateProjectionMatrix(),
              clearTimeout(this.setSizeTimeout),
              this.setSizeTimeout = setTimeout((()=>{
                  this.pixelSize = window.devicePixelRatio,
                    this.xCount.value = this.canvas.width / this.pixelSize,
                    this.yCount.value = this.canvas.height / this.pixelSize
                }
              ), 100)
          }
        }
        function nf() {
          this.light = new Su(16777215,255,1),
            this.light.position.set(-10, 10, 0),
            this.scene.add(this.light)
        }
        function rf(e) {
          this.onBeforeLeaveCallbacks || (this.onBeforeLeaveCallbacks = []),
            this.onBeforeLeaveCallbacks.push(e)
        }
        function sf() {
          this.onBeforeLeaveCallbacks && this.onBeforeLeaveCallbacks.forEach((e=>{
              e()
            }
          ))
        }
        function af(e) {
          this.onLeaveCallbacks || (this.onLeaveCallbacks = []),
            this.onLeaveCallbacks.push(e)
        }
        function of() {
          this.onLeaveCallbacks && this.onLeaveCallbacks.forEach((e=>{
              e()
            }
          ))
        }
        function lf(e) {
          this.onEnterCallbacks || (this.onEnterCallbacks = []),
            this.onEnterCallbacks.push(e)
        }
        function hf() {
          this.onEnterCallbacks && this.onEnterCallbacks.forEach((e=>{
              e()
            }
          ))
        }
        function cf() {
          let e, t;
          this.sky = new Qa(new qc(50,16,8),new to({
            vertexShader: "#define GLSLIFY 1\nvarying vec3 vPos;\nvarying vec2 vUv;\n\nvoid main()\n{\n    gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n\n    vPos = position;\n    vUv = uv;\n}",
            fragmentShader: "\nuniform float uTime;\nuniform float uGradientMixer;\nuniform float uYCompression;\n\nvarying vec3 vPos;\nvarying vec2 vUv;\n\nvec4 permute(vec4 x)\n{\n    return mod(((x*34.0)+1.0)*x, 289.0);\n}\n\n//\tClassic Perlin 2D Noise \n//\tby Stefan Gustavson\n//\nvec2 fade(vec2 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\nfloat cnoise(vec2 P){\n    vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n    vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n    Pi = mod(Pi, 289.0); // To avoid truncation effects in permutation\n    vec4 ix = Pi.xzxz;\n    vec4 iy = Pi.yyww;\n    vec4 fx = Pf.xzxz;\n    vec4 fy = Pf.yyww;\n    vec4 i = permute(permute(ix) + iy);\n    vec4 gx = 2.0 * fract(i * 0.0243902439) - 1.0; // 1/41 = 0.024...\n    vec4 gy = abs(gx) - 0.5;\n    vec4 tx = floor(gx + 0.5);\n    gx = gx - tx;\n    vec2 g00 = vec2(gx.x,gy.x);\n    vec2 g10 = vec2(gx.y,gy.y);\n    vec2 g01 = vec2(gx.z,gy.z);\n    vec2 g11 = vec2(gx.w,gy.w);\n    vec4 norm = 1.79284291400159 - 0.85373472095314 * vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));\n    g00 *= norm.x;\n    g01 *= norm.y;\n    g10 *= norm.z;\n    g11 *= norm.w;\n    float n00 = dot(g00, vec2(fx.x, fy.x));\n    float n10 = dot(g10, vec2(fx.y, fy.y));\n    float n01 = dot(g01, vec2(fx.z, fy.z));\n    float n11 = dot(g11, vec2(fx.w, fy.w));\n    vec2 fade_xy = fade(Pf.xy);\n    vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n    float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n    return 2.3 * n_xy;\n}\n\nvec3 rgb( int r, int g, int b ) {\n    return vec3(float(r) / 255.0, float(g) / 255.0, float(b) / 255.0);\n}\n\nvec3 multimix(vec3 elements[3], float v) {\n    lowp int i1 = int(v);\n\n    float completion = mod(v, 1.0);\n\n    if (i1 == 0) {\n        return mix(elements[0], elements[1], completion);\n    } else if (i1 == 1) {\n        return mix(elements[1], elements[2], completion);\n    }\n}\n\nvec3 gradientMultimix(vec3 elements[8], float v) {\n    lowp int i1 = int(v);\n\n    float completion = mod(v, 1.0);\n\n    if (i1 == 0) {\n        return mix(elements[0], elements[1], completion);\n    } else if (i1 == 1) {\n        return mix(elements[1], elements[2], completion);\n    } else if (i1 == 2) {\n        return mix(elements[2], elements[3], completion);\n    } else if (i1 == 3) {\n        return mix(elements[3], elements[4], completion);\n    } else if (i1 == 4) {\n        return mix(elements[4], elements[5], completion);\n    } else if (i1 == 5) {\n        return mix(elements[5], elements[6], completion);\n    } else if (i1 == 6) {\n        return mix(elements[6], elements[7], completion);\n    }\n}\n\nvec3 gradient(vec3 colorTop, vec3 colorBottom, vec3 colorNoise, float yFactor, float noise) {\n    vec3 vertical_gradient = mix(colorTop, colorBottom, yFactor);\n    return mix(vertical_gradient, colorNoise, noise * (1. - yFactor));\n}\n\nvoid main()\n{   \n    float yFactor = (.5 - (vPos.y * uYCompression) / 2. );\n    float speed = .2;\n    float noise = cnoise(vPos.xy * .025 + uTime * speed);\n    noise += cnoise(vPos.xy * .025 - uTime * speed);\n    noise = clamp(noise, 0., 1.);\n\n    vec3 gradients[8];\n    gradients[0] = gradient(rgb(8, 37, 198), rgb(196, 203, 244), rgb(0, 27, 181), yFactor, noise);\n    gradients[1] = gradient(rgb(116, 136, 234), rgb(255, 192, 148), rgb(116, 136, 234), yFactor, noise);\n    gradients[2] = gradient(rgb(255, 192, 148), rgb(222, 229, 253), rgb(136, 162, 247), yFactor, noise);\n    gradients[3] = gradient(rgb(136, 162, 247), rgb(222, 229, 253), rgb(136, 162, 247), yFactor, noise);\n    gradients[4] = gradient(rgb(136, 162, 247), rgb(222, 229, 253), rgb(255, 192, 148), yFactor, noise);\n    gradients[5] = gradient(rgb(253, 175, 120), rgb(255, 230, 213), rgb(253, 175, 120), yFactor, noise);\n    gradients[6] = gradient(rgb(253, 175, 120), rgb(197, 211, 254), rgb(90, 108, 216), yFactor, noise);\n    gradients[7] = gradient(rgb(90, 108, 216), rgb(197, 211, 254), rgb(90, 108, 216), yFactor, noise);\n\n    float gradientLength = 8.;\n    vec3 color = gradientMultimix(gradients, uGradientMixer * (gradientLength - 1.));\n\n    gl_FragColor = vec4(color, 1.0);\n}\n",
            side: 1,
            uniforms: {
              uTime: {
                value: 0
              },
              uGradientMixer: {
                value: .5
              },
              uYCompression: {
                value: .06
              }
            }
          })),
            e = Pr.mapLinear(this.camera.aspect, 1.6, .6, .06, .04),
            e = Pr.clamp(e, .04, .06),
            this.sky.material.uniforms.uYCompression.value = e,
            window.addEventListener("resize", (()=>{
                clearTimeout(t),
                  t = setTimeout((()=>{
                      e = Pr.mapLinear(this.camera.aspect, 1.6, .6, .06, .04),
                        e = Pr.clamp(e, .04, .06),
                        this.sky.material.uniforms.uYCompression.value = e
                    }
                  ), 100)
              }
            )),
            this.scene.add(this.sky),
            _n.ticker.add((e=>{
                this.sky.material.uniforms.uTime.value = e
              }
            ))
        }
        function uf() {
          const e = Math.random() > .5 ? 1 : -1
            , t = new Uc([new ts(0,0,0).multiplyScalar(this.curve_size_factor), new ts(0,0,-20).multiplyScalar(this.curve_size_factor), new ts(5 * e,0,-40).multiplyScalar(this.curve_size_factor), new ts(5 * -e,0,-60).multiplyScalar(this.curve_size_factor), new ts(5 * e,0,-80).multiplyScalar(this.curve_size_factor), new ts(0,0,-100).multiplyScalar(this.curve_size_factor), new ts(0,0,-120).multiplyScalar(this.curve_size_factor)]);
          t.curveType = "catmullrom",
            t.closed = !1,
            t.tension = .5,
            this.curveMesh = new Qa(new Qc(t,200 * this.curve_size_factor,.02,5,t.closed),new va({
              color: 16777215,
              transparent: !0,
              opacity: 0
            })),
            this.curveMesh.position.y = -.5,
            this.scene.add(this.curveMesh)
        }
        function df() {
          let e;
          Up.models.plane.scene.traverse((function(t) {
              t.isMesh && (e = t.geometry)
            }
          )),
            this.plane = new Qa(e,new Zc({
              color: "white",
              transparent: !0
            })),
            this.scene.add(this.plane),
            this.plane.initPosition = this.plane.position.clone(),
            this.plane.introPosition = new ts(0,-2,7 * this.curve_size_factor),
            this.plane.initRotation = this.plane.rotation.clone()
        }
        function pf() {
          var e, t = 0, i = [], n = 0, r = 0, s = d((function(e) {
              r || o(1, e)
            }
          )), a = d((function(e) {
              r || o(-1, e)
            }
          ));
          function o(i, n) {
            r++;
            var s = 0;
            try {
              n === m && p();
              var a = i > 0 && u(n);
              a ? a.call(n, d((function(e) {
                  s++,
                    o(1, e)
                }
              )), d((function(e) {
                  s++,
                    o(-1, e)
                }
              ))) : (t = i,
                e = n,
                l())
            } catch (e) {
              t || s || o(-1, e)
            }
          }
          function l() {
            n || (setTimeout(h, 0),
              n = 1)
          }
          function h() {
            var e = i;
            n = 0,
              i = [],
              e.forEach(c)
          }
          function c(e) {
            e()
          }
          function u(e) {
            var t = e && (f(e) || "object" == typeof e) && e.then;
            return f(t) && t
          }
          function d(e) {
            var t = 0;
            return function() {
              for (var i = [], n = arguments.length; n--; )
                i[n] = arguments[n];
              t++ || e.apply(this, i)
            }
          }
          function p() {
            throw new TypeError("Chaining cycle detected")
          }
          var f = function(e) {
            return "function" == typeof e
          }
            , m = {
            then: function(n, r) {
              var s = pf();
              return i.push((function() {
                  var i = t > 0 ? n : r;
                  if (f(i))
                    try {
                      var a = i(e);
                      a === s && p();
                      var o = u(a);
                      o ? o.call(a, s.resolve, s.reject) : s.resolve(a)
                    } catch (e) {
                      s.reject(e)
                    }
                  else
                    s[t > 0 ? "resolve" : "reject"](e)
                }
              )),
              t && l(),
                s
            },
            resolve: s,
            reject: a
          };
          return m
        }
        function ff() {
          var e, t, i = new Promise((function(i, n) {
              e = i,
                t = n
            }
          ));
          return {
            then: i.then.bind(i),
            resolve: e,
            reject: t
          }
        }
        pf.all = ff.all = function(e) {
          var t = 0
            , i = []
            , n = mf();
          return 0 === e.length ? n.resolve([]) : e.forEach((function(r, s) {
              var a = mf();
              a.resolve(r),
                a.then((function(r) {
                    t++,
                      i[s] = r,
                    t === e.length && n.resolve(i)
                  }
                ), n.reject)
            }
          )),
            n
        }
        ;
        var mf = "function" == typeof Promise ? ff : pf;
        function gf() {
          var e = Object.create(null);
          function t(n, r) {
            var s = n.id
              , a = n.name
              , o = n.dependencies;
            void 0 === o && (o = []);
            var l = n.init;
            void 0 === l && (l = function() {}
            );
            var h = n.getTransferables;
            if (void 0 === h && (h = null),
              !e[s])
              try {
                o = o.map((function(i) {
                    return i && i.isWorkerModule && (t(i, (function(e) {
                        if (e instanceof Error)
                          throw e
                      }
                    )),
                      i = e[i.id].value),
                      i
                  }
                )),
                  l = i("<" + a + ">.init", l),
                h && (h = i("<" + a + ">.getTransferables", h));
                var c = null;
                "function" == typeof l ? c = l.apply(void 0, o) : console.error("worker module init function failed to rehydrate"),
                  e[s] = {
                    id: s,
                    value: c,
                    getTransferables: h
                  },
                  r(c)
              } catch (e) {
                e && e.noLog || console.error(e),
                  r(e)
              }
          }
          function i(e, t) {
            var i = void 0;
            self.troikaDefine = function(e) {
              return i = e
            }
            ;
            var n = URL.createObjectURL(new Blob(["/** " + e.replace(/\*/g, "") + " **/\n\ntroikaDefine(\n" + t + "\n)"],{
              type: "application/javascript"
            }));
            try {
              importScripts(n)
            } catch (e) {
              console.error(e)
            }
            return URL.revokeObjectURL(n),
              delete self.troikaDefine,
              i
          }
          self.addEventListener("message", (function(i) {
              var n = i.data
                , r = n.messageId
                , s = n.action
                , a = n.data;
              try {
                "registerModule" === s && t(a, (function(e) {
                    e instanceof Error ? postMessage({
                      messageId: r,
                      success: !1,
                      error: e.message
                    }) : postMessage({
                      messageId: r,
                      success: !0,
                      result: {
                        isCallable: "function" == typeof e
                      }
                    })
                  }
                )),
                "callModule" === s && function(t, i) {
                  var n, r = t.id, s = t.args;
                  e[r] && "function" == typeof e[r].value || i(new Error("Worker module " + r + ": not found or its 'init' did not return a function"));
                  try {
                    var a = (n = e[r]).value.apply(n, s);
                    a && "function" == typeof a.then ? a.then(o, (function(e) {
                        return i(e instanceof Error ? e : new Error("" + e))
                      }
                    )) : o(a)
                  } catch (e) {
                    i(e)
                  }
                  function o(t) {
                    try {
                      var n = e[r].getTransferables && e[r].getTransferables(t);
                      n && Array.isArray(n) && n.length || (n = void 0),
                        i(t, n)
                    } catch (e) {
                      console.error(e),
                        i(e)
                    }
                  }
                }(a, (function(e, t) {
                    e instanceof Error ? postMessage({
                      messageId: r,
                      success: !1,
                      error: e.message
                    }) : postMessage({
                      messageId: r,
                      success: !0,
                      result: e
                    }, t || void 0)
                  }
                ))
              } catch (e) {
                postMessage({
                  messageId: r,
                  success: !1,
                  error: e.stack
                })
              }
            }
          ))
        }
        var vf = function() {
          var e = !1;
          if ("undefined" != typeof window && void 0 !== window.document)
            try {
              new Worker(URL.createObjectURL(new Blob([""],{
                type: "application/javascript"
              }))).terminate(),
                e = !0
            } catch (e) {
              console.log("Troika createWorkerModule: web workers not allowed; falling back to main thread execution. Cause: [" + e.message + "]")
            }
          return vf = function() {
            return e
          }
            ,
            e
        }
          , yf = 0
          , xf = 0
          , _f = !1
          , bf = Object.create(null)
          , wf = Object.create(null)
          , Af = Object.create(null);
        function Sf(e) {
          if (!(e && "function" == typeof e.init || _f))
            throw new Error("requires `options.init` function");
          var t = e.dependencies
            , i = e.init
            , n = e.getTransferables
            , r = e.workerId;
          if (!vf())
            return function(e) {
              var t = function() {
                for (var e = [], i = arguments.length; i--; )
                  e[i] = arguments[i];
                return t._getInitResult().then((function(t) {
                    if ("function" == typeof t)
                      return t.apply(void 0, e);
                    throw new Error("Worker module function was called but `init` did not return a callable function")
                  }
                ))
              };
              return t._getInitResult = function() {
                var i = e.dependencies
                  , n = e.init;
                i = Array.isArray(i) ? i.map((function(e) {
                    return e && e._getInitResult ? e._getInitResult() : e
                  }
                )) : [];
                var r = mf.all(i).then((function(e) {
                    return n.apply(null, e)
                  }
                ));
                return t._getInitResult = function() {
                  return r
                }
                  ,
                  r
              }
                ,
                t
            }(e);
          null == r && (r = "#default");
          var s = "workerModule" + ++yf
            , a = e.name || s
            , o = null;
          function l() {
            for (var e = [], t = arguments.length; t--; )
              e[t] = arguments[t];
            if (!o) {
              o = Tf(r, "registerModule", l.workerModuleData);
              var i = function() {
                o = null,
                  wf[r].delete(i)
              };
              (wf[r] || (wf[r] = new Set)).add(i)
            }
            return o.then((function(t) {
                if (t.isCallable)
                  return Tf(r, "callModule", {
                    id: s,
                    args: e
                  });
                throw new Error("Worker module function was called but `init` did not return a callable function")
              }
            ))
          }
          return t = t && t.map((function(e) {
              return "function" != typeof e || e.workerModuleData || (_f = !0,
                e = Sf({
                  workerId: r,
                  name: "<" + a + "> function dependency: " + e.name,
                  init: "function(){return (\n" + Mf(e) + "\n)}"
                }),
                _f = !1),
              e && e.workerModuleData && (e = e.workerModuleData),
                e
            }
          )),
            l.workerModuleData = {
              isWorkerModule: !0,
              id: s,
              name: a,
              dependencies: t,
              init: Mf(i),
              getTransferables: n && Mf(n)
            },
            l
        }
        function Mf(e) {
          var t = e.toString();
          return !/^function/.test(t) && /^\w+\s*\(/.test(t) && (t = "function " + t),
            t
        }
        function Tf(e, t, i) {
          var n = mf()
            , r = ++xf;
          return Af[r] = function(e) {
            e.success ? n.resolve(e.result) : n.reject(new Error("Error in worker " + t + " call: " + e.error))
          }
            ,
            function(e) {
              var t = bf[e];
              if (!t) {
                var i = Mf(gf);
                (t = bf[e] = new Worker(URL.createObjectURL(new Blob(["/** Worker Module Bootstrap: " + e.replace(/\*/g, "") + " **/\n\n;(" + i + ")()"],{
                  type: "application/javascript"
                })))).onmessage = function(e) {
                  var t = e.data
                    , i = t.messageId
                    , n = Af[i];
                  if (!n)
                    throw new Error("WorkerModule response with empty or unknown messageId");
                  delete Af[i],
                    n(t)
                }
              }
              return t
            }(e).postMessage({
              messageId: r,
              action: t,
              data: i
            }),
            n
        }
        var Ef = Sf({
          name: "Thenable",
          dependencies: [mf],
          init: function(e) {
            return e
          }
        });
        function Cf() {
          var e = function(e) {
            function t(e, t, i, n, r, s, a, o) {
              var l = 1 - a;
              o.x = l * l * e + 2 * l * a * i + a * a * r,
                o.y = l * l * t + 2 * l * a * n + a * a * s
            }
            function i(e, t, i, n, r, s, a, o, l, h) {
              var c = 1 - l;
              h.x = c * c * c * e + 3 * c * c * l * i + 3 * c * l * l * r + l * l * l * a,
                h.y = c * c * c * t + 3 * c * c * l * n + 3 * c * l * l * s + l * l * l * o
            }
            function n(e, t) {
              for (var i, n, r, s, a, o = /([MLQCZ])([^MLQCZ]*)/g; i = o.exec(e); ) {
                var l = i[2].replace(/^\s*|\s*$/g, "").split(/[,\s]+/).map((function(e) {
                    return parseFloat(e)
                  }
                ));
                switch (i[1]) {
                  case "M":
                    s = n = l[0],
                      a = r = l[1];
                    break;
                  case "L":
                    l[0] === s && l[1] === a || t("L", s, a, s = l[0], a = l[1]);
                    break;
                  case "Q":
                    t("Q", s, a, s = l[2], a = l[3], l[0], l[1]);
                    break;
                  case "C":
                    t("C", s, a, s = l[4], a = l[5], l[0], l[1], l[2], l[3]);
                    break;
                  case "Z":
                    s === n && a === r || t("L", s, a, n, r)
                }
              }
            }
            function r(e, r, s) {
              void 0 === s && (s = 16);
              var a = {
                x: 0,
                y: 0
              };
              n(e, (function(e, n, o, l, h, c, u, d, p) {
                  switch (e) {
                    case "L":
                      r(n, o, l, h);
                      break;
                    case "Q":
                      for (var f = n, m = o, g = 1; g < s; g++)
                        t(n, o, c, u, l, h, g / (s - 1), a),
                          r(f, m, a.x, a.y),
                          f = a.x,
                          m = a.y;
                      break;
                    case "C":
                      for (var v = n, y = o, x = 1; x < s; x++)
                        i(n, o, c, u, d, p, l, h, x / (s - 1), a),
                          r(v, y, a.x, a.y),
                          v = a.x,
                          y = a.y
                  }
                }
              ))
            }
            var s = "precision highp float;attribute vec2 aUV;varying vec2 vUV;void main(){vUV=aUV;gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}"
              , a = new WeakMap
              , o = {
              premultipliedAlpha: !1,
              preserveDrawingBuffer: !0,
              antialias: !1,
              depth: !1
            };
            function l(e, t) {
              var i = e.getContext ? e.getContext("webgl", o) : e
                , n = a.get(i);
              if (!n) {
                var r = "undefined" != typeof WebGL2RenderingContext && i instanceof WebGL2RenderingContext
                  , s = {}
                  , l = {}
                  , h = {}
                  , c = -1
                  , u = [];
                function d(e) {
                  var t = s[e];
                  if (!t && !(t = s[e] = i.getExtension(e)))
                    throw new Error(e + " not supported");
                  return t
                }
                function p(e, t) {
                  var n = i.createShader(t);
                  return i.shaderSource(n, e),
                    i.compileShader(n),
                    n
                }
                function f(e, t, n, s) {
                  if (!l[e]) {
                    var a = {}
                      , o = {}
                      , h = i.createProgram();
                    i.attachShader(h, p(t, i.VERTEX_SHADER)),
                      i.attachShader(h, p(n, i.FRAGMENT_SHADER)),
                      i.linkProgram(h),
                      l[e] = {
                        program: h,
                        transaction: function(e) {
                          i.useProgram(h),
                            e({
                              setUniform: function(e, t) {
                                for (var n = [], r = arguments.length - 2; r-- > 0; )
                                  n[r] = arguments[r + 2];
                                var s = o[t] || (o[t] = i.getUniformLocation(h, t));
                                i["uniform" + e].apply(i, [s].concat(n))
                              },
                              setAttribute: function(e, t, n, s, o) {
                                var l = a[e];
                                l || (l = a[e] = {
                                  buf: i.createBuffer(),
                                  loc: i.getAttribLocation(h, e),
                                  data: null
                                }),
                                  i.bindBuffer(i.ARRAY_BUFFER, l.buf),
                                  i.vertexAttribPointer(l.loc, t, i.FLOAT, !1, 0, 0),
                                  i.enableVertexAttribArray(l.loc),
                                  r ? i.vertexAttribDivisor(l.loc, s) : d("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(l.loc, s),
                                o !== l.data && (i.bufferData(i.ARRAY_BUFFER, o, n),
                                  l.data = o)
                              }
                            })
                        }
                      }
                  }
                  l[e].transaction(s)
                }
                function m(e, t) {
                  c++;
                  try {
                    i.activeTexture(i.TEXTURE0 + c);
                    var n = h[e];
                    n || (n = h[e] = i.createTexture(),
                      i.bindTexture(i.TEXTURE_2D, n),
                      i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, i.NEAREST),
                      i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, i.NEAREST)),
                      i.bindTexture(i.TEXTURE_2D, n),
                      t(n, c)
                  } finally {
                    c--
                  }
                }
                function g(e, t, n) {
                  var r = i.createFramebuffer();
                  u.push(r),
                    i.bindFramebuffer(i.FRAMEBUFFER, r),
                    i.activeTexture(i.TEXTURE0 + t),
                    i.bindTexture(i.TEXTURE_2D, e),
                    i.framebufferTexture2D(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, e, 0);
                  try {
                    n(r)
                  } finally {
                    i.deleteFramebuffer(r),
                      i.bindFramebuffer(i.FRAMEBUFFER, u[--u.length - 1] || null)
                  }
                }
                function v() {
                  s = {},
                    l = {},
                    h = {},
                    c = -1,
                    u.length = 0
                }
                i.canvas.addEventListener("webglcontextlost", (function(e) {
                    v(),
                      e.preventDefault()
                  }
                ), !1),
                  a.set(i, n = {
                    gl: i,
                    isWebGL2: r,
                    getExtension: d,
                    withProgram: f,
                    withTexture: m,
                    withTextureFramebuffer: g,
                    handleContextLoss: v
                  })
              }
              t(n)
            }
            function h(e, t, i, n, r, a, o, h) {
              void 0 === o && (o = 15),
              void 0 === h && (h = null),
                l(e, (function(e) {
                    var l = e.gl
                      , c = e.withProgram;
                    (0,
                      e.withTexture)("copy", (function(e, u) {
                        l.texImage2D(l.TEXTURE_2D, 0, l.RGBA, r, a, 0, l.RGBA, l.UNSIGNED_BYTE, t),
                          c("copy", s, "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){gl_FragColor=texture2D(tex,vUV);}", (function(e) {
                              var t = e.setUniform;
                              (0,
                                e.setAttribute)("aUV", 2, l.STATIC_DRAW, 0, new Float32Array([0, 0, 2, 0, 0, 2])),
                                t("1i", "image", u),
                                l.bindFramebuffer(l.FRAMEBUFFER, h || null),
                                l.disable(l.BLEND),
                                l.colorMask(8 & o, 4 & o, 2 & o, 1 & o),
                                l.viewport(i, n, r, a),
                                l.scissor(i, n, r, a),
                                l.drawArrays(l.TRIANGLES, 0, 3)
                            }
                          ))
                      }
                    ))
                  }
                ))
            }
            var c = Object.freeze({
              __proto__: null,
              withWebGLContext: l,
              renderImageData: h,
              resizeWebGLCanvasWithoutClearing: function(e, t, i) {
                var n = e.width
                  , r = e.height;
                l(e, (function(s) {
                    var a = s.gl
                      , o = new Uint8Array(n * r * 4);
                    a.readPixels(0, 0, n, r, a.RGBA, a.UNSIGNED_BYTE, o),
                      e.width = t,
                      e.height = i,
                      h(a, o, 0, 0, n, r)
                  }
                ))
              }
            });
            function u(e, t, i, n, s, a) {
              void 0 === a && (a = 1);
              var o = new Uint8Array(e * t)
                , l = n[2] - n[0]
                , h = n[3] - n[1]
                , c = [];
              r(i, (function(e, t, i, n) {
                  c.push({
                    x1: e,
                    y1: t,
                    x2: i,
                    y2: n,
                    minX: Math.min(e, i),
                    minY: Math.min(t, n),
                    maxX: Math.max(e, i),
                    maxY: Math.max(t, n)
                  })
                }
              )),
                c.sort((function(e, t) {
                    return e.maxX - t.maxX
                  }
                ));
              for (var u = 0; u < e; u++)
                for (var d = 0; d < t; d++) {
                  var p = g(n[0] + l * (u + .5) / e, n[1] + h * (d + .5) / t)
                    , m = Math.pow(1 - Math.abs(p) / s, a) / 2;
                  p < 0 && (m = 1 - m),
                    m = Math.max(0, Math.min(255, Math.round(255 * m))),
                    o[d * e + u] = m
                }
              return o;
              function g(e, t) {
                for (var i = 1 / 0, n = 1 / 0, r = c.length; r--; ) {
                  var s = c[r];
                  if (s.maxX + n <= e)
                    break;
                  if (e + n > s.minX && t - n < s.maxY && t + n > s.minY) {
                    var a = f(e, t, s.x1, s.y1, s.x2, s.y2);
                    a < i && (i = a,
                      n = Math.sqrt(i))
                  }
                }
                return function(e, t) {
                  for (var i = 0, n = c.length; n--; ) {
                    var r = c[n];
                    if (r.maxX <= e)
                      break;
                    r.y1 > t != r.y2 > t && e < (r.x2 - r.x1) * (t - r.y1) / (r.y2 - r.y1) + r.x1 && (i += r.y1 < r.y2 ? 1 : -1)
                  }
                  return 0 !== i
                }(e, t) && (n = -n),
                  n
              }
            }
            function d(e, t, i, n, r, s, a, o, l, h) {
              void 0 === s && (s = 1),
              void 0 === o && (o = 0),
              void 0 === l && (l = 0),
              void 0 === h && (h = 0),
                p(e, t, i, n, r, s, a, null, o, l, h)
            }
            function p(e, t, i, n, r, s, a, o, l, c, d) {
              void 0 === s && (s = 1),
              void 0 === l && (l = 0),
              void 0 === c && (c = 0),
              void 0 === d && (d = 0);
              for (var p = u(e, t, i, n, r, s), f = new Uint8Array(4 * p.length), m = 0; m < p.length; m++)
                f[4 * m + d] = p[m];
              h(a, f, l, c, e, t, 1 << 3 - d, o)
            }
            function f(e, t, i, n, r, s) {
              var a = r - i
                , o = s - n
                , l = a * a + o * o
                , h = l ? Math.max(0, Math.min(1, ((e - i) * a + (t - n) * o) / l)) : 0
                , c = e - (i + h * a)
                , u = t - (n + h * o);
              return c * c + u * u
            }
            var m = Object.freeze({
              __proto__: null,
              generate: u,
              generateIntoCanvas: d,
              generateIntoFramebuffer: p
            })
              , g = new Float32Array([0, 0, 2, 0, 0, 2])
              , v = null
              , y = !1
              , x = {}
              , _ = new WeakMap;
            function b(e) {
              if (!y && !M(e))
                throw new Error("WebGL generation not supported")
            }
            function w(e, t, i, n, r, s, a) {
              if (void 0 === s && (s = 1),
              void 0 === a && (a = null),
              !a && !(a = v)) {
                var o = "function" == typeof OffscreenCanvas ? new OffscreenCanvas(1,1) : "undefined" != typeof document ? document.createElement("canvas") : null;
                if (!o)
                  throw new Error("OffscreenCanvas or DOM canvas not supported");
                a = v = o.getContext("webgl", {
                  depth: !1
                })
              }
              b(a);
              var h = new Uint8Array(e * t * 4);
              l(a, (function(a) {
                  var o = a.gl
                    , l = a.withTexture
                    , c = a.withTextureFramebuffer;
                  l("readable", (function(a, l) {
                      o.texImage2D(o.TEXTURE_2D, 0, o.RGBA, e, t, 0, o.RGBA, o.UNSIGNED_BYTE, null),
                        c(a, l, (function(a) {
                            S(e, t, i, n, r, s, o, a, 0, 0, 0),
                              o.readPixels(0, 0, e, t, o.RGBA, o.UNSIGNED_BYTE, h)
                          }
                        ))
                    }
                  ))
                }
              ));
              for (var c = new Uint8Array(e * t), u = 0, d = 0; u < h.length; u += 4)
                c[d++] = h[u];
              return c
            }
            function A(e, t, i, n, r, s, a, o, l, h) {
              void 0 === s && (s = 1),
              void 0 === o && (o = 0),
              void 0 === l && (l = 0),
              void 0 === h && (h = 0),
                S(e, t, i, n, r, s, a, null, o, l, h)
            }
            function S(e, t, i, n, a, o, h, c, u, d, p) {
              void 0 === o && (o = 1),
              void 0 === u && (u = 0),
              void 0 === d && (d = 0),
              void 0 === p && (p = 0),
                b(h);
              var f = [];
              r(i, (function(e, t, i, n) {
                  f.push(e, t, i, n)
                }
              )),
                f = new Float32Array(f),
                l(h, (function(i) {
                    var r = i.gl
                      , l = i.isWebGL2
                      , h = i.getExtension
                      , m = i.withProgram
                      , v = i.withTexture
                      , y = i.withTextureFramebuffer
                      , x = i.handleContextLoss;
                    if (v("rawDistances", (function(i, v) {
                        e === i._lastWidth && t === i._lastHeight || r.texImage2D(r.TEXTURE_2D, 0, r.RGBA, i._lastWidth = e, i._lastHeight = t, 0, r.RGBA, r.UNSIGNED_BYTE, null),
                          m("main", "precision highp float;uniform vec4 uGlyphBounds;attribute vec2 aUV;attribute vec4 aLineSegment;varying vec4 vLineSegment;varying vec2 vGlyphXY;void main(){vLineSegment=aLineSegment;vGlyphXY=mix(uGlyphBounds.xy,uGlyphBounds.zw,aUV);gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}", "precision highp float;uniform vec4 uGlyphBounds;uniform float uMaxDistance;uniform float uExponent;varying vec4 vLineSegment;varying vec2 vGlyphXY;float absDistToSegment(vec2 point,vec2 lineA,vec2 lineB){vec2 lineDir=lineB-lineA;float lenSq=dot(lineDir,lineDir);float t=lenSq==0.0 ? 0.0 : clamp(dot(point-lineA,lineDir)/lenSq,0.0,1.0);vec2 linePt=lineA+t*lineDir;return distance(point,linePt);}void main(){vec4 seg=vLineSegment;vec2 p=vGlyphXY;float dist=absDistToSegment(p,seg.xy,seg.zw);float val=pow(1.0-clamp(dist/uMaxDistance,0.0,1.0),uExponent)*0.5;bool crossing=(seg.y>p.y!=seg.w>p.y)&&(p.x<(seg.z-seg.x)*(p.y-seg.y)/(seg.w-seg.y)+seg.x);bool crossingUp=crossing&&vLineSegment.y<vLineSegment.w;gl_FragColor=vec4(crossingUp ? 1.0/255.0 : 0.0,crossing&&!crossingUp ? 1.0/255.0 : 0.0,0.0,val);}", (function(s) {
                              var c = s.setAttribute
                                , u = s.setUniform
                                , d = !l && h("ANGLE_instanced_arrays")
                                , p = !l && h("EXT_blend_minmax");
                              c("aUV", 2, r.STATIC_DRAW, 0, g),
                                c("aLineSegment", 4, r.DYNAMIC_DRAW, 1, f),
                                u.apply(void 0, ["4f", "uGlyphBounds"].concat(n)),
                                u("1f", "uMaxDistance", a),
                                u("1f", "uExponent", o),
                                y(i, v, (function(i) {
                                    r.enable(r.BLEND),
                                      r.colorMask(!0, !0, !0, !0),
                                      r.viewport(0, 0, e, t),
                                      r.scissor(0, 0, e, t),
                                      r.blendFunc(r.ONE, r.ONE),
                                      r.blendEquationSeparate(r.FUNC_ADD, l ? r.MAX : p.MAX_EXT),
                                      r.clear(r.COLOR_BUFFER_BIT),
                                      l ? r.drawArraysInstanced(r.TRIANGLES, 0, 3, f.length / 4) : d.drawArraysInstancedANGLE(r.TRIANGLES, 0, 3, f.length / 4)
                                  }
                                ))
                            }
                          )),
                          m("post", s, "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){vec4 color=texture2D(tex,vUV);bool inside=color.r!=color.g;float val=inside ? 1.0-color.a : color.a;gl_FragColor=vec4(val);}", (function(i) {
                              i.setAttribute("aUV", 2, r.STATIC_DRAW, 0, g),
                                i.setUniform("1i", "tex", v),
                                r.bindFramebuffer(r.FRAMEBUFFER, c),
                                r.disable(r.BLEND),
                                r.colorMask(0 === p, 1 === p, 2 === p, 3 === p),
                                r.viewport(u, d, e, t),
                                r.scissor(u, d, e, t),
                                r.drawArrays(r.TRIANGLES, 0, 3)
                            }
                          ))
                      }
                    )),
                      r.isContextLost())
                      throw x(),
                        new Error("webgl context lost")
                  }
                ))
            }
            function M(e) {
              var t = e && e !== v ? e.canvas || e : x
                , i = _.get(t);
              if (void 0 === i) {
                y = !0;
                var n = null;
                try {
                  var r = [97, 106, 97, 61, 99, 137, 118, 80, 80, 118, 137, 99, 61, 97, 106, 97]
                    , s = w(4, 4, "M8,8L16,8L24,24L16,24Z", [0, 0, 32, 32], 24, 1, e);
                  i = s && r.length === s.length && s.every((function(e, t) {
                      return e === r[t]
                    }
                  )),
                  i || (n = "bad trial run results",
                    console.info(r, s))
                } catch (e) {
                  i = !1,
                    n = e.message
                }
                n && console.warn("WebGL SDF generation not supported:", n),
                  y = !1,
                  _.set(t, i)
              }
              return i
            }
            var T = Object.freeze({
              __proto__: null,
              generate: w,
              generateIntoCanvas: A,
              generateIntoFramebuffer: S,
              isSupported: M
            });
            return e.forEachPathCommand = n,
              e.generate = function(e, t, i, n, r, s) {
                void 0 === r && (r = Math.max(n[2] - n[0], n[3] - n[1]) / 2),
                void 0 === s && (s = 1);
                try {
                  return w.apply(T, arguments)
                } catch (e) {
                  return console.info("WebGL SDF generation failed, falling back to JS", e),
                    u.apply(m, arguments)
                }
              }
              ,
              e.generateIntoCanvas = function(e, t, i, n, r, s, a, o, l, h) {
                void 0 === r && (r = Math.max(n[2] - n[0], n[3] - n[1]) / 2),
                void 0 === s && (s = 1),
                void 0 === o && (o = 0),
                void 0 === l && (l = 0),
                void 0 === h && (h = 0);
                try {
                  return A.apply(T, arguments)
                } catch (e) {
                  return console.info("WebGL SDF generation failed, falling back to JS", e),
                    d.apply(m, arguments)
                }
              }
              ,
              e.javascript = m,
              e.pathToLineSegments = r,
              e.webgl = T,
              e.webglUtils = c,
              Object.defineProperty(e, "__esModule", {
                value: !0
              }),
              e
          }({});
          return e
        }
        const Pf = /\bvoid\s+main\s*\(\s*\)\s*{/g;
        function Df(e) {
          return e.replace(/^[ \t]*#include +<([\w\d./]+)>/gm, (function(e, t) {
              let i = xo[t];
              return i ? Df(i) : e
            }
          ))
        }
        const If = [];
        for (let e = 0; e < 256; e++)
          If[e] = (e < 16 ? "0" : "") + e.toString(16);
        const Rf = Object.assign || function() {
          let e = arguments[0];
          for (let t = 1, i = arguments.length; t < i; t++) {
            let i = arguments[t];
            if (i)
              for (let t in i)
                i.hasOwnProperty(t) && (e[t] = i[t])
          }
          return e
        }
          , Lf = Date.now()
          , kf = new WeakMap
          , Ff = new Map;
        let Bf = 1e10;
        function Of(e, t) {
          const i = function(e) {
            const t = JSON.stringify(e, zf);
            let i = Gf.get(t);
            return null == i && Gf.set(t, i = ++Uf),
              i
          }(t);
          let n = kf.get(e);
          if (n || kf.set(e, n = Object.create(null)),
            n[i])
            return new n[i];
          const r = `_onBeforeCompile${i}`
            , s = function(n) {
            e.onBeforeCompile.call(this, n);
            const s = this.customProgramCacheKey() + "|" + n.vertexShader + "|" + n.fragmentShader;
            let a = Ff[s];
            if (!a) {
              const e = function({vertexShader: e, fragmentShader: t}, i, n) {
                let {vertexDefs: r, vertexMainIntro: s, vertexMainOutro: a, vertexTransform: o, fragmentDefs: l, fragmentMainIntro: h, fragmentMainOutro: c, fragmentColorTransform: u, customRewriter: d, timeUniform: p} = i;
                if (r = r || "",
                  s = s || "",
                  a = a || "",
                  l = l || "",
                  h = h || "",
                  c = c || "",
                (o || d) && (e = Df(e)),
                (u || d) && (t = Df(t = t.replace(/^[ \t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm, "\n//!BEGIN_POST_CHUNK $1\n$&\n//!END_POST_CHUNK\n"))),
                  d) {
                  let i = d({
                    vertexShader: e,
                    fragmentShader: t
                  });
                  e = i.vertexShader,
                    t = i.fragmentShader
                }
                if (u) {
                  let e = [];
                  t = t.replace(/^\/\/!BEGIN_POST_CHUNK[^]+?^\/\/!END_POST_CHUNK/gm, (t=>(e.push(t),
                    ""))),
                    c = `${u}\n${e.join("\n")}\n${c}`
                }
                if (p) {
                  const e = `\nuniform float ${p};\n`;
                  r = e + r,
                    l = e + l
                }
                return o && (r = `${r}\nvoid troikaVertexTransform${n}(inout vec3 position, inout vec3 normal, inout vec2 uv) {\n  ${o}\n}\n`,
                  s = `\ntroika_position_${n} = vec3(position);\ntroika_normal_${n} = vec3(normal);\ntroika_uv_${n} = vec2(uv);\ntroikaVertexTransform${n}(troika_position_${n}, troika_normal_${n}, troika_uv_${n});\n${s}\n`,
                  e = (e = `vec3 troika_position_${n};\nvec3 troika_normal_${n};\nvec2 troika_uv_${n};\n${e}\n`).replace(/\b(position|normal|uv)\b/g, ((e,t,i,r)=>/\battribute\s+vec[23]\s+$/.test(r.substr(0, i)) ? t : `troika_${t}_${n}`))),
                  {
                    vertexShader: e = Nf(e, n, r, s, a),
                    fragmentShader: t = Nf(t, n, l, h, c)
                  }
              }(n, t, i);
              a = Ff[s] = e
            }
            n.vertexShader = a.vertexShader,
              n.fragmentShader = a.fragmentShader,
              Rf(n.uniforms, this.uniforms),
            t.timeUniform && (n.uniforms[t.timeUniform] = {
              get value() {
                return Date.now() - Lf
              }
            }),
            this[r] && this[r](n)
          }
            , a = function() {
            return o(t.chained ? e : e.clone())
          }
            , o = function(n) {
            const r = Object.create(n, l);
            return Object.defineProperty(r, "baseMaterial", {
              value: e
            }),
              Object.defineProperty(r, "id", {
                value: Bf++
              }),
              r.uuid = function() {
                const e = 4294967295 * Math.random() | 0
                  , t = 4294967295 * Math.random() | 0
                  , i = 4294967295 * Math.random() | 0
                  , n = 4294967295 * Math.random() | 0;
                return (If[255 & e] + If[e >> 8 & 255] + If[e >> 16 & 255] + If[e >> 24 & 255] + "-" + If[255 & t] + If[t >> 8 & 255] + "-" + If[t >> 16 & 15 | 64] + If[t >> 24 & 255] + "-" + If[63 & i | 128] + If[i >> 8 & 255] + "-" + If[i >> 16 & 255] + If[i >> 24 & 255] + If[255 & n] + If[n >> 8 & 255] + If[n >> 16 & 255] + If[n >> 24 & 255]).toUpperCase()
              }(),
              r.uniforms = Rf({}, n.uniforms, t.uniforms),
              r.defines = Rf({}, n.defines, t.defines),
              r.defines[`TROIKA_DERIVED_MATERIAL_${i}`] = "",
              r.extensions = Rf({}, n.extensions, t.extensions),
              r._listeners = void 0,
              r
          }
            , l = {
            constructor: {
              value: a
            },
            isDerivedMaterial: {
              value: !0
            },
            customProgramCacheKey: {
              writable: !0,
              configurable: !0,
              value: function() {
                return e.customProgramCacheKey() + "|" + i
              }
            },
            onBeforeCompile: {
              get: ()=>s,
              set(e) {
                this[r] = e
              }
            },
            copy: {
              writable: !0,
              configurable: !0,
              value: function(t) {
                return e.copy.call(this, t),
                e.isShaderMaterial || e.isDerivedMaterial || (Rf(this.extensions, t.extensions),
                  Rf(this.defines, t.defines),
                  Rf(this.uniforms, eo.clone(t.uniforms))),
                  this
              }
            },
            clone: {
              writable: !0,
              configurable: !0,
              value: function() {
                const t = new e.constructor;
                return o(t).copy(this)
              }
            },
            getDepthMaterial: {
              writable: !0,
              configurable: !0,
              value: function() {
                let i = this._depthMaterial;
                return i || (i = this._depthMaterial = Of(e.isDerivedMaterial ? e.getDepthMaterial() : new kh({
                  depthPacking: 3201
                }), t),
                  i.defines.IS_DEPTH_MATERIAL = "",
                  i.uniforms = this.uniforms),
                  i
              }
            },
            getDistanceMaterial: {
              writable: !0,
              configurable: !0,
              value: function() {
                let i = this._distanceMaterial;
                return i || (i = this._distanceMaterial = Of(e.isDerivedMaterial ? e.getDistanceMaterial() : new Fh, t),
                  i.defines.IS_DISTANCE_MATERIAL = "",
                  i.uniforms = this.uniforms),
                  i
              }
            },
            dispose: {
              writable: !0,
              configurable: !0,
              value() {
                const {_depthMaterial: t, _distanceMaterial: i} = this;
                t && t.dispose(),
                i && i.dispose(),
                  e.dispose.call(this)
              }
            }
          };
          return n[i] = a,
            new a
        }
        function Nf(e, t, i, n, r) {
          return (n || r || i) && (e = e.replace(Pf, `\n${i}\nvoid troikaOrigMain${t}() {`),
            e += `\nvoid main() {\n  ${n}\n  troikaOrigMain${t}();\n  ${r}\n}`),
            e
        }
        function zf(e, t) {
          return "uniforms" === e ? void 0 : "function" == typeof t ? t.toString() : t
        }
        let Uf = 0;
        const Gf = new Map
          , Vf = ()=>(self.performance || Date).now()
          , Hf = Cf();
        let Wf;
        const jf = function() {
          const e = [];
          let t = 0;
          function i() {
            const n = Vf();
            for (; e.length && Vf() - n < 5; )
              e.shift()();
            t = e.length ? setTimeout(i, 0) : 0
          }
          return (...n)=>{
            const r = mf();
            return e.push((()=>{
                const e = Vf();
                try {
                  Hf.webgl.generateIntoCanvas(...n),
                    r.resolve({
                      timing: Vf() - e
                    })
                } catch (e) {
                  r.reject(e)
                }
              }
            )),
            t || (t = setTimeout(i, 0)),
              r
          }
        }()
          , Xf = function() {
          const e = {};
          let t = 0;
          return function(i, n, r, s, a, o, l, h, c, u) {
            const d = "TroikaTextSDFGenerator_JS_" + t++ % 4;
            let p = e[d];
            return p || (p = e[d] = {
              workerModule: Sf({
                name: d,
                workerId: d,
                dependencies: [Cf, Vf],
                init(e, t) {
                  const i = e().javascript.generate;
                  return function(...e) {
                    const n = t();
                    return {
                      textureData: i(...e),
                      timing: t() - n
                    }
                  }
                },
                getTransferables: e=>[e.textureData.buffer]
              }),
              requests: 0,
              idleTimer: null
            }),
              p.requests++,
              clearTimeout(p.idleTimer),
              p.workerModule(i, n, r, s, a, o).then((({textureData: e, timing: t})=>{
                  const r = Vf()
                    , s = new Uint8Array(4 * e.length);
                  for (let t = 0; t < e.length; t++)
                    s[4 * t + u] = e[t];
                  return Hf.webglUtils.renderImageData(l, s, h, c, i, n, 1 << 3 - u),
                    t += Vf() - r,
                  0 == --p.requests && (p.idleTimer = setTimeout((()=>{
                      !function(e) {
                        wf[e] && wf[e].forEach((function(e) {
                            e()
                          }
                        )),
                        bf[e] && (bf[e].terminate(),
                          delete bf[e])
                      }(d)
                    }
                  ), 2e3)),
                    {
                      timing: t
                    }
                }
              ))
          }
        }()
          , Yf = Hf.webglUtils.resizeWebGLCanvasWithoutClearing
          , qf = Sf({
          name: "Typr Font Parser",
          dependencies: [function() {
            return "undefined" == typeof window && (self.window = self),
              function(e) {
                var t = {
                  parse: function(e) {
                    var i = t._bin
                      , n = new Uint8Array(e);
                    if ("ttcf" == i.readASCII(n, 0, 4)) {
                      var r = 4;
                      i.readUshort(n, r),
                        r += 2,
                        i.readUshort(n, r),
                        r += 2;
                      var s = i.readUint(n, r);
                      r += 4;
                      for (var a = [], o = 0; o < s; o++) {
                        var l = i.readUint(n, r);
                        r += 4,
                          a.push(t._readFont(n, l))
                      }
                      return a
                    }
                    return [t._readFont(n, 0)]
                  },
                  _readFont: function(e, i) {
                    var n = t._bin
                      , r = i;
                    n.readFixed(e, i),
                      i += 4;
                    var s = n.readUshort(e, i);
                    i += 2,
                      n.readUshort(e, i),
                      i += 2,
                      n.readUshort(e, i),
                      i += 2,
                      n.readUshort(e, i),
                      i += 2;
                    for (var a = ["cmap", "head", "hhea", "maxp", "hmtx", "name", "OS/2", "post", "loca", "glyf", "kern", "CFF ", "GPOS", "GSUB", "SVG "], o = {
                      _data: e,
                      _offset: r
                    }, l = {}, h = 0; h < s; h++) {
                      var c = n.readASCII(e, i, 4);
                      i += 4,
                        n.readUint(e, i),
                        i += 4;
                      var u = n.readUint(e, i);
                      i += 4;
                      var d = n.readUint(e, i);
                      i += 4,
                        l[c] = {
                          offset: u,
                          length: d
                        }
                    }
                    for (h = 0; h < a.length; h++) {
                      var p = a[h];
                      l[p] && (o[p.trim()] = t[p.trim()].parse(e, l[p].offset, l[p].length, o))
                    }
                    return o
                  },
                  _tabOffset: function(e, i, n) {
                    for (var r = t._bin, s = r.readUshort(e, n + 4), a = n + 12, o = 0; o < s; o++) {
                      var l = r.readASCII(e, a, 4);
                      a += 4,
                        r.readUint(e, a),
                        a += 4;
                      var h = r.readUint(e, a);
                      if (a += 4,
                        r.readUint(e, a),
                        a += 4,
                      l == i)
                        return h
                    }
                    return 0
                  }
                };
                t._bin = {
                  readFixed: function(e, t) {
                    return (e[t] << 8 | e[t + 1]) + (e[t + 2] << 8 | e[t + 3]) / 65540
                  },
                  readF2dot14: function(e, i) {
                    return t._bin.readShort(e, i) / 16384
                  },
                  readInt: function(e, i) {
                    return t._bin._view(e).getInt32(i)
                  },
                  readInt8: function(e, i) {
                    return t._bin._view(e).getInt8(i)
                  },
                  readShort: function(e, i) {
                    return t._bin._view(e).getInt16(i)
                  },
                  readUshort: function(e, i) {
                    return t._bin._view(e).getUint16(i)
                  },
                  readUshorts: function(e, i, n) {
                    for (var r = [], s = 0; s < n; s++)
                      r.push(t._bin.readUshort(e, i + 2 * s));
                    return r
                  },
                  readUint: function(e, i) {
                    return t._bin._view(e).getUint32(i)
                  },
                  readUint64: function(e, i) {
                    return 4294967296 * t._bin.readUint(e, i) + t._bin.readUint(e, i + 4)
                  },
                  readASCII: function(e, t, i) {
                    for (var n = "", r = 0; r < i; r++)
                      n += String.fromCharCode(e[t + r]);
                    return n
                  },
                  readUnicode: function(e, t, i) {
                    for (var n = "", r = 0; r < i; r++) {
                      var s = e[t++] << 8 | e[t++];
                      n += String.fromCharCode(s)
                    }
                    return n
                  },
                  _tdec: "undefined" != typeof window && window.TextDecoder ? new window.TextDecoder : null,
                  readUTF8: function(e, i, n) {
                    var r = t._bin._tdec;
                    return r && 0 == i && n == e.length ? r.decode(e) : t._bin.readASCII(e, i, n)
                  },
                  readBytes: function(e, t, i) {
                    for (var n = [], r = 0; r < i; r++)
                      n.push(e[t + r]);
                    return n
                  },
                  readASCIIArray: function(e, t, i) {
                    for (var n = [], r = 0; r < i; r++)
                      n.push(String.fromCharCode(e[t + r]));
                    return n
                  },
                  _view: function(e) {
                    return e._dataView || (e._dataView = e.buffer ? new DataView(e.buffer,e.byteOffset,e.byteLength) : new DataView(new Uint8Array(e).buffer))
                  }
                },
                  t._lctf = {},
                  t._lctf.parse = function(e, i, n, r, s) {
                    var a = t._bin
                      , o = {}
                      , l = i;
                    a.readFixed(e, i),
                      i += 4;
                    var h = a.readUshort(e, i);
                    i += 2;
                    var c = a.readUshort(e, i);
                    i += 2;
                    var u = a.readUshort(e, i);
                    return i += 2,
                      o.scriptList = t._lctf.readScriptList(e, l + h),
                      o.featureList = t._lctf.readFeatureList(e, l + c),
                      o.lookupList = t._lctf.readLookupList(e, l + u, s),
                      o
                  }
                  ,
                  t._lctf.readLookupList = function(e, i, n) {
                    var r = t._bin
                      , s = i
                      , a = []
                      , o = r.readUshort(e, i);
                    i += 2;
                    for (var l = 0; l < o; l++) {
                      var h = r.readUshort(e, i);
                      i += 2;
                      var c = t._lctf.readLookupTable(e, s + h, n);
                      a.push(c)
                    }
                    return a
                  }
                  ,
                  t._lctf.readLookupTable = function(e, i, n) {
                    var r = t._bin
                      , s = i
                      , a = {
                      tabs: []
                    };
                    a.ltype = r.readUshort(e, i),
                      i += 2,
                      a.flag = r.readUshort(e, i),
                      i += 2;
                    var o = r.readUshort(e, i);
                    i += 2;
                    for (var l = a.ltype, h = 0; h < o; h++) {
                      var c = r.readUshort(e, i);
                      i += 2;
                      var u = n(e, l, s + c, a);
                      a.tabs.push(u)
                    }
                    return a
                  }
                  ,
                  t._lctf.numOfOnes = function(e) {
                    for (var t = 0, i = 0; i < 32; i++)
                      0 != (e >>> i & 1) && t++;
                    return t
                  }
                  ,
                  t._lctf.readClassDef = function(e, i) {
                    var n = t._bin
                      , r = []
                      , s = n.readUshort(e, i);
                    if (i += 2,
                    1 == s) {
                      var a = n.readUshort(e, i);
                      i += 2;
                      var o = n.readUshort(e, i);
                      i += 2;
                      for (var l = 0; l < o; l++)
                        r.push(a + l),
                          r.push(a + l),
                          r.push(n.readUshort(e, i)),
                          i += 2
                    }
                    if (2 == s) {
                      var h = n.readUshort(e, i);
                      for (i += 2,
                             l = 0; l < h; l++)
                        r.push(n.readUshort(e, i)),
                          i += 2,
                          r.push(n.readUshort(e, i)),
                          i += 2,
                          r.push(n.readUshort(e, i)),
                          i += 2
                    }
                    return r
                  }
                  ,
                  t._lctf.getInterval = function(e, t) {
                    for (var i = 0; i < e.length; i += 3) {
                      var n = e[i]
                        , r = e[i + 1];
                      if (e[i + 2],
                      n <= t && t <= r)
                        return i
                    }
                    return -1
                  }
                  ,
                  t._lctf.readCoverage = function(e, i) {
                    var n = t._bin
                      , r = {};
                    r.fmt = n.readUshort(e, i),
                      i += 2;
                    var s = n.readUshort(e, i);
                    return i += 2,
                    1 == r.fmt && (r.tab = n.readUshorts(e, i, s)),
                    2 == r.fmt && (r.tab = n.readUshorts(e, i, 3 * s)),
                      r
                  }
                  ,
                  t._lctf.coverageIndex = function(e, i) {
                    var n = e.tab;
                    if (1 == e.fmt)
                      return n.indexOf(i);
                    if (2 == e.fmt) {
                      var r = t._lctf.getInterval(n, i);
                      if (-1 != r)
                        return n[r + 2] + (i - n[r])
                    }
                    return -1
                  }
                  ,
                  t._lctf.readFeatureList = function(e, i) {
                    var n = t._bin
                      , r = i
                      , s = []
                      , a = n.readUshort(e, i);
                    i += 2;
                    for (var o = 0; o < a; o++) {
                      var l = n.readASCII(e, i, 4);
                      i += 4;
                      var h = n.readUshort(e, i);
                      i += 2;
                      var c = t._lctf.readFeatureTable(e, r + h);
                      c.tag = l.trim(),
                        s.push(c)
                    }
                    return s
                  }
                  ,
                  t._lctf.readFeatureTable = function(e, i) {
                    var n = t._bin
                      , r = i
                      , s = {}
                      , a = n.readUshort(e, i);
                    i += 2,
                    a > 0 && (s.featureParams = r + a);
                    var o = n.readUshort(e, i);
                    i += 2,
                      s.tab = [];
                    for (var l = 0; l < o; l++)
                      s.tab.push(n.readUshort(e, i + 2 * l));
                    return s
                  }
                  ,
                  t._lctf.readScriptList = function(e, i) {
                    var n = t._bin
                      , r = i
                      , s = {}
                      , a = n.readUshort(e, i);
                    i += 2;
                    for (var o = 0; o < a; o++) {
                      var l = n.readASCII(e, i, 4);
                      i += 4;
                      var h = n.readUshort(e, i);
                      i += 2,
                        s[l.trim()] = t._lctf.readScriptTable(e, r + h)
                    }
                    return s
                  }
                  ,
                  t._lctf.readScriptTable = function(e, i) {
                    var n = t._bin
                      , r = i
                      , s = {}
                      , a = n.readUshort(e, i);
                    i += 2,
                      s.default = t._lctf.readLangSysTable(e, r + a);
                    var o = n.readUshort(e, i);
                    i += 2;
                    for (var l = 0; l < o; l++) {
                      var h = n.readASCII(e, i, 4);
                      i += 4;
                      var c = n.readUshort(e, i);
                      i += 2,
                        s[h.trim()] = t._lctf.readLangSysTable(e, r + c)
                    }
                    return s
                  }
                  ,
                  t._lctf.readLangSysTable = function(e, i) {
                    var n = t._bin
                      , r = {};
                    n.readUshort(e, i),
                      i += 2,
                      r.reqFeature = n.readUshort(e, i),
                      i += 2;
                    var s = n.readUshort(e, i);
                    return i += 2,
                      r.features = n.readUshorts(e, i, s),
                      r
                  }
                  ,
                  t.CFF = {},
                  t.CFF.parse = function(e, i, n) {
                    var r = t._bin;
                    (e = new Uint8Array(e.buffer,i,n))[i = 0],
                      e[++i],
                      e[++i],
                      e[++i],
                      i++;
                    var s = [];
                    i = t.CFF.readIndex(e, i, s);
                    for (var a = [], o = 0; o < s.length - 1; o++)
                      a.push(r.readASCII(e, i + s[o], s[o + 1] - s[o]));
                    i += s[s.length - 1];
                    var l = [];
                    i = t.CFF.readIndex(e, i, l);
                    var h = [];
                    for (o = 0; o < l.length - 1; o++)
                      h.push(t.CFF.readDict(e, i + l[o], i + l[o + 1]));
                    i += l[l.length - 1];
                    var c = h[0]
                      , u = [];
                    i = t.CFF.readIndex(e, i, u);
                    var d = [];
                    for (o = 0; o < u.length - 1; o++)
                      d.push(r.readASCII(e, i + u[o], u[o + 1] - u[o]));
                    if (i += u[u.length - 1],
                      t.CFF.readSubrs(e, i, c),
                      c.CharStrings) {
                      i = c.CharStrings,
                        u = [],
                        i = t.CFF.readIndex(e, i, u);
                      var p = [];
                      for (o = 0; o < u.length - 1; o++)
                        p.push(r.readBytes(e, i + u[o], u[o + 1] - u[o]));
                      c.CharStrings = p
                    }
                    if (c.ROS) {
                      i = c.FDArray;
                      var f = [];
                      for (i = t.CFF.readIndex(e, i, f),
                             c.FDArray = [],
                             o = 0; o < f.length - 1; o++) {
                        var m = t.CFF.readDict(e, i + f[o], i + f[o + 1]);
                        t.CFF._readFDict(e, m, d),
                          c.FDArray.push(m)
                      }
                      i += f[f.length - 1],
                        i = c.FDSelect,
                        c.FDSelect = [];
                      var g = e[i];
                      if (i++,
                      3 != g)
                        throw g;
                      var v = r.readUshort(e, i);
                      for (i += 2,
                             o = 0; o < v + 1; o++)
                        c.FDSelect.push(r.readUshort(e, i), e[i + 2]),
                          i += 3
                    }
                    return c.Encoding && (c.Encoding = t.CFF.readEncoding(e, c.Encoding, c.CharStrings.length)),
                    c.charset && (c.charset = t.CFF.readCharset(e, c.charset, c.CharStrings.length)),
                      t.CFF._readFDict(e, c, d),
                      c
                  }
                  ,
                  t.CFF._readFDict = function(e, i, n) {
                    var r;
                    for (var s in i.Private && (r = i.Private[1],
                      i.Private = t.CFF.readDict(e, r, r + i.Private[0]),
                    i.Private.Subrs && t.CFF.readSubrs(e, r + i.Private.Subrs, i.Private)),
                      i)
                      -1 != ["FamilyName", "FontName", "FullName", "Notice", "version", "Copyright"].indexOf(s) && (i[s] = n[i[s] - 426 + 35])
                  }
                  ,
                  t.CFF.readSubrs = function(e, i, n) {
                    var r = t._bin
                      , s = [];
                    i = t.CFF.readIndex(e, i, s);
                    var a, o = s.length;
                    a = o < 1240 ? 107 : o < 33900 ? 1131 : 32768,
                      n.Bias = a,
                      n.Subrs = [];
                    for (var l = 0; l < s.length - 1; l++)
                      n.Subrs.push(r.readBytes(e, i + s[l], s[l + 1] - s[l]))
                  }
                  ,
                  t.CFF.tableSE = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 0, 111, 112, 113, 114, 0, 115, 116, 117, 118, 119, 120, 121, 122, 0, 123, 0, 124, 125, 126, 127, 128, 129, 130, 131, 0, 132, 133, 0, 134, 135, 136, 137, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 138, 0, 139, 0, 0, 0, 0, 140, 141, 142, 143, 0, 0, 0, 0, 0, 144, 0, 0, 0, 145, 0, 0, 146, 147, 148, 149, 0, 0, 0, 0],
                  t.CFF.glyphByUnicode = function(e, t) {
                    for (var i = 0; i < e.charset.length; i++)
                      if (e.charset[i] == t)
                        return i;
                    return -1
                  }
                  ,
                  t.CFF.glyphBySE = function(e, i) {
                    return i < 0 || i > 255 ? -1 : t.CFF.glyphByUnicode(e, t.CFF.tableSE[i])
                  }
                  ,
                  t.CFF.readEncoding = function(e, i, n) {
                    t._bin;
                    var r = [".notdef"]
                      , s = e[i];
                    if (i++,
                    0 != s)
                      throw "error: unknown encoding format: " + s;
                    var a = e[i];
                    i++;
                    for (var o = 0; o < a; o++)
                      r.push(e[i + o]);
                    return r
                  }
                  ,
                  t.CFF.readCharset = function(e, i, n) {
                    var r = t._bin
                      , s = [".notdef"]
                      , a = e[i];
                    if (i++,
                    0 == a)
                      for (var o = 0; o < n; o++) {
                        var l = r.readUshort(e, i);
                        i += 2,
                          s.push(l)
                      }
                    else {
                      if (1 != a && 2 != a)
                        throw "error: format: " + a;
                      for (; s.length < n; ) {
                        l = r.readUshort(e, i),
                          i += 2;
                        var h = 0;
                        for (1 == a ? (h = e[i],
                          i++) : (h = r.readUshort(e, i),
                          i += 2),
                               o = 0; o <= h; o++)
                          s.push(l),
                            l++
                      }
                    }
                    return s
                  }
                  ,
                  t.CFF.readIndex = function(e, i, n) {
                    var r = t._bin
                      , s = r.readUshort(e, i) + 1
                      , a = e[i += 2];
                    if (i++,
                    1 == a)
                      for (var o = 0; o < s; o++)
                        n.push(e[i + o]);
                    else if (2 == a)
                      for (o = 0; o < s; o++)
                        n.push(r.readUshort(e, i + 2 * o));
                    else if (3 == a)
                      for (o = 0; o < s; o++)
                        n.push(16777215 & r.readUint(e, i + 3 * o - 1));
                    else if (1 != s)
                      throw "unsupported offset size: " + a + ", count: " + s;
                    return (i += s * a) - 1
                  }
                  ,
                  t.CFF.getCharString = function(e, i, n) {
                    var r = t._bin
                      , s = e[i]
                      , a = e[i + 1];
                    e[i + 2],
                      e[i + 3],
                      e[i + 4];
                    var o = 1
                      , l = null
                      , h = null;
                    s <= 20 && (l = s,
                      o = 1),
                    12 == s && (l = 100 * s + a,
                      o = 2),
                    21 <= s && s <= 27 && (l = s,
                      o = 1),
                    28 == s && (h = r.readShort(e, i + 1),
                      o = 3),
                    29 <= s && s <= 31 && (l = s,
                      o = 1),
                    32 <= s && s <= 246 && (h = s - 139,
                      o = 1),
                    247 <= s && s <= 250 && (h = 256 * (s - 247) + a + 108,
                      o = 2),
                    251 <= s && s <= 254 && (h = 256 * -(s - 251) - a - 108,
                      o = 2),
                    255 == s && (h = r.readInt(e, i + 1) / 65535,
                      o = 5),
                      n.val = null != h ? h : "o" + l,
                      n.size = o
                  }
                  ,
                  t.CFF.readCharString = function(e, i, n) {
                    for (var r = i + n, s = t._bin, a = []; i < r; ) {
                      var o = e[i]
                        , l = e[i + 1];
                      e[i + 2],
                        e[i + 3],
                        e[i + 4];
                      var h = 1
                        , c = null
                        , u = null;
                      o <= 20 && (c = o,
                        h = 1),
                      12 == o && (c = 100 * o + l,
                        h = 2),
                      19 != o && 20 != o || (c = o,
                        h = 2),
                      21 <= o && o <= 27 && (c = o,
                        h = 1),
                      28 == o && (u = s.readShort(e, i + 1),
                        h = 3),
                      29 <= o && o <= 31 && (c = o,
                        h = 1),
                      32 <= o && o <= 246 && (u = o - 139,
                        h = 1),
                      247 <= o && o <= 250 && (u = 256 * (o - 247) + l + 108,
                        h = 2),
                      251 <= o && o <= 254 && (u = 256 * -(o - 251) - l - 108,
                        h = 2),
                      255 == o && (u = s.readInt(e, i + 1) / 65535,
                        h = 5),
                        a.push(null != u ? u : "o" + c),
                        i += h
                    }
                    return a
                  }
                  ,
                  t.CFF.readDict = function(e, i, n) {
                    for (var r = t._bin, s = {}, a = []; i < n; ) {
                      var o = e[i]
                        , l = e[i + 1];
                      e[i + 2],
                        e[i + 3],
                        e[i + 4];
                      var h = 1
                        , c = null
                        , u = null;
                      if (28 == o && (u = r.readShort(e, i + 1),
                        h = 3),
                      29 == o && (u = r.readInt(e, i + 1),
                        h = 5),
                      32 <= o && o <= 246 && (u = o - 139,
                        h = 1),
                      247 <= o && o <= 250 && (u = 256 * (o - 247) + l + 108,
                        h = 2),
                      251 <= o && o <= 254 && (u = 256 * -(o - 251) - l - 108,
                        h = 2),
                      255 == o)
                        throw u = r.readInt(e, i + 1) / 65535,
                          h = 5,
                          "unknown number";
                      if (30 == o) {
                        var d = [];
                        for (h = 1; ; ) {
                          var p = e[i + h];
                          h++;
                          var f = p >> 4
                            , m = 15 & p;
                          if (15 != f && d.push(f),
                          15 != m && d.push(m),
                          15 == m)
                            break
                        }
                        for (var g = "", v = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ".", "e", "e-", "reserved", "-", "endOfNumber"], y = 0; y < d.length; y++)
                          g += v[d[y]];
                        u = parseFloat(g)
                      }
                      o <= 21 && (c = ["version", "Notice", "FullName", "FamilyName", "Weight", "FontBBox", "BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StdHW", "StdVW", "escape", "UniqueID", "XUID", "charset", "Encoding", "CharStrings", "Private", "Subrs", "defaultWidthX", "nominalWidthX"][o],
                        h = 1,
                      12 == o && (c = ["Copyright", "isFixedPitch", "ItalicAngle", "UnderlinePosition", "UnderlineThickness", "PaintType", "CharstringType", "FontMatrix", "StrokeWidth", "BlueScale", "BlueShift", "BlueFuzz", "StemSnapH", "StemSnapV", "ForceBold", 0, 0, "LanguageGroup", "ExpansionFactor", "initialRandomSeed", "SyntheticBase", "PostScript", "BaseFontName", "BaseFontBlend", 0, 0, 0, 0, 0, 0, "ROS", "CIDFontVersion", "CIDFontRevision", "CIDFontType", "CIDCount", "UIDBase", "FDArray", "FDSelect", "FontName"][l],
                        h = 2)),
                        null != c ? (s[c] = 1 == a.length ? a[0] : a,
                          a = []) : a.push(u),
                        i += h
                    }
                    return s
                  }
                  ,
                  t.cmap = {},
                  t.cmap.parse = function(e, i, n) {
                    e = new Uint8Array(e.buffer,i,n),
                      i = 0;
                    var r = t._bin
                      , s = {};
                    r.readUshort(e, i),
                      i += 2;
                    var a = r.readUshort(e, i);
                    i += 2;
                    var o = [];
                    s.tables = [];
                    for (var l = 0; l < a; l++) {
                      var h = r.readUshort(e, i);
                      i += 2;
                      var c = r.readUshort(e, i);
                      i += 2;
                      var u = r.readUint(e, i);
                      i += 4;
                      var d = "p" + h + "e" + c
                        , p = o.indexOf(u);
                      if (-1 == p) {
                        var f;
                        p = s.tables.length,
                          o.push(u);
                        var m = r.readUshort(e, u);
                        0 == m ? f = t.cmap.parse0(e, u) : 4 == m ? f = t.cmap.parse4(e, u) : 6 == m ? f = t.cmap.parse6(e, u) : 12 == m ? f = t.cmap.parse12(e, u) : console.debug("unknown format: " + m, h, c, u),
                          s.tables.push(f)
                      }
                      if (null != s[d])
                        throw "multiple tables for one platform+encoding";
                      s[d] = p
                    }
                    return s
                  }
                  ,
                  t.cmap.parse0 = function(e, i) {
                    var n = t._bin
                      , r = {};
                    r.format = n.readUshort(e, i),
                      i += 2;
                    var s = n.readUshort(e, i);
                    i += 2,
                      n.readUshort(e, i),
                      i += 2,
                      r.map = [];
                    for (var a = 0; a < s - 6; a++)
                      r.map.push(e[i + a]);
                    return r
                  }
                  ,
                  t.cmap.parse4 = function(e, i) {
                    var n = t._bin
                      , r = i
                      , s = {};
                    s.format = n.readUshort(e, i),
                      i += 2;
                    var a = n.readUshort(e, i);
                    i += 2,
                      n.readUshort(e, i),
                      i += 2;
                    var o = n.readUshort(e, i);
                    i += 2;
                    var l = o / 2;
                    s.searchRange = n.readUshort(e, i),
                      i += 2,
                      s.entrySelector = n.readUshort(e, i),
                      i += 2,
                      s.rangeShift = n.readUshort(e, i),
                      i += 2,
                      s.endCount = n.readUshorts(e, i, l),
                      i += 2 * l,
                      i += 2,
                      s.startCount = n.readUshorts(e, i, l),
                      i += 2 * l,
                      s.idDelta = [];
                    for (var h = 0; h < l; h++)
                      s.idDelta.push(n.readShort(e, i)),
                        i += 2;
                    for (s.idRangeOffset = n.readUshorts(e, i, l),
                           i += 2 * l,
                           s.glyphIdArray = []; i < r + a; )
                      s.glyphIdArray.push(n.readUshort(e, i)),
                        i += 2;
                    return s
                  }
                  ,
                  t.cmap.parse6 = function(e, i) {
                    var n = t._bin
                      , r = {};
                    r.format = n.readUshort(e, i),
                      i += 2,
                      n.readUshort(e, i),
                      i += 2,
                      n.readUshort(e, i),
                      i += 2,
                      r.firstCode = n.readUshort(e, i),
                      i += 2;
                    var s = n.readUshort(e, i);
                    i += 2,
                      r.glyphIdArray = [];
                    for (var a = 0; a < s; a++)
                      r.glyphIdArray.push(n.readUshort(e, i)),
                        i += 2;
                    return r
                  }
                  ,
                  t.cmap.parse12 = function(e, i) {
                    var n = t._bin
                      , r = {};
                    r.format = n.readUshort(e, i),
                      i += 2,
                      i += 2,
                      n.readUint(e, i),
                      i += 4,
                      n.readUint(e, i),
                      i += 4;
                    var s = n.readUint(e, i);
                    i += 4,
                      r.groups = [];
                    for (var a = 0; a < s; a++) {
                      var o = i + 12 * a
                        , l = n.readUint(e, o + 0)
                        , h = n.readUint(e, o + 4)
                        , c = n.readUint(e, o + 8);
                      r.groups.push([l, h, c])
                    }
                    return r
                  }
                  ,
                  t.glyf = {},
                  t.glyf.parse = function(e, t, i, n) {
                    for (var r = [], s = 0; s < n.maxp.numGlyphs; s++)
                      r.push(null);
                    return r
                  }
                  ,
                  t.glyf._parseGlyf = function(e, i) {
                    var n = t._bin
                      , r = e._data
                      , s = t._tabOffset(r, "glyf", e._offset) + e.loca[i];
                    if (e.loca[i] == e.loca[i + 1])
                      return null;
                    var a = {};
                    if (a.noc = n.readShort(r, s),
                      s += 2,
                      a.xMin = n.readShort(r, s),
                      s += 2,
                      a.yMin = n.readShort(r, s),
                      s += 2,
                      a.xMax = n.readShort(r, s),
                      s += 2,
                      a.yMax = n.readShort(r, s),
                      s += 2,
                    a.xMin >= a.xMax || a.yMin >= a.yMax)
                      return null;
                    if (a.noc > 0) {
                      a.endPts = [];
                      for (var o = 0; o < a.noc; o++)
                        a.endPts.push(n.readUshort(r, s)),
                          s += 2;
                      var l = n.readUshort(r, s);
                      if (s += 2,
                      r.length - s < l)
                        return null;
                      a.instructions = n.readBytes(r, s, l),
                        s += l;
                      var h = a.endPts[a.noc - 1] + 1;
                      for (a.flags = [],
                             o = 0; o < h; o++) {
                        var c = r[s];
                        if (s++,
                          a.flags.push(c),
                        0 != (8 & c)) {
                          var u = r[s];
                          s++;
                          for (var d = 0; d < u; d++)
                            a.flags.push(c),
                              o++
                        }
                      }
                      for (a.xs = [],
                             o = 0; o < h; o++) {
                        var p = 0 != (2 & a.flags[o])
                          , f = 0 != (16 & a.flags[o]);
                        p ? (a.xs.push(f ? r[s] : -r[s]),
                          s++) : f ? a.xs.push(0) : (a.xs.push(n.readShort(r, s)),
                          s += 2)
                      }
                      for (a.ys = [],
                             o = 0; o < h; o++)
                        p = 0 != (4 & a.flags[o]),
                          f = 0 != (32 & a.flags[o]),
                          p ? (a.ys.push(f ? r[s] : -r[s]),
                            s++) : f ? a.ys.push(0) : (a.ys.push(n.readShort(r, s)),
                            s += 2);
                      var m = 0
                        , g = 0;
                      for (o = 0; o < h; o++)
                        m += a.xs[o],
                          g += a.ys[o],
                          a.xs[o] = m,
                          a.ys[o] = g
                    } else {
                      var v;
                      a.parts = [];
                      do {
                        v = n.readUshort(r, s),
                          s += 2;
                        var y = {
                          m: {
                            a: 1,
                            b: 0,
                            c: 0,
                            d: 1,
                            tx: 0,
                            ty: 0
                          },
                          p1: -1,
                          p2: -1
                        };
                        if (a.parts.push(y),
                          y.glyphIndex = n.readUshort(r, s),
                          s += 2,
                        1 & v) {
                          var x = n.readShort(r, s);
                          s += 2;
                          var _ = n.readShort(r, s);
                          s += 2
                        } else
                          x = n.readInt8(r, s),
                            s++,
                            _ = n.readInt8(r, s),
                            s++;
                        2 & v ? (y.m.tx = x,
                          y.m.ty = _) : (y.p1 = x,
                          y.p2 = _),
                          8 & v ? (y.m.a = y.m.d = n.readF2dot14(r, s),
                            s += 2) : 64 & v ? (y.m.a = n.readF2dot14(r, s),
                            s += 2,
                            y.m.d = n.readF2dot14(r, s),
                            s += 2) : 128 & v && (y.m.a = n.readF2dot14(r, s),
                            s += 2,
                            y.m.b = n.readF2dot14(r, s),
                            s += 2,
                            y.m.c = n.readF2dot14(r, s),
                            s += 2,
                            y.m.d = n.readF2dot14(r, s),
                            s += 2)
                      } while (32 & v);
                      if (256 & v) {
                        var b = n.readUshort(r, s);
                        for (s += 2,
                               a.instr = [],
                               o = 0; o < b; o++)
                          a.instr.push(r[s]),
                            s++
                      }
                    }
                    return a
                  }
                  ,
                  t.GPOS = {},
                  t.GPOS.parse = function(e, i, n, r) {
                    return t._lctf.parse(e, i, n, r, t.GPOS.subt)
                  }
                  ,
                  t.GPOS.subt = function(e, i, n, r) {
                    var s = t._bin
                      , a = n
                      , o = {};
                    if (o.fmt = s.readUshort(e, n),
                      n += 2,
                    1 == i || 2 == i || 3 == i || 7 == i || 8 == i && o.fmt <= 2) {
                      var l = s.readUshort(e, n);
                      n += 2,
                        o.coverage = t._lctf.readCoverage(e, l + a)
                    }
                    if (1 == i && 1 == o.fmt) {
                      var h = s.readUshort(e, n);
                      n += 2;
                      var c = t._lctf.numOfOnes(h);
                      0 != h && (o.pos = t.GPOS.readValueRecord(e, n, h))
                    } else if (2 == i && o.fmt >= 1 && o.fmt <= 2) {
                      h = s.readUshort(e, n),
                        n += 2;
                      var u = s.readUshort(e, n);
                      n += 2,
                        c = t._lctf.numOfOnes(h);
                      var d = t._lctf.numOfOnes(u);
                      if (1 == o.fmt) {
                        o.pairsets = [];
                        var p = s.readUshort(e, n);
                        n += 2;
                        for (var f = 0; f < p; f++) {
                          var m = a + s.readUshort(e, n);
                          n += 2;
                          var g = s.readUshort(e, m);
                          m += 2;
                          for (var v = [], y = 0; y < g; y++) {
                            var x = s.readUshort(e, m);
                            m += 2,
                            0 != h && (M = t.GPOS.readValueRecord(e, m, h),
                              m += 2 * c),
                            0 != u && (T = t.GPOS.readValueRecord(e, m, u),
                              m += 2 * d),
                              v.push({
                                gid2: x,
                                val1: M,
                                val2: T
                              })
                          }
                          o.pairsets.push(v)
                        }
                      }
                      if (2 == o.fmt) {
                        var _ = s.readUshort(e, n);
                        n += 2;
                        var b = s.readUshort(e, n);
                        n += 2;
                        var w = s.readUshort(e, n);
                        n += 2;
                        var A = s.readUshort(e, n);
                        for (n += 2,
                               o.classDef1 = t._lctf.readClassDef(e, a + _),
                               o.classDef2 = t._lctf.readClassDef(e, a + b),
                               o.matrix = [],
                               f = 0; f < w; f++) {
                          var S = [];
                          for (y = 0; y < A; y++) {
                            var M = null
                              , T = null;
                            0 != h && (M = t.GPOS.readValueRecord(e, n, h),
                              n += 2 * c),
                            0 != u && (T = t.GPOS.readValueRecord(e, n, u),
                              n += 2 * d),
                              S.push({
                                val1: M,
                                val2: T
                              })
                          }
                          o.matrix.push(S)
                        }
                      }
                    } else {
                      if (9 == i && 1 == o.fmt) {
                        var E = s.readUshort(e, n);
                        n += 2;
                        var C = s.readUint(e, n);
                        if (n += 4,
                        9 == r.ltype)
                          r.ltype = E;
                        else if (r.ltype != E)
                          throw "invalid extension substitution";
                        return t.GPOS.subt(e, r.ltype, a + C)
                      }
                      console.debug("unsupported GPOS table LookupType", i, "format", o.fmt)
                    }
                    return o
                  }
                  ,
                  t.GPOS.readValueRecord = function(e, i, n) {
                    var r = t._bin
                      , s = [];
                    return s.push(1 & n ? r.readShort(e, i) : 0),
                      i += 1 & n ? 2 : 0,
                      s.push(2 & n ? r.readShort(e, i) : 0),
                      i += 2 & n ? 2 : 0,
                      s.push(4 & n ? r.readShort(e, i) : 0),
                      i += 4 & n ? 2 : 0,
                      s.push(8 & n ? r.readShort(e, i) : 0),
                      i += 8 & n ? 2 : 0,
                      s
                  }
                  ,
                  t.GSUB = {},
                  t.GSUB.parse = function(e, i, n, r) {
                    return t._lctf.parse(e, i, n, r, t.GSUB.subt)
                  }
                  ,
                  t.GSUB.subt = function(e, i, n, r) {
                    var s = t._bin
                      , a = n
                      , o = {};
                    if (o.fmt = s.readUshort(e, n),
                      n += 2,
                    1 != i && 4 != i && 5 != i && 6 != i)
                      return null;
                    if (1 == i || 4 == i || 5 == i && o.fmt <= 2 || 6 == i && o.fmt <= 2) {
                      var l = s.readUshort(e, n);
                      n += 2,
                        o.coverage = t._lctf.readCoverage(e, a + l)
                    }
                    if (1 == i && o.fmt >= 1 && o.fmt <= 2) {
                      if (1 == o.fmt)
                        o.delta = s.readShort(e, n),
                          n += 2;
                      else if (2 == o.fmt) {
                        var h = s.readUshort(e, n);
                        n += 2,
                          o.newg = s.readUshorts(e, n, h),
                          n += 2 * o.newg.length
                      }
                    } else if (4 == i) {
                      o.vals = [],
                        h = s.readUshort(e, n),
                        n += 2;
                      for (var c = 0; c < h; c++) {
                        var u = s.readUshort(e, n);
                        n += 2,
                          o.vals.push(t.GSUB.readLigatureSet(e, a + u))
                      }
                    } else if (5 == i && 2 == o.fmt) {
                      if (2 == o.fmt) {
                        var d = s.readUshort(e, n);
                        n += 2,
                          o.cDef = t._lctf.readClassDef(e, a + d),
                          o.scset = [];
                        var p = s.readUshort(e, n);
                        for (n += 2,
                               c = 0; c < p; c++) {
                          var f = s.readUshort(e, n);
                          n += 2,
                            o.scset.push(0 == f ? null : t.GSUB.readSubClassSet(e, a + f))
                        }
                      }
                    } else if (6 == i && 3 == o.fmt) {
                      if (3 == o.fmt) {
                        for (c = 0; c < 3; c++) {
                          h = s.readUshort(e, n),
                            n += 2;
                          for (var m = [], g = 0; g < h; g++)
                            m.push(t._lctf.readCoverage(e, a + s.readUshort(e, n + 2 * g)));
                          n += 2 * h,
                          0 == c && (o.backCvg = m),
                          1 == c && (o.inptCvg = m),
                          2 == c && (o.ahedCvg = m)
                        }
                        h = s.readUshort(e, n),
                          n += 2,
                          o.lookupRec = t.GSUB.readSubstLookupRecords(e, n, h)
                      }
                    } else {
                      if (7 == i && 1 == o.fmt) {
                        var v = s.readUshort(e, n);
                        n += 2;
                        var y = s.readUint(e, n);
                        if (n += 4,
                        9 == r.ltype)
                          r.ltype = v;
                        else if (r.ltype != v)
                          throw "invalid extension substitution";
                        return t.GSUB.subt(e, r.ltype, a + y)
                      }
                      console.debug("unsupported GSUB table LookupType", i, "format", o.fmt)
                    }
                    return o
                  }
                  ,
                  t.GSUB.readSubClassSet = function(e, i) {
                    var n = t._bin.readUshort
                      , r = i
                      , s = []
                      , a = n(e, i);
                    i += 2;
                    for (var o = 0; o < a; o++) {
                      var l = n(e, i);
                      i += 2,
                        s.push(t.GSUB.readSubClassRule(e, r + l))
                    }
                    return s
                  }
                  ,
                  t.GSUB.readSubClassRule = function(e, i) {
                    var n = t._bin.readUshort
                      , r = {}
                      , s = n(e, i)
                      , a = n(e, i += 2);
                    i += 2,
                      r.input = [];
                    for (var o = 0; o < s - 1; o++)
                      r.input.push(n(e, i)),
                        i += 2;
                    return r.substLookupRecords = t.GSUB.readSubstLookupRecords(e, i, a),
                      r
                  }
                  ,
                  t.GSUB.readSubstLookupRecords = function(e, i, n) {
                    for (var r = t._bin.readUshort, s = [], a = 0; a < n; a++)
                      s.push(r(e, i), r(e, i + 2)),
                        i += 4;
                    return s
                  }
                  ,
                  t.GSUB.readChainSubClassSet = function(e, i) {
                    var n = t._bin
                      , r = i
                      , s = []
                      , a = n.readUshort(e, i);
                    i += 2;
                    for (var o = 0; o < a; o++) {
                      var l = n.readUshort(e, i);
                      i += 2,
                        s.push(t.GSUB.readChainSubClassRule(e, r + l))
                    }
                    return s
                  }
                  ,
                  t.GSUB.readChainSubClassRule = function(e, i) {
                    for (var n = t._bin, r = {}, s = ["backtrack", "input", "lookahead"], a = 0; a < s.length; a++) {
                      var o = n.readUshort(e, i);
                      i += 2,
                      1 == a && o--,
                        r[s[a]] = n.readUshorts(e, i, o),
                        i += 2 * r[s[a]].length
                    }
                    return o = n.readUshort(e, i),
                      i += 2,
                      r.subst = n.readUshorts(e, i, 2 * o),
                      i += 2 * r.subst.length,
                      r
                  }
                  ,
                  t.GSUB.readLigatureSet = function(e, i) {
                    var n = t._bin
                      , r = i
                      , s = []
                      , a = n.readUshort(e, i);
                    i += 2;
                    for (var o = 0; o < a; o++) {
                      var l = n.readUshort(e, i);
                      i += 2,
                        s.push(t.GSUB.readLigature(e, r + l))
                    }
                    return s
                  }
                  ,
                  t.GSUB.readLigature = function(e, i) {
                    var n = t._bin
                      , r = {
                      chain: []
                    };
                    r.nglyph = n.readUshort(e, i),
                      i += 2;
                    var s = n.readUshort(e, i);
                    i += 2;
                    for (var a = 0; a < s - 1; a++)
                      r.chain.push(n.readUshort(e, i)),
                        i += 2;
                    return r
                  }
                  ,
                  t.head = {},
                  t.head.parse = function(e, i, n) {
                    var r = t._bin
                      , s = {};
                    return r.readFixed(e, i),
                      i += 4,
                      s.fontRevision = r.readFixed(e, i),
                      i += 4,
                      r.readUint(e, i),
                      i += 4,
                      r.readUint(e, i),
                      i += 4,
                      s.flags = r.readUshort(e, i),
                      i += 2,
                      s.unitsPerEm = r.readUshort(e, i),
                      i += 2,
                      s.created = r.readUint64(e, i),
                      i += 8,
                      s.modified = r.readUint64(e, i),
                      i += 8,
                      s.xMin = r.readShort(e, i),
                      i += 2,
                      s.yMin = r.readShort(e, i),
                      i += 2,
                      s.xMax = r.readShort(e, i),
                      i += 2,
                      s.yMax = r.readShort(e, i),
                      i += 2,
                      s.macStyle = r.readUshort(e, i),
                      i += 2,
                      s.lowestRecPPEM = r.readUshort(e, i),
                      i += 2,
                      s.fontDirectionHint = r.readShort(e, i),
                      i += 2,
                      s.indexToLocFormat = r.readShort(e, i),
                      i += 2,
                      s.glyphDataFormat = r.readShort(e, i),
                      i += 2,
                      s
                  }
                  ,
                  t.hhea = {},
                  t.hhea.parse = function(e, i, n) {
                    var r = t._bin
                      , s = {};
                    return r.readFixed(e, i),
                      i += 4,
                      s.ascender = r.readShort(e, i),
                      i += 2,
                      s.descender = r.readShort(e, i),
                      i += 2,
                      s.lineGap = r.readShort(e, i),
                      i += 2,
                      s.advanceWidthMax = r.readUshort(e, i),
                      i += 2,
                      s.minLeftSideBearing = r.readShort(e, i),
                      i += 2,
                      s.minRightSideBearing = r.readShort(e, i),
                      i += 2,
                      s.xMaxExtent = r.readShort(e, i),
                      i += 2,
                      s.caretSlopeRise = r.readShort(e, i),
                      i += 2,
                      s.caretSlopeRun = r.readShort(e, i),
                      i += 2,
                      s.caretOffset = r.readShort(e, i),
                      i += 2,
                      i += 8,
                      s.metricDataFormat = r.readShort(e, i),
                      i += 2,
                      s.numberOfHMetrics = r.readUshort(e, i),
                      i += 2,
                      s
                  }
                  ,
                  t.hmtx = {},
                  t.hmtx.parse = function(e, i, n, r) {
                    for (var s = t._bin, a = {
                      aWidth: [],
                      lsBearing: []
                    }, o = 0, l = 0, h = 0; h < r.maxp.numGlyphs; h++)
                      h < r.hhea.numberOfHMetrics && (o = s.readUshort(e, i),
                        i += 2,
                        l = s.readShort(e, i),
                        i += 2),
                        a.aWidth.push(o),
                        a.lsBearing.push(l);
                    return a
                  }
                  ,
                  t.kern = {},
                  t.kern.parse = function(e, i, n, r) {
                    var s = t._bin
                      , a = s.readUshort(e, i);
                    if (i += 2,
                    1 == a)
                      return t.kern.parseV1(e, i - 2, n, r);
                    var o = s.readUshort(e, i);
                    i += 2;
                    for (var l = {
                      glyph1: [],
                      rval: []
                    }, h = 0; h < o; h++) {
                      i += 2,
                        n = s.readUshort(e, i),
                        i += 2;
                      var c = s.readUshort(e, i);
                      i += 2;
                      var u = c >>> 8;
                      if (0 != (u &= 15))
                        throw "unknown kern table format: " + u;
                      i = t.kern.readFormat0(e, i, l)
                    }
                    return l
                  }
                  ,
                  t.kern.parseV1 = function(e, i, n, r) {
                    var s = t._bin;
                    s.readFixed(e, i),
                      i += 4;
                    var a = s.readUint(e, i);
                    i += 4;
                    for (var o = {
                      glyph1: [],
                      rval: []
                    }, l = 0; l < a; l++) {
                      s.readUint(e, i),
                        i += 4;
                      var h = s.readUshort(e, i);
                      i += 2,
                        s.readUshort(e, i),
                        i += 2;
                      var c = h >>> 8;
                      if (0 != (c &= 15))
                        throw "unknown kern table format: " + c;
                      i = t.kern.readFormat0(e, i, o)
                    }
                    return o
                  }
                  ,
                  t.kern.readFormat0 = function(e, i, n) {
                    var r = t._bin
                      , s = -1
                      , a = r.readUshort(e, i);
                    i += 2,
                      r.readUshort(e, i),
                      i += 2,
                      r.readUshort(e, i),
                      i += 2,
                      r.readUshort(e, i),
                      i += 2;
                    for (var o = 0; o < a; o++) {
                      var l = r.readUshort(e, i);
                      i += 2;
                      var h = r.readUshort(e, i);
                      i += 2;
                      var c = r.readShort(e, i);
                      i += 2,
                      l != s && (n.glyph1.push(l),
                        n.rval.push({
                          glyph2: [],
                          vals: []
                        }));
                      var u = n.rval[n.rval.length - 1];
                      u.glyph2.push(h),
                        u.vals.push(c),
                        s = l
                    }
                    return i
                  }
                  ,
                  t.loca = {},
                  t.loca.parse = function(e, i, n, r) {
                    var s = t._bin
                      , a = []
                      , o = r.head.indexToLocFormat
                      , l = r.maxp.numGlyphs + 1;
                    if (0 == o)
                      for (var h = 0; h < l; h++)
                        a.push(s.readUshort(e, i + (h << 1)) << 1);
                    if (1 == o)
                      for (h = 0; h < l; h++)
                        a.push(s.readUint(e, i + (h << 2)));
                    return a
                  }
                  ,
                  t.maxp = {},
                  t.maxp.parse = function(e, i, n) {
                    var r = t._bin
                      , s = {}
                      , a = r.readUint(e, i);
                    return i += 4,
                      s.numGlyphs = r.readUshort(e, i),
                      i += 2,
                    65536 == a && (s.maxPoints = r.readUshort(e, i),
                      i += 2,
                      s.maxContours = r.readUshort(e, i),
                      i += 2,
                      s.maxCompositePoints = r.readUshort(e, i),
                      i += 2,
                      s.maxCompositeContours = r.readUshort(e, i),
                      i += 2,
                      s.maxZones = r.readUshort(e, i),
                      i += 2,
                      s.maxTwilightPoints = r.readUshort(e, i),
                      i += 2,
                      s.maxStorage = r.readUshort(e, i),
                      i += 2,
                      s.maxFunctionDefs = r.readUshort(e, i),
                      i += 2,
                      s.maxInstructionDefs = r.readUshort(e, i),
                      i += 2,
                      s.maxStackElements = r.readUshort(e, i),
                      i += 2,
                      s.maxSizeOfInstructions = r.readUshort(e, i),
                      i += 2,
                      s.maxComponentElements = r.readUshort(e, i),
                      i += 2,
                      s.maxComponentDepth = r.readUshort(e, i),
                      i += 2),
                      s
                  }
                  ,
                  t.name = {},
                  t.name.parse = function(e, i, n) {
                    var r = t._bin
                      , s = {};
                    r.readUshort(e, i),
                      i += 2;
                    var a = r.readUshort(e, i);
                    i += 2,
                      r.readUshort(e, i);
                    for (var o, l = ["copyright", "fontFamily", "fontSubfamily", "ID", "fullName", "version", "postScriptName", "trademark", "manufacturer", "designer", "description", "urlVendor", "urlDesigner", "licence", "licenceURL", "---", "typoFamilyName", "typoSubfamilyName", "compatibleFull", "sampleText", "postScriptCID", "wwsFamilyName", "wwsSubfamilyName", "lightPalette", "darkPalette"], h = i += 2, c = 0; c < a; c++) {
                      var u = r.readUshort(e, i);
                      i += 2;
                      var d = r.readUshort(e, i);
                      i += 2;
                      var p = r.readUshort(e, i);
                      i += 2;
                      var f = r.readUshort(e, i);
                      i += 2;
                      var m = r.readUshort(e, i);
                      i += 2;
                      var g = r.readUshort(e, i);
                      i += 2;
                      var v, y = l[f], x = h + 12 * a + g;
                      if (0 == u)
                        v = r.readUnicode(e, x, m / 2);
                      else if (3 == u && 0 == d)
                        v = r.readUnicode(e, x, m / 2);
                      else if (0 == d)
                        v = r.readASCII(e, x, m);
                      else if (1 == d)
                        v = r.readUnicode(e, x, m / 2);
                      else if (3 == d)
                        v = r.readUnicode(e, x, m / 2);
                      else {
                        if (1 != u)
                          throw "unknown encoding " + d + ", platformID: " + u;
                        v = r.readASCII(e, x, m),
                          console.debug("reading unknown MAC encoding " + d + " as ASCII")
                      }
                      var _ = "p" + u + "," + p.toString(16);
                      null == s[_] && (s[_] = {}),
                        s[_][void 0 !== y ? y : f] = v,
                        s[_]._lang = p
                    }
                    for (var b in s)
                      if (null != s[b].postScriptName && 1033 == s[b]._lang)
                        return s[b];
                    for (var b in s)
                      if (null != s[b].postScriptName && 0 == s[b]._lang)
                        return s[b];
                    for (var b in s)
                      if (null != s[b].postScriptName && 3084 == s[b]._lang)
                        return s[b];
                    for (var b in s)
                      if (null != s[b].postScriptName)
                        return s[b];
                    for (var b in s) {
                      o = b;
                      break
                    }
                    return console.debug("returning name table with languageID " + s[o]._lang),
                      s[o]
                  }
                  ,
                  t["OS/2"] = {},
                  t["OS/2"].parse = function(e, i, n) {
                    var r = t._bin.readUshort(e, i);
                    i += 2;
                    var s = {};
                    if (0 == r)
                      t["OS/2"].version0(e, i, s);
                    else if (1 == r)
                      t["OS/2"].version1(e, i, s);
                    else if (2 == r || 3 == r || 4 == r)
                      t["OS/2"].version2(e, i, s);
                    else {
                      if (5 != r)
                        throw "unknown OS/2 table version: " + r;
                      t["OS/2"].version5(e, i, s)
                    }
                    return s
                  }
                  ,
                  t["OS/2"].version0 = function(e, i, n) {
                    var r = t._bin;
                    return n.xAvgCharWidth = r.readShort(e, i),
                      i += 2,
                      n.usWeightClass = r.readUshort(e, i),
                      i += 2,
                      n.usWidthClass = r.readUshort(e, i),
                      i += 2,
                      n.fsType = r.readUshort(e, i),
                      i += 2,
                      n.ySubscriptXSize = r.readShort(e, i),
                      i += 2,
                      n.ySubscriptYSize = r.readShort(e, i),
                      i += 2,
                      n.ySubscriptXOffset = r.readShort(e, i),
                      i += 2,
                      n.ySubscriptYOffset = r.readShort(e, i),
                      i += 2,
                      n.ySuperscriptXSize = r.readShort(e, i),
                      i += 2,
                      n.ySuperscriptYSize = r.readShort(e, i),
                      i += 2,
                      n.ySuperscriptXOffset = r.readShort(e, i),
                      i += 2,
                      n.ySuperscriptYOffset = r.readShort(e, i),
                      i += 2,
                      n.yStrikeoutSize = r.readShort(e, i),
                      i += 2,
                      n.yStrikeoutPosition = r.readShort(e, i),
                      i += 2,
                      n.sFamilyClass = r.readShort(e, i),
                      i += 2,
                      n.panose = r.readBytes(e, i, 10),
                      i += 10,
                      n.ulUnicodeRange1 = r.readUint(e, i),
                      i += 4,
                      n.ulUnicodeRange2 = r.readUint(e, i),
                      i += 4,
                      n.ulUnicodeRange3 = r.readUint(e, i),
                      i += 4,
                      n.ulUnicodeRange4 = r.readUint(e, i),
                      i += 4,
                      n.achVendID = [r.readInt8(e, i), r.readInt8(e, i + 1), r.readInt8(e, i + 2), r.readInt8(e, i + 3)],
                      i += 4,
                      n.fsSelection = r.readUshort(e, i),
                      i += 2,
                      n.usFirstCharIndex = r.readUshort(e, i),
                      i += 2,
                      n.usLastCharIndex = r.readUshort(e, i),
                      i += 2,
                      n.sTypoAscender = r.readShort(e, i),
                      i += 2,
                      n.sTypoDescender = r.readShort(e, i),
                      i += 2,
                      n.sTypoLineGap = r.readShort(e, i),
                      i += 2,
                      n.usWinAscent = r.readUshort(e, i),
                      i += 2,
                      n.usWinDescent = r.readUshort(e, i),
                    i + 2
                  }
                  ,
                  t["OS/2"].version1 = function(e, i, n) {
                    var r = t._bin;
                    return i = t["OS/2"].version0(e, i, n),
                      n.ulCodePageRange1 = r.readUint(e, i),
                      i += 4,
                      n.ulCodePageRange2 = r.readUint(e, i),
                    i + 4
                  }
                  ,
                  t["OS/2"].version2 = function(e, i, n) {
                    var r = t._bin;
                    return i = t["OS/2"].version1(e, i, n),
                      n.sxHeight = r.readShort(e, i),
                      i += 2,
                      n.sCapHeight = r.readShort(e, i),
                      i += 2,
                      n.usDefault = r.readUshort(e, i),
                      i += 2,
                      n.usBreak = r.readUshort(e, i),
                      i += 2,
                      n.usMaxContext = r.readUshort(e, i),
                    i + 2
                  }
                  ,
                  t["OS/2"].version5 = function(e, i, n) {
                    var r = t._bin;
                    return i = t["OS/2"].version2(e, i, n),
                      n.usLowerOpticalPointSize = r.readUshort(e, i),
                      i += 2,
                      n.usUpperOpticalPointSize = r.readUshort(e, i),
                    i + 2
                  }
                  ,
                  t.post = {},
                  t.post.parse = function(e, i, n) {
                    var r = t._bin
                      , s = {};
                    return s.version = r.readFixed(e, i),
                      i += 4,
                      s.italicAngle = r.readFixed(e, i),
                      i += 4,
                      s.underlinePosition = r.readShort(e, i),
                      i += 2,
                      s.underlineThickness = r.readShort(e, i),
                      i += 2,
                      s
                  }
                  ,
                null == t && (t = {}),
                null == t.U && (t.U = {}),
                  t.U.codeToGlyph = function(e, t) {
                    var i = e.cmap
                      , n = -1;
                    if (null != i.p0e4 ? n = i.p0e4 : null != i.p3e1 ? n = i.p3e1 : null != i.p1e0 ? n = i.p1e0 : null != i.p0e3 && (n = i.p0e3),
                    -1 == n)
                      throw "no familiar platform and encoding!";
                    var r = i.tables[n];
                    if (0 == r.format)
                      return t >= r.map.length ? 0 : r.map[t];
                    if (4 == r.format) {
                      for (var s = -1, a = 0; a < r.endCount.length; a++)
                        if (t <= r.endCount[a]) {
                          s = a;
                          break
                        }
                      return -1 == s || r.startCount[s] > t ? 0 : 65535 & (0 != r.idRangeOffset[s] ? r.glyphIdArray[t - r.startCount[s] + (r.idRangeOffset[s] >> 1) - (r.idRangeOffset.length - s)] : t + r.idDelta[s])
                    }
                    if (12 == r.format) {
                      if (t > r.groups[r.groups.length - 1][1])
                        return 0;
                      for (a = 0; a < r.groups.length; a++) {
                        var o = r.groups[a];
                        if (o[0] <= t && t <= o[1])
                          return o[2] + (t - o[0])
                      }
                      return 0
                    }
                    throw "unknown cmap table format " + r.format
                  }
                  ,
                  t.U.glyphToPath = function(e, i) {
                    var n = {
                      cmds: [],
                      crds: []
                    };
                    if (e.SVG && e.SVG.entries[i]) {
                      var r = e.SVG.entries[i];
                      return null == r ? n : ("string" == typeof r && (r = t.SVG.toPath(r),
                        e.SVG.entries[i] = r),
                        r)
                    }
                    if (e.CFF) {
                      var s = {
                        x: 0,
                        y: 0,
                        stack: [],
                        nStems: 0,
                        haveWidth: !1,
                        width: e.CFF.Private ? e.CFF.Private.defaultWidthX : 0,
                        open: !1
                      }
                        , a = e.CFF
                        , o = e.CFF.Private;
                      if (a.ROS) {
                        for (var l = 0; a.FDSelect[l + 2] <= i; )
                          l += 2;
                        o = a.FDArray[a.FDSelect[l + 1]].Private
                      }
                      t.U._drawCFF(e.CFF.CharStrings[i], s, a, o, n)
                    } else
                      e.glyf && t.U._drawGlyf(i, e, n);
                    return n
                  }
                  ,
                  t.U._drawGlyf = function(e, i, n) {
                    var r = i.glyf[e];
                    null == r && (r = i.glyf[e] = t.glyf._parseGlyf(i, e)),
                    null != r && (r.noc > -1 ? t.U._simpleGlyph(r, n) : t.U._compoGlyph(r, i, n))
                  }
                  ,
                  t.U._simpleGlyph = function(e, i) {
                    for (var n = 0; n < e.noc; n++) {
                      for (var r = 0 == n ? 0 : e.endPts[n - 1] + 1, s = e.endPts[n], a = r; a <= s; a++) {
                        var o = a == r ? s : a - 1
                          , l = a == s ? r : a + 1
                          , h = 1 & e.flags[a]
                          , c = 1 & e.flags[o]
                          , u = 1 & e.flags[l]
                          , d = e.xs[a]
                          , p = e.ys[a];
                        if (a == r)
                          if (h) {
                            if (!c) {
                              t.U.P.moveTo(i, d, p);
                              continue
                            }
                            t.U.P.moveTo(i, e.xs[o], e.ys[o])
                          } else
                            c ? t.U.P.moveTo(i, e.xs[o], e.ys[o]) : t.U.P.moveTo(i, (e.xs[o] + d) / 2, (e.ys[o] + p) / 2);
                        h ? c && t.U.P.lineTo(i, d, p) : u ? t.U.P.qcurveTo(i, d, p, e.xs[l], e.ys[l]) : t.U.P.qcurveTo(i, d, p, (d + e.xs[l]) / 2, (p + e.ys[l]) / 2)
                      }
                      t.U.P.closePath(i)
                    }
                  }
                  ,
                  t.U._compoGlyph = function(e, i, n) {
                    for (var r = 0; r < e.parts.length; r++) {
                      var s = {
                        cmds: [],
                        crds: []
                      }
                        , a = e.parts[r];
                      t.U._drawGlyf(a.glyphIndex, i, s);
                      for (var o = a.m, l = 0; l < s.crds.length; l += 2) {
                        var h = s.crds[l]
                          , c = s.crds[l + 1];
                        n.crds.push(h * o.a + c * o.b + o.tx),
                          n.crds.push(h * o.c + c * o.d + o.ty)
                      }
                      for (l = 0; l < s.cmds.length; l++)
                        n.cmds.push(s.cmds[l])
                    }
                  }
                  ,
                  t.U._getGlyphClass = function(e, i) {
                    var n = t._lctf.getInterval(i, e);
                    return -1 == n ? 0 : i[n + 2]
                  }
                  ,
                  t.U.getPairAdjustment = function(e, i, n) {
                    var r = 0
                      , s = !1;
                    if (e.GPOS)
                      for (var a = e.GPOS, o = a.lookupList, l = a.featureList, h = [], c = 0; c < l.length; c++) {
                        var u = l[c];
                        if ("kern" == u.tag) {
                          s = !0;
                          for (var d = 0; d < u.tab.length; d++)
                            if (!h[u.tab[d]]) {
                              h[u.tab[d]] = !0;
                              for (var p = o[u.tab[d]], f = 0; f < p.tabs.length; f++)
                                if (null != p.tabs[f]) {
                                  var m, g = p.tabs[f];
                                  if (!g.coverage || -1 != (m = t._lctf.coverageIndex(g.coverage, i)))
                                    if (1 == p.ltype)
                                      ;
                                    else if (2 == p.ltype) {
                                      var v;
                                      if (1 == g.fmt) {
                                        var y = g.pairsets[m];
                                        for (c = 0; c < y.length; c++)
                                          y[c].gid2 == n && (v = y[c])
                                      } else if (2 == g.fmt) {
                                        var x = t.U._getGlyphClass(i, g.classDef1)
                                          , _ = t.U._getGlyphClass(n, g.classDef2);
                                        v = g.matrix[x][_]
                                      }
                                      v && v.val1 && v.val1[2] && (r += v.val1[2]),
                                      v && v.val2 && v.val2[0] && (r += v.val2[0])
                                    }
                                }
                            }
                        }
                      }
                    if (e.kern && !s) {
                      var b = e.kern.glyph1.indexOf(i);
                      if (-1 != b) {
                        var w = e.kern.rval[b].glyph2.indexOf(n);
                        -1 != w && (r += e.kern.rval[b].vals[w])
                      }
                    }
                    return r
                  }
                  ,
                  t.U._applySubs = function(e, i, n, r) {
                    for (var s = e.length - i - 1, a = 0; a < n.tabs.length; a++)
                      if (null != n.tabs[a]) {
                        var o, l = n.tabs[a];
                        if (!l.coverage || -1 != (o = t._lctf.coverageIndex(l.coverage, e[i])))
                          if (1 == n.ltype)
                            e[i],
                              1 == l.fmt ? e[i] = e[i] + l.delta : e[i] = l.newg[o];
                          else if (4 == n.ltype)
                            for (var h = l.vals[o], c = 0; c < h.length; c++) {
                              var u = h[c]
                                , d = u.chain.length;
                              if (!(d > s)) {
                                for (var p = !0, f = 0, m = 0; m < d; m++) {
                                  for (; -1 == e[i + f + (1 + m)]; )
                                    f++;
                                  u.chain[m] != e[i + f + (1 + m)] && (p = !1)
                                }
                                if (p) {
                                  for (e[i] = u.nglyph,
                                         m = 0; m < d + f; m++)
                                    e[i + m + 1] = -1;
                                  break
                                }
                              }
                            }
                          else if (5 == n.ltype && 2 == l.fmt)
                            for (var g = t._lctf.getInterval(l.cDef, e[i]), v = l.cDef[g + 2], y = l.scset[v], x = 0; x < y.length; x++) {
                              var _ = y[x]
                                , b = _.input;
                              if (!(b.length > s)) {
                                for (p = !0,
                                       m = 0; m < b.length; m++) {
                                  var w = t._lctf.getInterval(l.cDef, e[i + 1 + m]);
                                  if (-1 == g && l.cDef[w + 2] != b[m]) {
                                    p = !1;
                                    break
                                  }
                                }
                                if (p) {
                                  var A = _.substLookupRecords;
                                  for (c = 0; c < A.length; c += 2)
                                    A[c],
                                      A[c + 1]
                                }
                              }
                            }
                          else if (6 == n.ltype && 3 == l.fmt) {
                            if (!t.U._glsCovered(e, l.backCvg, i - l.backCvg.length))
                              continue;
                            if (!t.U._glsCovered(e, l.inptCvg, i))
                              continue;
                            if (!t.U._glsCovered(e, l.ahedCvg, i + l.inptCvg.length))
                              continue;
                            var S = l.lookupRec;
                            for (x = 0; x < S.length; x += 2) {
                              g = S[x];
                              var M = r[S[x + 1]];
                              t.U._applySubs(e, i + g, M, r)
                            }
                          }
                      }
                  }
                  ,
                  t.U._glsCovered = function(e, i, n) {
                    for (var r = 0; r < i.length; r++)
                      if (-1 == t._lctf.coverageIndex(i[r], e[n + r]))
                        return !1;
                    return !0
                  }
                  ,
                  t.U.glyphsToPath = function(e, i, n) {
                    for (var r = {
                      cmds: [],
                      crds: []
                    }, s = 0, a = 0; a < i.length; a++) {
                      var o = i[a];
                      if (-1 != o) {
                        for (var l = a < i.length - 1 && -1 != i[a + 1] ? i[a + 1] : 0, h = t.U.glyphToPath(e, o), c = 0; c < h.crds.length; c += 2)
                          r.crds.push(h.crds[c] + s),
                            r.crds.push(h.crds[c + 1]);
                        for (n && r.cmds.push(n),
                               c = 0; c < h.cmds.length; c++)
                          r.cmds.push(h.cmds[c]);
                        n && r.cmds.push("X"),
                          s += e.hmtx.aWidth[o],
                        a < i.length - 1 && (s += t.U.getPairAdjustment(e, o, l))
                      }
                    }
                    return r
                  }
                  ,
                  t.U.P = {},
                  t.U.P.moveTo = function(e, t, i) {
                    e.cmds.push("M"),
                      e.crds.push(t, i)
                  }
                  ,
                  t.U.P.lineTo = function(e, t, i) {
                    e.cmds.push("L"),
                      e.crds.push(t, i)
                  }
                  ,
                  t.U.P.curveTo = function(e, t, i, n, r, s, a) {
                    e.cmds.push("C"),
                      e.crds.push(t, i, n, r, s, a)
                  }
                  ,
                  t.U.P.qcurveTo = function(e, t, i, n, r) {
                    e.cmds.push("Q"),
                      e.crds.push(t, i, n, r)
                  }
                  ,
                  t.U.P.closePath = function(e) {
                    e.cmds.push("Z")
                  }
                  ,
                  t.U._drawCFF = function(e, i, n, r, s) {
                    for (var a = i.stack, o = i.nStems, l = i.haveWidth, h = i.width, c = i.open, u = 0, d = i.x, p = i.y, f = 0, m = 0, g = 0, v = 0, y = 0, x = 0, _ = 0, b = 0, w = 0, A = 0, S = {
                      val: 0,
                      size: 0
                    }; u < e.length; ) {
                      t.CFF.getCharString(e, u, S);
                      var M = S.val;
                      if (u += S.size,
                      "o1" == M || "o18" == M)
                        a.length % 2 != 0 && !l && (h = a.shift() + r.nominalWidthX),
                          o += a.length >> 1,
                          a.length = 0,
                          l = !0;
                      else if ("o3" == M || "o23" == M)
                        a.length % 2 != 0 && !l && (h = a.shift() + r.nominalWidthX),
                          o += a.length >> 1,
                          a.length = 0,
                          l = !0;
                      else if ("o4" == M)
                        a.length > 1 && !l && (h = a.shift() + r.nominalWidthX,
                          l = !0),
                        c && t.U.P.closePath(s),
                          p += a.pop(),
                          t.U.P.moveTo(s, d, p),
                          c = !0;
                      else if ("o5" == M)
                        for (; a.length > 0; )
                          d += a.shift(),
                            p += a.shift(),
                            t.U.P.lineTo(s, d, p);
                      else if ("o6" == M || "o7" == M)
                        for (var T = a.length, E = "o6" == M, C = 0; C < T; C++) {
                          var P = a.shift();
                          E ? d += P : p += P,
                            E = !E,
                            t.U.P.lineTo(s, d, p)
                        }
                      else if ("o8" == M || "o24" == M) {
                        T = a.length;
                        for (var D = 0; D + 6 <= T; )
                          f = d + a.shift(),
                            m = p + a.shift(),
                            g = f + a.shift(),
                            v = m + a.shift(),
                            d = g + a.shift(),
                            p = v + a.shift(),
                            t.U.P.curveTo(s, f, m, g, v, d, p),
                            D += 6;
                        "o24" == M && (d += a.shift(),
                          p += a.shift(),
                          t.U.P.lineTo(s, d, p))
                      } else {
                        if ("o11" == M)
                          break;
                        if ("o1234" == M || "o1235" == M || "o1236" == M || "o1237" == M)
                          "o1234" == M && (m = p,
                            g = (f = d + a.shift()) + a.shift(),
                            A = v = m + a.shift(),
                            x = v,
                            b = p,
                            d = (_ = (y = (w = g + a.shift()) + a.shift()) + a.shift()) + a.shift(),
                            t.U.P.curveTo(s, f, m, g, v, w, A),
                            t.U.P.curveTo(s, y, x, _, b, d, p)),
                          "o1235" == M && (f = d + a.shift(),
                            m = p + a.shift(),
                            g = f + a.shift(),
                            v = m + a.shift(),
                            w = g + a.shift(),
                            A = v + a.shift(),
                            y = w + a.shift(),
                            x = A + a.shift(),
                            _ = y + a.shift(),
                            b = x + a.shift(),
                            d = _ + a.shift(),
                            p = b + a.shift(),
                            a.shift(),
                            t.U.P.curveTo(s, f, m, g, v, w, A),
                            t.U.P.curveTo(s, y, x, _, b, d, p)),
                          "o1236" == M && (f = d + a.shift(),
                            m = p + a.shift(),
                            g = f + a.shift(),
                            A = v = m + a.shift(),
                            x = v,
                            _ = (y = (w = g + a.shift()) + a.shift()) + a.shift(),
                            b = x + a.shift(),
                            d = _ + a.shift(),
                            t.U.P.curveTo(s, f, m, g, v, w, A),
                            t.U.P.curveTo(s, y, x, _, b, d, p)),
                          "o1237" == M && (f = d + a.shift(),
                            m = p + a.shift(),
                            g = f + a.shift(),
                            v = m + a.shift(),
                            w = g + a.shift(),
                            A = v + a.shift(),
                            y = w + a.shift(),
                            x = A + a.shift(),
                            _ = y + a.shift(),
                            b = x + a.shift(),
                            Math.abs(_ - d) > Math.abs(b - p) ? d = _ + a.shift() : p = b + a.shift(),
                            t.U.P.curveTo(s, f, m, g, v, w, A),
                            t.U.P.curveTo(s, y, x, _, b, d, p));
                        else if ("o14" == M) {
                          if (a.length > 0 && !l && (h = a.shift() + n.nominalWidthX,
                            l = !0),
                          4 == a.length) {
                            var I = a.shift()
                              , R = a.shift()
                              , L = a.shift()
                              , k = a.shift()
                              , F = t.CFF.glyphBySE(n, L)
                              , B = t.CFF.glyphBySE(n, k);
                            t.U._drawCFF(n.CharStrings[F], i, n, r, s),
                              i.x = I,
                              i.y = R,
                              t.U._drawCFF(n.CharStrings[B], i, n, r, s)
                          }
                          c && (t.U.P.closePath(s),
                            c = !1)
                        } else if ("o19" == M || "o20" == M)
                          a.length % 2 != 0 && !l && (h = a.shift() + r.nominalWidthX),
                            o += a.length >> 1,
                            a.length = 0,
                            l = !0,
                            u += o + 7 >> 3;
                        else if ("o21" == M)
                          a.length > 2 && !l && (h = a.shift() + r.nominalWidthX,
                            l = !0),
                            p += a.pop(),
                            d += a.pop(),
                          c && t.U.P.closePath(s),
                            t.U.P.moveTo(s, d, p),
                            c = !0;
                        else if ("o22" == M)
                          a.length > 1 && !l && (h = a.shift() + r.nominalWidthX,
                            l = !0),
                            d += a.pop(),
                          c && t.U.P.closePath(s),
                            t.U.P.moveTo(s, d, p),
                            c = !0;
                        else if ("o25" == M) {
                          for (; a.length > 6; )
                            d += a.shift(),
                              p += a.shift(),
                              t.U.P.lineTo(s, d, p);
                          f = d + a.shift(),
                            m = p + a.shift(),
                            g = f + a.shift(),
                            v = m + a.shift(),
                            d = g + a.shift(),
                            p = v + a.shift(),
                            t.U.P.curveTo(s, f, m, g, v, d, p)
                        } else if ("o26" == M)
                          for (a.length % 2 && (d += a.shift()); a.length > 0; )
                            f = d,
                              m = p + a.shift(),
                              d = g = f + a.shift(),
                              p = (v = m + a.shift()) + a.shift(),
                              t.U.P.curveTo(s, f, m, g, v, d, p);
                        else if ("o27" == M)
                          for (a.length % 2 && (p += a.shift()); a.length > 0; )
                            m = p,
                              g = (f = d + a.shift()) + a.shift(),
                              v = m + a.shift(),
                              d = g + a.shift(),
                              p = v,
                              t.U.P.curveTo(s, f, m, g, v, d, p);
                        else if ("o10" == M || "o29" == M) {
                          var O = "o10" == M ? r : n;
                          if (0 == a.length)
                            console.debug("error: empty stack");
                          else {
                            var N = a.pop()
                              , z = O.Subrs[N + O.Bias];
                            i.x = d,
                              i.y = p,
                              i.nStems = o,
                              i.haveWidth = l,
                              i.width = h,
                              i.open = c,
                              t.U._drawCFF(z, i, n, r, s),
                              d = i.x,
                              p = i.y,
                              o = i.nStems,
                              l = i.haveWidth,
                              h = i.width,
                              c = i.open
                          }
                        } else if ("o30" == M || "o31" == M) {
                          var U = a.length
                            , G = (D = 0,
                          "o31" == M);
                          for (D += U - (T = -3 & U); D < T; )
                            G ? (m = p,
                              g = (f = d + a.shift()) + a.shift(),
                              p = (v = m + a.shift()) + a.shift(),
                              T - D == 5 ? (d = g + a.shift(),
                                D++) : d = g,
                              G = !1) : (f = d,
                              m = p + a.shift(),
                              g = f + a.shift(),
                              v = m + a.shift(),
                              d = g + a.shift(),
                              T - D == 5 ? (p = v + a.shift(),
                                D++) : p = v,
                              G = !0),
                              t.U.P.curveTo(s, f, m, g, v, d, p),
                              D += 4
                        } else {
                          if ("o" == (M + "").charAt(0))
                            throw console.debug("Unknown operation: " + M, e),
                              M;
                          a.push(M)
                        }
                      }
                    }
                    i.x = d,
                      i.y = p,
                      i.nStems = o,
                      i.haveWidth = l,
                      i.width = h,
                      i.open = c
                  }
                ;
                var i = t
                  , n = {
                  Typr: i
                };
                return e.Typr = i,
                  e.default = n,
                  Object.defineProperty(e, "__esModule", {
                    value: !0
                  }),
                  e
              }({}).Typr
          }
            , function() {
              return function(e) {
                var t = Uint8Array
                  , i = Uint16Array
                  , n = Uint32Array
                  , r = new t([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0])
                  , s = new t([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0])
                  , a = new t([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
                  , o = function(e, t) {
                  for (var r = new i(31), s = 0; s < 31; ++s)
                    r[s] = t += 1 << e[s - 1];
                  var a = new n(r[30]);
                  for (s = 1; s < 30; ++s)
                    for (var o = r[s]; o < r[s + 1]; ++o)
                      a[o] = o - r[s] << 5 | s;
                  return [r, a]
                }
                  , l = o(r, 2)
                  , h = l[0]
                  , c = l[1];
                h[28] = 258,
                  c[258] = 28;
                for (var u = o(s, 0)[0], d = new i(32768), p = 0; p < 32768; ++p) {
                  var f = (43690 & p) >>> 1 | (21845 & p) << 1;
                  f = (61680 & (f = (52428 & f) >>> 2 | (13107 & f) << 2)) >>> 4 | (3855 & f) << 4,
                    d[p] = ((65280 & f) >>> 8 | (255 & f) << 8) >>> 1
                }
                var m = function(e, t, n) {
                  for (var r = e.length, s = 0, a = new i(t); s < r; ++s)
                    ++a[e[s] - 1];
                  var o, l = new i(t);
                  for (s = 0; s < t; ++s)
                    l[s] = l[s - 1] + a[s - 1] << 1;
                  if (n) {
                    o = new i(1 << t);
                    var h = 15 - t;
                    for (s = 0; s < r; ++s)
                      if (e[s])
                        for (var c = s << 4 | e[s], u = t - e[s], p = l[e[s] - 1]++ << u, f = p | (1 << u) - 1; p <= f; ++p)
                          o[d[p] >>> h] = c
                  } else
                    for (o = new i(r),
                           s = 0; s < r; ++s)
                      e[s] && (o[s] = d[l[e[s] - 1]++] >>> 15 - e[s]);
                  return o
                }
                  , g = new t(288);
                for (p = 0; p < 144; ++p)
                  g[p] = 8;
                for (p = 144; p < 256; ++p)
                  g[p] = 9;
                for (p = 256; p < 280; ++p)
                  g[p] = 7;
                for (p = 280; p < 288; ++p)
                  g[p] = 8;
                var v = new t(32);
                for (p = 0; p < 32; ++p)
                  v[p] = 5;
                var y = m(g, 9, 1)
                  , x = m(v, 5, 1)
                  , _ = function(e) {
                  for (var t = e[0], i = 1; i < e.length; ++i)
                    e[i] > t && (t = e[i]);
                  return t
                }
                  , b = function(e, t, i) {
                  var n = t / 8 | 0;
                  return (e[n] | e[n + 1] << 8) >> (7 & t) & i
                }
                  , w = function(e, t) {
                  var i = t / 8 | 0;
                  return (e[i] | e[i + 1] << 8 | e[i + 2] << 16) >> (7 & t)
                }
                  , A = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"]
                  , S = function(e, t, i) {
                  var n = new Error(t || A[e]);
                  if (n.code = e,
                  Error.captureStackTrace && Error.captureStackTrace(n, S),
                    !i)
                    throw n;
                  return n
                }
                  , M = function(e, o, l) {
                  var c = e.length;
                  if (!c || l && !l.l && c < 5)
                    return o || new t(0);
                  var d = !o || l
                    , p = !l || l.i;
                  l || (l = {}),
                  o || (o = new t(3 * c));
                  var f, g = function(e) {
                    var i = o.length;
                    if (e > i) {
                      var n = new t(Math.max(2 * i, e));
                      n.set(o),
                        o = n
                    }
                  }, v = l.f || 0, A = l.p || 0, M = l.b || 0, T = l.l, E = l.d, C = l.m, P = l.n, D = 8 * c;
                  do {
                    if (!T) {
                      l.f = v = b(e, A, 1);
                      var I = b(e, A + 1, 3);
                      if (A += 3,
                        !I) {
                        var R = e[(H = ((f = A) / 8 | 0) + (7 & f && 1) + 4) - 4] | e[H - 3] << 8
                          , L = H + R;
                        if (L > c) {
                          p && S(0);
                          break
                        }
                        d && g(M + R),
                          o.set(e.subarray(H, L), M),
                          l.b = M += R,
                          l.p = A = 8 * L;
                        continue
                      }
                      if (1 == I)
                        T = y,
                          E = x,
                          C = 9,
                          P = 5;
                      else if (2 == I) {
                        var k = b(e, A, 31) + 257
                          , F = b(e, A + 10, 15) + 4
                          , B = k + b(e, A + 5, 31) + 1;
                        A += 14;
                        for (var O = new t(B), N = new t(19), z = 0; z < F; ++z)
                          N[a[z]] = b(e, A + 3 * z, 7);
                        A += 3 * F;
                        var U = _(N)
                          , G = (1 << U) - 1
                          , V = m(N, U, 1);
                        for (z = 0; z < B; ) {
                          var H, W = V[b(e, A, G)];
                          if (A += 15 & W,
                          (H = W >>> 4) < 16)
                            O[z++] = H;
                          else {
                            var j = 0
                              , X = 0;
                            for (16 == H ? (X = 3 + b(e, A, 3),
                              A += 2,
                              j = O[z - 1]) : 17 == H ? (X = 3 + b(e, A, 7),
                              A += 3) : 18 == H && (X = 11 + b(e, A, 127),
                              A += 7); X--; )
                              O[z++] = j
                          }
                        }
                        var Y = O.subarray(0, k)
                          , q = O.subarray(k);
                        C = _(Y),
                          P = _(q),
                          T = m(Y, C, 1),
                          E = m(q, P, 1)
                      } else
                        S(1);
                      if (A > D) {
                        p && S(0);
                        break
                      }
                    }
                    d && g(M + 131072);
                    for (var Q = (1 << C) - 1, K = (1 << P) - 1, J = A; ; J = A) {
                      var Z = (j = T[w(e, A) & Q]) >>> 4;
                      if ((A += 15 & j) > D) {
                        p && S(0);
                        break
                      }
                      if (j || S(2),
                      Z < 256)
                        o[M++] = Z;
                      else {
                        if (256 == Z) {
                          J = A,
                            T = null;
                          break
                        }
                        var $ = Z - 254;
                        if (Z > 264) {
                          var ee = r[z = Z - 257];
                          $ = b(e, A, (1 << ee) - 1) + h[z],
                            A += ee
                        }
                        var te = E[w(e, A) & K]
                          , ie = te >>> 4;
                        if (te || S(3),
                          A += 15 & te,
                          q = u[ie],
                        ie > 3 && (ee = s[ie],
                          q += w(e, A) & (1 << ee) - 1,
                          A += ee),
                        A > D) {
                          p && S(0);
                          break
                        }
                        d && g(M + 131072);
                        for (var ne = M + $; M < ne; M += 4)
                          o[M] = o[M - q],
                            o[M + 1] = o[M + 1 - q],
                            o[M + 2] = o[M + 2 - q],
                            o[M + 3] = o[M + 3 - q];
                        M = ne
                      }
                    }
                    l.l = T,
                      l.p = J,
                      l.b = M,
                    T && (v = 1,
                      l.m = C,
                      l.d = E,
                      l.n = P)
                  } while (!v);
                  return M == o.length ? o : function(e, r, s) {
                    (null == r || r < 0) && (r = 0),
                    (null == s || s > e.length) && (s = e.length);
                    var a = new (e instanceof i ? i : e instanceof n ? n : t)(s - r);
                    return a.set(e.subarray(r, s)),
                      a
                  }(o, 0, M)
                }
                  , T = new t(0)
                  , E = "undefined" != typeof TextDecoder && new TextDecoder;
                try {
                  E.decode(T, {
                    stream: !0
                  })
                } catch (e) {}
                return e.convert_streams = function(e) {
                  var t = new DataView(e)
                    , i = 0;
                  function n() {
                    var e = t.getUint16(i);
                    return i += 2,
                      e
                  }
                  function r() {
                    var e = t.getUint32(i);
                    return i += 4,
                      e
                  }
                  function s(e) {
                    v.setUint16(y, e),
                      y += 2
                  }
                  function a(e) {
                    v.setUint32(y, e),
                      y += 4
                  }
                  for (var o = {
                    signature: r(),
                    flavor: r(),
                    length: r(),
                    numTables: n(),
                    reserved: n(),
                    totalSfntSize: r(),
                    majorVersion: n(),
                    minorVersion: n(),
                    metaOffset: r(),
                    metaLength: r(),
                    metaOrigLength: r(),
                    privOffset: r(),
                    privLength: r()
                  }, l = 0; Math.pow(2, l) <= o.numTables; )
                    l++;
                  l--;
                  for (var h = 16 * Math.pow(2, l), c = 16 * o.numTables - h, u = 12, d = [], p = 0; p < o.numTables; p++)
                    d.push({
                      tag: r(),
                      offset: r(),
                      compLength: r(),
                      origLength: r(),
                      origChecksum: r()
                    }),
                      u += 16;
                  var f, m = new Uint8Array(12 + 16 * d.length + d.reduce((function(e, t) {
                      return e + t.origLength + 4
                    }
                  ), 0)), g = m.buffer, v = new DataView(g), y = 0;
                  return a(o.flavor),
                    s(o.numTables),
                    s(h),
                    s(l),
                    s(c),
                    d.forEach((function(e) {
                        a(e.tag),
                          a(e.origChecksum),
                          a(u),
                          a(e.origLength),
                          e.outOffset = u,
                        (u += e.origLength) % 4 != 0 && (u += 4 - u % 4)
                      }
                    )),
                    d.forEach((function(t) {
                        var i, n = e.slice(t.offset, t.offset + t.compLength);
                        if (t.compLength != t.origLength) {
                          var r = new Uint8Array(t.origLength);
                          i = new Uint8Array(n,2),
                            M(i, r)
                        } else
                          r = new Uint8Array(n);
                        m.set(r, t.outOffset);
                        var s = 0;
                        (u = t.outOffset + t.origLength) % 4 != 0 && (s = 4 - u % 4),
                          m.set(new Uint8Array(s).buffer, t.outOffset + t.origLength),
                          f = u + s
                      }
                    )),
                    g.slice(0, f)
                }
                  ,
                  Object.defineProperty(e, "__esModule", {
                    value: !0
                  }),
                  e
              }({}).convert_streams
            }
            , function(e, t) {
              const i = {
                M: 2,
                L: 2,
                Q: 4,
                C: 6,
                Z: 0
              }
                , n = {
                C: "18g,ca,368,1kz",
                D: "17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v",
                R: "17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6",
                L: "x9u,jff,a,fd,jv",
                T: "4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n"
              };
              let r;
              function s(e) {
                if (!r) {
                  const e = {
                    R: 2,
                    L: 1,
                    D: 4,
                    C: 16,
                    U: 32,
                    T: 8
                  };
                  r = new Map;
                  for (let t in n) {
                    let i = 0;
                    n[t].split(",").forEach((n=>{
                        let[s,a] = n.split("+");
                        s = parseInt(s, 36),
                          a = a ? parseInt(a, 36) : 0,
                          r.set(i += s, e[t]);
                        for (let n = a; n--; )
                          r.set(++i, e[t])
                      }
                    ))
                  }
                }
                return r.get(e) || 32
              }
              const a = [null, "isol", "init", "fina", "medi"];
              function o(e) {
                const t = new Uint8Array(e.length);
                let i = 32
                  , n = 1
                  , r = -1;
                for (let a = 0; a < e.length; a++) {
                  const o = e.codePointAt(a);
                  let l = 0 | s(o)
                    , h = 1;
                  8 & l || (21 & i ? 22 & l ? (h = 3,
                  1 !== n && 3 !== n || t[r]++) : 33 & l && (2 !== n && 4 !== n || t[r]--) : 34 & i && (2 !== n && 4 !== n || t[r]--),
                    n = t[a] = h,
                    i = l,
                    r = a,
                  o > 65535 && a++)
                }
                return t
              }
              return function(n) {
                const r = new Uint8Array(n,0,4)
                  , s = e._bin.readASCII(r, 0, 4);
                if ("wOFF" === s)
                  n = t(n);
                else if ("wOF2" === s)
                  throw new Error("woff2 fonts not supported");
                return function(t) {
                  const n = Object.create(null)
                    , r = {
                    unitsPerEm: t.head.unitsPerEm,
                    ascender: t.hhea.ascender,
                    descender: t.hhea.descender,
                    forEachGlyph(s, l, h, c) {
                      let u = 0;
                      const d = 1 / r.unitsPerEm * l
                        , p = function(t, i) {
                        const n = [];
                        for (let r = 0; r < i.length; r++) {
                          const s = i.codePointAt(r);
                          s > 65535 && r++,
                            n.push(e.U.codeToGlyph(t, s))
                        }
                        const r = t.GSUB;
                        if (r) {
                          const {lookupList: t, featureList: s} = r;
                          let l;
                          const h = /^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws)$/
                            , c = [];
                          s.forEach((r=>{
                              if (h.test(r.tag))
                                for (let s = 0; s < r.tab.length; s++) {
                                  if (c[r.tab[s]])
                                    continue;
                                  c[r.tab[s]] = !0;
                                  const h = t[r.tab[s]]
                                    , u = /^(isol|init|fina|medi)$/.test(r.tag);
                                  u && !l && (l = o(i));
                                  for (let i = 0; i < n.length; i++)
                                    l && u && a[l[i]] !== r.tag || e.U._applySubs(n, i, h, t)
                                }
                            }
                          ))
                        }
                        return n
                      }(t, s);
                      let f = 0
                        , m = -1;
                      return p.forEach(((r,a)=>{
                          if (-1 !== r) {
                            let s = n[r];
                            if (!s) {
                              const {cmds: a, crds: o} = e.U.glyphToPath(t, r);
                              let l, h, c, u, d = "", p = 0;
                              for (let e = 0, t = a.length; e < t; e++) {
                                const t = i[a[e]];
                                d += a[e];
                                for (let e = 1; e <= t; e++)
                                  d += (e > 1 ? "," : "") + o[p++]
                              }
                              if (o.length) {
                                l = h = 1 / 0,
                                  c = u = -1 / 0;
                                for (let e = 0, t = o.length; e < t; e += 2) {
                                  let t = o[e]
                                    , i = o[e + 1];
                                  t < l && (l = t),
                                  i < h && (h = i),
                                  t > c && (c = t),
                                  i > u && (u = i)
                                }
                              } else
                                l = c = h = u = 0;
                              s = n[r] = {
                                index: r,
                                advanceWidth: t.hmtx.aWidth[r],
                                xMin: l,
                                yMin: h,
                                xMax: c,
                                yMax: u,
                                path: d,
                                pathCommandCount: a.length
                              }
                            }
                            -1 !== m && (u += e.U.getPairAdjustment(t, m, r) * d),
                              c.call(null, s, u, f),
                            s.advanceWidth && (u += s.advanceWidth * d),
                            h && (u += h * l),
                              m = r
                          }
                          f += s.codePointAt(f) > 65535 ? 2 : 1
                        }
                      )),
                        u
                    }
                  };
                  return r
                }(e.parse(n)[0])
              }
            }
          ],
          init: (e,t,i)=>i(e(), t())
        })
          , Qf = {
          defaultFontURL: "https://fonts.gstatic.com/s/roboto/v18/KFOmCnqEu92Fr1Mu4mxM.woff",
          sdfGlyphSize: 64,
          sdfMargin: 1 / 16,
          sdfExponent: 9,
          textureWidth: 2048
        }
          , Kf = new Wr;
        let Jf = !1;
        function Zf() {
          return (self.performance || Date).now()
        }
        const $f = Object.create(null);
        function em({path: e, atlasIndex: t, sdfViewBox: i}, {sdfGlyphSize: n, sdfCanvas: r, contextLost: s}, a) {
          if (s)
            return Promise.resolve({
              timing: -1
            });
          const {textureWidth: o, sdfExponent: l} = Qf
            , h = Math.max(i[2] - i[0], i[3] - i[1])
            , c = Math.floor(t / 4);
          return function(e, t, i, n, r, s, a, o, l, h, c=!0) {
            return c ? jf(e, t, i, n, r, s, a, o, l, h).then(null, (c=>(Wf || (console.warn("WebGL SDF generation failed, falling back to JS", c),
              Wf = !0),
              Xf(e, t, i, n, r, s, a, o, l, h)))) : Xf(e, t, i, n, r, s, a, o, l, h)
          }(n, n, e, i, h, l, r, c % (o / n) * n, Math.floor(c / (o / n)) * n, t % 4, a)
        }
        let tm;
        function im(e) {
          if ("function" != typeof createImageBitmap) {
            console.info("Safari<15: applying SDF canvas workaround");
            const {sdfCanvas: t, sdfTexture: i} = e
              , {width: n, height: r} = t
              , s = e.sdfCanvas.getContext("webgl");
            let a = i.image.data;
            a && a.length === n * r * 4 || (a = new Uint8Array(n * r * 4),
              i.image = {
                width: n,
                height: r,
                data: a
              },
              i.flipY = !1,
              i.isDataTexture = !0),
              s.readPixels(0, 0, n, r, s.RGBA, s.UNSIGNED_BYTE, a)
          }
        }
        const nm = Sf({
          name: "Typesetter",
          dependencies: [Qf, qf, function(e, t, i) {
            const {defaultFontURL: n} = i
              , r = Object.create(null)
              , s = 1 / 0
              , a = /[\u00AD\u034F\u061C\u115F-\u1160\u17B4-\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8]/
              , o = /[\s\-\u007C\u00AD\u2010\u2012-\u2014\u2027\u2056\u2E17\u2E40]/;
            function l(t, i) {
              t || (t = n);
              let s = r[t];
              var a;
              s ? s.pending ? s.pending.push(i) : i(s) : (r[t] = {
                pending: [i]
              },
                a = t,
                function i() {
                  const s = e=>{
                      console.error(`Failure loading font ${a}${a === n ? "" : "; trying fallback"}`, e),
                      a !== n && (a = n,
                        i())
                    }
                  ;
                  try {
                    const i = new XMLHttpRequest;
                    i.open("get", a, !0),
                      i.responseType = "arraybuffer",
                      i.onload = function() {
                        if (i.status >= 400)
                          s(new Error(i.statusText));
                        else if (i.status > 0)
                          try {
                            (e=>{
                                let i = r[t].pending;
                                r[t] = e,
                                  i.forEach((t=>t(e)))
                              }
                            )(e(i.response))
                          } catch (e) {
                            s(e)
                          }
                      }
                      ,
                      i.onerror = s,
                      i.send()
                  } catch (e) {
                    s(e)
                  }
                }())
            }
            function h({text: e="", font: i=n, sdfGlyphSize: r=64, fontSize: h=1, letterSpacing: f=0, lineHeight: m="normal", maxWidth: g=s, direction: v, textAlign: y="left", textIndent: x=0, whiteSpace: _="normal", overflowWrap: b="normal", anchorX: w=0, anchorY: A=0, includeCaretPositions: S=!1, chunkedBoundsSize: M=8192, colorRanges: T=null}, E, C=!1) {
              const P = d()
                , D = {
                fontLoad: 0,
                typesetting: 0
              };
              e.indexOf("\r") > -1 && (console.info("Typesetter: got text with \\r chars; normalizing to \\n"),
                e = e.replace(/\r\n/g, "\n").replace(/\r/g, "\n")),
                h = +h,
                f = +f,
                g = +g,
                m = m || "normal",
                x = +x,
                l(i, (i=>{
                    const n = isFinite(g);
                    let r = null
                      , l = null
                      , I = null
                      , R = null
                      , L = null
                      , k = null
                      , F = null
                      , B = 0
                      , O = 0
                      , N = "nowrap" !== _;
                    const {ascender: z, descender: U, unitsPerEm: G} = i;
                    D.fontLoad = d() - P;
                    const V = d()
                      , H = h / G;
                    "normal" === m && (m = (z - U) / G);
                    const W = ((m *= h) - (z - U) * H) / 2
                      , j = -(z * H + W)
                      , X = Math.min(m, (z - U) * H)
                      , Y = (z + U) / 2 * H - X / 2;
                    let q = x
                      , Q = new p;
                    const K = [Q];
                    i.forEachGlyph(e, h, f, ((t,i,r)=>{
                        const s = e.charAt(r)
                          , l = t.advanceWidth * H
                          , c = Q.count;
                        let u;
                        if ("isEmpty"in t || (t.isWhitespace = !!s && /\s/.test(s),
                          t.canBreakAfter = !!s && o.test(s),
                          t.isEmpty = t.xMin === t.xMax || t.yMin === t.yMax || a.test(s)),
                        t.isWhitespace || t.isEmpty || O++,
                        N && n && !t.isWhitespace && i + l + q > g && c) {
                          if (Q.glyphAt(c - 1).glyphObj.canBreakAfter)
                            u = new p,
                              q = -i;
                          else
                            for (let e = c; e--; ) {
                              if (0 === e && "break-word" === b) {
                                u = new p,
                                  q = -i;
                                break
                              }
                              if (Q.glyphAt(e).glyphObj.canBreakAfter) {
                                u = Q.splitAt(e + 1);
                                const t = u.glyphAt(0).x;
                                q -= t;
                                for (let e = u.count; e--; )
                                  u.glyphAt(e).x -= t;
                                break
                              }
                            }
                          u && (Q.isSoftWrapped = !0,
                            Q = u,
                            K.push(Q),
                            B = g)
                        }
                        let d = Q.glyphAt(Q.count);
                        d.glyphObj = t,
                          d.x = i + q,
                          d.width = l,
                          d.charIndex = r,
                        "\n" === s && (Q = new p,
                          K.push(Q),
                          q = -(i + l + f * h) + x)
                      }
                    )),
                      K.forEach((e=>{
                          for (let t = e.count; t--; ) {
                            let {glyphObj: i, x: n, width: r} = e.glyphAt(t);
                            if (!i.isWhitespace)
                              return e.width = n + r,
                                void (e.width > B && (B = e.width))
                          }
                        }
                      ));
                    let J = 0
                      , Z = 0;
                    if (w && ("number" == typeof w ? J = -w : "string" == typeof w && (J = -B * ("left" === w ? 0 : "center" === w ? .5 : "right" === w ? 1 : c(w)))),
                      A)
                      if ("number" == typeof A)
                        Z = -A;
                      else if ("string" == typeof A) {
                        let e = K.length * m;
                        Z = "top" === A ? 0 : "top-baseline" === A ? -j : "middle" === A ? e / 2 : "bottom" === A ? e : "bottom-baseline" === A ? e - W + U * H : c(A) * e
                      }
                    if (!C) {
                      const n = t.getEmbeddingLevels(e, v);
                      r = new Uint16Array(O),
                        l = new Float32Array(2 * O),
                        I = {},
                        k = [s, s, -1 / 0, -1 / 0],
                        F = [];
                      let a = j;
                      S && (L = new Float32Array(3 * e.length)),
                      T && (R = new Uint8Array(3 * O));
                      let o, h, c = 0, d = -1, p = -1;
                      if (K.forEach(((f,g)=>{
                          let {count: v, width: x} = f;
                          if (v > 0) {
                            let m = 0;
                            for (let e = v; e-- && f.glyphAt(e).glyphObj.isWhitespace; )
                              m++;
                            let g = 0
                              , _ = 0;
                            if ("center" === y)
                              g = (B - x) / 2;
                            else if ("right" === y)
                              g = B - x;
                            else if ("justify" === y && f.isSoftWrapped) {
                              let e = 0;
                              for (let t = v - m; t--; )
                                f.glyphAt(t).glyphObj.isWhitespace && e++;
                              _ = (B - x) / e
                            }
                            if (_ || g) {
                              let e = 0;
                              for (let t = 0; t < v; t++) {
                                let i = f.glyphAt(t);
                                const n = i.glyphObj;
                                i.x += g + e,
                                0 !== _ && n.isWhitespace && t < v - m && (e += _,
                                  i.width += _)
                              }
                            }
                            const b = t.getReorderSegments(e, n, f.glyphAt(0).charIndex, f.glyphAt(f.count - 1).charIndex);
                            for (let e = 0; e < b.length; e++) {
                              const [t,i] = b[e];
                              let n = 1 / 0
                                , r = -1 / 0;
                              for (let e = 0; e < v; e++)
                                if (f.glyphAt(e).charIndex >= t) {
                                  let t = e
                                    , s = e;
                                  for (; s < v; s++) {
                                    let e = f.glyphAt(s);
                                    if (e.charIndex > i)
                                      break;
                                    s < v - m && (n = Math.min(n, e.x),
                                      r = Math.max(r, e.x + e.width))
                                  }
                                  for (let e = t; e < s; e++) {
                                    const t = f.glyphAt(e);
                                    t.x = r - (t.x + t.width - n)
                                  }
                                  break
                                }
                            }
                            let w;
                            const A = e=>w = e;
                            for (let m = 0; m < v; m++) {
                              let g = f.glyphAt(m);
                              w = g.glyphObj;
                              const v = w.index
                                , y = 1 & n.levels[g.charIndex];
                              if (y) {
                                const n = t.getMirroredCharacter(e[g.charIndex]);
                                n && i.forEachGlyph(n, 0, 0, A)
                              }
                              if (S) {
                                const {charIndex: e} = g
                                  , t = g.x + J
                                  , i = g.x + g.width + J;
                                L[3 * e] = y ? i : t,
                                  L[3 * e + 1] = y ? t : i,
                                  L[3 * e + 2] = a + Y + Z;
                                const n = e - d;
                                n > 1 && u(L, d, n),
                                  d = e
                              }
                              if (T) {
                                const {charIndex: e} = g;
                                for (; e > p; )
                                  p++,
                                  T.hasOwnProperty(p) && (h = T[p])
                              }
                              if (!w.isWhitespace && !w.isEmpty) {
                                const e = c++;
                                I[v] || (I[v] = {
                                  path: w.path,
                                  pathBounds: [w.xMin, w.yMin, w.xMax, w.yMax]
                                });
                                const t = g.x + J
                                  , i = a + Z;
                                l[2 * e] = t,
                                  l[2 * e + 1] = i;
                                const n = t + w.xMin * H
                                  , u = i + w.yMin * H
                                  , d = t + w.xMax * H
                                  , p = i + w.yMax * H;
                                n < k[0] && (k[0] = n),
                                u < k[1] && (k[1] = u),
                                d > k[2] && (k[2] = d),
                                p > k[3] && (k[3] = p),
                                e % M == 0 && (o = {
                                  start: e,
                                  end: e,
                                  rect: [s, s, -1 / 0, -1 / 0]
                                },
                                  F.push(o)),
                                  o.end++;
                                const f = o.rect;
                                if (n < f[0] && (f[0] = n),
                                u < f[1] && (f[1] = u),
                                d > f[2] && (f[2] = d),
                                p > f[3] && (f[3] = p),
                                  r[e] = v,
                                  T) {
                                  const t = 3 * e;
                                  R[t] = h >> 16 & 255,
                                    R[t + 1] = h >> 8 & 255,
                                    R[t + 2] = 255 & h
                                }
                              }
                            }
                          }
                          a -= m
                        }
                      )),
                        L) {
                        const t = e.length - d;
                        t > 1 && u(L, d, t)
                      }
                    }
                    D.typesetting = d() - V,
                      E({
                        glyphIds: r,
                        glyphPositions: l,
                        glyphData: I,
                        caretPositions: L,
                        caretHeight: X,
                        glyphColors: R,
                        chunkedBounds: F,
                        fontSize: h,
                        unitsPerEm: G,
                        ascender: z * H,
                        descender: U * H,
                        lineHeight: m,
                        topBaseline: j,
                        blockBounds: [J, Z - K.length * m, J + B, Z],
                        visibleBounds: k,
                        timings: D
                      })
                  }
                ))
            }
            function c(e) {
              let t = e.match(/^([\d.]+)%$/)
                , i = t ? parseFloat(t[1]) : NaN;
              return isNaN(i) ? 0 : i / 100
            }
            function u(e, t, i) {
              const n = e[3 * t]
                , r = e[3 * t + 1]
                , s = e[3 * t + 2]
                , a = (r - n) / i;
              for (let r = 0; r < i; r++) {
                const i = 3 * (t + r);
                e[i] = n + a * r,
                  e[i + 1] = n + a * (r + 1),
                  e[i + 2] = s
              }
            }
            function d() {
              return (self.performance || Date).now()
            }
            function p() {
              this.data = []
            }
            const f = ["glyphObj", "x", "width", "charIndex"];
            return p.prototype = {
              width: 0,
              isSoftWrapped: !1,
              get count() {
                return Math.ceil(this.data.length / f.length)
              },
              glyphAt(e) {
                let t = p.flyweight;
                return t.data = this.data,
                  t.index = e,
                  t
              },
              splitAt(e) {
                let t = new p;
                return t.data = this.data.splice(e * f.length),
                  t
              }
            },
              p.flyweight = f.reduce(((e,t,i,n)=>(Object.defineProperty(e, t, {
                get() {
                  return this.data[this.index * f.length + i]
                },
                set(e) {
                  this.data[this.index * f.length + i] = e
                }
              }),
                e)), {
                data: null,
                index: 0
              }),
              {
                typeset: h,
                measure: function(e, t) {
                  h(e, (e=>{
                      const [i,n,r,s] = e.blockBounds;
                      t({
                        width: r - i,
                        height: s - n
                      })
                    }
                  ), {
                    metricsOnly: !0
                  })
                },
                loadFont: l
              }
          }
            , function() {
              var e = function(e) {
                var t = {
                  R: "13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73",
                  EN: "1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9",
                  ES: "17,2,6dp+1,f+1,av,16vr,mx+1,4o,2",
                  ET: "z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj",
                  AN: "16o+5,2j+9,2+1,35,ed,1ff2+9,87+u",
                  CS: "18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b",
                  B: "a,3,f+2,2v,690",
                  S: "9,2,k",
                  WS: "c,k,4f4,1vk+a,u,1j,335",
                  ON: "x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i",
                  BN: "0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1",
                  NSM: "lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n",
                  AL: "16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d",
                  LRO: "6ct",
                  RLO: "6cu",
                  LRE: "6cq",
                  RLE: "6cr",
                  PDF: "6cs",
                  LRI: "6ee",
                  RLI: "6ef",
                  FSI: "6eg",
                  PDI: "6eh"
                }
                  , i = {}
                  , n = {};
                i.L = 1,
                  n[1] = "L",
                  Object.keys(t).forEach((function(e, t) {
                      i[e] = 1 << t + 1,
                        n[i[e]] = e
                    }
                  )),
                  Object.freeze(i);
                var r = i.LRI | i.RLI | i.FSI
                  , s = i.L | i.R | i.AL
                  , a = i.B | i.S | i.WS | i.ON | i.FSI | i.LRI | i.RLI | i.PDI
                  , o = i.BN | i.RLE | i.LRE | i.RLO | i.LRO | i.PDF
                  , l = i.S | i.WS | i.B | r | i.PDI | o
                  , h = null;
                function c(e) {
                  return function() {
                    if (!h) {
                      h = new Map;
                      var e = function(e) {
                        if (t.hasOwnProperty(e)) {
                          var n = 0;
                          t[e].split(",").forEach((function(t) {
                              var r = t.split("+")
                                , s = r[0]
                                , a = r[1];
                              s = parseInt(s, 36),
                                a = a ? parseInt(a, 36) : 0,
                                h.set(n += s, i[e]);
                              for (var o = 0; o < a; o++)
                                h.set(++n, i[e])
                            }
                          ))
                        }
                      };
                      for (var n in t)
                        e(n)
                    }
                  }(),
                  h.get(e.codePointAt(0)) || i.L
                }
                var u, d, p;
                function f(e, t) {
                  var i, n = 0, r = new Map, s = t && new Map;
                  return e.split(",").forEach((function e(a) {
                      if (-1 !== a.indexOf("+"))
                        for (var o = +a; o--; )
                          e(i);
                      else {
                        i = a;
                        var l = a.split(">")
                          , h = l[0]
                          , c = l[1];
                        h = String.fromCodePoint(n += parseInt(h, 36)),
                          c = String.fromCodePoint(n += parseInt(c, 36)),
                          r.set(h, c),
                        t && s.set(c, h)
                      }
                    }
                  )),
                    {
                      map: r,
                      reverseMap: s
                    }
                }
                function m() {
                  if (!u) {
                    var e = f("14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1", !0)
                      , t = e.map
                      , i = e.reverseMap;
                    u = t,
                      d = i,
                      p = f("6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye", !1).map
                  }
                }
                function g(e) {
                  return m(),
                  u.get(e) || null
                }
                function v(e) {
                  return m(),
                  d.get(e) || null
                }
                function y(e) {
                  return m(),
                  p.get(e) || null
                }
                var x, _ = i.L, b = i.R, w = i.EN, A = i.ES, S = i.ET, M = i.AN, T = i.CS, E = i.B, C = i.S, P = i.ON, D = i.BN, I = i.NSM, R = i.AL, L = i.LRO, k = i.RLO, F = i.LRE, B = i.RLE, O = i.PDF, N = i.LRI, z = i.RLI, U = i.FSI, G = i.PDI;
                function V(e) {
                  return function() {
                    if (!x) {
                      var e = f("14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1", !0)
                        , t = e.map;
                      e.reverseMap.forEach((function(e, i) {
                          t.set(i, e)
                        }
                      )),
                        x = t
                    }
                  }(),
                  x.get(e) || null
                }
                function H(e, t, i, n) {
                  var r = e.length;
                  i = Math.max(0, null == i ? 0 : +i),
                    n = Math.min(r - 1, null == n ? r - 1 : +n);
                  var s = [];
                  return t.paragraphs.forEach((function(r) {
                      var a = Math.max(i, r.start)
                        , o = Math.min(n, r.end);
                      if (a < o) {
                        for (var h = t.levels.slice(a, o + 1), u = o; u >= a && c(e[u]) & l; u--)
                          h[u] = r.level;
                        for (var d = r.level, p = 1 / 0, f = 0; f < h.length; f++) {
                          var m = h[f];
                          m > d && (d = m),
                          m < p && (p = 1 | m)
                        }
                        for (var g = d; g >= p; g--)
                          for (var v = 0; v < h.length; v++)
                            if (h[v] >= g) {
                              for (var y = v; v + 1 < h.length && h[v + 1] >= g; )
                                v++;
                              v > y && s.push([y + i, v + i])
                            }
                      }
                    }
                  )),
                    s
                }
                function W(e, t, i, n) {
                  for (var r = H(e, t, i, n), s = [], a = 0; a < e.length; a++)
                    s[a] = a;
                  return r.forEach((function(e) {
                      for (var t = e[0], i = e[1], n = s.slice(t, i + 1), r = n.length; r--; )
                        s[i - r] = n[r]
                    }
                  )),
                    s
                }
                return e.closingToOpeningBracket = v,
                  e.getBidiCharType = c,
                  e.getBidiCharTypeName = function(e) {
                    return n[c(e)]
                  }
                  ,
                  e.getCanonicalBracket = y,
                  e.getEmbeddingLevels = function(e, t) {
                    for (var i = new Uint32Array(e.length), n = 0; n < e.length; n++)
                      i[n] = c(e[n]);
                    var h = new Map;
                    function u(e, t) {
                      var n = i[e];
                      i[e] = t,
                        h.set(n, h.get(n) - 1),
                      n & a && h.set(a, h.get(a) - 1),
                        h.set(t, (h.get(t) || 0) + 1),
                      t & a && h.set(a, (h.get(a) || 0) + 1)
                    }
                    for (var d = new Uint8Array(e.length), p = new Map, f = [], m = null, x = 0; x < e.length; x++)
                      m || f.push(m = {
                        start: x,
                        end: e.length - 1,
                        level: "rtl" === t ? 1 : "ltr" === t ? 0 : Gt(x, !1)
                      }),
                      i[x] & E && (m.end = x,
                        m = null);
                    for (var V = B | F | k | L | r | G | O | E, H = function(e) {
                      return e + (1 & e ? 1 : 2)
                    }, W = function(e) {
                      return e + (1 & e ? 2 : 1)
                    }, j = 0; j < f.length; j++) {
                      var X = [{
                        _level: (m = f[j]).level,
                        _override: 0,
                        _isolate: 0
                      }]
                        , Y = void 0
                        , q = 0
                        , Q = 0
                        , K = 0;
                      h.clear();
                      for (var J = m.start; J <= m.end; J++) {
                        var Z = i[J];
                        if (Y = X[X.length - 1],
                          h.set(Z, (h.get(Z) || 0) + 1),
                        Z & a && h.set(a, (h.get(a) || 0) + 1),
                        Z & V)
                          if (Z & (B | F)) {
                            d[J] = Y._level;
                            var $ = (Z === B ? W : H)(Y._level);
                            $ <= 125 && !q && !Q ? X.push({
                              _level: $,
                              _override: 0,
                              _isolate: 0
                            }) : q || Q++
                          } else if (Z & (k | L)) {
                            d[J] = Y._level;
                            var ee = (Z === k ? W : H)(Y._level);
                            ee <= 125 && !q && !Q ? X.push({
                              _level: ee,
                              _override: Z & k ? b : _,
                              _isolate: 0
                            }) : q || Q++
                          } else if (Z & r) {
                            Z & U && (Z = 1 === Gt(J + 1, !0) ? z : N),
                              d[J] = Y._level,
                            Y._override && u(J, Y._override);
                            var te = (Z === z ? W : H)(Y._level);
                            te <= 125 && 0 === q && 0 === Q ? (K++,
                              X.push({
                                _level: te,
                                _override: 0,
                                _isolate: 1,
                                _isolInitIndex: J
                              })) : q++
                          } else if (Z & G) {
                            if (q > 0)
                              q--;
                            else if (K > 0) {
                              for (Q = 0; !X[X.length - 1]._isolate; )
                                X.pop();
                              var ie = X[X.length - 1]._isolInitIndex;
                              null != ie && (p.set(ie, J),
                                p.set(J, ie)),
                                X.pop(),
                                K--
                            }
                            Y = X[X.length - 1],
                              d[J] = Y._level,
                            Y._override && u(J, Y._override)
                          } else
                            Z & O ? (0 === q && (Q > 0 ? Q-- : !Y._isolate && X.length > 1 && (X.pop(),
                              Y = X[X.length - 1])),
                              d[J] = Y._level) : Z & E && (d[J] = m.level);
                        else
                          d[J] = Y._level,
                          Y._override && Z !== D && u(J, Y._override)
                      }
                      for (var ne = [], re = null, se = m.start; se <= m.end; se++) {
                        var ae = i[se];
                        if (!(ae & o)) {
                          var oe = d[se]
                            , le = ae & r
                            , he = ae === G;
                          re && oe === re._level ? (re._end = se,
                            re._endsWithIsolInit = le) : ne.push(re = {
                            _start: se,
                            _end: se,
                            _level: oe,
                            _startsWithPDI: he,
                            _endsWithIsolInit: le
                          })
                        }
                      }
                      for (var ce = [], ue = 0; ue < ne.length; ue++) {
                        var de = ne[ue];
                        if (!de._startsWithPDI || de._startsWithPDI && !p.has(de._start)) {
                          for (var pe = [re = de], fe = void 0; re && re._endsWithIsolInit && null != (fe = p.get(re._end)); )
                            for (var me = ue + 1; me < ne.length; me++)
                              if (ne[me]._start === fe) {
                                pe.push(re = ne[me]);
                                break
                              }
                          for (var ge = [], ve = 0; ve < pe.length; ve++)
                            for (var ye = pe[ve], xe = ye._start; xe <= ye._end; xe++)
                              ge.push(xe);
                          for (var _e = d[ge[0]], be = m.level, we = ge[0] - 1; we >= 0; we--)
                            if (!(i[we] & o)) {
                              be = d[we];
                              break
                            }
                          var Ae = ge[ge.length - 1]
                            , Se = d[Ae]
                            , Me = m.level;
                          if (!(i[Ae] & r))
                            for (var Te = Ae + 1; Te <= m.end; Te++)
                              if (!(i[Te] & o)) {
                                Me = d[Te];
                                break
                              }
                          ce.push({
                            _seqIndices: ge,
                            _sosType: Math.max(be, _e) % 2 ? b : _,
                            _eosType: Math.max(Me, Se) % 2 ? b : _
                          })
                        }
                      }
                      for (var Ee = 0; Ee < ce.length; Ee++) {
                        var Ce = ce[Ee]
                          , Pe = Ce._seqIndices
                          , De = Ce._sosType
                          , Ie = Ce._eosType;
                        if (h.get(I))
                          for (var Re = 0; Re < Pe.length; Re++) {
                            var Le = Pe[Re];
                            if (i[Le] & I) {
                              for (var ke = De, Fe = Re - 1; Fe >= 0; Fe--)
                                if (!(i[Pe[Fe]] & o)) {
                                  ke = i[Pe[Fe]];
                                  break
                                }
                              u(Le, ke & (r | G) ? P : ke)
                            }
                          }
                        if (h.get(w))
                          for (var Be = 0; Be < Pe.length; Be++) {
                            var Oe = Pe[Be];
                            if (i[Oe] & w)
                              for (var Ne = Be - 1; Ne >= -1; Ne--) {
                                var ze = -1 === Ne ? De : i[Pe[Ne]];
                                if (ze & s) {
                                  ze === R && u(Oe, M);
                                  break
                                }
                              }
                          }
                        if (h.get(R))
                          for (var Ue = 0; Ue < Pe.length; Ue++) {
                            var Ge = Pe[Ue];
                            i[Ge] & R && u(Ge, b)
                          }
                        if (h.get(A) || h.get(T))
                          for (var Ve = 1; Ve < Pe.length - 1; Ve++) {
                            var He = Pe[Ve];
                            if (i[He] & (A | T)) {
                              for (var We = 0, je = 0, Xe = Ve - 1; Xe >= 0 && (We = i[Pe[Xe]]) & o; Xe--)
                                ;
                              for (var Ye = Ve + 1; Ye < Pe.length && (je = i[Pe[Ye]]) & o; Ye++)
                                ;
                              We === je && (i[He] === A ? We === w : We & (w | M)) && u(He, We)
                            }
                          }
                        if (h.get(w))
                          for (var qe = 0; qe < Pe.length; qe++) {
                            var Qe = Pe[qe];
                            if (i[Qe] & w) {
                              for (var Ke = qe - 1; Ke >= 0 && i[Pe[Ke]] & (S | o); Ke--)
                                u(Pe[Ke], w);
                              for (var Je = qe + 1; Je < Pe.length && i[Pe[Je]] & (S | o); Je++)
                                u(Pe[Je], w)
                            }
                          }
                        if (h.get(S) || h.get(A) || h.get(T))
                          for (var Ze = 0; Ze < Pe.length; Ze++) {
                            var $e = Pe[Ze];
                            if (i[$e] & (S | A | T)) {
                              u($e, P);
                              for (var et = Ze - 1; et >= 0 && i[Pe[et]] & o; et--)
                                u(Pe[et], P);
                              for (var tt = Ze + 1; tt < Pe.length && i[Pe[tt]] & o; tt++)
                                u(Pe[tt], P)
                            }
                          }
                        if (h.get(w))
                          for (var it = 0, nt = De; it < Pe.length; it++) {
                            var rt = Pe[it]
                              , st = i[rt];
                            st & w ? nt === _ && u(rt, _) : st & s && (nt = st)
                          }
                        if (h.get(a)) {
                          for (var at = b | w | M, ot = at | _, lt = [], ht = [], ct = 0; ct < Pe.length; ct++)
                            if (i[Pe[ct]] & a) {
                              var ut = e[Pe[ct]]
                                , dt = void 0;
                              if (null !== g(ut)) {
                                if (!(ht.length < 63))
                                  break;
                                ht.push({
                                  char: ut,
                                  seqIndex: ct
                                })
                              } else if (null !== (dt = v(ut)))
                                for (var pt = ht.length - 1; pt >= 0; pt--) {
                                  var ft = ht[pt].char;
                                  if (ft === dt || ft === v(y(ut)) || g(y(ft)) === ut) {
                                    lt.push([ht[pt].seqIndex, ct]),
                                      ht.length = pt;
                                    break
                                  }
                                }
                            }
                          lt.sort((function(e, t) {
                              return e[0] - t[0]
                            }
                          ));
                          for (var mt = 0; mt < lt.length; mt++) {
                            for (var gt = lt[mt], vt = gt[0], yt = gt[1], xt = !1, _t = 0, bt = vt + 1; bt < yt; bt++) {
                              var wt = Pe[bt];
                              if (i[wt] & ot) {
                                xt = !0;
                                var At = i[wt] & at ? b : _;
                                if (At === Ht(wt)) {
                                  _t = At;
                                  break
                                }
                              }
                            }
                            if (xt && !_t) {
                              _t = De;
                              for (var St = vt - 1; St >= 0; St--) {
                                var Mt = Pe[St];
                                if (i[Mt] & ot) {
                                  var Tt = i[Mt] & at ? b : _;
                                  _t = Tt !== Ht(Mt) ? Tt : Ht(Mt);
                                  break
                                }
                              }
                            }
                            if (_t) {
                              if (i[Pe[vt]] = i[Pe[yt]] = _t,
                              _t !== Ht(Pe[vt]))
                                for (var Et = vt + 1; Et < Pe.length; Et++)
                                  if (!(i[Pe[Et]] & o)) {
                                    c(e[Pe[Et]]) & I && (i[Pe[Et]] = _t);
                                    break
                                  }
                              if (_t !== Ht(Pe[yt]))
                                for (var Ct = yt + 1; Ct < Pe.length; Ct++)
                                  if (!(i[Pe[Ct]] & o)) {
                                    c(e[Pe[Ct]]) & I && (i[Pe[Ct]] = _t);
                                    break
                                  }
                            }
                          }
                          for (var Pt = 0; Pt < Pe.length; Pt++)
                            if (i[Pe[Pt]] & a) {
                              for (var Dt = Pt, It = Pt, Rt = De, Lt = Pt - 1; Lt >= 0; Lt--) {
                                if (!(i[Pe[Lt]] & o)) {
                                  Rt = i[Pe[Lt]] & at ? b : _;
                                  break
                                }
                                Dt = Lt
                              }
                              for (var kt = Ie, Ft = Pt + 1; Ft < Pe.length; Ft++) {
                                if (!(i[Pe[Ft]] & (a | o))) {
                                  kt = i[Pe[Ft]] & at ? b : _;
                                  break
                                }
                                It = Ft
                              }
                              for (var Bt = Dt; Bt <= It; Bt++)
                                i[Pe[Bt]] = Rt === kt ? Rt : Ht(Pe[Bt]);
                              Pt = It
                            }
                        }
                      }
                      for (var Ot = m.start; Ot <= m.end; Ot++) {
                        var Nt = d[Ot]
                          , zt = i[Ot];
                        if (1 & Nt ? zt & (_ | w | M) && d[Ot]++ : zt & b ? d[Ot]++ : zt & (M | w) && (d[Ot] += 2),
                        zt & o && (d[Ot] = 0 === Ot ? m.level : d[Ot - 1]),
                        Ot === m.end || c(e[Ot]) & (C | E))
                          for (var Ut = Ot; Ut >= 0 && c(e[Ut]) & l; Ut--)
                            d[Ut] = m.level
                      }
                    }
                    return {
                      levels: d,
                      paragraphs: f
                    };
                    function Gt(t, n) {
                      for (var s = t; s < e.length; s++) {
                        var a = i[s];
                        if (a & (b | R))
                          return 1;
                        if (a & (E | _) || n && a === G)
                          return 0;
                        if (a & r) {
                          var o = Vt(s);
                          s = -1 === o ? e.length : o
                        }
                      }
                      return 0
                    }
                    function Vt(t) {
                      for (var n = 1, s = t + 1; s < e.length; s++) {
                        var a = i[s];
                        if (a & E)
                          break;
                        if (a & G) {
                          if (0 == --n)
                            return s
                        } else
                          a & r && n++
                      }
                      return -1
                    }
                    function Ht(e) {
                      return 1 & d[e] ? b : _
                    }
                  }
                  ,
                  e.getMirroredCharacter = V,
                  e.getMirroredCharactersMap = function(e, t, i, n) {
                    var r = e.length;
                    i = Math.max(0, null == i ? 0 : +i),
                      n = Math.min(r - 1, null == n ? r - 1 : +n);
                    for (var s = new Map, a = i; a <= n; a++)
                      if (1 & t[a]) {
                        var o = V(e[a]);
                        null !== o && s.set(a, o)
                      }
                    return s
                  }
                  ,
                  e.getReorderSegments = H,
                  e.getReorderedIndices = W,
                  e.getReorderedString = function(e, t, i, n) {
                    var r = W(e, t, i, n)
                      , s = [].concat(e);
                    return r.forEach((function(i, n) {
                        s[n] = (1 & t.levels[i] ? V(e[i]) : null) || e[i]
                      }
                    )),
                      s.join("")
                  }
                  ,
                  e.openingToClosingBracket = g,
                  Object.defineProperty(e, "__esModule", {
                    value: !0
                  }),
                  e
              }({});
              return e
            }
          ],
          init(e, t, i, n) {
            const {defaultFontURL: r} = e;
            return i(t, n(), {
              defaultFontURL: r
            })
          }
        })
          , rm = Sf({
          name: "Typesetter",
          dependencies: [nm, Ef],
          init: (e,t)=>function(i) {
            const n = new t;
            return e.typeset(i, n.resolve),
              n
          }
          ,
          getTransferables(e) {
            const t = [e.glyphPositions.buffer, e.glyphIds.buffer];
            return e.caretPositions && t.push(e.caretPositions.buffer),
            e.glyphColors && t.push(e.glyphColors.buffer),
              t
          }
        })
          , sm = (()=>{
            const e = {}
              , t = "aTroikaGlyphIndex";
            class i extends zu {
              constructor() {
                super(),
                  this.detail = 1,
                  this.curveRadius = 0,
                  this.groups = [{
                    start: 0,
                    count: 1 / 0,
                    materialIndex: 0
                  }, {
                    start: 0,
                    count: 1 / 0,
                    materialIndex: 1
                  }],
                  this.boundingSphere = new As,
                  this.boundingBox = new rs
              }
              computeBoundingSphere() {}
              computeBoundingBox() {}
              setSide(e) {
                const t = this.getIndex().count;
                this.setDrawRange(1 === e ? t / 2 : 0, 2 === e ? t : t / 2)
              }
              set detail(t) {
                if (t !== this._detail) {
                  this._detail = t,
                  ("number" != typeof t || t < 1) && (t = 1);
                  let i = function(t) {
                    let i = e[t];
                    if (!i) {
                      const n = new yo(1,1,t,t)
                        , r = n.clone()
                        , s = n.attributes
                        , a = r.attributes
                        , o = new Ia
                        , l = s.uv.count;
                      for (let e = 0; e < l; e++)
                        a.position.array[3 * e] *= -1,
                          a.normal.array[3 * e + 2] *= -1;
                      ["position", "normal", "uv"].forEach((e=>{
                          o.setAttribute(e, new Aa([...s[e].array, ...a[e].array],s[e].itemSize))
                        }
                      )),
                        o.setIndex([...n.index.array, ...r.index.array.map((e=>e + l))]),
                        o.translate(.5, .5, 0),
                        i = e[t] = o
                    }
                    return i
                  }(t);
                  ["position", "normal", "uv"].forEach((e=>{
                      this.attributes[e] = i.attributes[e].clone()
                    }
                  )),
                    this.setIndex(i.getIndex().clone())
                }
              }
              get detail() {
                return this._detail
              }
              set curveRadius(e) {
                e !== this._curveRadius && (this._curveRadius = e,
                  this._updateBounds())
              }
              get curveRadius() {
                return this._curveRadius
              }
              updateGlyphs(e, i, s, a, o) {
                n(this, "aTroikaGlyphBounds", e, 4),
                  n(this, t, i, 1),
                  n(this, "aTroikaGlyphColor", o, 3),
                  this._blockBounds = s,
                  this._chunkedBounds = a,
                  r(this, i.length),
                  this._updateBounds()
              }
              _updateBounds() {
                const e = this._blockBounds;
                if (e) {
                  const {curveRadius: t, boundingBox: i} = this;
                  if (t) {
                    const {PI: n, floor: r, min: s, max: a, sin: o, cos: l} = Math
                      , h = n / 2
                      , c = 2 * n
                      , u = Math.abs(t)
                      , d = e[0] / u
                      , p = e[2] / u
                      , f = r((d + h) / c) !== r((p + h) / c) ? -u : s(o(d) * u, o(p) * u)
                      , m = r((d - h) / c) !== r((p - h) / c) ? u : a(o(d) * u, o(p) * u)
                      , g = r((d + n) / c) !== r((p + n) / c) ? 2 * u : a(u - l(d) * u, u - l(p) * u);
                    i.min.set(f, e[1], t < 0 ? -g : 0),
                      i.max.set(m, e[3], t < 0 ? 0 : g)
                  } else
                    i.min.set(e[0], e[1], 0),
                      i.max.set(e[2], e[3], 0);
                  i.getBoundingSphere(this.boundingSphere)
                }
              }
              applyClipRect(e) {
                let i = this.getAttribute(t).count
                  , n = this._chunkedBounds;
                if (n)
                  for (let t = n.length; t--; ) {
                    i = n[t].end;
                    let r = n[t].rect;
                    if (r[1] < e.w && r[3] > e.y && r[0] < e.z && r[2] > e.x)
                      break
                  }
                r(this, i)
              }
            }
            function n(e, t, i, n) {
              const r = e.getAttribute(t);
              i ? r && r.array.length === i.length ? (r.array.set(i),
                r.needsUpdate = !0) : (e.setAttribute(t, new hc(i,n)),
                delete e._maxInstanceCount,
                e.dispose()) : r && e.deleteAttribute(t)
            }
            function r(e, t) {
              e[e.hasOwnProperty("instanceCount") ? "instanceCount" : "maxInstancedCount"] = t
            }
            return i.prototype.setAttribute || (i.prototype.setAttribute = function(e, t) {
                return this.attributes[e] = t,
                  this
              }
            ),
              i
          }
        )()
          , am = (()=>{
            const e = new va({
              color: 16777215,
              side: 2,
              transparent: !0
            })
              , t = 8421504
              , i = new Rs
              , n = new ts
              , r = new ts
              , s = []
              , a = new ts
              , o = "+x+y";
            function l(e) {
              return Array.isArray(e) ? e[0] : e
            }
            let h = ()=>{
                const t = new Qa(new yo(1,1),e);
                return h = ()=>t,
                  t
              }
              , c = ()=>{
                const t = new Qa(new yo(1,1,32,1),e);
                return c = ()=>t,
                  t
              }
            ;
            const u = {
              type: "syncstart"
            }
              , d = {
              type: "synccomplete"
            }
              , p = ["font", "fontSize", "letterSpacing", "lineHeight", "maxWidth", "overflowWrap", "text", "direction", "textAlign", "textIndent", "whiteSpace", "anchorX", "anchorY", "colorRanges", "sdfGlyphSize"]
              , f = p.concat("material", "color", "depthOffset", "clipRect", "curveRadius", "orientation", "glyphGeometryDetail");
            class m extends Qa {
              constructor() {
                super(new sm, null),
                  this.text = "",
                  this.anchorX = 0,
                  this.anchorY = 0,
                  this.curveRadius = 0,
                  this.direction = "auto",
                  this.font = null,
                  this.fontSize = .1,
                  this.letterSpacing = 0,
                  this.lineHeight = "normal",
                  this.maxWidth = 1 / 0,
                  this.overflowWrap = "normal",
                  this.textAlign = "left",
                  this.textIndent = 0,
                  this.whiteSpace = "normal",
                  this.material = null,
                  this.color = null,
                  this.colorRanges = null,
                  this.outlineWidth = 0,
                  this.outlineColor = 0,
                  this.outlineOpacity = 1,
                  this.outlineBlur = 0,
                  this.outlineOffsetX = 0,
                  this.outlineOffsetY = 0,
                  this.strokeWidth = 0,
                  this.strokeColor = t,
                  this.strokeOpacity = 1,
                  this.fillOpacity = 1,
                  this.depthOffset = 0,
                  this.clipRect = null,
                  this.orientation = o,
                  this.glyphGeometryDetail = 1,
                  this.sdfGlyphSize = null,
                  this.gpuAccelerateSDF = !0,
                  this.debugSDF = !1
              }
              sync(e) {
                this._needsSync && (this._needsSync = !1,
                  this._isSyncing ? (this._queuedSyncs || (this._queuedSyncs = [])).push(e) : (this._isSyncing = !0,
                    this.dispatchEvent(u),
                    function(e, t) {
                      Jf = !0,
                        e = function(e, t) {
                          for (let i in t)
                            t.hasOwnProperty(i) && (e[i] = t[i]);
                          return e
                        }({}, e);
                      const i = Zf();
                      if (e.font = (n = e.font || Qf.defaultFontURL,
                      tm || (tm = "undefined" == typeof document ? {} : document.createElement("a")),
                        tm.href = n,
                        tm.href),
                        e.text = "" + e.text,
                        e.sdfGlyphSize = e.sdfGlyphSize || Qf.sdfGlyphSize,
                      null != e.colorRanges) {
                        let t = {};
                        for (let i in e.colorRanges)
                          if (e.colorRanges.hasOwnProperty(i)) {
                            let n = e.colorRanges[i];
                            "number" != typeof n && (n = Kf.set(n).getHex()),
                              t[i] = n
                          }
                        e.colorRanges = t
                      }
                      var n;
                      Object.freeze(e);
                      const {textureWidth: r, sdfExponent: s} = Qf
                        , {sdfGlyphSize: a} = e
                        , o = r / a * 4;
                      let l = $f[a];
                      if (!l) {
                        const e = document.createElement("canvas");
                        e.width = r,
                          e.height = 256 * a / o,
                          l = $f[a] = {
                            glyphCount: 0,
                            sdfGlyphSize: a,
                            sdfCanvas: e,
                            sdfTexture: new Kr(e,void 0,void 0,void 0,Hn,Hn),
                            contextLost: !1,
                            glyphsByFont: new Map
                          },
                          l.sdfTexture.generateMipmaps = !1,
                          function(e) {
                            const t = e.sdfCanvas;
                            t.addEventListener("webglcontextlost", (t=>{
                                console.log("Context Lost", t),
                                  t.preventDefault(),
                                  e.contextLost = !0
                              }
                            )),
                              t.addEventListener("webglcontextrestored", (t=>{
                                  console.log("Context Restored", t),
                                    e.contextLost = !1;
                                  const i = [];
                                  e.glyphsByFont.forEach((t=>{
                                      t.forEach((t=>{
                                          i.push(em(t, e, !0))
                                        }
                                      ))
                                    }
                                  )),
                                    mf.all(i).then((()=>{
                                        im(e),
                                          e.sdfTexture.needsUpdate = !0
                                      }
                                    ))
                                }
                              ))
                          }(l)
                      }
                      const {sdfTexture: h, sdfCanvas: c} = l;
                      let u = l.glyphsByFont.get(e.font);
                      u || l.glyphsByFont.set(e.font, u = new Map),
                        rm(e).then((n=>{
                            const {glyphIds: d, glyphPositions: p, fontSize: f, unitsPerEm: m, timings: g} = n
                              , v = []
                              , y = new Float32Array(4 * d.length)
                              , x = f / m;
                            let _ = 0
                              , b = 0;
                            const w = Zf();
                            d.forEach(((e,t)=>{
                                let i = u.get(e);
                                if (!i) {
                                  const {path: t, pathBounds: r} = n.glyphData[e]
                                    , s = Math.max(r[2] - r[0], r[3] - r[1]) / a * (Qf.sdfMargin * a + .5)
                                    , o = l.glyphCount++
                                    , h = [r[0] - s, r[1] - s, r[2] + s, r[3] + s];
                                  u.set(e, i = {
                                    path: t,
                                    atlasIndex: o,
                                    sdfViewBox: h
                                  }),
                                    v.push(i)
                                }
                                const {sdfViewBox: r} = i
                                  , s = p[b++]
                                  , o = p[b++];
                                y[_++] = s + r[0] * x,
                                  y[_++] = o + r[1] * x,
                                  y[_++] = s + r[2] * x,
                                  y[_++] = o + r[3] * x,
                                  d[t] = i.atlasIndex
                              }
                            )),
                              g.quads = (g.quads || 0) + (Zf() - w);
                            const A = Zf();
                            g.sdf = {};
                            const S = c.height
                              , M = Math.ceil(l.glyphCount / o)
                              , T = Math.pow(2, Math.ceil(Math.log2(M * a)));
                            T > S && (console.info(`Increasing SDF texture size ${S}->${T}`),
                              Yf(c, r, T),
                              h.dispose()),
                              mf.all(v.map((t=>em(t, l, e.gpuAccelerateSDF).then((({timing: e})=>{
                                  g.sdf[t.atlasIndex] = e
                                }
                              ))))).then((()=>{
                                  v.length && !l.contextLost && (im(l),
                                    h.needsUpdate = !0),
                                    g.sdfTotal = Zf() - A,
                                    g.total = Zf() - i,
                                    t(Object.freeze({
                                      parameters: e,
                                      sdfTexture: h,
                                      sdfGlyphSize: a,
                                      sdfExponent: s,
                                      glyphBounds: y,
                                      glyphAtlasIndices: d,
                                      glyphColors: n.glyphColors,
                                      caretPositions: n.caretPositions,
                                      caretHeight: n.caretHeight,
                                      chunkedBounds: n.chunkedBounds,
                                      ascender: n.ascender,
                                      descender: n.descender,
                                      lineHeight: n.lineHeight,
                                      topBaseline: n.topBaseline,
                                      blockBounds: n.blockBounds,
                                      visibleBounds: n.visibleBounds,
                                      timings: n.timings,
                                      get totalBounds() {
                                        return console.log("totalBounds deprecated, use blockBounds instead"),
                                          n.blockBounds
                                      },
                                      get totalBlockSize() {
                                        console.log("totalBlockSize deprecated, use blockBounds instead");
                                        const [e,t,i,r] = n.blockBounds;
                                        return [i - e, r - t]
                                      }
                                    }))
                                }
                              ))
                          }
                        )),
                        mf.all([]).then((()=>{
                            var e;
                            l.contextLost || (e = c)._warm || (Hf.webgl.isSupported(e),
                              e._warm = !0)
                          }
                        ))
                    }({
                      text: this.text,
                      font: this.font,
                      fontSize: this.fontSize || .1,
                      letterSpacing: this.letterSpacing || 0,
                      lineHeight: this.lineHeight || "normal",
                      maxWidth: this.maxWidth,
                      direction: this.direction || "auto",
                      textAlign: this.textAlign,
                      textIndent: this.textIndent,
                      whiteSpace: this.whiteSpace,
                      overflowWrap: this.overflowWrap,
                      anchorX: this.anchorX,
                      anchorY: this.anchorY,
                      colorRanges: this.colorRanges,
                      includeCaretPositions: !0,
                      sdfGlyphSize: this.sdfGlyphSize,
                      gpuAccelerateSDF: this.gpuAccelerateSDF
                    }, (t=>{
                        this._isSyncing = !1,
                          this._textRenderInfo = t,
                          this.geometry.updateGlyphs(t.glyphBounds, t.glyphAtlasIndices, t.blockBounds, t.chunkedBounds, t.glyphColors);
                        const i = this._queuedSyncs;
                        i && (this._queuedSyncs = null,
                          this._needsSync = !0,
                          this.sync((()=>{
                              i.forEach((e=>e && e()))
                            }
                          ))),
                          this.dispatchEvent(d),
                        e && e()
                      }
                    ))))
              }
              onBeforeRender(e, t, i, n, r, s) {
                this.sync(),
                r.isTroikaTextMaterial && this._prepareForRender(r),
                  r._hadOwnSide = r.hasOwnProperty("side"),
                  this.geometry.setSide(r._actualSide = r.side),
                  r.side = 0
              }
              onAfterRender(e, t, i, n, r, s) {
                r._hadOwnSide ? r.side = r._actualSide : delete r.side
              }
              dispose() {
                this.geometry.dispose()
              }
              get textRenderInfo() {
                return this._textRenderInfo || null
              }
              get material() {
                let t = this._derivedMaterial;
                const i = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = e.clone());
                if (t && t.baseMaterial === i || (t = this._derivedMaterial = function(e) {
                  const t = Of(e, {
                    chained: !0,
                    extensions: {
                      derivatives: !0
                    },
                    uniforms: {
                      uTroikaSDFTexture: {
                        value: null
                      },
                      uTroikaSDFTextureSize: {
                        value: new Dr
                      },
                      uTroikaSDFGlyphSize: {
                        value: 0
                      },
                      uTroikaSDFExponent: {
                        value: 0
                      },
                      uTroikaTotalBounds: {
                        value: new Jr(0,0,0,0)
                      },
                      uTroikaClipRect: {
                        value: new Jr(0,0,0,0)
                      },
                      uTroikaDistanceOffset: {
                        value: 0
                      },
                      uTroikaOutlineOpacity: {
                        value: 0
                      },
                      uTroikaFillOpacity: {
                        value: 1
                      },
                      uTroikaPositionOffset: {
                        value: new Dr
                      },
                      uTroikaCurveRadius: {
                        value: 0
                      },
                      uTroikaBlurRadius: {
                        value: 0
                      },
                      uTroikaStrokeWidth: {
                        value: 0
                      },
                      uTroikaStrokeColor: {
                        value: new Wr
                      },
                      uTroikaStrokeOpacity: {
                        value: 1
                      },
                      uTroikaOrient: {
                        value: new Ir
                      },
                      uTroikaUseGlyphColors: {
                        value: !0
                      },
                      uTroikaSDFDebug: {
                        value: !1
                      }
                    },
                    vertexDefs: "\nuniform vec2 uTroikaSDFTextureSize;\nuniform float uTroikaSDFGlyphSize;\nuniform vec4 uTroikaTotalBounds;\nuniform vec4 uTroikaClipRect;\nuniform mat3 uTroikaOrient;\nuniform bool uTroikaUseGlyphColors;\nuniform float uTroikaDistanceOffset;\nuniform float uTroikaBlurRadius;\nuniform vec2 uTroikaPositionOffset;\nuniform float uTroikaCurveRadius;\nattribute vec4 aTroikaGlyphBounds;\nattribute float aTroikaGlyphIndex;\nattribute vec3 aTroikaGlyphColor;\nvarying vec2 vTroikaGlyphUV;\nvarying vec4 vTroikaTextureUVBounds;\nvarying float vTroikaTextureChannel;\nvarying vec3 vTroikaGlyphColor;\nvarying vec2 vTroikaGlyphDimensions;\n",
                    vertexTransform: "\nvec4 bounds = aTroikaGlyphBounds;\nbounds.xz += uTroikaPositionOffset.x;\nbounds.yw -= uTroikaPositionOffset.y;\n\nvec4 outlineBounds = vec4(\n  bounds.xy - uTroikaDistanceOffset - uTroikaBlurRadius,\n  bounds.zw + uTroikaDistanceOffset + uTroikaBlurRadius\n);\nvec4 clippedBounds = vec4(\n  clamp(outlineBounds.xy, uTroikaClipRect.xy, uTroikaClipRect.zw),\n  clamp(outlineBounds.zw, uTroikaClipRect.xy, uTroikaClipRect.zw)\n);\n\nvec2 clippedXY = (mix(clippedBounds.xy, clippedBounds.zw, position.xy) - bounds.xy) / (bounds.zw - bounds.xy);\n\nposition.xy = mix(bounds.xy, bounds.zw, clippedXY);\n\nuv = (position.xy - uTroikaTotalBounds.xy) / (uTroikaTotalBounds.zw - uTroikaTotalBounds.xy);\n\nfloat rad = uTroikaCurveRadius;\nif (rad != 0.0) {\n  float angle = position.x / rad;\n  position.xz = vec2(sin(angle) * rad, rad - cos(angle) * rad);\n  normal.xz = vec2(sin(angle), cos(angle));\n}\n  \nposition = uTroikaOrient * position;\nnormal = uTroikaOrient * normal;\n\nvTroikaGlyphUV = clippedXY.xy;\nvTroikaGlyphDimensions = vec2(bounds[2] - bounds[0], bounds[3] - bounds[1]);\n\n\nfloat txCols = uTroikaSDFTextureSize.x / uTroikaSDFGlyphSize;\nvec2 txUvPerSquare = uTroikaSDFGlyphSize / uTroikaSDFTextureSize;\nvec2 txStartUV = txUvPerSquare * vec2(\n  mod(floor(aTroikaGlyphIndex / 4.0), txCols),\n  floor(floor(aTroikaGlyphIndex / 4.0) / txCols)\n);\nvTroikaTextureUVBounds = vec4(txStartUV, vec2(txStartUV) + txUvPerSquare);\nvTroikaTextureChannel = mod(aTroikaGlyphIndex, 4.0);\n",
                    fragmentDefs: "\nuniform sampler2D uTroikaSDFTexture;\nuniform vec2 uTroikaSDFTextureSize;\nuniform float uTroikaSDFGlyphSize;\nuniform float uTroikaSDFExponent;\nuniform float uTroikaDistanceOffset;\nuniform float uTroikaFillOpacity;\nuniform float uTroikaOutlineOpacity;\nuniform float uTroikaBlurRadius;\nuniform vec3 uTroikaStrokeColor;\nuniform float uTroikaStrokeWidth;\nuniform float uTroikaStrokeOpacity;\nuniform bool uTroikaSDFDebug;\nvarying vec2 vTroikaGlyphUV;\nvarying vec4 vTroikaTextureUVBounds;\nvarying float vTroikaTextureChannel;\nvarying vec2 vTroikaGlyphDimensions;\n\nfloat troikaSdfValueToSignedDistance(float alpha) {\n  // Inverse of exponential encoding in webgl-sdf-generator\n  \n  float maxDimension = max(vTroikaGlyphDimensions.x, vTroikaGlyphDimensions.y);\n  float absDist = (1.0 - pow(2.0 * (alpha > 0.5 ? 1.0 - alpha : alpha), 1.0 / uTroikaSDFExponent)) * maxDimension;\n  float signedDist = absDist * (alpha > 0.5 ? -1.0 : 1.0);\n  return signedDist;\n}\n\nfloat troikaGlyphUvToSdfValue(vec2 glyphUV) {\n  vec2 textureUV = mix(vTroikaTextureUVBounds.xy, vTroikaTextureUVBounds.zw, glyphUV);\n  vec4 rgba = texture2D(uTroikaSDFTexture, textureUV);\n  float ch = floor(vTroikaTextureChannel + 0.5); //NOTE: can't use round() in WebGL1\n  return ch == 0.0 ? rgba.r : ch == 1.0 ? rgba.g : ch == 2.0 ? rgba.b : rgba.a;\n}\n\nfloat troikaGlyphUvToDistance(vec2 uv) {\n  return troikaSdfValueToSignedDistance(troikaGlyphUvToSdfValue(uv));\n}\n\nfloat troikaGetAADist() {\n  \n  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300\n  return length(fwidth(vTroikaGlyphUV * vTroikaGlyphDimensions)) * 0.5;\n  #else\n  return vTroikaGlyphDimensions.x / 64.0;\n  #endif\n}\n\nfloat troikaGetFragDistValue() {\n  vec2 clampedGlyphUV = clamp(vTroikaGlyphUV, 0.5 / uTroikaSDFGlyphSize, 1.0 - 0.5 / uTroikaSDFGlyphSize);\n  float distance = troikaGlyphUvToDistance(clampedGlyphUV);\n \n  // Extrapolate distance when outside bounds:\n  distance += clampedGlyphUV == vTroikaGlyphUV ? 0.0 : \n    length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);\n\n  \n\n  return distance;\n}\n\nfloat troikaGetEdgeAlpha(float distance, float distanceOffset, float aaDist) {\n  #if defined(IS_DEPTH_MATERIAL) || defined(IS_DISTANCE_MATERIAL)\n  float alpha = step(-distanceOffset, -distance);\n  #else\n\n  float alpha = smoothstep(\n    distanceOffset + aaDist,\n    distanceOffset - aaDist,\n    distance\n  );\n  #endif\n\n  return alpha;\n}\n",
                    fragmentColorTransform: "\nfloat aaDist = troikaGetAADist();\nfloat fragDistance = troikaGetFragDistValue();\nfloat edgeAlpha = uTroikaSDFDebug ?\n  troikaGlyphUvToSdfValue(vTroikaGlyphUV) :\n  troikaGetEdgeAlpha(fragDistance, uTroikaDistanceOffset, max(aaDist, uTroikaBlurRadius));\n\n#if !defined(IS_DEPTH_MATERIAL) && !defined(IS_DISTANCE_MATERIAL)\nvec4 fillRGBA = gl_FragColor;\nfillRGBA.a *= uTroikaFillOpacity;\nvec4 strokeRGBA = uTroikaStrokeWidth == 0.0 ? fillRGBA : vec4(uTroikaStrokeColor, uTroikaStrokeOpacity);\nif (fillRGBA.a == 0.0) fillRGBA.rgb = strokeRGBA.rgb;\ngl_FragColor = mix(fillRGBA, strokeRGBA, smoothstep(\n  -uTroikaStrokeWidth - aaDist,\n  -uTroikaStrokeWidth + aaDist,\n  fragDistance\n));\ngl_FragColor.a *= edgeAlpha;\n#endif\n\nif (edgeAlpha == 0.0) {\n  discard;\n}\n",
                    customRewriter({vertexShader: e, fragmentShader: t}) {
                      let i = /\buniform\s+vec3\s+diffuse\b/;
                      return i.test(t) && (t = t.replace(i, "varying vec3 vTroikaGlyphColor").replace(/\bdiffuse\b/g, "vTroikaGlyphColor"),
                      i.test(e) || (e = e.replace(Pf, "uniform vec3 diffuse;\n$&\nvTroikaGlyphColor = uTroikaUseGlyphColors ? aTroikaGlyphColor / 255.0 : diffuse;\n"))),
                        {
                          vertexShader: e,
                          fragmentShader: t
                        }
                    }
                  });
                  return t.transparent = !0,
                    Object.defineProperties(t, {
                      isTroikaTextMaterial: {
                        value: !0
                      },
                      shadowSide: {
                        get() {
                          return this.side
                        },
                        set() {}
                      }
                    }),
                    t
                }(i),
                  i.addEventListener("dispose", (function e() {
                      i.removeEventListener("dispose", e),
                        t.dispose()
                    }
                  ))),
                this.outlineWidth || this.outlineBlur || this.outlineOffsetX || this.outlineOffsetY) {
                  let e = t._outlineMtl;
                  return e || (e = t._outlineMtl = Object.create(t, {
                    id: {
                      value: t.id + .1
                    }
                  }),
                    e.isTextOutlineMaterial = !0,
                    e.depthWrite = !1,
                    e.map = null,
                    t.addEventListener("dispose", (function i() {
                        t.removeEventListener("dispose", i),
                          e.dispose()
                      }
                    ))),
                    [e, t]
                }
                return t
              }
              set material(e) {
                e && e.isTroikaTextMaterial ? (this._derivedMaterial = e,
                  this._baseMaterial = e.baseMaterial) : this._baseMaterial = e
              }
              get glyphGeometryDetail() {
                return this.geometry.detail
              }
              set glyphGeometryDetail(e) {
                this.geometry.detail = e
              }
              get curveRadius() {
                return this.geometry.curveRadius
              }
              set curveRadius(e) {
                this.geometry.curveRadius = e
              }
              get customDepthMaterial() {
                return l(this.material).getDepthMaterial()
              }
              get customDistanceMaterial() {
                return l(this.material).getDistanceMaterial()
              }
              _prepareForRender(e) {
                const s = e.isTextOutlineMaterial
                  , l = e.uniforms
                  , h = this.textRenderInfo;
                if (h) {
                  const {sdfTexture: e, blockBounds: i} = h;
                  l.uTroikaSDFTexture.value = e,
                    l.uTroikaSDFTextureSize.value.set(e.image.width, e.image.height),
                    l.uTroikaSDFGlyphSize.value = h.sdfGlyphSize,
                    l.uTroikaSDFExponent.value = h.sdfExponent,
                    l.uTroikaTotalBounds.value.fromArray(i),
                    l.uTroikaUseGlyphColors.value = !s && !!h.glyphColors;
                  let n, r, a, o = 0, c = 0, u = 0, d = 0, p = 0;
                  if (s) {
                    let {outlineWidth: e, outlineOffsetX: t, outlineOffsetY: i, outlineBlur: r, outlineOpacity: s} = this;
                    o = this._parsePercent(e) || 0,
                      c = Math.max(0, this._parsePercent(r) || 0),
                      n = s,
                      d = this._parsePercent(t) || 0,
                      p = this._parsePercent(i) || 0
                  } else
                    u = Math.max(0, this._parsePercent(this.strokeWidth) || 0),
                    u && (a = this.strokeColor,
                      l.uTroikaStrokeColor.value.set(null == a ? t : a),
                      r = this.strokeOpacity,
                    null == r && (r = 1)),
                      n = this.fillOpacity;
                  l.uTroikaDistanceOffset.value = o,
                    l.uTroikaPositionOffset.value.set(d, p),
                    l.uTroikaBlurRadius.value = c,
                    l.uTroikaStrokeWidth.value = u,
                    l.uTroikaStrokeOpacity.value = r,
                    l.uTroikaFillOpacity.value = null == n ? 1 : n,
                    l.uTroikaCurveRadius.value = this.curveRadius || 0;
                  let f = this.clipRect;
                  if (f && Array.isArray(f) && 4 === f.length)
                    l.uTroikaClipRect.value.fromArray(f);
                  else {
                    const e = 100 * (this.fontSize || .1);
                    l.uTroikaClipRect.value.set(i[0] - e, i[1] - e, i[2] + e, i[3] + e)
                  }
                  this.geometry.applyClipRect(l.uTroikaClipRect.value)
                }
                l.uTroikaSDFDebug.value = !!this.debugSDF,
                  e.polygonOffset = !!this.depthOffset,
                  e.polygonOffsetFactor = e.polygonOffsetUnits = this.depthOffset || 0;
                const c = s ? this.outlineColor || 0 : this.color;
                if (null == c)
                  delete e.color;
                else {
                  const t = e.hasOwnProperty("color") ? e.color : e.color = new Wr;
                  c === t._input && "object" != typeof c || t.set(t._input = c)
                }
                let u = this.orientation || o;
                if (u !== e._orientation) {
                  let t = l.uTroikaOrient.value;
                  u = u.replace(/[^-+xyz]/g, "");
                  let s = u !== o && u.match(/^([-+])([xyz])([-+])([xyz])$/);
                  if (s) {
                    let[,e,o,l,h] = s;
                    n.set(0, 0, 0)[o] = "-" === e ? 1 : -1,
                      r.set(0, 0, 0)[h] = "-" === l ? -1 : 1,
                      i.lookAt(a, n.cross(r), r),
                      t.setFromMatrix4(i)
                  } else
                    t.identity();
                  e._orientation = u
                }
              }
              _parsePercent(e) {
                if ("string" == typeof e) {
                  let t = e.match(/^(-?[\d.]+)%$/)
                    , i = t ? parseFloat(t[1]) : NaN;
                  e = (isNaN(i) ? 0 : i / 100) * this.fontSize
                }
                return e
              }
              localPositionToTextCoords(e, t=new Dr) {
                t.copy(e);
                const i = this.curveRadius;
                return i && (t.x = Math.atan2(e.x, Math.abs(i) - Math.abs(e.z)) * Math.abs(i)),
                  t
              }
              worldPositionToTextCoords(e, t=new Dr) {
                return n.copy(e),
                  this.localPositionToTextCoords(this.worldToLocal(n), t)
              }
              raycast(e, t) {
                const {textRenderInfo: i, curveRadius: n} = this;
                if (i) {
                  const r = i.blockBounds
                    , a = n ? c() : h()
                    , o = a.geometry
                    , {position: l, uv: u} = o.attributes;
                  for (let e = 0; e < u.count; e++) {
                    let t = r[0] + u.getX(e) * (r[2] - r[0]);
                    const i = r[1] + u.getY(e) * (r[3] - r[1]);
                    let s = 0;
                    n && (s = n - Math.cos(t / n) * n,
                      t = Math.sin(t / n) * n),
                      l.setXYZ(e, t, i, s)
                  }
                  o.boundingSphere = this.geometry.boundingSphere,
                    o.boundingBox = this.geometry.boundingBox,
                    a.matrixWorld = this.matrixWorld,
                    a.material.side = this.material.side,
                    s.length = 0,
                    a.raycast(e, s);
                  for (let e = 0; e < s.length; e++)
                    s[e].object = this,
                      t.push(s[e])
                }
              }
              copy(e) {
                const t = this.geometry;
                return super.copy(e),
                  this.geometry = t,
                  f.forEach((t=>{
                      this[t] = e[t]
                    }
                  )),
                  this
              }
              clone() {
                return (new this.constructor).copy(this)
              }
            }
            p.forEach((e=>{
                const t = "_private_" + e;
                Object.defineProperty(m.prototype, e, {
                  get() {
                    return this[t]
                  },
                  set(e) {
                    e !== this[t] && (this[t] = e,
                      this._needsSync = !0)
                  }
                })
              }
            ));
            let g = !1;
            return Object.defineProperty(m.prototype, "anchor", {
              get() {
                return this._deprecated_anchor
              },
              set(e) {
                this._deprecated_anchor = e,
                g || (console.warn("TextMesh: `anchor` has been deprecated; use `anchorX` and `anchorY` instead."),
                  g = !0),
                  Array.isArray(e) ? (this.anchorX = 100 * (+e[0] || 0) + "%",
                    this.anchorY = 100 * (+e[1] || 0) + "%") : this.anchorX = this.anchorY = 0
              }
            }),
              m
          }
        )();
        new WeakMap,
          new WeakMap;
        const om = [{
          lightGroundColor: new Wr("rgb(8, 37, 198)"),
          fogColor: new Wr("rgb(159, 181, 205)"),
          progress: .1,
          text: {
            automatic: !1,
            body: "2019年 7月20号的初次相遇",
            bodyMaxWidth: 3.2,
            bodyFontSize: .3,
            position: new ts(1,2.8,0),
            align: "left"
          }
        }, {
          lightGroundColor: new Wr("rgb(8, 37, 198)"),
          fogColor: new Wr("rgb(159, 181, 205)"),
          progress: .2,
          text: {
            position: new ts(1,1,0),
            align: "left"
          }
        }, {
          lightGroundColor: new Wr("rgb(116, 136, 234)"),
          fogColor: new Wr("rgb(159, 181, 205)"),
          progress: .3,
          text: {
            position: new ts(1,1,0),
            align: "left"
          }
        }, {
          lightGroundColor: new Wr("rgb(255, 192, 148)"),
          fogColor: new Wr("rgb(191, 150, 140)"),
          progress: .4,
          text: {
            position: new ts(-1,1,0),
            align: "right"
          }
        }, {
          lightGroundColor: new Wr("rgb(136, 162, 247)"),
          fogColor: new Wr("rgb(140, 190, 150)"),
          progress: .5,
          text: {
            position: new ts(1,1,0),
            align: "left"
          }
        }, {
          lightGroundColor: new Wr("rgb(136, 162, 247)"),
          fogColor: new Wr("rgb(140, 190, 150)"),
          progress: .6,
          text: {
            position: new ts(-1,1,0),
            align: "right"
          }
        }, {
          lightGroundColor: new Wr("rgb(253, 175, 120)"),
          fogColor: new Wr("rgb(140, 190, 150)"),
          progress: .7,
          text: {
            position: new ts(1,1,0),
            align: "left"
          }
        }, {
          lightGroundColor: new Wr("rgb(253, 175, 120)"),
          fogColor: new Wr("rgb(140, 190, 150)"),
          progress: .8,
          text: {
            position: new ts(-.5,1,0),
            align: "right"
          }
        }, {
          lightGroundColor: new Wr("rgb(90, 108, 216)"),
          fogColor: new Wr("rgb(90, 108, 216)"),
          progress: .9,
          text: {
            position: new ts(1,1,0),
            align: "left"
          }
        }, {
          lightGroundColor: new Wr("rgb(90, 108, 216)"),
          fogColor: new Wr("rgb(90, 108, 216)"),
          progress: 1
        }]
          , lm = [{
          sup: "Fact #01",
          title: "SKY BABIES",
          body: "Apart from a crash, the worst nightmare of every flight attendant is childbirth on board. Although extremely rare, nearly 60 babies were born in the sky!",
          source: "https://www.cntraveller.in/story/explained-happens-baby-born-airplane/"
        }, {
          sup: "Fact #02",
          title: "A LONG FLIGHT",
          body: "The longest commercial flight you can book is a flight from Singapore to New York that lasts 18 hours 50 minutes... better get comfortable!",
          source: "https://upgradedpoints.com/travel/airlines/longest-nonstop-flights-in-the-world/"
        }, {
          sup: "Fact #03123",
          title: "哈哈哈哈47 SECONDS34retrty546",
          body: "Not a fan of airtime? The shortest flight available takes place in Scotland. It connects Westray to Papa Westray and takes 47 seconds!",
          source: "https://www.amusingplanet.com/2013/08/worlds-shortest-commercial-flight-is.html"
        }, {
          sup: "Fact #04",
          title: "FORBIDDEN NUMBER",
          body: "Since the number 13 is considered an unlucky number in Western culture, most airlines don't have a row 13 on their planes!",
          source: "https://simpleflying.com/row-13-on-planes/#:~:text=Dropping%20row%2013,based%20on%20a%20superstitious%20belief."
        }, {
          sup: "Fact #05",
          title: "NOWHERE TO GO",
          titleMaxWidth: 3,
          body: "As a result of the pandemic, some companies started offering ‘flights to nowhere’. Although the destination was the same as the departure, it seemed to have been a commercial success!",
          source: "https://www.nytimes.com/2020/09/19/travel/airlines-pandemic-flights-to-nowhere.html"
        }, {
          sup: "Fact #06",
          title: "FLIGHT TO HEL",
          titleMaxWidth: 2.25,
          body: "In 2017, on a Friday the 13th, Flight 666 to HEL took off for the last time, before being renumbered.",
          source: "https://www.washingtonpost.com/news/acts-of-faith/wp/2017/10/13/flight-666-to-hel-took-off-one-last-time-this-friday-the-13th/"
        }, {
          sup: "Fact #07",
          title: "DRIED OUT",
          body: "The pressurised air in the flight cabin is kept below 20% humidity, which is about the average humidity of the Sahara desert!",
          source: "https://blueskypit.com/2019/05/24/drier-than-the-desert-tips-to-stay-hydrated-on-your-flight/"
        }, {
          sup: "Fact #08",
          title: "PILOTS' MEALS",
          body: "In most airlines, pilots and co-pilots are required to eat different meals in case of food poisoning!",
          source: "https://www.foodandwine.com/travel/surprising-reason-airplane-pilots-and-co-pilots-eat-different-meals#:~:text=A%20report%20in%20the%20Independent,food%20poisoning%20affecting%20the%20flight.%22"
        }, {
          sup: "Fact #09",
          title: "LUCKY FEW",
          body: "It is estimated that only around 5% of the world’s population gets boards on a plane each year.",
          source: "https://www.smithsonianmag.com/air-space-magazine/how-much-worlds-population-has-flown-airplane-180957719/"
        }, {
          sup: "Fact #10",
          title: "TASTE BUDS",
          body: "Your taste buds become 30% less sensitive while flying. But not every flavor is affected equally!",
          source: "https://www.businessinsider.com/airplane-food-tastes-different-explained-2020-1#:~:text=A%202010%20study%20tested%20people's,30%25%20while%20in%20the%20cabin."
        }, {
          sup: "Fact #11",
          title: "MAYDAY MAYDAY",
          body: '"MAYDAY" was made official as an international distress call in 1948. It is derived from the French word "m’aidez", which means "help me"!',
          source: "https://www.merriam-webster.com/words-at-play/mayday-meaning-origin"
        }, {
          sup: "Fact #12",
          title: "OLD BONES",
          body: "The average age of commercial aircraft is 20 years. They are usually retired at around 30 years of age.",
          source: "https://www.thehindubusinessline.com/specials/flight-plan/what-commercial-airlines-can-do-to-extend-the-longevity-of-their-fleet/article34805181.ece"
        }, {
          sup: "Fact #13",
          title: "FAST AS LIGHTNING",
          body: "From 1976 to 2003, the Concorde flew at twice the speed of sound, connecting NYC to London in 2 hours and 52 minutes!",
          source: "https://simpleflying.com/concorde-new-york-to-london-time/"
        }, {
          sup: "Fact #14",
          title: "IN THE DARK",
          body: "At night, lights on board are dimmed for landing and takeoff so that in the event of an emergency, passengers' eyes will already be adjusted to darkness.",
          source: "https://www.cntraveler.com/story/the-real-reason-planes-dim-the-lights-during-takeoff-and-landing"
        }, {
          sup: "Fact #15123123",
          title: "RAISE YOUR SHADE",
          titleMaxWidth: 3.5,
          body: "On landing and take-off, attendants ask you to raise your shade so they can see outside and decide which side of the aircraft is the safest if an evacuation was needed!",
          source: "https://www.cntraveler.com/story/why-do-airlines-ask-you-to-raise-window-shades-during-takeoff#:~:text=%E2%80%9CFrom%20a%20safety%20standpoint%2C%20open,and%20use%20an%20emergency%20exit."
        }];
        function hm() {
          let e = lm.map(((e, i)=>({
            value: e,
            sort: i
          }))).sort(((e,t)=>e.sort - t.sort)).map((({value: e})=>e));
          this.texts = [],
            this.updateTextsAlpha = !0;
          for (let t = 0; t < om.length; t++) {
            const i = om[t].text;
            if (!i)
              continue;
            !1 !== i.automatic && (i.sup = e[t].sup,
              i.title = e[t].title,
              i.body = e[t].body,
              i.bodyMaxWidth = e[t].bodyMaxWidth,
              i.titleMaxWidth = e[t].titleMaxWidth),
              i.pre_position = new ts;
            const n = new Gh;
            let r, s, a;
            if (i.title && (r = new am,
              n.add(r)),
            i.body && (a = new am,
              n.add(a)),
            i.sup && (s = new am,
              n.add(s)),
              this.scene.add(n),
            !i.progress && om[t].progress && (i.progress = om[t].progress),
              i.progress) {
              let e = new ts;
              this.curveMesh.geometry.parameters.path.getPointAt(i.progress, n.position),
                this.curveMesh.geometry.parameters.path.getPointAt(i.progress - .015, i.pre_position),
                this.curveMesh.geometry.parameters.path.getPointAt(Math.max(0, i.progress - .01 * this.curve_size_factor), e),
              i.position && (n.position.add(i.position),
                i.pre_position.add(i.position)),
                e.y = n.position.y,
                n.lookAt(e)
            } else
              i.position && n.position.copy(i.position);
            i.rotation && n.rotation.copy(i.rotation),
            r && (r.text = i.title,
              r.fontSize = .5,
              r.position.y -= .055,
              r.color = 16777215,
              r.textAlign = i.align || "left",
              r.anchorX = r.textAlign,
              r.maxWidth = i.titleMaxWidth || 2.5,
              r.lineHeight = 1.05,
              r.font = __webpack_require__(145),
              r.sdfGlyphSize = 128),
            s && (s.text = i.sup,
              s.fontSize = .18,
              s.position.y += .25,
              s.color = 16777215,
              s.textAlign = i.align || "left",
              s.anchorX = s.textAlign,
              s.font = __webpack_require__(314)),
            a && (a.text = i.body,
              a.fontSize = i.bodyFontSize || .18,
              a.position.y -= 1.2,
              a.color = 16777215,
              a.textAlign = i.align || "left",
              a.anchorX = a.textAlign,
              a.maxWidth = i.bodyMaxWidth || 3,
              a.font = __webpack_require__(314)),
              _n.ticker.add((()=>{
                  if (!this.updateTextsAlpha)
                    return;
                  let e = Pr.clamp(1 - n.position.distanceTo(this.camera.position) / 30, 0, 1);
                  e = 2 * Math.pow(e, 2),
                  r && (r.material.opacity = e),
                  a && (a.material.opacity = e),
                  s && (s.material.opacity = e)
                }
              )),
            r && r.sync(),
            s && s.sync(),
            a && a.sync(),
              i.group_position = n.position,
              this.texts.push(i)
          }
          this.onLeave((()=>{
              this.updateTextsAlpha = !1
            }
          )),
            this.onEnter((()=>{
                this.updateTextsAlpha = !0
              }
            ))
        }
        const cm = [{
          type: 1,
          progress: .053,
          position: new ts(-7,-6,0),
          scale: new ts(-3.5,3.5,-3.5)
        }, {
          type: 2,
          progress: .05,
          position: new ts(-15,0,0),
          scale: new ts(-2.5,2.5,2.5)
        }, {
          type: 2,
          progress: .08,
          position: new ts(8,6,0),
          scale: new ts(-2,2,-2)
        }, {
          type: 1,
          progress: .09,
          position: new ts(8,-6,0),
          scale: new ts(2.5,2.5,-2.5)
        }, {
          type: 2,
          progress: .13,
          position: new ts(8,6,0),
          scale: new ts(2.5,2.5,-2.5)
        }, {
          type: 1,
          progress: .185,
          position: new ts(-9,6,0),
          scale: new ts(1.8,1.8,1.8)
        }, {
          type: 2,
          progress: .2,
          position: new ts(8,6,0),
          scale: new ts(2,2,2)
        }, {
          type: 1,
          progress: .24,
          position: new ts(8,0,0),
          scale: new ts(2,2,2)
        }, {
          type: 1,
          progress: .32,
          position: new ts(-5,0,0),
          scale: new ts(1.5,1.5,1.5)
        }, {
          type: 1,
          progress: .32,
          position: new ts(-5,0,0),
          scale: new ts(1.5,1.5,1.5)
        }, {
          type: 1,
          progress: .35,
          position: new ts(-5,2,0),
          scale: new ts(-.5,.5,.5)
        }, {
          type: 2,
          progress: .36,
          position: new ts(5,-1,0),
          scale: new ts(-.5,.5,.5)
        }, {
          type: 2,
          progress: .41,
          position: new ts(9,-9,0),
          scale: new ts(3,3,3)
        }, {
          type: 2,
          progress: .42,
          position: new ts(-9,-9,0),
          scale: new ts(3,3,3)
        }, {
          type: 2,
          progress: .43,
          position: new ts(-9,7,0),
          scale: new ts(3,3,3)
        }, {
          type: 2,
          progress: .57,
          position: new ts(9,0,0),
          scale: new ts(2,2,2)
        }, {
          type: 2,
          progress: .7,
          position: new ts(3.5,2,0),
          scale: new ts(.4,.4,.4)
        }, {
          type: 1,
          progress: .72,
          position: new ts(2,0,0),
          scale: new ts(.4,.4,.4)
        }]
          , um = [{
          type: 1,
          progress: .034,
          position: new ts(5.5,-4.6,0),
          scale: new ts(3,3,3)
        }, {
          type: 1,
          progress: .037,
          position: new ts(10.7,1,0),
          scale: new ts(2,2,2)
        }, {
          type: 1,
          progress: .1,
          position: new ts(-.5,-3,0),
          rotation: new Vs(0,1 * Math.PI,0)
        }, {
          type: 1,
          progress: .12,
          position: new ts(-4,-1,0),
          scale: new ts(1.3,1.3,1.3)
        }, {
          type: 2,
          progress: .16,
          position: new ts(3.5,-1,0),
          scale: new ts(1,1,1)
        }, {
          type: 1,
          progress: .18,
          position: new ts(-3,-1,0)
        }, {
          type: 2,
          progress: .22,
          position: new ts(-4.5,1.5,0),
          scale: new ts(-1,1,1)
        }, {
          type: 1,
          progress: .25,
          position: new ts(0,-3,0),
          rotation: new Vs(0,1 * Math.PI,0),
          scale: new ts(-1,1,1)
        }, {
          type: 2,
          progress: .28,
          position: new ts(-4,1.5,0),
          scale: new ts(-1,1,1)
        }, {
          type: 1,
          progress: .32,
          position: new ts(3.5,.5,0),
          scale: new ts(1,1,-1)
        }, {
          type: 2,
          progress: .37,
          position: new ts(-2.5,-3,0)
        }, {
          type: 1,
          progress: .4,
          position: new ts(2,1.5,0)
        }, {
          type: 1,
          progress: .46,
          position: new ts(2.5,1.5,0),
          scale: new ts(1,1,-1)
        }, {
          type: 1,
          progress: .5,
          position: new ts(-3,-1.5,0),
          scale: new ts(-1.2,1.2,1.2)
        }, {
          type: 1,
          progress: .55,
          position: new ts(-2.5,1.5,0),
          scale: new ts(-1,1,1)
        }, {
          type: 2,
          progress: .6,
          position: new ts(3,-3,0),
          rotation: new Vs(0,1 * Math.PI,0)
        }, {
          type: 1,
          progress: .62,
          position: new ts(-3,2,0)
        }, {
          type: 1,
          progress: .65,
          position: new ts(3,-2,0),
          rotation: new Vs(0,1 * Math.PI,0)
        }, {
          type: 1,
          progress: .69,
          position: new ts(4,-2.5,0),
          scale: new ts(.3,.3,.3)
        }, {
          type: 1,
          progress: .7,
          position: new ts(-3,1,0),
          scale: new ts(.35,.35,.35)
        }, {
          type: 1,
          progress: .76,
          position: new ts(-4,-1,0),
          scale: new ts(-1.5,1.5,1.5)
        }, {
          type: 1,
          progress: .85,
          position: new ts(-.5,-3,0),
          rotation: new Vs(0,1 * Math.PI,0)
        }, {
          type: 1,
          progress: .87,
          position: new ts(-3,-1,0),
          rotation: new Vs(-1,1 * Math.PI,0)
        }].concat(cm);
        function dm() {
          let e = [];
          Up.models["cloud-1"].scene.traverse((t=>{
              t.isMesh && (e[0] = t.geometry)
            }
          )),
            Up.models["cloud-2"].scene.traverse((t=>{
                t.isMesh && (e[1] = t.geometry)
              }
            )),
            this.introCloudAlpha = 0,
            this.updateCloudsAlpha = !0;
          for (let t = 0; t < um.length; t++) {
            let i = um[t]
              , n = new Qa(e[i.type - 1],new Zc({
              transparent: !0
            }));
            if (this.scene.add(n),
              i.progress) {
              let e = new ts;
              this.curveMesh.geometry.parameters.path.getPointAt(i.progress, n.position),
                this.curveMesh.geometry.parameters.path.getPointAt(Math.max(0, i.progress - .05 * this.curve_size_factor), e),
              i.position && n.position.add(i.position),
                e.y = n.position.y,
                n.lookAt(e)
            } else
              i.position && n.position.copy(i.position);
            i.rotation && (n.rotation.x += i.rotation.x,
              n.rotation.y += i.rotation.y,
              n.rotation.z += i.rotation.z),
            i.scale && n.scale.copy(i.scale),
            i.color && (n.material.color = i.color),
              _n.ticker.add((()=>{
                  if (!this.updateCloudsAlpha)
                    return;
                  let e = Pr.clamp(1 - n.position.distanceTo(this.camera.position) / 30, 0, 1);
                  e = 2 * Math.pow(e, 2),
                    n.material.opacity = e * this.introCloudAlpha
                }
              ))
          }
          this.onLeave((()=>{
              this.updateCloudsAlpha = !1
            }
          )),
            this.onEnter((()=>{
                this.updateCloudsAlpha = !0
              }
            ))
        }
        function pm() {
          const e = new Fp({
            progressBar: !1,
            dracoLoader: Op,
            dracoDecoderPath: "draco/"
          });
          this.elephant = null,
            e.onLoaded.add((()=>{
                this.elephant = e.models.elephant.scene,
                  this.elephant.rotation.y = 2 * Math.PI * .2,
                  this.elephant.scale.set(.5, .5, .5);
                let t = [{
                  progress: .3,
                  position: new ts(-4.5,1,0)
                }, {
                  progress: .425,
                  position: new ts(4,2,0)
                }, {
                  progress: .6,
                  position: new ts(4,2,0)
                }, {
                  progress: .75,
                  position: new ts(-4,-2,0)
                }, {
                  progress: .78,
                  position: new ts(-4.5,-2,0)
                }, {
                  progress: 0,
                  position: new ts(0,0,100)
                }]
                  , i = t[Math.floor(Math.random() * t.length)]
                  , n = new ts;
                this.curveMesh.geometry.parameters.path.getPointAt(i.progress, this.elephant.position),
                  this.curveMesh.geometry.parameters.path.getPointAt(Math.max(0, i.progress - .05 * this.curve_size_factor), n),
                  this.elephant.position.add(i.position);
                let r = new Zc({
                  transparent: !0
                });
                this.elephant.traverse((e=>{
                    e.isMesh && (e.material = r)
                  }
                )),
                  this.elephant.initPosition = this.elephant.position.clone(),
                  this.scene.add(this.elephant);
                const s = new ed(this.elephant);
                e.models.elephant.animations.forEach((e=>{
                    s.clipAction(e).play()
                  }
                )),
                  _n.ticker.add(((e,t)=>{
                      s.update(t / 1e3),
                        this.elephant.position.y = this.elephant.initPosition.y + 1 * Math.sin(.2 * e),
                        this.elephant.rotation.y += 1e-4 * t;
                      let i = Pr.clamp(1 - this.elephant.position.distanceTo(this.camera.position) / 30, 0, 1);
                      i = 2 * Math.pow(i, 2),
                        r.opacity = i
                    }
                  ))
              }
            )),
            e.assets = [{
              alias: "elephant",
              type: "gltf",
              path: "models/elephant.glb"
            }],
            e.load(e.assets)
        }
        var fm = __webpack_require__(840)
          , mm = __webpack_require__.n(fm)
          , gm = __webpack_require__(796)
          , vm = __webpack_require__.n(gm);
        class ym {
          constructor(e) {
            let t = "object" == typeof e ? e : {};
            this.container = null != t.container ? t.container : window,
              this.container.addEventListener("mousewheel", this.updateScrollDeltaValue.bind(this)),
              this.container.addEventListener("wheel", this.updateScrollDeltaValue.bind(this)),
              this.deltaY = this.currentY = "number" == typeof t.startY ? t.startY : 0,
              this.lerpAmount = this.lerpAmountScroll = null != t.lerpAmount ? t.lerpAmount : .1,
              this.lerpAmountSwipe = null != t.lerpAmountSwipe ? t.lerpAmountSwipe : 4 * this.lerpAmount,
              this.mobileSensibility = t.mobileSensibility ?? 1,
              this.amp = t.amp > 1 ? t.amp : 1,
              this.triggers = "object" == typeof t.triggers ? t.triggers : [],
              this.range = "object" == typeof t.range && t.range,
              this.completion = 0,
              this.scrollbarCreation = "boolean" != typeof t.createScrollbar || t.createScrollbar,
              this.scrollbarPosition = t.scrollbarPosition || "right",
              this.scrollbarDirection = "top" == this.scrollbarPosition || "bottom" == this.scrollbarPosition ? "horizontal" : "vertical",
              this.swipeStrength = "number" == typeof t.swipeStrength ? t.swipeStrength : 75,
              this.customScrollbarStyles = "string" == typeof t.customScrollbarStyles && t.customScrollbarStyles,
              this.fadeOutDelay = "number" == typeof t.fadeOutDelay && t.fadeOutDelay,
              this.fadeOutTimeout,
              this.active = !0,
              this.handleSize = "number" == typeof t.handleSize ? t.handleSize : .1,
              this.distanceToScroll = -100 * (this.handleSize - 1) / this.handleSize;
            const i = new (mm().Manager)(document.body,{
              inputClass: mm().TouchInput
            });
            i.add(new (mm().Pan)({
              direction: mm().DIRECTION_ALL,
              threshold: 0
            })),
              i.on("pan", this.updateSwipeDeltaValue.bind(this)),
            this instanceof ym && ("number" != typeof ym[ym.instanceCounter] ? ym[ym.instanceCounter] = 0 : ym[ym.instanceCounter]++),
              this.instanceId = ym[ym.instanceCounter],
              this.lerpAnimation = !0,
            this.scrollbarCreation && this.createScrollbar()
          }
          createScrollbar() {
            let e = document.createElement("style");
            e.id = `virtual-scroll-handler-${this.instanceId}`,
              e.innerHTML = `.vsh-scrollbar-${this.instanceId} {\n            position: fixed;\n            ${"bottom" == this.scrollbarPosition ? "bottom" : "top"}: 10px;\n            ${"left" == this.scrollbarPosition ? "left" : "right"}: 10px;\n            ${"vertical" == this.scrollbarDirection ? "height" : "width"}: calc(100% - 20px);\n            ${"vertical" == this.scrollbarDirection ? "width" : "height"}: 2px;\n            background: #333333;\n            mix-blend-mode: difference;\n            z-index: 10000;\n        }\n\n        .vsh-scrollbar-${this.instanceId}--out {\n            opacity: 0;\n            transition: .5s opacity linear;\n        }\n\n        .vsh-scrollbar__handle-${this.instanceId} {\n            position: absolute;\n            ${"vertical" == this.scrollbarDirection ? "width" : "height"}: 300%;\n            ${"vertical" == this.scrollbarDirection ? "height" : "width"}: ${100 * this.handleSize}%;\n            ${"vertical" == this.scrollbarDirection ? "top" : "left"}: 0;\n            ${"vertical" == this.scrollbarDirection ? "left" : "top"}: -100%;\n            cursor: grab;\n        }\n\n        .vsh-scrollbar__handle-${this.instanceId}:after{\n            content: '';\n            position: absolute;\n            background: white;\n            ${"vertical" == this.scrollbarDirection ? "width" : "height"}: 33.33%;\n            ${"vertical" == this.scrollbarDirection ? "height" : "width"}: 100%;\n            ${"vertical" == this.scrollbarDirection ? "top" : "left"}: 0;\n            ${"vertical" == this.scrollbarDirection ? "left" : "top"}: 33.33%;\n        }`,
            this.customScrollbarStyles && (e.innerHTML += this.customScrollbarStyles),
              document.head.appendChild(e);
            let t = document.createElement("div");
            t.id = `vsh-scrollbar-${this.instanceId}`,
              t.classList.add(`vsh-scrollbar-${this.instanceId}`),
            this.fadeOutDelay && t.classList.add(`vsh-scrollbar-${this.instanceId}--out`),
              document.body.appendChild(t);
            let i = document.createElement("div");
            i.id = `vsh-scrollbar__handle-${this.instanceId}`,
              i.classList.add(`vsh-scrollbar__handle-${this.instanceId}`),
              t.appendChild(i),
              this.domElements = {
                scrollbar: t,
                handle: i
              },
              setTimeout(function() {
                this.handleDrag(),
                  this.domElements.scrollbar.addEventListener("mouseenter", (()=>{
                      this.domElements.scrollbar.classList.remove(`vsh-scrollbar-${this.instanceId}--out`),
                        clearTimeout(this.fadeOutTimeout)
                    }
                  )),
                  this.domElements.scrollbar.addEventListener("mouseleave", (()=>{
                      this.resetFadeOutTimeout()
                    }
                  ))
              }
                .bind(this), 100)
          }
          handleDrag() {
            let e = {
              prevY: 0,
              y: 0
            }
              , t = new (mm())(this.domElements.handle)
              , i = this.getWindowSize();
            window.addEventListener("resize", function() {
              i = this.getWindowSize()
            }
              .bind(this));
            let n = "vertical" == this.scrollbarDirection ? 1 : 0
              , r = "vertical" == this.scrollbarDirection ? "deltaY" : "deltaX";
            this.domElements.handle.addEventListener("mousedown", (()=>{
                this.preventFadeOut = !0
              }
            )),
              window.addEventListener("mouseup", (()=>{
                  this.preventFadeOut = !1,
                    this.resetFadeOutTimeout()
                }
              )),
              t.get("pan").set({
                direction: mm().DIRECTION_ALL
              }),
              t.on("panstart", function() {
                this.active && (this.lerpAnimation = !1,
                  e.prevY = this.currentY / this.range[1] * i[n])
              }
                .bind(this)),
              t.on("pan", function(t) {
                this.active && (e.y = e.prevY + t[r],
                  e.y = xm(e.y, 0, i[n]),
                  this.currentY = this.deltaY = e.y / i[n] * this.range[1],
                  this.domElements.handle.style.transform = `translateY(${e.y / i[n] * this.distanceToScroll}%)`)
              }
                .bind(this)),
              t.on("panend", function() {
                this.active && (this.lerpAnimation = !0)
              }
                .bind(this))
          }
          getWindowSize() {
            return [window.innerWidth, window.innerHeight]
          }
          updateScrollDeltaValue(e) {
            if (!this.active)
              return;
            let t, i = window.devicePixelRatio || 1, n = vm()(e).pixelY / i * this.amp;
            t = this.range ? xm(this.deltaY + n, this.range[0], this.range[1]) : this.deltaY + n,
              this.deltaY = t,
              this.lerpAmount = this.lerpAmountScroll,
              this.resetFadeOutTimeout()
          }
          resetFadeOutTimeout() {
            this.fadeOutDelay && this.scrollbarCreation && (this.domElements.scrollbar.classList.remove(`vsh-scrollbar-${this.instanceId}--out`),
              clearTimeout(this.fadeOutTimeout),
              this.fadeOutTimeout = setTimeout((()=>{
                  this.preventFadeOut || this.domElements.scrollbar.classList.add(`vsh-scrollbar-${this.instanceId}--out`)
                }
              ), this.fadeOutDelay))
          }
          updateSwipeDeltaValue(e) {
            if (!this.active)
              return;
            let t;
            this.fadeOutTimeout && this.scrollbarCreation && (this.domElements.scrollbar.classList.remove(`vsh-scrollbar-${this.instanceId}--out`),
              clearTimeout(this.fadeOutTimeout)),
              t = this.range ? xm(this.deltaY + this.swipeStrength * -e.velocityY * this.mobileSensibility * this.amp, this.range[0], this.range[1]) : this.deltaY + this.swipeStrength * -e.velocityY * this.mobileSensibility * this.amp,
              this.deltaY = t,
              this.lerpAmount = this.lerpAmountSwipe,
            this.fadeOutDelay && this.scrollbarCreation && (this.fadeOutTimeout = setTimeout((()=>{
                this.domElements.scrollbar.classList.add(`vsh-scrollbar-${this.instanceId}--out`)
              }
            ), this.fadeOutDelay))
          }
          update() {
            let e;
            var t, i, n;
            this.lerpAnimation ? (t = this.currentY,
              i = this.deltaY,
              e = (1 - (n = this.lerpAmount)) * t + n * i) : e = this.deltaY,
              this.currentY = Math.round(100 * e) / 100,
              this.checkTriggers(),
              this.updateCompletion(),
            this.scrollbarCreation && ("left" == this.scrollbarPosition || "right" == this.scrollbarPosition ? this.domElements.handle.style.transform = "translate3d(0," + this.completion * this.distanceToScroll + "%,0)" : this.domElements.handle.style.transform = "translate3d(" + this.completion * this.distanceToScroll + "%,0,0)")
          }
          checkTriggers() {
            this.triggers.forEach((e=>{
                ">y" == e.condition || null == e.condition ? (this.currentY >= e.y && !e.triggered && (e.callback(),
                  e.triggered = !0),
                this.currentY < e.y && e.triggered && !e.once && (e.triggered = !1)) : "<y" == e.condition && (this.currentY <= e.y && !e.triggered && (e.callback(),
                  e.triggered = !0),
                this.currentY > e.y && e.triggered && !e.once && (e.triggered = !1))
              }
            ))
          }
          updateCompletion() {
            this.range && (this.completion = (this.currentY - this.range[0]) / (this.range[1] - this.range[0]))
          }
          goTo(e, t=!0) {
            t ? this.deltaY = e : (this.lerpAnimation = !1,
              this.deltaY = e,
              setTimeout((()=>{
                  this.lerpAnimation = !0
                }
              ), 50))
          }
        }
        function xm(e, t, i) {
          return e <= t ? t : e >= i ? i : e
        }
        const _m = new ts;
        let bm = new ts(0,0,0)
          , wm = new ts
          , Am = 0
          , Sm = new ts(1,0,0);
        function Mm() {
          this.scroller = new ym({
            range: [0, 13e3 * this.curve_size_factor],
            lerpAmount: .2
          }),
            this.scroller.active = !1,
            this.progress_amp_amp = 1,
            this.plane.lookAtPosition = new ts,
            this.progress_amp = 1,
            this.camera_offset_factor = Pr.mapLinear(this.camera.aspect, 1.6, 0, 0, 1),
            this.camera_offset_factor = Pr.clamp(this.camera_offset_factor, 0, 1),
            this.deblur_factor = Pr.mapLinear(this.camera.aspect, 1.6, .6, 0, 1),
            this.deblur_factor = Pr.clamp(this.deblur_factor, 0, 1),
            window.addEventListener("resize", (()=>{
                this.camera_offset_factor = Pr.mapLinear(this.camera.aspect, 1.6, 0, 0, 1),
                  this.camera_offset_factor = Pr.clamp(this.camera_offset_factor, 0, 1),
                  this.deblur_factor = Pr.mapLinear(this.camera.aspect, 1.6, .6, 0, 1),
                  this.deblur_factor = Pr.clamp(this.deblur_factor, 0, 1)
              }
            )),
            this.texts_progress_array = [];
          for (let e = 0; e < this.texts.length; e++)
            this.texts_progress_array.push(this.texts[e].progress);
          this.step_count = om.length,
            this.getClosestText = Em,
            this.processProgress = Tm,
            this.soundBtnSpans = document.querySelectorAll(".sound-btn span"),
            this.updateLoop = Cm,
            this.updateLoopRef = this.updateLoop.bind(this),
            _n.ticker.add(this.updateLoopRef),
            this.onBeforeLeave((()=>{
                this.scroller.active = !1,
                  this.scroller.amp = 0
              }
            )),
            this.onLeave((()=>{
                _n.ticker.remove(this.updateLoopRef),
                  this.scroller.completion = this.lerped_completion
              }
            )),
            this.onEnter((()=>{
                this.scroller.amp = 1,
                  this.progress_amp_amp = 1,
                  this.scroller.active = !0,
                  _n.ticker.add(this.updateLoopRef)
              }
            ))
        }
        function Tm(e) {
          this.current_index = (this.step_count - 1) * e,
            this.prev_step_index = Math.floor(this.current_index),
            this.current_step_progress = this.current_index - this.prev_step_index,
            this.next_step_index = Math.min(this.prev_step_index + 1, this.step_count - 1),
            this.current_index = Math.floor(this.current_index),
          bn.camera_offset && (this.closest_text = this.getClosestText(e),
            this.closest_text_distance = this.camera.position.distanceTo(this.closest_text.pre_position))
        }
        function Em(e) {
          return this.texts.reduce(((t,i)=>Math.abs(e - i.progress) < Math.abs(e - t.progress) ? i : t))
        }
        function Cm(e) {
          if (this.scroller.update(),
            Am = Pr.lerp(Am, this.scroller.completion, .025 * this.progress_amp),
            this.lerped_completion = Am,
            this.processProgress(Am),
          Am > 0 && this.hint && (this.hint = !1,
            document.querySelector(".hint").classList.add("hint--out")),
          Am >= .95)
            return _n.ticker.remove(this.updateLoopRef),
              void this.end();
          if (this.curveMesh.geometry.parameters.path.getPointAt(Am, _m),
            this.curveMesh.geometry.parameters.path.getPointAt(Math.min(Am + .01 / this.curve_size_factor, 1), this.wind_particles_mesh.position),
            this.curveMesh.geometry.parameters.path.getPointAt(Math.min(Am + .05 / this.curve_size_factor, 1), this.plane.initPosition),
            this.curveMesh.geometry.parameters.path.getPointAt(Math.min(Am + .1 / this.curve_size_factor, 1), this.plane.lookAtPosition),
            this.curveMesh.geometry.parameters.path.getTangentAt(Am, wm),
            this.camera.position.copy(_m),
            bm.copy(_m).add(wm),
            this.camera.lookAt(bm),
            this.wind_particles_mesh.lookAt(bm),
            bn.camera_offset) {
            let e = Pr.clamp(1 - this.closest_text_distance / (5 * this.curve_size_factor), 0, 1);
            e = Math.pow(e, 3),
              this.progress_amp = Math.max(1 - 1.2 * e, .01) * this.progress_amp_amp,
              tf.textureMixEffect.uniforms.get("uMixerAmp").value = 1 - (1 - this.progress_amp) * this.deblur_factor;
            let t = e * this.closest_text.position.x * 3;
            this.camera.position.add(Sm.applyQuaternion(this.camera.quaternion).multiplyScalar(t * this.camera_offset_factor)),
              this.camera.rotation.y += .1 * -t,
              Sm.set(1, 0, 0)
          }
          this.plane.position.y = this.plane.initPosition.y + .2 * Math.sin(e) + this.plane.introPosition.y,
            this.plane.position.x = this.plane.initPosition.x + .1 * (-.5 + Math.sin(.5 * e)),
            this.plane.position.z = this.plane.initPosition.z + this.plane.introPosition.z,
            this.plane.lookAt(this.plane.lookAtPosition),
            this.plane.rotation.z += .15 * (this.plane.lookAtPosition.x - this.plane.position.x),
            this.sky.position.copy(this.camera.position),
            this.sky.material.uniforms.uGradientMixer.value = Am / .95,
            this.light.groundColor.lerpColors(om[this.current_index].lightGroundColor, om[this.next_step_index].lightGroundColor, this.current_step_progress),
            this.camera.updateMatrixWorld()
        }
        function Pm(e=!1) {
          const t = new Yc(.02,0)
            , i = new va({
            transparent: !0,
            opacity: .1,
            depthWrite: !1
          })
            , n = new Rs;
          this.wind_particles_mesh = new fc(t,i,200);
          var r = new ts
            , s = new Vs
            , a = new es
            , o = new ts(1,50,1);
          for (let e = 0; e < 200; e++) {
            let t = 360 * Math.random()
              , i = 3 + Math.random();
            r.x = Math.cos(t) * i,
              r.y = Math.sin(t) * i,
              r.z = 80 * Math.random() - 40,
              s.x = .5 * Math.PI,
              s.y = 2 * Math.PI * Math.random(),
              s.z = this.plane.rotation.y,
              a.setFromEuler(s),
              n.compose(r, a, o),
              this.wind_particles_mesh.setMatrixAt(e, n)
          }
          this.scene.add(this.wind_particles_mesh),
            this.wind_particles_factor = "desktop" == Gp() ? .001 : .02,
            window.addEventListener("resize", (()=>{
                this.wind_particles_factor = "desktop" == Gp() ? .001 : .02
              }
            )),
            _n.ticker.add((()=>{
                for (let e = 0; e < 200; e++)
                  this.wind_particles_mesh.getMatrixAt(e, n),
                    r.setFromMatrixPosition(n),
                    r.z += .2 * (1 + e % 5),
                    r.z = (r.z + 40) % 80 - 40,
                    s.z = this.plane.rotation.y,
                    n.setPosition(r),
                    this.wind_particles_mesh.setMatrixAt(e, n);
                if (this.wind_particles_mesh.instanceMatrix.needsUpdate = !0,
                  this.scroller.active) {
                  let e = Math.min((this.scroller.deltaY - this.scroller.currentY) * this.wind_particles_factor, 1);
                  i.opacity = Pr.lerp(i.opacity, e, .05),
                    i.opacity = Pr.clamp(i.opacity, 0, .1)
                } else
                  i.opacity = Pr.lerp(i.opacity, 0, .1)
              }
            ))
        }
        function Dm(e, t) {
          for (var i = 0; i < t.length; i++) {
            var n = t[i];
            n.enumerable = n.enumerable || !1,
              n.configurable = !0,
            "value"in n && (n.writable = !0),
              Object.defineProperty(e, n.key, n)
          }
        }
        var Im, Rm, Lm, km, Fm, Bm, Om, Nm, zm, Um, Gm, Vm, Hm = function() {
          return Im || "undefined" != typeof window && (Im = window.gsap) && Im.registerPlugin && Im
        }, Wm = 1, jm = [], Xm = [], Ym = [], qm = Date.now, Qm = function(e, t) {
          return t
        }, Km = function(e, t) {
          return ~Ym.indexOf(e) && Ym[Ym.indexOf(e) + 1][t]
        }, Jm = function(e) {
          return !!~Um.indexOf(e)
        }, Zm = function(e, t, i, n, r) {
          return e.addEventListener(t, i, {
            passive: !n,
            capture: !!r
          })
        }, $m = function(e, t, i, n) {
          return e.removeEventListener(t, i, !!n)
        }, eg = function() {
          return Gm && Gm.isPressed || Xm.cache++
        }, tg = function(e, t) {
          var i = function i(n) {
            if (n || 0 === n) {
              Wm && (Lm.history.scrollRestoration = "manual");
              var r = Gm && Gm.isPressed;
              n = i.v = Math.round(n) || (Gm && Gm.iOS ? 1 : 0),
                e(n),
                i.cacheID = Xm.cache,
              r && Qm("ss", n)
            } else
              (t || Xm.cache !== i.cacheID || Qm("ref")) && (i.cacheID = Xm.cache,
                i.v = e());
            return i.v + i.offset
          };
          return i.offset = 0,
          e && i
        }, ig = {
          s: "scrollLeft",
          p: "left",
          p2: "Left",
          os: "right",
          os2: "Right",
          d: "width",
          d2: "Width",
          a: "x",
          sc: tg((function(e) {
              return arguments.length ? Lm.scrollTo(e, ng.sc()) : Lm.pageXOffset || km.scrollLeft || Fm.scrollLeft || Bm.scrollLeft || 0
            }
          ))
        }, ng = {
          s: "scrollTop",
          p: "top",
          p2: "Top",
          os: "bottom",
          os2: "Bottom",
          d: "height",
          d2: "Height",
          a: "y",
          op: ig,
          sc: tg((function(e) {
              return arguments.length ? Lm.scrollTo(ig.sc(), e) : Lm.pageYOffset || km.scrollTop || Fm.scrollTop || Bm.scrollTop || 0
            }
          ))
        }, rg = function(e) {
          return Im.utils.toArray(e)[0] || ("string" == typeof e && !1 !== Im.config().nullTargetWarn ? console.warn("Element not found:", e) : null)
        }, sg = function(e, t) {
          var i = t.s
            , n = t.sc
            , r = Xm.indexOf(e)
            , s = n === ng.sc ? 1 : 2;
          return !~r && (r = Xm.push(e) - 1),
          Xm[r + s] || (Xm[r + s] = tg(Km(e, i), !0) || (Jm(e) ? n : tg((function(t) {
              return arguments.length ? e[i] = t : e[i]
            }
          ))))
        }, ag = function(e, t, i) {
          var n = e
            , r = e
            , s = qm()
            , a = s
            , o = t || 50
            , l = Math.max(500, 3 * o)
            , h = function(e, t) {
            var l = qm();
            t || l - s > o ? (r = n,
              n = e,
              a = s,
              s = l) : i ? n += e : n = r + (e - r) / (l - a) * (s - a)
          };
          return {
            update: h,
            reset: function() {
              r = n = i ? 0 : n,
                a = s = 0
            },
            getVelocity: function(e) {
              var t = a
                , o = r
                , c = qm();
              return (e || 0 === e) && e !== n && h(e),
                s === a || c - a > l ? 0 : (n + (i ? o : -o)) / ((i ? c : s) - t) * 1e3
            }
          }
        }, og = function(e, t) {
          return t && !e._gsapAllow && e.preventDefault(),
            e.changedTouches ? e.changedTouches[0] : e
        }, lg = function(e) {
          var t = Math.max.apply(Math, e)
            , i = Math.min.apply(Math, e);
          return Math.abs(t) >= Math.abs(i) ? t : i
        }, hg = function() {
          var e, t, i, n;
          (zm = Im.core.globals().ScrollTrigger) && zm.core && (e = zm.core,
              t = e.bridge || {},
              i = e._scrollers,
              n = e._proxies,
              i.push.apply(i, Xm),
              n.push.apply(n, Ym),
              Xm = i,
              Ym = n,
              Qm = function(e, i) {
                return t[e](i)
              }
          )
        }, cg = function(e) {
          return (Im = e || Hm()) && "undefined" != typeof document && document.body && (Lm = window,
            km = document,
            Fm = km.documentElement,
            Bm = km.body,
            Um = [Lm, km, Fm, Bm],
            Im.utils.clamp,
            Nm = "onpointerenter"in Bm ? "pointer" : "mouse",
            Om = ug.isTouch = Lm.matchMedia && Lm.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart"in Lm || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0,
            Vm = ug.eventTypes = ("ontouchstart"in Fm ? "touchstart,touchmove,touchcancel,touchend" : "onpointerdown"in Fm ? "pointerdown,pointermove,pointercancel,pointerup" : "mousedown,mousemove,mouseup,mouseup").split(","),
            setTimeout((function() {
                return Wm = 0
              }
            ), 500),
            hg(),
            Rm = 1),
            Rm
        };
        ig.op = ng,
          Xm.cache = 0;
        var ug = function() {
          function e(e) {
            this.init(e)
          }
          var t, i;
          return e.prototype.init = function(e) {
            Rm || cg(Im) || console.warn("Please gsap.registerPlugin(Observer)"),
            zm || hg();
            var t = e.tolerance
              , i = e.dragMinimum
              , n = e.type
              , r = e.target
              , s = e.lineHeight
              , a = e.debounce
              , o = e.preventDefault
              , l = e.onStop
              , h = e.onStopDelay
              , c = e.ignore
              , u = e.wheelSpeed
              , d = e.event
              , p = e.onDragStart
              , f = e.onDragEnd
              , m = e.onDrag
              , g = e.onPress
              , v = e.onRelease
              , y = e.onRight
              , x = e.onLeft
              , _ = e.onUp
              , b = e.onDown
              , w = e.onChangeX
              , A = e.onChangeY
              , S = e.onChange
              , M = e.onToggleX
              , T = e.onToggleY
              , E = e.onHover
              , C = e.onHoverEnd
              , P = e.onMove
              , D = e.ignoreCheck
              , I = e.isNormalizer
              , R = e.onGestureStart
              , L = e.onGestureEnd
              , k = e.onWheel
              , F = e.onEnable
              , B = e.onDisable
              , O = e.onClick
              , N = e.scrollSpeed
              , z = e.capture
              , U = e.allowClicks
              , G = e.lockAxis
              , V = e.onLockAxis;
            this.target = r = rg(r) || Fm,
              this.vars = e,
            c && (c = Im.utils.toArray(c)),
              t = t || 0,
              i = i || 0,
              u = u || 1,
              N = N || 1,
              n = n || "wheel,touch,pointer",
              a = !1 !== a,
            s || (s = parseFloat(Lm.getComputedStyle(Bm).lineHeight) || 22);
            var H, W, j, X, Y, q, Q, K = this, J = 0, Z = 0, $ = sg(r, ig), ee = sg(r, ng), te = $(), ie = ee(), ne = ~n.indexOf("touch") && !~n.indexOf("pointer") && "pointerdown" === Vm[0], re = Jm(r), se = r.ownerDocument || km, ae = [0, 0, 0], oe = [0, 0, 0], le = 0, he = function() {
              return le = qm()
            }, ce = function(e, t) {
              return (K.event = e) && c && ~c.indexOf(e.target) || t && ne && "touch" !== e.pointerType || D && D(e, t)
            }, ue = function() {
              var e = K.deltaX = lg(ae)
                , i = K.deltaY = lg(oe)
                , n = Math.abs(e) >= t
                , r = Math.abs(i) >= t;
              S && (n || r) && S(K, e, i, ae, oe),
              n && (y && K.deltaX > 0 && y(K),
              x && K.deltaX < 0 && x(K),
              w && w(K),
              M && K.deltaX < 0 != J < 0 && M(K),
                J = K.deltaX,
                ae[0] = ae[1] = ae[2] = 0),
              r && (b && K.deltaY > 0 && b(K),
              _ && K.deltaY < 0 && _(K),
              A && A(K),
              T && K.deltaY < 0 != Z < 0 && T(K),
                Z = K.deltaY,
                oe[0] = oe[1] = oe[2] = 0),
              (X || j) && (P && P(K),
              V && q && V(K),
              j && (m(K),
                j = !1),
                X = q = !1),
              Y && (k(K),
                Y = !1),
                H = 0
            }, de = function(e, t, i) {
              ae[i] += e,
                oe[i] += t,
                K._vx.update(e),
                K._vy.update(t),
                a ? H || (H = requestAnimationFrame(ue)) : ue()
            }, pe = function(e, t) {
              "y" !== Q && (ae[2] += e,
                K._vx.update(e, !0)),
              "x" !== Q && (oe[2] += t,
                K._vy.update(t, !0)),
              G && !Q && (K.axis = Q = Math.abs(e) > Math.abs(t) ? "x" : "y",
                q = !0),
                a ? H || (H = requestAnimationFrame(ue)) : ue()
            }, fe = function(e) {
              if (!ce(e, 1)) {
                var t = (e = og(e, o)).clientX
                  , n = e.clientY
                  , r = t - K.x
                  , s = n - K.y
                  , a = K.isDragging;
                K.x = t,
                  K.y = n,
                (a || Math.abs(K.startX - t) >= i || Math.abs(K.startY - n) >= i) && (m && (j = !0),
                a || (K.isDragging = !0),
                  pe(r, s),
                a || p && p(K))
              }
            }, me = K.onPress = function(e) {
              ce(e, 1) || (K.axis = Q = null,
                W.pause(),
                K.isPressed = !0,
                e = og(e),
                J = Z = 0,
                K.startX = K.x = e.clientX,
                K.startY = K.y = e.clientY,
                K._vx.reset(),
                K._vy.reset(),
                Zm(I ? r : se, Vm[1], fe, o, !0),
                K.deltaX = K.deltaY = 0,
              g && g(K))
            }
              , ge = function(e) {
              if (!ce(e, 1)) {
                $m(I ? r : se, Vm[1], fe, !0);
                var t = K.isDragging && (Math.abs(K.x - K.startX) > 3 || Math.abs(K.y - K.startY) > 3)
                  , i = og(e);
                t || (K._vx.reset(),
                  K._vy.reset(),
                o && U && Im.delayedCall(.08, (function() {
                    if (qm() - le > 300 && !e.defaultPrevented)
                      if (e.target.click)
                        e.target.click();
                      else if (se.createEvent) {
                        var t = se.createEvent("MouseEvents");
                        t.initMouseEvent("click", !0, !0, Lm, 1, i.screenX, i.screenY, i.clientX, i.clientY, !1, !1, !1, !1, 0, null),
                          e.target.dispatchEvent(t)
                      }
                  }
                ))),
                  K.isDragging = K.isGesturing = K.isPressed = !1,
                l && !I && W.restart(!0),
                f && t && f(K),
                v && v(K, t)
              }
            }, ve = function(e) {
              return e.touches && e.touches.length > 1 && (K.isGesturing = !0) && R(e, K.isDragging)
            }, ye = function() {
              return (K.isGesturing = !1) || L(K)
            }, xe = function(e) {
              if (!ce(e)) {
                var t = $()
                  , i = ee();
                de((t - te) * N, (i - ie) * N, 1),
                  te = t,
                  ie = i,
                l && W.restart(!0)
              }
            }, _e = function(e) {
              if (!ce(e)) {
                e = og(e, o),
                k && (Y = !0);
                var t = (1 === e.deltaMode ? s : 2 === e.deltaMode ? Lm.innerHeight : 1) * u;
                de(e.deltaX * t, e.deltaY * t, 0),
                l && !I && W.restart(!0)
              }
            }, be = function(e) {
              if (!ce(e)) {
                var t = e.clientX
                  , i = e.clientY
                  , n = t - K.x
                  , r = i - K.y;
                K.x = t,
                  K.y = i,
                  X = !0,
                (n || r) && pe(n, r)
              }
            }, we = function(e) {
              K.event = e,
                E(K)
            }, Ae = function(e) {
              K.event = e,
                C(K)
            }, Se = function(e) {
              return ce(e) || og(e, o) && O(K)
            };
            W = K._dc = Im.delayedCall(h || .25, (function() {
                K._vx.reset(),
                  K._vy.reset(),
                  W.pause(),
                l && l(K)
              }
            )).pause(),
              K.deltaX = K.deltaY = 0,
              K._vx = ag(0, 50, !0),
              K._vy = ag(0, 50, !0),
              K.scrollX = $,
              K.scrollY = ee,
              K.isDragging = K.isGesturing = K.isPressed = !1,
              K.enable = function(e) {
                return K.isEnabled || (Zm(re ? se : r, "scroll", eg),
                n.indexOf("scroll") >= 0 && Zm(re ? se : r, "scroll", xe, o, z),
                n.indexOf("wheel") >= 0 && Zm(r, "wheel", _e, o, z),
                (n.indexOf("touch") >= 0 && Om || n.indexOf("pointer") >= 0) && (Zm(r, Vm[0], me, o, z),
                  Zm(se, Vm[2], ge),
                  Zm(se, Vm[3], ge),
                U && Zm(r, "click", he, !1, !0),
                O && Zm(r, "click", Se),
                R && Zm(se, "gesturestart", ve),
                L && Zm(se, "gestureend", ye),
                E && Zm(r, Nm + "enter", we),
                C && Zm(r, Nm + "leave", Ae),
                P && Zm(r, Nm + "move", be)),
                  K.isEnabled = !0,
                e && e.type && me(e),
                F && F(K)),
                  K
              }
              ,
              K.disable = function() {
                K.isEnabled && (jm.filter((function(e) {
                    return e !== K && Jm(e.target)
                  }
                )).length || $m(re ? se : r, "scroll", eg),
                K.isPressed && (K._vx.reset(),
                  K._vy.reset(),
                  $m(I ? r : se, Vm[1], fe, !0)),
                  $m(re ? se : r, "scroll", xe, z),
                  $m(r, "wheel", _e, z),
                  $m(r, Vm[0], me, z),
                  $m(se, Vm[2], ge),
                  $m(se, Vm[3], ge),
                  $m(r, "click", he, !0),
                  $m(r, "click", Se),
                  $m(se, "gesturestart", ve),
                  $m(se, "gestureend", ye),
                  $m(r, Nm + "enter", we),
                  $m(r, Nm + "leave", Ae),
                  $m(r, Nm + "move", be),
                  K.isEnabled = K.isPressed = K.isDragging = !1,
                B && B(K))
              }
              ,
              K.kill = function() {
                K.disable();
                var e = jm.indexOf(K);
                e >= 0 && jm.splice(e, 1),
                Gm === K && (Gm = 0)
              }
              ,
              jm.push(K),
            I && Jm(r) && (Gm = K),
              K.enable(d)
          }
            ,
            t = e,
          (i = [{
            key: "velocityX",
            get: function() {
              return this._vx.getVelocity()
            }
          }, {
            key: "velocityY",
            get: function() {
              return this._vy.getVelocity()
            }
          }]) && Dm(t.prototype, i),
            e
        }();
        ug.version = "3.10.4",
          ug.create = function(e) {
            return new ug(e)
          }
          ,
          ug.register = cg,
          ug.getAll = function() {
            return jm.slice()
          }
          ,
          ug.getById = function(e) {
            return jm.filter((function(t) {
                return t.vars.id === e
              }
            ))[0]
          }
          ,
        Hm() && Im.registerPlugin(ug);
        var dg, pg, fg, mg, gg, vg, yg, xg, _g, bg, wg, Ag, Sg, Mg, Tg, Eg, Cg, Pg, Dg, Ig, Rg, Lg, kg, Fg, Bg, Og, Ng, zg, Ug, Gg, Vg, Hg, Wg, jg = 1, Xg = Date.now, Yg = Xg(), qg = 0, Qg = 0, Kg = function() {
          return Mg = 1
        }, Jg = function() {
          return Mg = 0
        }, Zg = function(e) {
          return e
        }, $g = function(e) {
          return Math.round(1e5 * e) / 1e5 || 0
        }, ev = function() {
          return "undefined" != typeof window
        }, tv = function() {
          return dg || ev() && (dg = window.gsap) && dg.registerPlugin && dg
        }, iv = function(e) {
          return !!~yg.indexOf(e)
        }, nv = function(e) {
          return Km(e, "getBoundingClientRect") || (iv(e) ? function() {
                return dy.width = fg.innerWidth,
                  dy.height = fg.innerHeight,
                  dy
              }
              : function() {
                return Mv(e)
              }
          )
        }, rv = function(e, t) {
          var i = t.s
            , n = t.d2
            , r = t.d
            , s = t.a;
          return (i = "scroll" + n) && (s = Km(e, i)) ? s() - nv(e)()[r] : iv(e) ? (gg[i] || vg[i]) - (fg["inner" + n] || gg["client" + n] || vg["client" + n]) : e[i] - e["offset" + n]
        }, sv = function(e, t) {
          for (var i = 0; i < Dg.length; i += 3)
            (!t || ~t.indexOf(Dg[i + 1])) && e(Dg[i], Dg[i + 1], Dg[i + 2])
        }, av = function(e) {
          return "string" == typeof e
        }, ov = function(e) {
          return "function" == typeof e
        }, lv = function(e) {
          return "number" == typeof e
        }, hv = function(e) {
          return "object" == typeof e
        }, cv = function(e) {
          return ov(e) && e()
        }, uv = function(e, t) {
          return function() {
            var i = cv(e)
              , n = cv(t);
            return function() {
              cv(i),
                cv(n)
            }
          }
        }, dv = function(e, t, i) {
          return e && e.progress(t ? 0 : 1) && i && e.pause()
        }, pv = function(e, t) {
          if (e.enabled) {
            var i = t(e);
            i && i.totalTime && (e.callbackAnimation = i)
          }
        }, fv = Math.abs, mv = "right", gv = "bottom", vv = "width", yv = "height", xv = "padding", _v = "margin", bv = "Width", wv = "px", Av = function(e) {
          return fg.getComputedStyle(e)
        }, Sv = function(e, t) {
          for (var i in t)
            i in e || (e[i] = t[i]);
          return e
        }, Mv = function(e, t) {
          var i = t && "matrix(1, 0, 0, 1, 0, 0)" !== Av(e)[Tg] && dg.to(e, {
            x: 0,
            y: 0,
            xPercent: 0,
            yPercent: 0,
            rotation: 0,
            rotationX: 0,
            rotationY: 0,
            scale: 1,
            skewX: 0,
            skewY: 0
          }).progress(1)
            , n = e.getBoundingClientRect();
          return i && i.progress(0).kill(),
            n
        }, Tv = function(e, t) {
          var i = t.d2;
          return e["offset" + i] || e["client" + i] || 0
        }, Ev = function(e) {
          var t, i = [], n = e.labels, r = e.duration();
          for (t in n)
            i.push(n[t] / r);
          return i
        }, Cv = function(e) {
          var t = dg.utils.snap(e)
            , i = Array.isArray(e) && e.slice(0).sort((function(e, t) {
              return e - t
            }
          ));
          return i ? function(e, n, r) {
              var s;
              if (void 0 === r && (r = .001),
                !n)
                return t(e);
              if (n > 0) {
                for (e -= r,
                       s = 0; s < i.length; s++)
                  if (i[s] >= e)
                    return i[s];
                return i[s - 1]
              }
              for (s = i.length,
                     e += r; s--; )
                if (i[s] <= e)
                  return i[s];
              return i[0]
            }
            : function(i, n, r) {
              void 0 === r && (r = .001);
              var s = t(i);
              return !n || Math.abs(s - i) < r || s - i < 0 == n < 0 ? s : t(n < 0 ? i - e : i + e)
            }
        }, Pv = function(e, t, i, n) {
          return i.split(",").forEach((function(i) {
              return e(t, i, n)
            }
          ))
        }, Dv = function(e, t, i, n, r) {
          return e.addEventListener(t, i, {
            passive: !n,
            capture: !!r
          })
        }, Iv = function(e, t, i, n) {
          return e.removeEventListener(t, i, !!n)
        }, Rv = function(e, t, i) {
          return i && i.wheelHandler && e(t, "wheel", i)
        }, Lv = {
          startColor: "green",
          endColor: "red",
          indent: 0,
          fontSize: "16px",
          fontWeight: "normal"
        }, kv = {
          toggleActions: "play",
          anticipatePin: 0
        }, Fv = {
          top: 0,
          left: 0,
          center: .5,
          bottom: 1,
          right: 1
        }, Bv = function(e, t) {
          if (av(e)) {
            var i = e.indexOf("=")
              , n = ~i ? +(e.charAt(i - 1) + 1) * parseFloat(e.substr(i + 1)) : 0;
            ~i && (e.indexOf("%") > i && (n *= t / 100),
              e = e.substr(0, i - 1)),
              e = n + (e in Fv ? Fv[e] * t : ~e.indexOf("%") ? parseFloat(e) * t / 100 : parseFloat(e) || 0)
          }
          return e
        }, Ov = function(e, t, i, n, r, s, a, o) {
          var l = r.startColor
            , h = r.endColor
            , c = r.fontSize
            , u = r.indent
            , d = r.fontWeight
            , p = mg.createElement("div")
            , f = iv(i) || "fixed" === Km(i, "pinType")
            , m = -1 !== e.indexOf("scroller")
            , g = f ? vg : i
            , v = -1 !== e.indexOf("start")
            , y = v ? l : h
            , x = "border-color:" + y + ";font-size:" + c + ";color:" + y + ";font-weight:" + d + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
          return x += "position:" + ((m || o) && f ? "fixed;" : "absolute;"),
          (m || o || !f) && (x += (n === ng ? mv : gv) + ":" + (s + parseFloat(u)) + "px;"),
          a && (x += "box-sizing:border-box;text-align:left;width:" + a.offsetWidth + "px;"),
            p._isStart = v,
            p.setAttribute("class", "gsap-marker-" + e + (t ? " marker-" + t : "")),
            p.style.cssText = x,
            p.innerText = t || 0 === t ? e + "-" + t : e,
            g.children[0] ? g.insertBefore(p, g.children[0]) : g.appendChild(p),
            p._offset = p["offset" + n.op.d2],
            Nv(p, 0, n, v),
            p
        }, Nv = function(e, t, i, n) {
          var r = {
            display: "block"
          }
            , s = i[n ? "os2" : "p2"]
            , a = i[n ? "p2" : "os2"];
          e._isFlipped = n,
            r[i.a + "Percent"] = n ? -100 : 0,
            r[i.a] = n ? "1px" : 0,
            r["border" + s + bv] = 1,
            r["border" + a + bv] = 0,
            r[i.p] = t + "px",
            dg.set(e, r)
        }, zv = [], Uv = {}, Gv = function() {
          return Xg() - qg > 34 && sy()
        }, Vv = function() {
          (!kg || !kg.isPressed || kg.startX > vg.clientWidth) && (Xm.cache++,
          Ug || (Ug = requestAnimationFrame(sy)),
          qg || Kv("scrollStart"),
            qg = Xg())
        }, Hv = function() {
          Og = fg.innerWidth,
            Bg = fg.innerHeight
        }, Wv = function() {
          Xm.cache++,
          !Sg && !Lg && !mg.fullscreenElement && !mg.webkitFullscreenElement && (!Fg || Og !== fg.innerWidth || Math.abs(fg.innerHeight - Bg) > .25 * fg.innerHeight) && xg.restart(!0)
        }, jv = {}, Xv = [], Yv = [], qv = function(e) {
          var t, i = dg.ticker.frame, n = [], r = 0;
          if (Vg !== i || jg) {
            for ($v(); r < Yv.length; r += 4)
              (t = fg.matchMedia(Yv[r]).matches) !== Yv[r + 3] && (Yv[r + 3] = t,
                t ? n.push(r) : $v(1, Yv[r]) || ov(Yv[r + 2]) && Yv[r + 2]());
            for (Zv(),
                   r = 0; r < n.length; r++)
              t = n[r],
                Gg = Yv[t],
                Yv[t + 2] = Yv[t + 1](e);
            Gg = 0,
            pg && iy(0, 1),
              Vg = i,
              Kv("matchMedia")
          }
        }, Qv = function e() {
          return Iv(vy, "scrollEnd", e) || iy(!0)
        }, Kv = function(e) {
          return jv[e] && jv[e].map((function(e) {
              return e()
            }
          )) || Xv
        }, Jv = [], Zv = function(e) {
          for (var t = 0; t < Jv.length; t += 5)
            e && Jv[t + 4] !== e || (Jv[t].style.cssText = Jv[t + 1],
            Jv[t].getBBox && Jv[t].setAttribute("transform", Jv[t + 2] || ""),
              Jv[t + 3].uncache = 1)
        }, $v = function(e, t) {
          var i;
          for (Eg = 0; Eg < zv.length; Eg++)
            i = zv[Eg],
            t && i.media !== t || (e ? i.kill(1) : i.revert());
          t && Zv(t),
          t || Kv("revert")
        }, ey = function() {
          return Xm.cache++ && Xm.forEach((function(e) {
              return "function" == typeof e && (e.rec = 0)
            }
          ))
        }, ty = 0, iy = function(e, t) {
          if (!qg || e) {
            Hg = !0;
            var i = Kv("refreshInit");
            Ig && vy.sort(),
            t || $v(),
              zv.slice(0).forEach((function(e) {
                  return e.refresh()
                }
              )),
              zv.forEach((function(e) {
                  return "max" === e.vars.end && e.setPositions(e.start, rv(e.scroller, e._dir))
                }
              )),
              i.forEach((function(e) {
                  return e && e.render && e.render(-1)
                }
              )),
              ey(),
              xg.pause(),
              ty++,
              Hg = !1,
              Kv("refresh")
          } else
            Dv(vy, "scrollEnd", Qv)
        }, ny = 0, ry = 1, sy = function() {
          if (!Hg) {
            vy.isUpdating = !0,
            Wg && Wg.update(0);
            var e = zv.length
              , t = Xg()
              , i = t - Yg >= 50
              , n = e && zv[0].scroll();
            if (ry = ny > n ? -1 : 1,
              ny = n,
            i && (qg && !Mg && t - qg > 200 && (qg = 0,
              Kv("scrollEnd")),
              wg = Yg,
              Yg = t),
            ry < 0) {
              for (Eg = e; Eg-- > 0; )
                zv[Eg] && zv[Eg].update(0, i);
              ry = 1
            } else
              for (Eg = 0; Eg < e; Eg++)
                zv[Eg] && zv[Eg].update(0, i);
            vy.isUpdating = !1
          }
          Ug = 0
        }, ay = ["left", "top", gv, mv, "marginBottom", "marginRight", "marginTop", "marginLeft", "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"], oy = ay.concat([vv, yv, "boxSizing", "maxWidth", "maxHeight", "position", _v, xv, "paddingTop", "paddingRight", "paddingBottom", "paddingLeft"]), ly = function(e, t, i, n) {
          if (e.parentNode !== t) {
            for (var r, s = ay.length, a = t.style, o = e.style; s--; )
              a[r = ay[s]] = i[r];
            a.position = "absolute" === i.position ? "absolute" : "relative",
            "inline" === i.display && (a.display = "inline-block"),
              o.bottom = o.right = a.flexBasis = "auto",
              a.overflow = "visible",
              a.boxSizing = "border-box",
              a.width = Tv(e, ig) + wv,
              a.height = Tv(e, ng) + wv,
              a.padding = o.margin = o.top = o.left = "0",
              cy(n),
              o.width = o.maxWidth = i.width,
              o.height = o.maxHeight = i.height,
              o.padding = i.padding,
              e.parentNode.insertBefore(t, e),
              t.appendChild(e)
          }
        }, hy = /([A-Z])/g, cy = function(e) {
          if (e) {
            var t, i, n = e.t.style, r = e.length, s = 0;
            for ((e.t._gsap || dg.core.getCache(e.t)).uncache = 1; s < r; s += 2)
              i = e[s + 1],
                t = e[s],
                i ? n[t] = i : n[t] && n.removeProperty(t.replace(hy, "-$1").toLowerCase())
          }
        }, uy = function(e) {
          for (var t = oy.length, i = e.style, n = [], r = 0; r < t; r++)
            n.push(oy[r], i[oy[r]]);
          return n.t = e,
            n
        }, dy = {
          left: 0,
          top: 0
        }, py = function(e, t, i, n, r, s, a, o, l, h, c, u, d) {
          ov(e) && (e = e(o)),
          av(e) && "max" === e.substr(0, 3) && (e = u + ("=" === e.charAt(4) ? Bv("0" + e.substr(3), i) : 0));
          var p, f, m, g = d ? d.time() : 0;
          if (d && d.seek(0),
            lv(e))
            a && Nv(a, i, n, !0);
          else {
            ov(t) && (t = t(o));
            var v, y, x, _, b = e.split(" ");
            m = rg(t) || vg,
            (v = Mv(m) || {}) && (v.left || v.top) || "none" !== Av(m).display || (_ = m.style.display,
              m.style.display = "block",
              v = Mv(m),
              _ ? m.style.display = _ : m.style.removeProperty("display")),
              y = Bv(b[0], v[n.d]),
              x = Bv(b[1] || "0", i),
              e = v[n.p] - l[n.p] - h + y + r - x,
            a && Nv(a, x, n, i - x < 20 || a._isStart && x > 20),
              i -= i - x
          }
          if (s) {
            var w = e + i
              , A = s._isStart;
            p = "scroll" + n.d2,
              Nv(s, w, n, A && w > 20 || !A && (c ? Math.max(vg[p], gg[p]) : s.parentNode[p]) <= w + 1),
            c && (l = Mv(a),
            c && (s.style[n.op.p] = l[n.op.p] - n.op.m - s._offset + wv))
          }
          return d && m && (p = Mv(m),
            d.seek(u),
            f = Mv(m),
            d._caScrollDist = p[n.p] - f[n.p],
            e = e / d._caScrollDist * u),
          d && d.seek(g),
            d ? e : Math.round(e)
        }, fy = /(webkit|moz|length|cssText|inset)/i, my = function(e, t, i, n) {
          if (e.parentNode !== t) {
            var r, s, a = e.style;
            if (t === vg) {
              for (r in e._stOrig = a.cssText,
                s = Av(e))
                +r || fy.test(r) || !s[r] || "string" != typeof a[r] || "0" === r || (a[r] = s[r]);
              a.top = i,
                a.left = n
            } else
              a.cssText = e._stOrig;
            dg.core.getCache(e).uncache = 1,
              t.appendChild(e)
          }
        }, gy = function(e, t) {
          var i, n, r = sg(e, t), s = "_scroll" + t.p2, a = function t(a, o, l, h, c) {
            var u = t.tween
              , d = o.onComplete
              , p = {};
            return l = l || r(),
              c = h && c || 0,
              h = h || a - l,
            u && u.kill(),
              i = Math.round(l),
              o[s] = a,
              o.modifiers = p,
              p[s] = function(e) {
                return (e = $g(r())) !== i && e !== n && Math.abs(e - i) > 2 && Math.abs(e - n) > 2 ? (u.kill(),
                  t.tween = 0) : e = l + h * u.ratio + c * u.ratio * u.ratio,
                  n = i,
                  i = $g(e)
              }
              ,
              o.onComplete = function() {
                t.tween = 0,
                d && d.call(u)
              }
              ,
              u = t.tween = dg.to(e, o)
          };
          return e[s] = r,
            r.wheelHandler = function() {
              return a.tween && a.tween.kill() && (a.tween = 0)
            }
            ,
            Dv(e, "wheel", r.wheelHandler),
            a
        }, vy = function() {
          function e(t, i) {
            pg || e.register(dg) || console.warn("Please gsap.registerPlugin(ScrollTrigger)"),
              this.init(t, i)
          }
          return e.prototype.init = function(t, i) {
            if (this.progress = this.start = 0,
            this.vars && this.kill(!0, !0),
              Qg) {
              var n, r, s, a, o, l, h, c, u, d, p, f, m, g, v, y, x, _, b, w, A, S, M, T, E, C, P, D, I, R, L, k, F, B, O, N, z, U, G, V = t = Sv(av(t) || lv(t) || t.nodeType ? {
                trigger: t
              } : t, kv), H = V.onUpdate, W = V.toggleClass, j = V.id, X = V.onToggle, Y = V.onRefresh, q = V.scrub, Q = V.trigger, K = V.pin, J = V.pinSpacing, Z = V.invalidateOnRefresh, $ = V.anticipatePin, ee = V.onScrubComplete, te = V.onSnapComplete, ie = V.once, ne = V.snap, re = V.pinReparent, se = V.pinSpacer, ae = V.containerAnimation, oe = V.fastScrollEnd, le = V.preventOverlaps, he = t.horizontal || t.containerAnimation && !1 !== t.horizontal ? ig : ng, ce = !q && 0 !== q, ue = rg(t.scroller || fg), de = dg.core.getCache(ue), pe = iv(ue), fe = "fixed" === ("pinType"in t ? t.pinType : Km(ue, "pinType") || pe && "fixed"), me = [t.onEnter, t.onLeave, t.onEnterBack, t.onLeaveBack], ge = ce && t.toggleActions.split(" "), ve = "markers"in t ? t.markers : kv.markers, ye = pe ? 0 : parseFloat(Av(ue)["border" + he.p2 + bv]) || 0, xe = this, _e = t.onRefreshInit && function() {
                return t.onRefreshInit(xe)
              }
                , be = function(e, t, i) {
                var n = i.d
                  , r = i.d2
                  , s = i.a;
                return (s = Km(e, "getBoundingClientRect")) ? function() {
                    return s()[n]
                  }
                  : function() {
                    return (t ? fg["inner" + r] : e["client" + r]) || 0
                  }
              }(ue, pe, he), we = function(e, t) {
                return !t || ~Ym.indexOf(e) ? nv(e) : function() {
                  return dy
                }
              }(ue, pe), Ae = 0, Se = 0, Me = sg(ue, he);
              if (xe.media = Gg,
                xe._dir = he,
                $ *= 45,
                xe.scroller = ue,
                xe.scroll = ae ? ae.time.bind(ae) : Me,
                a = Me(),
                xe.vars = t,
                i = i || t.animation,
              "refreshPriority"in t && (Ig = 1,
              -9999 === t.refreshPriority && (Wg = xe)),
                de.tweenScroll = de.tweenScroll || {
                  top: gy(ue, ng),
                  left: gy(ue, ig)
                },
                xe.tweenTo = n = de.tweenScroll[he.p],
                xe.scrubDuration = function(e) {
                  (L = lv(e) && e) ? R ? R.duration(e) : R = dg.to(i, {
                    ease: "expo",
                    totalProgress: "+=0.001",
                    duration: L,
                    paused: !0,
                    onComplete: function() {
                      return ee && ee(xe)
                    }
                  }) : (R && R.progress(1).kill(),
                    R = 0)
                }
                ,
              i && (i.vars.lazy = !1,
              i._initted || !1 !== i.vars.immediateRender && !1 !== t.immediateRender && i.render(0, !0, !0),
                xe.animation = i.pause(),
                i.scrollTrigger = xe,
                xe.scrubDuration(q),
                D = 0,
              j || (j = i.vars.id)),
                zv.push(xe),
              ne && (hv(ne) && !ne.push || (ne = {
                snapTo: ne
              }),
              "scrollBehavior"in vg.style && dg.set(pe ? [vg, gg] : ue, {
                scrollBehavior: "auto"
              }),
                s = ov(ne.snapTo) ? ne.snapTo : "labels" === ne.snapTo ? function(e) {
                  return function(t) {
                    return dg.utils.snap(Ev(e), t)
                  }
                }(i) : "labelsDirectional" === ne.snapTo ? (G = i,
                    function(e, t) {
                      return Cv(Ev(G))(e, t.direction)
                    }
                ) : !1 !== ne.directional ? function(e, t) {
                    return Cv(ne.snapTo)(e, Xg() - Se < 500 ? 0 : t.direction)
                  }
                  : dg.utils.snap(ne.snapTo),
                k = ne.duration || {
                  min: .1,
                  max: 2
                },
                k = hv(k) ? bg(k.min, k.max) : bg(k, k),
                F = dg.delayedCall(ne.delay || L / 2 || .1, (function() {
                    var e = Me()
                      , t = Xg() - Se < 500
                      , r = n.tween;
                    if (!(t || Math.abs(xe.getVelocity()) < 10) || r || Mg || Ae === e)
                      xe.isActive && Ae !== e && F.restart(!0);
                    else {
                      var a = (e - l) / m
                        , o = i && !ce ? i.totalProgress() : a
                        , c = t ? 0 : (o - I) / (Xg() - wg) * 1e3 || 0
                        , u = dg.utils.clamp(-a, 1 - a, fv(c / 2) * c / .185)
                        , d = a + (!1 === ne.inertia ? 0 : u)
                        , p = bg(0, 1, s(d, xe))
                        , f = Math.round(l + p * m)
                        , g = ne
                        , v = g.onStart
                        , y = g.onInterrupt
                        , x = g.onComplete;
                      if (e <= h && e >= l && f !== e) {
                        if (r && !r._initted && r.data <= fv(f - e))
                          return;
                        !1 === ne.inertia && (u = p - a),
                          n(f, {
                            duration: k(fv(.185 * Math.max(fv(d - o), fv(p - o)) / c / .05 || 0)),
                            ease: ne.ease || "power3",
                            data: fv(f - e),
                            onInterrupt: function() {
                              return F.restart(!0) && y && y(xe)
                            },
                            onComplete: function() {
                              xe.update(),
                                Ae = Me(),
                                D = I = i && !ce ? i.totalProgress() : xe.progress,
                              te && te(xe),
                              x && x(xe)
                            }
                          }, e, u * m, f - e - u * m),
                        v && v(xe, n.tween)
                      }
                    }
                  }
                )).pause()),
              j && (Uv[j] = xe),
              (U = (Q = xe.trigger = rg(Q || K)) && Q._gsap && Q._gsap.stRevert) && (U = U(xe)),
                K = !0 === K ? Q : rg(K),
              av(W) && (W = {
                targets: Q,
                className: W
              }),
              K && (!1 === J || J === _v || (J = !(!J && "flex" === Av(K.parentNode).display) && xv),
                xe.pin = K,
              !1 !== t.force3D && dg.set(K, {
                force3D: !0
              }),
                (r = dg.core.getCache(K)).spacer ? g = r.pinState : (se && ((se = rg(se)) && !se.nodeType && (se = se.current || se.nativeElement),
                  r.spacerIsNative = !!se,
                se && (r.spacerState = uy(se))),
                  r.spacer = x = se || mg.createElement("div"),
                  x.classList.add("pin-spacer"),
                j && x.classList.add("pin-spacer-" + j),
                  r.pinState = g = uy(K)),
                xe.spacer = x = r.spacer,
                P = Av(K),
                M = P[J + he.os2],
                b = dg.getProperty(K),
                w = dg.quickSetter(K, he.a, wv),
                ly(K, x, P),
                y = uy(K)),
                ve) {
                f = hv(ve) ? Sv(ve, Lv) : Lv,
                  d = Ov("scroller-start", j, ue, he, f, 0),
                  p = Ov("scroller-end", j, ue, he, f, 0, d),
                  _ = d["offset" + he.op.d2];
                var Te = rg(Km(ue, "content") || ue);
                c = this.markerStart = Ov("start", j, Te, he, f, _, 0, ae),
                  u = this.markerEnd = Ov("end", j, Te, he, f, _, 0, ae),
                ae && (z = dg.quickSetter([c, u], he.a, wv)),
                fe || Ym.length && !0 === Km(ue, "fixedMarkers") || (function(e) {
                  var t = Av(e).position;
                  e.style.position = "absolute" === t || "fixed" === t ? t : "relative"
                }(pe ? vg : ue),
                  dg.set([d, p], {
                    force3D: !0
                  }),
                  E = dg.quickSetter(d, he.a, wv),
                  C = dg.quickSetter(p, he.a, wv))
              }
              if (ae) {
                var Ee = ae.vars.onUpdate
                  , Ce = ae.vars.onUpdateParams;
                ae.eventCallback("onUpdate", (function() {
                    xe.update(0, 0, 1),
                    Ee && Ee.apply(Ce || [])
                  }
                ))
              }
              xe.previous = function() {
                return zv[zv.indexOf(xe) - 1]
              }
                ,
                xe.next = function() {
                  return zv[zv.indexOf(xe) + 1]
                }
                ,
                xe.revert = function(e) {
                  var t = !1 !== e || !xe.enabled
                    , n = Sg;
                  t !== xe.isReverted && (t && (xe.scroll.rec || !Sg || !Hg || (xe.scroll.rec = Me()),
                    O = Math.max(Me(), xe.scroll.rec || 0),
                    B = xe.progress,
                    N = i && i.progress()),
                  c && [c, u, d, p].forEach((function(e) {
                      return e.style.display = t ? "none" : "block"
                    }
                  )),
                  t && (Sg = 1),
                    xe.update(t),
                    Sg = n,
                  K && (t ? function(e, t, i) {
                    cy(i);
                    var n = e._gsap;
                    if (n.spacerIsNative)
                      cy(n.spacerState);
                    else if (e.parentNode === t) {
                      var r = t.parentNode;
                      r && (r.insertBefore(e, t),
                        r.removeChild(t))
                    }
                  }(K, x, g) : (!re || !xe.isActive) && ly(K, x, Av(K), T)),
                    xe.isReverted = t)
                }
                ,
                xe.refresh = function(r, s) {
                  if (!Sg && xe.enabled || s)
                    if (K && r && qg)
                      Dv(e, "scrollEnd", Qv);
                    else {
                      !Hg && _e && _e(xe),
                        Sg = 1,
                        Se = Xg(),
                      n.tween && (n.tween.kill(),
                        n.tween = 0),
                      R && R.pause(),
                      Z && i && i.time(-.01, !0).invalidate(),
                      xe.isReverted || xe.revert();
                      for (var f, _, w, M, E, C, P, D, I, L, k = be(), z = we(), U = ae ? ae.duration() : rv(ue, he), G = 0, V = 0, H = t.end, W = t.endTrigger || Q, j = t.start || (0 !== t.start && Q ? K ? "0 0" : "0 100%" : 0), X = xe.pinnedContainer = t.pinnedContainer && rg(t.pinnedContainer), q = Q && Math.max(0, zv.indexOf(xe)) || 0, $ = q; $--; )
                        (C = zv[$]).end || C.refresh(0, 1) || (Sg = 1),
                        !(P = C.pin) || P !== Q && P !== K || C.isReverted || (L || (L = []),
                          L.unshift(C),
                          C.revert()),
                        C !== zv[$] && (q--,
                          $--);
                      for (ov(j) && (j = j(xe)),
                             l = py(j, Q, k, he, Me(), c, d, xe, z, ye, fe, U, ae) || (K ? -.001 : 0),
                           ov(H) && (H = H(xe)),
                           av(H) && !H.indexOf("+=") && (~H.indexOf(" ") ? H = (av(j) ? j.split(" ")[0] : "") + H : (G = Bv(H.substr(2), k),
                             H = av(j) ? j : l + G,
                             W = Q)),
                             h = Math.max(l, py(H || (W ? "100% 0" : U), W, k, he, Me() + G, u, p, xe, z, ye, fe, U, ae)) || -.001,
                             m = h - l || (l -= .01) && .001,
                             G = 0,
                             $ = q; $--; )
                        (P = (C = zv[$]).pin) && C.start - C._pinPush < l && !ae && C.end > 0 && (f = C.end - C.start,
                        P !== Q && P !== X || lv(j) || (G += f * (1 - C.progress)),
                        P === K && (V += f));
                      if (l += G,
                        h += G,
                        xe._pinPush = V,
                      c && G && ((f = {})[he.a] = "+=" + G,
                      X && (f[he.p] = "-=" + Me()),
                        dg.set([c, u], f)),
                        K)
                        f = Av(K),
                          M = he === ng,
                          w = Me(),
                          A = parseFloat(b(he.a)) + V,
                        !U && h > 1 && ((pe ? vg : ue).style["overflow-" + he.a] = "scroll"),
                          ly(K, x, f),
                          y = uy(K),
                          _ = Mv(K, !0),
                          D = fe && sg(ue, M ? ig : ng)(),
                        J && ((T = [J + he.os2, m + V + wv]).t = x,
                        ($ = J === xv ? Tv(K, he) + m + V : 0) && T.push(he.d, $ + wv),
                          cy(T),
                        fe && Me(O)),
                        fe && ((E = {
                          top: _.top + (M ? w - l : D) + wv,
                          left: _.left + (M ? D : w - l) + wv,
                          boxSizing: "border-box",
                          position: "fixed"
                        }).width = E.maxWidth = Math.ceil(_.width) + wv,
                          E.height = E.maxHeight = Math.ceil(_.height) + wv,
                          E.margin = E.marginTop = E.marginRight = E.marginBottom = E.marginLeft = "0",
                          E.padding = f.padding,
                          E.paddingTop = f.paddingTop,
                          E.paddingRight = f.paddingRight,
                          E.paddingBottom = f.paddingBottom,
                          E.paddingLeft = f.paddingLeft,
                          v = function(e, t, i) {
                            for (var n, r = [], s = e.length, a = i ? 8 : 0; a < s; a += 2)
                              n = e[a],
                                r.push(n, n in t ? t[n] : e[a + 1]);
                            return r.t = e.t,
                              r
                          }(g, E, re)),
                          i ? (I = i._initted,
                            Rg(1),
                            i.render(i.duration(), !0, !0),
                            S = b(he.a) - A + m + V,
                          m !== S && fe && v.splice(v.length - 2, 2),
                            i.render(0, !0, !0),
                          I || i.invalidate(),
                            Rg(0)) : S = m;
                      else if (Q && Me() && !ae)
                        for (_ = Q.parentNode; _ && _ !== vg; )
                          _._pinOffset && (l -= _._pinOffset,
                            h -= _._pinOffset),
                            _ = _.parentNode;
                      L && L.forEach((function(e) {
                          return e.revert(!1)
                        }
                      )),
                        xe.start = l,
                        xe.end = h,
                        a = o = Me(),
                      ae || (a < O && Me(O),
                        xe.scroll.rec = 0),
                        xe.revert(!1),
                      F && (Ae = -1,
                      xe.isActive && Me(l + m * B),
                        F.restart(!0)),
                        Sg = 0,
                      i && ce && (i._initted || N) && i.progress() !== N && i.progress(N, !0).render(i.time(), !0, !0),
                      (B !== xe.progress || ae) && (i && !ce && i.totalProgress(B, !0),
                        xe.progress = B,
                        xe.update(0, 0, 1)),
                      K && J && (x._pinOffset = Math.round(xe.progress * S)),
                      Y && Y(xe)
                    }
                }
                ,
                xe.getVelocity = function() {
                  return (Me() - o) / (Xg() - wg) * 1e3 || 0
                }
                ,
                xe.endAnimation = function() {
                  dv(xe.callbackAnimation),
                  i && (R ? R.progress(1) : i.paused() ? ce || dv(i, xe.direction < 0, 1) : dv(i, i.reversed()))
                }
                ,
                xe.labelToScroll = function(e) {
                  return i && i.labels && (l || xe.refresh() || l) + i.labels[e] / i.duration() * m || 0
                }
                ,
                xe.getTrailing = function(e) {
                  var t = zv.indexOf(xe)
                    , i = xe.direction > 0 ? zv.slice(0, t).reverse() : zv.slice(t + 1);
                  return (av(e) ? i.filter((function(t) {
                      return t.vars.preventOverlaps === e
                    }
                  )) : i).filter((function(e) {
                      return xe.direction > 0 ? e.end <= l : e.start >= h
                    }
                  ))
                }
                ,
                xe.update = function(e, t, r) {
                  if (!ae || r || e) {
                    var s, c, u, p, f, g, _, b = xe.scroll(), T = e ? 0 : (b - l) / m, P = T < 0 ? 0 : T > 1 ? 1 : T || 0, L = xe.progress;
                    if (t && (o = a,
                      a = ae ? Me() : b,
                    ne && (I = D,
                      D = i && !ce ? i.totalProgress() : P)),
                    $ && !P && K && !Sg && !jg && qg && l < b + (b - o) / (Xg() - wg) * $ && (P = 1e-4),
                    P !== L && xe.enabled) {
                      if (p = (f = (s = xe.isActive = !!P && P < 1) != (!!L && L < 1)) || !!P != !!L,
                        xe.direction = P > L ? 1 : -1,
                        xe.progress = P,
                      p && !Sg && (c = P && !L ? 0 : 1 === P ? 1 : 1 === L ? 2 : 3,
                      ce && (u = !f && "none" !== ge[c + 1] && ge[c + 1] || ge[c],
                        _ = i && ("complete" === u || "reset" === u || u in i))),
                      le && (f || _) && (_ || q || !i) && (ov(le) ? le(xe) : xe.getTrailing(le).forEach((function(e) {
                          return e.endAnimation()
                        }
                      ))),
                      ce || (!R || Sg || jg ? i && i.totalProgress(P, !!Sg) : ((ae || Wg && Wg !== xe) && R.render(R._dp._time - R._start),
                        R.resetTo ? R.resetTo("totalProgress", P, i._tTime / i._tDur) : (R.vars.totalProgress = P,
                          R.invalidate().restart()))),
                        K)
                        if (e && J && (x.style[J + he.os2] = M),
                          fe) {
                          if (p) {
                            if (g = !e && P > L && h + 1 > b && b + 1 >= rv(ue, he),
                              re)
                              if (e || !s && !g)
                                my(K, x);
                              else {
                                var k = Mv(K, !0)
                                  , B = b - l;
                                my(K, vg, k.top + (he === ng ? B : 0) + wv, k.left + (he === ng ? 0 : B) + wv)
                              }
                            cy(s || g ? v : y),
                            S !== m && P < 1 && s || w(A + (1 !== P || g ? 0 : S))
                          }
                        } else
                          w($g(A + S * P));
                      ne && !n.tween && !Sg && !jg && F.restart(!0),
                      W && (f || ie && P && (P < 1 || !zg)) && _g(W.targets).forEach((function(e) {
                          return e.classList[s || ie ? "add" : "remove"](W.className)
                        }
                      )),
                      H && !ce && !e && H(xe),
                        p && !Sg ? (ce && (_ && ("complete" === u ? i.pause().totalProgress(1) : "reset" === u ? i.restart(!0).pause() : "restart" === u ? i.restart(!0) : i[u]()),
                        H && H(xe)),
                        !f && zg || (X && f && pv(xe, X),
                        me[c] && pv(xe, me[c]),
                        ie && (1 === P ? xe.kill(!1, 1) : me[c] = 0),
                        f || me[c = 1 === P ? 1 : 3] && pv(xe, me[c])),
                        oe && !s && Math.abs(xe.getVelocity()) > (lv(oe) ? oe : 2500) && (dv(xe.callbackAnimation),
                          R ? R.progress(1) : dv(i, !P, 1))) : ce && H && !Sg && H(xe)
                    }
                    if (C) {
                      var O = ae ? b / ae.duration() * (ae._caScrollDist || 0) : b;
                      E(O + (d._isFlipped ? 1 : 0)),
                        C(O)
                    }
                    z && z(-b / ae.duration() * (ae._caScrollDist || 0))
                  }
                }
                ,
                xe.enable = function(t, i) {
                  xe.enabled || (xe.enabled = !0,
                    Dv(ue, "resize", Wv),
                    Dv(pe ? mg : ue, "scroll", Vv),
                  _e && Dv(e, "refreshInit", _e),
                  !1 !== t && (xe.progress = B = 0,
                    a = o = Ae = Me()),
                  !1 !== i && xe.refresh())
                }
                ,
                xe.getTween = function(e) {
                  return e && n ? n.tween : R
                }
                ,
                xe.setPositions = function(e, t) {
                  K && (A += e - l,
                    S += t - e - m),
                    xe.start = l = e,
                    xe.end = h = t,
                    m = t - e,
                    xe.update()
                }
                ,
                xe.disable = function(t, i) {
                  if (xe.enabled && (!1 !== t && xe.revert(),
                    xe.enabled = xe.isActive = !1,
                  i || R && R.pause(),
                    O = 0,
                  r && (r.uncache = 1),
                  _e && Iv(e, "refreshInit", _e),
                  F && (F.pause(),
                  n.tween && n.tween.kill() && (n.tween = 0)),
                    !pe)) {
                    for (var s = zv.length; s--; )
                      if (zv[s].scroller === ue && zv[s] !== xe)
                        return;
                    Iv(ue, "resize", Wv),
                      Iv(ue, "scroll", Vv)
                  }
                }
                ,
                xe.kill = function(e, n) {
                  xe.disable(e, n),
                  R && !n && R.kill(),
                  j && delete Uv[j];
                  var s = zv.indexOf(xe);
                  s >= 0 && zv.splice(s, 1),
                  s === Eg && ry > 0 && Eg--,
                    s = 0,
                    zv.forEach((function(e) {
                        return e.scroller === xe.scroller && (s = 1)
                      }
                    )),
                  s || (xe.scroll.rec = 0),
                  i && (i.scrollTrigger = null,
                  e && i.render(-1),
                  n || i.kill()),
                  c && [c, u, d, p].forEach((function(e) {
                      return e.parentNode && e.parentNode.removeChild(e)
                    }
                  )),
                  Wg === xe && (Wg = 0),
                  K && (r && (r.uncache = 1),
                    s = 0,
                    zv.forEach((function(e) {
                        return e.pin === K && s++
                      }
                    )),
                  s || (r.spacer = 0)),
                  t.onKill && t.onKill(xe)
                }
                ,
                xe.enable(!1, !1),
              U && U(xe),
                i && i.add && !m ? dg.delayedCall(.01, (function() {
                    return l || h || xe.refresh()
                  }
                )) && (m = .01) && (l = h = 0) : xe.refresh()
            } else
              this.update = this.refresh = this.kill = Zg
          }
            ,
            e.register = function(t) {
              return pg || (dg = t || tv(),
              ev() && window.document && e.enable(),
                pg = Qg),
                pg
            }
            ,
            e.defaults = function(e) {
              if (e)
                for (var t in e)
                  kv[t] = e[t];
              return kv
            }
            ,
            e.disable = function(e, t) {
              Qg = 0,
                zv.forEach((function(i) {
                    return i[t ? "kill" : "disable"](e)
                  }
                )),
                Iv(fg, "wheel", Vv),
                Iv(mg, "scroll", Vv),
                clearInterval(Ag),
                Iv(mg, "touchcancel", Zg),
                Iv(vg, "touchstart", Zg),
                Pv(Iv, mg, "pointerdown,touchstart,mousedown", Kg),
                Pv(Iv, mg, "pointerup,touchend,mouseup", Jg),
                xg.kill(),
                sv(Iv);
              for (var i = 0; i < Xm.length; i += 3)
                Rv(Iv, Xm[i], Xm[i + 1]),
                  Rv(Iv, Xm[i], Xm[i + 2])
            }
            ,
            e.enable = function() {
              if (fg = window,
                mg = document,
                gg = mg.documentElement,
                vg = mg.body,
              dg && (_g = dg.utils.toArray,
                bg = dg.utils.clamp,
                Rg = dg.core.suppressOverwrites || Zg,
                dg.core.globals("ScrollTrigger", e),
                vg)) {
                Qg = 1,
                  ug.register(dg),
                  e.isTouch = ug.isTouch,
                  Ng = ug.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent),
                  Dv(fg, "wheel", Vv),
                  yg = [fg, mg, gg, vg],
                  e.matchMedia({
                    "(orientation: portrait)": function() {
                      return Hv(),
                        Hv
                    }
                  }),
                  Dv(mg, "scroll", Vv);
                var t, i, n = vg.style, r = n.borderTopStyle;
                for (n.borderTopStyle = "solid",
                       t = Mv(vg),
                       ng.m = Math.round(t.top + ng.sc()) || 0,
                       ig.m = Math.round(t.left + ig.sc()) || 0,
                       r ? n.borderTopStyle = r : n.removeProperty("border-top-style"),
                       Ag = setInterval(Gv, 250),
                       dg.delayedCall(.5, (function() {
                           return jg = 0
                         }
                       )),
                       Dv(mg, "touchcancel", Zg),
                       Dv(vg, "touchstart", Zg),
                       Pv(Dv, mg, "pointerdown,touchstart,mousedown", Kg),
                       Pv(Dv, mg, "pointerup,touchend,mouseup", Jg),
                       Tg = dg.utils.checkPrefix("transform"),
                       oy.push(Tg),
                       pg = Xg(),
                       xg = dg.delayedCall(.2, iy).pause(),
                       Dg = [mg, "visibilitychange", function() {
                         var e = fg.innerWidth
                           , t = fg.innerHeight;
                         mg.hidden ? (Cg = e,
                           Pg = t) : Cg === e && Pg === t || Wv()
                       }
                         , mg, "DOMContentLoaded", iy, fg, "load", iy, fg, "resize", Wv],
                       sv(Dv),
                       zv.forEach((function(e) {
                           return e.enable(0, 1)
                         }
                       )),
                       i = 0; i < Xm.length; i += 3)
                  Rv(Iv, Xm[i], Xm[i + 1]),
                    Rv(Iv, Xm[i], Xm[i + 2])
              }
            }
            ,
            e.config = function(t) {
              "limitCallbacks"in t && (zg = !!t.limitCallbacks);
              var i = t.syncInterval;
              i && clearInterval(Ag) || (Ag = i) && setInterval(Gv, i),
              "ignoreMobileResize"in t && (Fg = 1 === e.isTouch && t.ignoreMobileResize),
              "autoRefreshEvents"in t && (sv(Iv) || sv(Dv, t.autoRefreshEvents || "none"),
                Lg = -1 === (t.autoRefreshEvents + "").indexOf("resize"))
            }
            ,
            e.scrollerProxy = function(e, t) {
              var i = rg(e)
                , n = Xm.indexOf(i)
                , r = iv(i);
              ~n && Xm.splice(n, r ? 6 : 2),
              t && (r ? Ym.unshift(fg, t, vg, t, gg, t) : Ym.unshift(i, t))
            }
            ,
            e.matchMedia = function(e) {
              var t, i, n, r, s;
              for (i in e)
                n = Yv.indexOf(i),
                  r = e[i],
                  Gg = i,
                  "all" === i ? r() : (t = fg.matchMedia(i)) && (t.matches && (s = r()),
                    ~n ? (Yv[n + 1] = uv(Yv[n + 1], r),
                      Yv[n + 2] = uv(Yv[n + 2], s)) : (n = Yv.length,
                      Yv.push(i, r, s),
                      t.addListener ? t.addListener(qv) : t.addEventListener("change", qv)),
                    Yv[n + 3] = t.matches),
                  Gg = 0;
              return Yv
            }
            ,
            e.clearMatchMedia = function(e) {
              e || (Yv.length = 0),
              (e = Yv.indexOf(e)) >= 0 && Yv.splice(e, 4)
            }
            ,
            e.isInViewport = function(e, t, i) {
              var n = (av(e) ? rg(e) : e).getBoundingClientRect()
                , r = n[i ? vv : yv] * t || 0;
              return i ? n.right - r > 0 && n.left + r < fg.innerWidth : n.bottom - r > 0 && n.top + r < fg.innerHeight
            }
            ,
            e.positionInViewport = function(e, t, i) {
              av(e) && (e = rg(e));
              var n = e.getBoundingClientRect()
                , r = n[i ? vv : yv]
                , s = null == t ? r / 2 : t in Fv ? Fv[t] * r : ~t.indexOf("%") ? parseFloat(t) * r / 100 : parseFloat(t) || 0;
              return i ? (n.left + s) / fg.innerWidth : (n.top + s) / fg.innerHeight
            }
            ,
            e
        }();
        vy.version = "3.10.4",
          vy.saveStyles = function(e) {
            return e ? _g(e).forEach((function(e) {
                if (e && e.style) {
                  var t = Jv.indexOf(e);
                  t >= 0 && Jv.splice(t, 5),
                    Jv.push(e, e.style.cssText, e.getBBox && e.getAttribute("transform"), dg.core.getCache(e), Gg)
                }
              }
            )) : Jv
          }
          ,
          vy.revert = function(e, t) {
            return $v(!e, t)
          }
          ,
          vy.create = function(e, t) {
            return new vy(e,t)
          }
          ,
          vy.refresh = function(e) {
            return e ? Wv() : (pg || vy.register()) && iy(!0)
          }
          ,
          vy.update = sy,
          vy.clearScrollMemory = ey,
          vy.maxScroll = function(e, t) {
            return rv(e, t ? ig : ng)
          }
          ,
          vy.getScrollFunc = function(e, t) {
            return sg(rg(e), t ? ig : ng)
          }
          ,
          vy.getById = function(e) {
            return Uv[e]
          }
          ,
          vy.getAll = function() {
            return zv.filter((function(e) {
                return "ScrollSmoother" !== e.vars.id
              }
            ))
          }
          ,
          vy.isScrolling = function() {
            return !!qg
          }
          ,
          vy.snapDirectional = Cv,
          vy.addEventListener = function(e, t) {
            var i = jv[e] || (jv[e] = []);
            ~i.indexOf(t) || i.push(t)
          }
          ,
          vy.removeEventListener = function(e, t) {
            var i = jv[e]
              , n = i && i.indexOf(t);
            n >= 0 && i.splice(n, 1)
          }
          ,
          vy.batch = function(e, t) {
            var i, n = [], r = {}, s = t.interval || .016, a = t.batchMax || 1e9, o = function(e, t) {
              var i = []
                , n = []
                , r = dg.delayedCall(s, (function() {
                  t(i, n),
                    i = [],
                    n = []
                }
              )).pause();
              return function(e) {
                i.length || r.restart(!0),
                  i.push(e.trigger),
                  n.push(e),
                a <= i.length && r.progress(1)
              }
            };
            for (i in t)
              r[i] = "on" === i.substr(0, 2) && ov(t[i]) && "onRefreshInit" !== i ? o(0, t[i]) : t[i];
            return ov(a) && (a = a(),
              Dv(vy, "refresh", (function() {
                  return a = t.batchMax()
                }
              ))),
              _g(e).forEach((function(e) {
                  var t = {};
                  for (i in r)
                    t[i] = r[i];
                  t.trigger = e,
                    n.push(vy.create(t))
                }
              )),
              n
          }
        ;
        var yy, xy = function(e, t, i, n) {
          return t > n ? e(n) : t < 0 && e(0),
            i > n ? (n - t) / (i - t) : i < 0 ? t / (t - i) : 1
        }, _y = function e(t, i) {
          !0 === i ? t.style.removeProperty("touch-action") : t.style.touchAction = !0 === i ? "auto" : i ? "pan-" + i + (ug.isTouch ? " pinch-zoom" : "") : "none",
          t === gg && e(vg, i)
        }, by = {
          auto: 1,
          scroll: 1
        }, wy = function(e) {
          var t, i = e.event, n = e.target, r = e.axis, s = (i.changedTouches ? i.changedTouches[0] : i).target, a = s._gsap || dg.core.getCache(s), o = Xg();
          if (!a._isScrollT || o - a._isScrollT > 2e3) {
            for (; s && s.scrollHeight <= s.clientHeight; )
              s = s.parentNode;
            a._isScroll = s && !iv(s) && s !== n && (by[(t = Av(s)).overflowY] || by[t.overflowX]),
              a._isScrollT = o
          }
          (a._isScroll || "x" === r) && (i._gsapAllow = !0)
        }, Ay = function(e, t, i, n) {
          return ug.create({
            target: e,
            capture: !0,
            debounce: !1,
            lockAxis: !0,
            type: t,
            onWheel: n = n && wy,
            onPress: n,
            onDrag: n,
            onScroll: n,
            onEnable: function() {
              return i && Dv(mg, ug.eventTypes[0], My, !1, !0)
            },
            onDisable: function() {
              return Iv(mg, ug.eventTypes[0], My, !0)
            }
          })
        }, Sy = /(input|label|select|textarea)/i, My = function(e) {
          var t = Sy.test(e.target.tagName);
          (t || yy) && (e._gsapAllow = !0,
            yy = t)
        };
        vy.sort = function(e) {
          return zv.sort(e || function(e, t) {
            return -1e6 * (e.vars.refreshPriority || 0) + e.start - (t.start + -1e6 * (t.vars.refreshPriority || 0))
          }
          )
        }
          ,
          vy.observe = function(e) {
            return new ug(e)
          }
          ,
          vy.normalizeScroll = function(e) {
            if (void 0 === e)
              return kg;
            if (!0 === e && kg)
              return kg.enable();
            if (!1 === e)
              return kg && kg.kill();
            var t = e instanceof ug ? e : function(e) {
              hv(e) || (e = {}),
                e.preventDefault = e.isNormalizer = e.allowClicks = !0,
              e.type || (e.type = "wheel,touch"),
                e.debounce = !!e.debounce,
                e.id = e.id || "normalizer";
              var t, i, n, r, s, a, o, l, h = e, c = h.normalizeScrollX, u = h.momentum, d = h.allowNestedScroll, p = rg(e.target) || gg, f = dg.core.globals().ScrollSmoother, m = Ng && (e.content && rg(e.content) || f && f.get() && f.get().content()), g = sg(p, ng), v = sg(p, ig), y = 1, x = (ug.isTouch && fg.visualViewport ? fg.visualViewport.scale * fg.visualViewport.width : fg.outerWidth) / fg.innerWidth, _ = 0, b = ov(u) ? function() {
                  return u(t)
                }
                : function() {
                  return u || 2.8
                }
                , w = Ay(p, e.type, !0, d), A = function() {
                return n = !1
              }, S = Zg, M = Zg, T = function() {
                i = rv(p, ng),
                  M = bg(Ng ? 1 : 0, i),
                c && (S = bg(0, rv(p, ig))),
                  r = ty
              }, E = function() {
                T(),
                s.isActive() && s.vars.scrollY > i && (g() > i ? s.progress(1) && g(i) : s.resetTo("scrollY", i))
              };
              return e.ignoreCheck = function(e) {
                return Ng && "touchmove" === e.type && function() {
                  if (n) {
                    requestAnimationFrame(A);
                    var e = $g(t.deltaY / 2)
                      , i = M(g.v - e);
                    return m && i !== g.v + g.offset && (g.offset = i - g.v,
                      m.style.transform = "translateY(" + -g.offset + "px)",
                    m._gsap && (m._gsap.y = -g.offset + "px"),
                      g.cacheID = Xm.cache,
                      sy()),
                      !0
                  }
                  m && (m.style.transform = "translateY(0px)",
                    g.offset = g.cacheID = 0,
                  m._gsap && (m._gsap.y = "0px")),
                    n = !0
                }() || y > 1.05 && "touchstart" !== e.type || t.isGesturing || e.touches && e.touches.length > 1
              }
                ,
                e.onPress = function() {
                  var e = y;
                  y = $g((fg.visualViewport && fg.visualViewport.scale || 1) / x),
                    s.pause(),
                  e !== y && _y(p, y > 1.01 || !c && "x"),
                    n = !1,
                    a = v(),
                    o = g(),
                    T(),
                    r = ty
                }
                ,
                e.onRelease = e.onGestureStart = function(e, t) {
                  if (m && (m.style.transform = "translateY(0px)",
                    g.offset = g.cacheID = 0,
                  m._gsap && (m._gsap.y = "0px")),
                    t) {
                    Xm.cache++;
                    var n, r, a = b();
                    c && (r = (n = v()) + .05 * a * -e.velocityX / .227,
                      a *= xy(v, n, r, rv(p, ig)),
                      s.vars.scrollX = S(r)),
                      r = (n = g()) + .05 * a * -e.velocityY / .227,
                      a *= xy(g, n, r, rv(p, ng)),
                      s.vars.scrollY = M(r),
                      s.invalidate().duration(a).play(.01),
                    (Ng && s.vars.scrollY >= i || n >= i - 1) && dg.to({}, {
                      onUpdate: E,
                      duration: a
                    })
                  } else
                    l.restart(!0)
                }
                ,
                e.onWheel = function() {
                  s._ts && s.pause(),
                  Xg() - _ > 1e3 && (r = 0,
                    _ = Xg())
                }
                ,
                e.onChange = function(e, t, i, n, s) {
                  ty !== r && T(),
                  t && c && v(S(n[2] === t ? a + (e.startX - e.x) : v() + t - n[1])),
                  i && g(M(s[2] === i ? o + (e.startY - e.y) : g() + i - s[1])),
                    sy()
                }
                ,
                e.onEnable = function() {
                  _y(p, !c && "x"),
                    Dv(fg, "resize", E),
                    w.enable()
                }
                ,
                e.onDisable = function() {
                  _y(p, !0),
                    Iv(fg, "resize", E),
                    w.kill()
                }
                ,
                (t = new ug(e)).iOS = Ng,
              Ng && !g() && g(1),
                l = t._dc,
                s = dg.to(t, {
                  ease: "power4",
                  paused: !0,
                  scrollX: c ? "+=0.1" : "+=0",
                  scrollY: "+=0.1",
                  onComplete: l.vars.onComplete
                }),
                t
            }(e);
            return kg && kg.target === t.target && kg.kill(),
            iv(t.target) && (kg = t),
              t
          }
          ,
          vy.core = {
            _getVelocityProp: ag,
            _inputObserver: Ay,
            _scrollers: Xm,
            _proxies: Ym,
            bridge: {
              ss: function() {
                qg || Kv("scrollStart"),
                  qg = Xg()
              },
              ref: function() {
                return Sg
              }
            }
          },
        tv() && dg.registerPlugin(vy);
        class Ty {
          static init() {
            this.music = new Audio(__webpack_require__(689)),
              this.music.volume = this.music.initVolume = .3,
              this.music.loop = !0,
              this.click = new Audio(__webpack_require__(966)),
              this.click.volume = this.click.initVolume = .3,
              this.woosh1 = new Audio(__webpack_require__(690)),
              this.woosh1.volume = this.woosh1.initVolume = .3,
              this.woosh2 = new Audio(__webpack_require__(783)),
              this.woosh2.volume = this.woosh2.initVolume = .3,
              this.local_storage_item = "atmos-mute",
              this.musicPlaying = !1,
              this.btn = document.querySelector(".sound-btn"),
              this.spans = Array.from(this.btn.querySelectorAll("span")),
              this.spans_animations = [],
              this.btn.addEventListener("click", (()=>{
                  this.musicPlaying ? (localStorage.setItem(this.local_storage_item, "true"),
                    this.btn.classList.remove("sound-btn--on"),
                    this.pauseMusic()) : "false" == localStorage.getItem(this.local_storage_item) ? (localStorage.setItem(this.local_storage_item, "true"),
                    this.btn.classList.remove("sound-btn--on")) : (localStorage.setItem(this.local_storage_item, "false"),
                    this.btn.classList.add("sound-btn--on"),
                  document.querySelector(".overlay-item--intro") || this.playMusic())
                }
              )),
              document.addEventListener("visibilitychange", (()=>{
                  "visible" === document.visibilityState ? this.music.volume = this.music.initVolume : this.music.volume = 0
                }
              ))
          }
          static _canPlay() {
            return !localStorage.getItem(this.local_storage_item) || "false" == localStorage.getItem(this.local_storage_item)
          }
          static playFx(e) {
            this._canPlay() && (this[e].currentTime = 0,
              this[e].play())
          }
          static startBtnAnimation() {
            this.spans_animations.forEach((e=>{
                e.pause(),
                  e.kill()
              }
            )),
              this.spans_animations = [],
              this.spans.forEach(((e,t)=>{
                  let i = _n.fromTo(e, {
                    scaleY: .1
                  }, {
                    scaleY: 1,
                    delay: t / 5,
                    yoyo: !0,
                    repeat: -1,
                    duration: 1.5,
                    ease: "power1.inOut"
                  });
                  this.spans_animations.push(i)
                }
              ))
          }
          static stopBtnAnimation() {
            this.spans_animations.forEach((e=>{
                e.pause(),
                  e.kill()
              }
            )),
              this.spans_animations = [],
              this.spans.forEach(((e,t)=>{
                  let i = _n.to(e, {
                    scaleY: .1,
                    duration: 1,
                    ease: "power1.inOut"
                  });
                  this.spans_animations.push(i)
                }
              ))
          }
          static playMusic() {
            this._canPlay() && (this.startBtnAnimation(),
              _n.to(this.music, {
                volume: this.music.initVolume,
                duration: 1,
                ease: "none"
              }),
              this.music.play(),
              this.musicPlaying = !0)
          }
          static pauseMusic() {
            this.stopBtnAnimation(),
              _n.to(this.music, {
                volume: 0,
                duration: 1,
                ease: "none",
                onComplete: ()=>{
                  this.music.pause()
                }
              }),
              this.musicPlaying = !1
          }
        }
        _n.registerPlugin(vy);
        class Ey {
          static init() {
            for (let e in t)
              this[e] = t[e];
            this.scene = tf.scene_about,
              this.camera = tf.camera,
              this.passes = [tf.renderPassAbout, tf.renderSavePass, tf.blurPass, tf.blurSavePass, tf.transitionPass, tf.effectPass],
              this.exitRef = this.exit.bind(this),
              this.sky = Py.sky.clone(),
              this.sky.material = this.sky.material.clone(),
              this.sky.material.uniforms.uGradientMixer.value = .01,
              this.sky.rotation.x = .1 * -Math.PI,
              this.scene.add(this.sky),
              this.plane = Py.plane.clone(),
              this.plane.material = Py.plane.material.clone(),
              this.scene.add(this.plane),
              this.light = Py.light.clone(),
              this.scene.add(this.light),
              this.scroller = new ym({
                range: [0, 2500],
                lerpAmount: .1,
                lerpAmountSwipe: .2,
                mobileSensibility: .6
              }),
              this.scroller.active = !1,
              this.visible = !1,
              this.unproject_direction = new ts(0,0,0),
              this.dom = document.querySelector(".about"),
              this.domHeight = this.dom.offsetHeight,
              this.windowHeight = window.innerHeight,
              window.addEventListener("resize", (()=>{
                  this.domHeight = this.dom.offsetHeight,
                    this.windowHeight = window.innerHeight
                }
              )),
              this.updateRef = this.update.bind(this),
              this.dom = document.querySelector(".about"),
              this.atmos_title = document.querySelector(".intro__title"),
              this.y_dynamics = {
                value: -.5
              },
              this.x_position = window.innerWidth > 1e3 ? -.4 : 0,
              this.dummy = {
                value: 1
              },
              this.x_dynamics = {
                value: this.dummy.value * this.x_position
              },
              window.addEventListener("resize", (()=>{
                  this.x_position = window.innerWidth > 1e3 ? -.4 : 0,
                    this.x_dynamics.value = this.dummy.value * this.x_position
                }
              )),
              this.onEnter((()=>{
                  this.visible = !0,
                    this.update_title_opacity = !0,
                    this.startUpdate(),
                    document.querySelector(".outro").classList.remove("outro--in"),
                    document.querySelector(".vsh-scrollbar-1").classList.add("vsh-scrollbar-1--in"),
                    document.querySelector(".about-btn").classList.remove("about-btn--in"),
                    document.querySelector(".close-btn").classList.remove("close-btn--out"),
                    document.querySelector(".close-btn").classList.add("close-btn--in"),
                    this.distance_factor = {
                      value: 50
                    },
                    this.y_dynamics.value = -.5,
                    this.x_dynamics.value = 0,
                    _n.to(this.distance_factor, {
                      value: 20,
                      duration: 3,
                      ease: "power2.out"
                    }),
                    _n.to(this.y_dynamics, {
                      value: 0,
                      duration: 3,
                      ease: "power2.out"
                    }),
                    _n.to(this.dummy, {
                      value: 1,
                      duration: 3,
                      ease: "power2.out",
                      onUpdate: ()=>{
                        this.x_dynamics.value = this.dummy.value * this.x_position
                      }
                    })
                }
              )),
              this.onBeforeLeave((()=>{
                  this.visible = !1,
                    document.querySelector(".close-btn").classList.add("close-btn--out"),
                    setTimeout((()=>{
                        document.querySelector(".close-btn").classList.remove("close-btn--in"),
                          document.querySelector(".about-btn").classList.add("about-btn--in")
                      }
                    ), 1500),
                    document.querySelector(".vsh-scrollbar-1").classList.remove("vsh-scrollbar-1--in"),
                    _n.to(this.distance_factor, {
                      value: 10,
                      duration: 2,
                      ease: "power2.in"
                    }),
                    _n.to(this.y_dynamics, {
                      value: 1,
                      duration: 2,
                      ease: "power2.in"
                    }),
                    this.update_title_opacity = !1,
                    _n.to(this.atmos_title, {
                      opacity: 1,
                      duration: 1,
                      delay: .5,
                      ease: "none"
                    })
                }
              )),
              this.onLeave((()=>{
                  this.stopUpdate(),
                    this.dom.classList.remove("about--in")
                }
              ))
          }
          static domIntro() {
            _n.set(".about", {
              opacity: 1
            }),
              _n.set([".about__h2-ref", ".reference", ".about__h2-xp", ".about__p", ".about__h2-leeroy", ".about__p-leeroy", ".about__p-music"], {
                opacity: 0,
                y: 20
              }),
              _n.set(["source-link"], {
                opacity: 0,
                x: 20
              });
            let e = _n.timeline({
              delay: 1,
              defaults: {
                ease: "power2.out",
                duration: 1,
                y: 0,
                x: 0,
                opacity: 1
              }
            });
            e.to(".about__p", {}, "<+=.2"),
              e.to(".about__h2-ref", {}, "<+=.2"),
              e.to(".reference", {
                stagger: .05,
                duration: 1
              }, "<+=.2"),
              e.to("source-link", {
                stagger: .05,
                duration: 1
              }, "<+=.5"),
              e.to(".about__h2-leeroy", {}, ">-=1"),
              e.to(".about__p-leeroy", {}, "<+=.2"),
              e.to(".about__p-music", {}, "<+=.2")
          }
          static domOutro() {
            _n.to(".about", {
              opacity: 0,
              duration: 1,
              ease: "none "
            })
          }
          static startUpdate() {
            this.scroller.goTo(0, !1),
              this.scroller.active = !0,
              this.dom.classList.add("about--in"),
              this.domIntro(),
              _n.ticker.add(this.updateRef)
          }
          static stopUpdate() {
            this.scroller.active = !1,
              _n.ticker.remove(this.updateRef)
          }
          static update(e) {
            this.scroller.update();
            let t = this.x_dynamics.value + .05 * Math.sin(.4 * e)
              , i = .18 * Math.sin(.6 * e) + this.y_dynamics.value
              , n = this.unproject_direction.set(t, i, 0).unproject(this.camera)
              , r = n.clone().sub(this.camera.position).multiplyScalar(this.distance_factor.value)
              , s = n.clone().add(r);
            this.plane.position.copy(s),
              this.sky.position.copy(this.camera.position),
              this.handleScroll();
            for (let e = 0; e < Py.soundBtnSpans.length; e++)
              Py.soundBtnSpans[e].style.backgroundColor = "#ffffff"
          }
          static display() {
            tf.compose(this.passes),
              document.querySelector(".close-btn").addEventListener("click", this.exitRef, {
                once: !0
              })
          }
          static exit() {
            Ty.playFx("click"),
              Ty.playFx("woosh2"),
              this.domOutro(),
              this.beforeLeave(),
              Py.enter(),
              tf.transition(this.passes, Py.passes, {
                pingpong: !1,
                endWithPasses2: !1,
                onComplete: ()=>{
                  this.leave(),
                    Py.display()
                }
                ,
                direction: 0
              })
          }
          static handleScroll() {
            this.dom.style.transform = `translateY(${this.scroller.completion * -(this.domHeight - this.windowHeight)}px)`,
            this.update_title_opacity && (this.atmos_title.style.opacity = Math.max(0, 1 - 10 * this.scroller.completion))
          }
        }
        function Cy() {
          this.scroller.active = !1,
            document.querySelector(".vsh-scrollbar-0").classList.remove("vsh-scrollbar-0--in"),
            document.querySelector(".outro").classList.add("transition"),
            this.ended ? setTimeout((()=>{
                Ey.visible || document.querySelector(".outro").classList.add("outro--in")
              }
            ), 500) : (setTimeout((()=>{
                Ey.visible || document.querySelector(".outro").classList.add("outro--in")
              }
            ), 2e3),
              _n.to(this.plane.position, {
                z: "-=20",
                y: "+=5",
                ease: "power2.in",
                duration: 2
              }),
              _n.to(this.plane.rotation, {
                x: "+=.3",
                ease: "power2.in",
                duration: 2
              }),
              _n.to([this.plane.material, this.curveMesh.material], {
                opacity: 0,
                ease: "power2.in",
                duration: 2
              }),
              _n.to(this.camera.position, {
                y: "+=5",
                ease: "power2.inOut",
                duration: 3.5
              }),
              _n.to(this.camera.rotation, {
                x: "+=.2",
                ease: "power2.inOut",
                duration: 3.5
              }),
              this.ended = !0)
        }
        class Py {
          static init() {
            this.ready = !1;
            for (let e in t)
              this[e] = t[e];
            this.scene = tf.scene,
              this.camera = tf.camera,
              this.passes = [tf.renderPass, tf.renderSavePass, tf.blurPass, tf.blurSavePass, tf.transitionPass, tf.effectPass],
              this.curve_size_factor = 2.5,
              this.hint = !0,
              this.addLight = nf,
              this.addLight(),
              this.addCurve = uf,
              this.addCurve(),
              this.addSky = cf,
              this.addSky(),
              this.addText = hm,
              this.addText(),
              this.addPlane = df,
              this.addPlane(),
              this.addClouds = dm,
              this.addClouds(),
              this.end = Cy,
              this.addWindParticles = Pm,
              this.addWindParticles(),
              this.handleProgress = Mm,
              this.handleProgress(),
              this.addBonus = pm,
              this.addBonus(),
              this.onBeforeLeave((()=>{
                  document.querySelector(".vsh-scrollbar-0").classList.remove("vsh-scrollbar-0--in")
                }
              )),
              this.onEnter((()=>{
                  document.querySelector(".vsh-scrollbar-0").classList.add("vsh-scrollbar-0--in")
                }
              ))
          }
          static display() {
            tf.compose(this.passes),
              document.querySelector(".about-btn").addEventListener("click", (()=>{
                  Ty.playFx("click"),
                    Ty.playFx("woosh2"),
                    document.querySelector(".hint").classList.add("hint--out"),
                    this.beforeLeave(),
                    Ey.enter(),
                    tf.transition(this.passes, Ey.passes, {
                      pingpong: !1,
                      endWithPasses2: !1,
                      onComplete: ()=>{
                        this.leave(),
                          Ey.display()
                      }
                    })
                }
              ), {
                once: !0
              })
          }
        }
        var Dy = __webpack_require__(248)
          , Iy = __webpack_require__.n(Dy);
        const Ry = {
          init: e=>{
            (class {
                static init(e) {
                  bn.canvas = "string" == typeof e ? document.querySelector(e) : e,
                    Vp = new Yh({
                      canvas: bn.canvas,
                      powerPreference: "high-performance",
                      antialias: !1,
                      stencil: !1,
                      depth: !1,
                      alpha: !0
                    }),
                    "desktop" == Gp() ? Vp.setPixelRatio(1) : (Vp.setPixelRatio(Math.min(window.devicePixelRatio, 2)),
                      window.addEventListener("resize", (()=>{
                          Vp.setPixelRatio(Math.min(window.devicePixelRatio, 2))
                        }
                      )));
                  let t = new gu;
                  t.itemStart("gpuTier"),
                    t.itemStart("assets_loading"),
                    t.onLoad = this.start.bind(this),
                    (async()=>{
                        const e = await (({mobileTiers: e=[0, 15, 30, 60], desktopTiers: t=[0, 15, 30, 60], override: i={}, glContext: n, failIfMajorPerformanceCaveat: r=!1, benchmarksURL: s="https://unpkg.com/detect-gpu@4.0.25/dist/benchmarks"}={})=>wn(void 0, void 0, void 0, (function*() {
                            const a = {};
                            if (Mn)
                              return {
                                tier: 0,
                                type: "SSR"
                              };
                            const {isIpad: o=!!(null == Tn ? void 0 : Tn.isIpad), isMobile: l=!!(null == Tn ? void 0 : Tn.isMobile), screenSize: h=window.screen, loadBenchmarks: c=(e=>wn(void 0, void 0, void 0, (function*() {
                                const t = yield fetch(`${s}/${e}`).then((e=>e.json()));
                                if (parseInt(t.shift().split(".")[0], 10) < 4)
                                  throw new In("Detect GPU benchmark data is out of date. Please update to version 4x");
                                return t
                              }
                            )))} = i;
                            let {renderer: u} = i;
                            const d = (e,t,i,n,r)=>({
                              device: r,
                              fps: n,
                              gpu: i,
                              isMobile: l,
                              tier: e,
                              type: t
                            });
                            let p, f = "";
                            if (u)
                              u = Sn(u),
                                p = [u];
                            else {
                              const e = n || function(e, t=!1) {
                                const i = {
                                  alpha: !1,
                                  antialias: !1,
                                  depth: !1,
                                  failIfMajorPerformanceCaveat: t,
                                  powerPreference: "high-performance",
                                  stencil: !1
                                };
                                e && delete i.powerPreference;
                                const n = window.document.createElement("canvas")
                                  , r = n.getContext("webgl", i) || n.getContext("experimental-webgl", i);
                                return null != r ? r : void 0
                              }(null == Tn ? void 0 : Tn.isSafari12, r);
                              if (!e)
                                return d(0, "WEBGL_UNSUPPORTED");
                              const t = e.getExtension("WEBGL_debug_renderer_info");
                              if (t && (u = e.getParameter(t.UNMASKED_RENDERER_WEBGL)),
                                !u)
                                return d(1, "FALLBACK");
                              f = u,
                                u = Sn(u),
                                p = function(e, t, i) {
                                  return "apple gpu" === t ? function(e, t, i) {
                                    if (!i)
                                      return [t];
                                    const n = function(e) {
                                      const t = e.createShader(35633)
                                        , i = e.createShader(35632)
                                        , n = e.createProgram();
                                      if (!(i && t && n))
                                        return;
                                      e.shaderSource(t, "\n    precision highp float;\n    attribute vec3 aPosition;\n    varying float vvv;\n    void main() {\n      vvv = 0.31622776601683794;\n      gl_Position = vec4(aPosition, 1.0);\n    }\n  "),
                                        e.shaderSource(i, "\n    precision highp float;\n    varying float vvv;\n    void main() {\n      vec4 enc = vec4(1.0, 255.0, 65025.0, 16581375.0) * vvv;\n      enc = fract(enc);\n      enc -= enc.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\n      gl_FragColor = enc;\n    }\n  "),
                                        e.compileShader(t),
                                        e.compileShader(i),
                                        e.attachShader(n, t),
                                        e.attachShader(n, i),
                                        e.linkProgram(n),
                                        e.detachShader(n, t),
                                        e.detachShader(n, i),
                                        e.deleteShader(t),
                                        e.deleteShader(i),
                                        e.useProgram(n);
                                      const r = e.createBuffer();
                                      e.bindBuffer(34962, r),
                                        e.bufferData(34962, new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]), 35044);
                                      const s = e.getAttribLocation(n, "aPosition");
                                      e.vertexAttribPointer(s, 3, 5126, !1, 0, 0),
                                        e.enableVertexAttribArray(s),
                                        e.clearColor(1, 1, 1, 1),
                                        e.clear(16384),
                                        e.viewport(0, 0, 1, 1),
                                        e.drawArrays(4, 0, 3);
                                      const a = new Uint8Array(4);
                                      return e.readPixels(0, 0, 1, 1, 6408, 5121, a),
                                        e.deleteProgram(n),
                                        e.deleteBuffer(r),
                                        a.join("")
                                    }(e)
                                      , r = "801621810"
                                      , s = "8016218135"
                                      , a = "80162181161"
                                      , o = (null == Tn ? void 0 : Tn.isIpad) ? [["a7", a, 12], ["a8", s, 15], ["a8x", s, 15], ["a9", s, 15], ["a9x", s, 15], ["a10", s, 15], ["a10x", s, 15], ["a12", r, 15], ["a12x", r, 15], ["a12z", r, 15], ["a14", r, 15], ["m1", r, 15]] : [["a7", a, 12], ["a8", s, 12], ["a9", s, 15], ["a10", s, 15], ["a11", r, 15], ["a12", r, 15], ["a13", r, 15], ["a14", r, 15]];
                                    let l;
                                    return "80162181255" === n ? l = o.filter((([,,e])=>e >= 14)) : (l = o.filter((([,e])=>e === n)),
                                    l.length || (l = o)),
                                      l.map((([e])=>`apple ${e} gpu`))
                                  }(e, t, i) : [t]
                                }(e, u, l)
                            }
                            const m = (yield Promise.all(p.map((e=>wn(void 0, void 0, void 0, (function*() {
                                var t;
                                const i = (e=>{
                                    const t = l ? ["adreno", "apple", "mali-t", "mali", "nvidia", "powervr"] : ["intel", "apple", "amd", "radeon", "nvidia", "geforce"];
                                    for (const i of t)
                                      if (e.includes(i))
                                        return i
                                  }
                                )(e);
                                if (!i)
                                  return;
                                const n = `${l ? "m" : "d"}-${i}${o ? "-ipad" : ""}.json`
                                  , r = a[n] = null !== (t = a[n]) && void 0 !== t ? t : c(n);
                                let s;
                                try {
                                  s = yield r
                                } catch (t) {
                                  if (t instanceof In)
                                    throw t;
                                  return
                                }
                                const u = function(e) {
                                  var t;
                                  const i = (e = e.replace(/\([^)]+\)/, "")).match(/\d+/) || e.match(/(\W|^)([A-Za-z]{1,3})(\W|$)/g);
                                  return null !== (t = null == i ? void 0 : i.join("").replace(/\W|amd/g, "")) && void 0 !== t ? t : ""
                                }(e);
                                let d = s.filter((([,e])=>e === u));
                                d.length || (d = s.filter((([t])=>t.includes(e))));
                                const p = d.length;
                                if (0 === p)
                                  return;
                                let f, [m,,,g] = p > 1 ? d.map((t=>[t, Pn(e, t[0])])).sort((([,e],[,t])=>e - t))[0][0] : d[0], v = Number.MAX_VALUE;
                                const {devicePixelRatio: y} = window
                                  , x = h.width * y * h.height * y;
                                for (const e of g) {
                                  const [t,i] = e
                                    , n = t * i
                                    , r = Math.abs(x - n);
                                  r < v && (v = r,
                                    f = e)
                                }
                                if (!f)
                                  return;
                                const [,,_,b] = f;
                                return [v, _, m, b]
                              }
                            )))))).filter(Dn).sort((([e=Number.MAX_VALUE,t],[i=Number.MAX_VALUE,n])=>e === i ? t - n : e - i));
                            if (!m.length) {
                              const e = An.find((e=>u.includes(e)));
                              return e ? d(0, "BLOCKLISTED", e) : d(1, "FALLBACK", `${u} (${f})`)
                            }
                            const [,g,v,y] = m[0];
                            if (-1 === g)
                              return d(0, "BLOCKLISTED", v, g, y);
                            const x = l ? e : t;
                            let _ = 0;
                            for (let e = 0; e < x.length; e++)
                              g >= x[e] && (_ = e);
                            return d(_, "BENCHMARK", v, g, y)
                          }
                        )))();
                        bn.gpuTier = e.tier,
                          t.itemEnd("gpuTier")
                      }
                    )(),
                    Up.onLoaded.add((()=>{
                        t.itemEnd("assets_loading")
                      }
                    )),
                    Up.load(Up.assets)
                }
                static start() {
                  tf.init(Up.images["smaa-search"], Up.images["smaa-area"]);
                  const e = document.querySelector(".references");
                  for (let t = 0; t < lm.length; t++) {
                    const i = document.createElement("div");
                    i.className = "reference",
                      e.appendChild(i);
                    const n = document.createElement("div");
                    n.className = "reference__title",
                      n.textContent = lm[t].title,
                      i.appendChild(n);
                    const r = document.createElement("source-link");
                    r.setAttribute("data-href", lm[t].source),
                      i.appendChild(r)
                  }
                  Ty.init(),
                    class {
                      static init() {
                        this.title_spans = document.querySelectorAll("h1 span"),
                          this.intro_cta = document.querySelector(".intro__cta"),
                          this.outro_cta = document.querySelector(".outro__cta"),
                          this.subtitle = document.querySelector(".intro__subtitle"),
                          this.intro_lottie = Iy().loadAnimation({
                            container: this.intro_cta,
                            renderer: "svg",
                            loop: !1,
                            autoplay: !1,
                            path: __webpack_require__(701)
                          }),
                          this.intro_cta.addEventListener("mouseenter", (()=>{
                              this.intro_lottie.setDirection(1),
                                this.intro_lottie.play()
                            }
                          )),
                          this.intro_cta.addEventListener("mouseleave", (()=>{
                              Py.ready || (this.intro_lottie.setDirection(-1),
                                this.intro_lottie.play())
                            }
                          )),
                          this.intro_cta.addEventListener("click", this.startCtaClicked.bind(this), {
                            once: !0
                          });
                        var e = Iy().loadAnimation({
                          container: this.outro_cta,
                          renderer: "svg",
                          loop: !1,
                          autoplay: !1,
                          path: __webpack_require__(531)
                        });
                        this.outro_cta.addEventListener("mouseenter", (()=>{
                            e.setDirection(1),
                              e.play()
                          }
                        )),
                          this.outro_cta.addEventListener("mouseleave", (()=>{
                              this.outro_cta.clicked || (e.setDirection(-1),
                                e.play())
                            }
                          )),
                          this.outro_cta.addEventListener("click", (()=>{
                              this.outro_cta.clicked = !0,
                                e.setDirection(1),
                                e.play(),
                                _n.to(document.body, {
                                  opacity: 0,
                                  duration: 1,
                                  ease: "none",
                                  onComplete: ()=>{
                                    window.location.reload()
                                  }
                                })
                            }
                          )),
                          setTimeout((()=>{
                              this.introAnimation()
                            }
                          ), 100)
                      }
                      static introAnimation() {
                        for (let e = 0; e < this.title_spans.length; e++)
                          setTimeout((()=>{
                              this.title_spans[e].classList.add("in")
                            }
                          ), 1e3 * this.title_spans[e].dataset.delay);
                        setTimeout((()=>{
                            this.subtitle.classList.add("intro__subtitle--in"),
                              this.intro_cta.classList.add("intro__cta--in")
                          }
                        ), 500)
                      }
                      static startCtaClicked() {
                        this.intro_lottie.setDirection(1),
                          this.intro_lottie.play(),
                          Py.ready = !0,
                          Py.scroller.active = !0,
                          document.querySelector(".vsh-scrollbar-0").classList.add("vsh-scrollbar-0--in"),
                          setTimeout((()=>{
                              document.querySelector(".intro").classList.add("intro--out"),
                                document.querySelector(".hint").classList.add("hint--in"),
                                _n.to(Py.curveMesh.material, {
                                  opacity: .5,
                                  ease: "none",
                                  duration: 2
                                }),
                                _n.to(Py, {
                                  introCloudAlpha: 1,
                                  ease: "power2.in",
                                  duration: 2
                                })
                            }
                          ), 500),
                          _n.to(Py.plane.introPosition, {
                            z: 0,
                            y: 0,
                            duration: 3,
                            ease: "power2.out"
                          }),
                          Ty.playMusic(),
                          Ty.playFx("click"),
                          Ty.playFx("woosh1"),
                          this.subtitle.classList.add("intro__subtitle--out"),
                          setTimeout((()=>{
                              this.positionAboutBtn(),
                                window.addEventListener("resize", (()=>{
                                    setTimeout((()=>{
                                        this.positionAboutBtn()
                                      }
                                    ), 100),
                                      setTimeout((()=>{
                                          this.positionAboutBtn()
                                        }
                                      ), 300)
                                  }
                                )),
                                document.querySelector(".sound-btn").classList.add("sound-btn--in"),
                                document.querySelector(".about-btn").classList.add("about-btn--in"),
                                document.querySelector(".intro__title").classList.add("no-transition")
                            }
                          ), 1500)
                      }
                      static positionAboutBtn() {
                        let e = document.querySelector(".about-btn")
                          , t = document.querySelector(".close-btn")
                          , i = document.querySelector(".sound-btn")
                          , n = document.querySelector(".intro__title").getBoundingClientRect()
                          , r = n.height / 2 + n.top;
                        e.style.top = `calc(${r}px - 1rem)`,
                          t.style.top = `calc(${r}px - 15px)`,
                          i.style.top = e.style.top
                      }
                    }
                      .init(),
                    Py.init(),
                    Ey.init(),
                    Py.display(),
                    _n.ticker.add((()=>{
                        tf.composer.render()
                      }
                    ))
                }
              }
            ).init(e)
          }
        }
          , Ly = Ry
          , ky = document.createElement("template");
        ky.innerHTML = `\n    <style>\n        .source-link {\n            font-size: 1.8rem;\n            font-family: 'DM Sans', sans-serif;\n            font-weight: 400;\n            display: flex;\n            align-items: center;\n            color: white;\n            text-decoration: none;\n        }\n        \n        span {\n            display: inline-block;\n            width: 10px;\n            height: 10px;\n            background-image: url(${__webpack_require__(73)});\n            background-size: cover;\n            background-position: center;\n            background-repeat: no-repeat;\n            margin-left: 20px;\n        }\n\n        /* Nested roll-title component,\n         so styles need to be declared here again */\n        roll-title {\n            position: relative;\n        }\n\n        .roll-title div:last-child {\n            position: absolute;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n            opacity: 0;\n        }\n            \n        .roll-title div:last-child:after {\n            content: attr(data-content);\n            position: absolute;\n            top: 0;\n            left: 0;        \n        }\n\n/* Custom styles */\n.roll-title {\n    perspective: 500px;\n}\n    </style>\n\n    <a class="source-link" target="_blank"><roll-title>\n                <div class="roll-title">\n                    <div>See the source</div>\n                    <div data-content="See the source"></div>\n                </div>\n            </roll-title> <span></span></a>\n`;
        class Fy extends HTMLElement {
          constructor() {
            super(),
              this.attachShadow({
                mode: "open"
              }),
              this.shadowRoot.appendChild(ky.content.cloneNode(!0))
          }
          connectedCallback() {
            this.shadowRoot.querySelector(".source-link").setAttribute("href", this.dataset.href)
          }
        }
        window.customElements.define("source-link", Fy);
        const By = document.createElement("template");
        By.innerHTML = "\n    <slot></slot>\n";
        class Oy extends HTMLElement {
          constructor() {
            super(),
              this.attachShadow({
                mode: "open"
              }),
              this.shadowRoot.appendChild(By.content.cloneNode(!0)),
              this.element1 = this.querySelector(".roll-title div:first-child"),
              this.element2 = this.querySelector(".roll-title div:last-child"),
              this.clicked = !1,
              _n.set(this.element2, {
                opacity: 0,
                y: "50%",
                rotateX: -90
              }),
              this.enterRef = this.enter.bind(this),
              this.leaveRef = this.leave.bind(this),
              "desktop" == Gp() ? (this.addEventListener("mouseenter", this.enterRef),
                this.addEventListener("mouseleave", this.leaveRef)) : this.addEventListener("touchstart", this.enterRef),
              this.addEventListener("click", (()=>{
                  this.clicked = !0,
                    setTimeout((()=>{
                        this.clicked = !1,
                          this.leaveRef()
                      }
                    ), 1500)
                }
              ))
          }
          enter() {
            _n.to(this.element1, {
              opacity: 0,
              y: "-50%",
              rotateX: 90,
              ease: "power2.inOut"
            }),
              _n.to(this.element2, {
                opacity: 1,
                y: 0,
                rotateX: 0,
                ease: "power2.inOut"
              })
          }
          leave() {
            this.clicked || (_n.to(this.element1, {
              opacity: 1,
              y: 0,
              rotateX: 0,
              ease: "power2.inOut"
            }),
              _n.to(this.element2, {
                opacity: 0,
                y: "50%",
                rotateX: -90,
                ease: "power2.inOut"
              }))
          }
        }
        window.customElements.define("roll-title", Oy);
        let Ny = .01 * window.innerHeight;
        document.documentElement.style.setProperty("--vh", `${Ny}px`),
          window.addEventListener("resize", (()=>{
              let e = .01 * window.innerHeight;
              document.documentElement.style.setProperty("--vh", `${e}px`)
            }
          )),
          Ly.init("#canvas")
      }
    )()
  }
)();
